<source file="/cmpt816/tmp/init/do_mounts_initrd.c.ifdefed" startline="20" endline="23">
{
    mount_initrd = 0;
    return 1;
}
</source>
<source file="/cmpt816/tmp/init/do_mounts_initrd.c.ifdefed" startline="28" endline="39">
{
    static char *argv [] = {"linuxrc", NULL,};
    extern char *envp_init [];
    sys_close (old_fd);
    sys_close (root_fd);
    sys_close (0);
    sys_close (1);
    sys_close (2);
    sys_setsid ();
    (void) sys_open ("/dev/console", O_RDWR, 0);
    (void) sys_dup (0);
    (void) sys_dup (0);
    return kernel_execve (shell, argv, envp_init);
}
</source>
<source file="/cmpt816/tmp/init/do_mounts_initrd.c.ifdefed" startline="42" endline="109">
{
    int error;
    int pid;
    real_root_dev = new_encode_dev (ROOT_DEV);
    create_dev ("/dev/root.old", Root_RAM0);
    mount_block_root ("/dev/root.old", root_mountflags & ~ MS_RDONLY);
    sys_mkdir ("/old", 0700);
    root_fd = sys_open ("/", 0, 0);
    old_fd = sys_open ("/old", 0, 0);
    sys_chdir ("/root");
    sys_mount (".", "/", NULL, MS_MOVE, NULL);
    sys_chroot (".");
    current->flags |= PF_FREEZER_SKIP;
    pid = kernel_thread (do_linuxrc, "/linuxrc", SIGCHLD);
    if (pid > 0)
        while (pid != sys_wait4 (-1, NULL, 0, NULL))
            yield ();
    current->flags &= ~PF_FREEZER_SKIP;
    sys_fchdir (old_fd);
    sys_mount ("/", ".", NULL, MS_MOVE, NULL);
    sys_fchdir (root_fd);
    sys_chroot (".");
    sys_close (old_fd);
    sys_close (root_fd);
    if (new_decode_dev (real_root_dev) == Root_RAM0) {
        sys_chdir ("/old");
        return;
    }
    ROOT_DEV = new_decode_dev (real_root_dev);
    mount_root ();
    printk (KERN_NOTICE "Trying to move old root to /initrd ... ");
    error = sys_mount ("/old", "/root/initrd", NULL, MS_MOVE, NULL);
    if (!error)
        printk ("okay\n");
    else {
        int fd = sys_open ("/dev/root.old", O_RDWR, 0);
        if (error == -ENOENT)
            printk ("/initrd does not exist. Ignored.\n");
        else
            printk ("failed\n");
        printk (KERN_NOTICE "Unmounting old root\n");
        sys_umount ("/old", MNT_DETACH);
        printk (KERN_NOTICE "Trying to free ramdisk memory ... ");
        if (fd < 0) {
            error = fd;
        }
        else {
            error = sys_ioctl (fd, BLKFLSBUF, 0);
            sys_close (fd);
        }
        printk (! error ? "okay\n" : "failed\n");
    }
}
</source>
<source file="/cmpt816/tmp/init/do_mounts_initrd.c.ifdefed" startline="80" endline="83">
{
    sys_chdir ("/old");
    return;
}
</source>
<source file="/cmpt816/tmp/init/do_mounts_initrd.c.ifdefed" startline="92" endline="108">
{
    int fd = sys_open ("/dev/root.old", O_RDWR, 0);
    if (error == -ENOENT)
        printk ("/initrd does not exist. Ignored.\n");
    else
        printk ("failed\n");
    printk (KERN_NOTICE "Unmounting old root\n");
    sys_umount ("/old", MNT_DETACH);
    printk (KERN_NOTICE "Trying to free ramdisk memory ... ");
    if (fd < 0) {
        error = fd;
    }
    else {
        error = sys_ioctl (fd, BLKFLSBUF, 0);
        sys_close (fd);
    }
    printk (! error ? "okay\n" : "failed\n");
}
</source>
<source file="/cmpt816/tmp/init/do_mounts_initrd.c.ifdefed" startline="101" endline="103">
{
    error = fd;
}
</source>
<source file="/cmpt816/tmp/init/do_mounts_initrd.c.ifdefed" startline="103" endline="106">
{
    error = sys_ioctl (fd, BLKFLSBUF, 0);
    sys_close (fd);
}
</source>
<source file="/cmpt816/tmp/init/do_mounts_initrd.c.ifdefed" startline="112" endline="129">
{
    if (mount_initrd) {
        create_dev ("/dev/ram", Root_RAM0);
        if (rd_load_image ("/initrd.image") && ROOT_DEV != Root_RAM0) {
            sys_unlink ("/initrd.image");
            handle_initrd ();
            return 1;
        }
    }
    sys_unlink ("/initrd.image");
    return 0;
}
</source>
<source file="/cmpt816/tmp/init/do_mounts_initrd.c.ifdefed" startline="113" endline="126">
{
    create_dev ("/dev/ram", Root_RAM0);
    if (rd_load_image ("/initrd.image") && ROOT_DEV != Root_RAM0) {
        sys_unlink ("/initrd.image");
        handle_initrd ();
        return 1;
    }
}
</source>
<source file="/cmpt816/tmp/init/do_mounts_initrd.c.ifdefed" startline="121" endline="125">
{
    sys_unlink ("/initrd.image");
    handle_initrd ();
    return 1;
}
</source>
<source file="/cmpt816/tmp/init/do_mounts_rd.c.ifdefed" startline="16" endline="19">
{
    rd_prompt = simple_strtol (str, NULL, 0) & 1;
    return 1;
}
</source>
<source file="/cmpt816/tmp/init/do_mounts_rd.c.ifdefed" startline="25" endline="28">
{
    rd_image_start = simple_strtol (str, NULL, 0);
    return 1;
}
</source>
<source file="/cmpt816/tmp/init/do_mounts_rd.c.ifdefed" startline="48" endline="136">
{
    const int size = 512;
    struct minix_super_block *minixsb;
    struct ext2_super_block *ext2sb;
    struct romfs_super_block *romfsb;
    struct cramfs_super *cramfsb;
    int nblocks = -1;
    unsigned char *buf;
    buf = kmalloc (size, GFP_KERNEL);
    if (!buf)
        return -1;
    minixsb = (struct minix_super_block *) buf;
    ext2sb = (struct ext2_super_block *) buf;
    romfsb = (struct romfs_super_block *) buf;
    cramfsb = (struct cramfs_super *) buf;
    memset (buf, 0xe5, size);
    sys_lseek (fd, start_block * BLOCK_SIZE, 0);
    sys_read (fd, buf, size);
    if (buf[0] == 037 && ((buf[1] == 0213) || (buf[1] == 0236))) {
        printk (KERN_NOTICE "RAMDISK: Compressed image found at block %d\n", start_block);
        nblocks = 0;
        goto done;
    }
    if (romfsb->word0 == ROMSB_WORD0 && romfsb->word1 == ROMSB_WORD1) {
        printk (KERN_NOTICE "RAMDISK: romfs filesystem found at block %d\n", start_block);
        nblocks = (ntohl (romfsb->size) + BLOCK_SIZE - 1) >> BLOCK_SIZE_BITS;
        goto done;
    }
    if (cramfsb->magic == CRAMFS_MAGIC) {
        printk (KERN_NOTICE "RAMDISK: cramfs filesystem found at block %d\n", start_block);
        nblocks = (cramfsb->size + BLOCK_SIZE - 1) >> BLOCK_SIZE_BITS;
        goto done;
    }
    sys_lseek (fd, (start_block + 1) * BLOCK_SIZE, 0);
    sys_read (fd, buf, size);
    if (minixsb->s_magic == MINIX_SUPER_MAGIC || minixsb->s_magic == MINIX_SUPER_MAGIC2) {
        printk (KERN_NOTICE "RAMDISK: Minix filesystem found at block %d\n", start_block);
        nblocks = minixsb->s_nzones << minixsb->s_log_zone_size;
        goto done;
    }
    if (ext2sb->s_magic == cpu_to_le16 (EXT2_SUPER_MAGIC)) {
        printk (KERN_NOTICE "RAMDISK: ext2 filesystem found at block %d\n", start_block);
        nblocks = le32_to_cpu (ext2sb->s_blocks_count) << le32_to_cpu (ext2sb->s_log_block_size);
        goto done;
    }
    printk (KERN_NOTICE "RAMDISK: Couldn't find valid RAM disk image starting at %d.\n", start_block);
done :
    sys_lseek (fd, start_block *BLOCK_SIZE, 0);
    kfree (buf);
    return nblocks;
}
</source>
<source file="/cmpt816/tmp/init/do_mounts_rd.c.ifdefed" startline="76" endline="82">
{
    printk (KERN_NOTICE "RAMDISK: Compressed image found at block %d\n", start_block);
    nblocks = 0;
    goto done;
}
</source>
<source file="/cmpt816/tmp/init/do_mounts_rd.c.ifdefed" startline="86" endline="92">
{
    printk (KERN_NOTICE "RAMDISK: romfs filesystem found at block %d\n", start_block);
    nblocks = (ntohl (romfsb->size) + BLOCK_SIZE - 1) >> BLOCK_SIZE_BITS;
    goto done;
}
</source>
<source file="/cmpt816/tmp/init/do_mounts_rd.c.ifdefed" startline="94" endline="100">
{
    printk (KERN_NOTICE "RAMDISK: cramfs filesystem found at block %d\n", start_block);
    nblocks = (cramfsb->size + BLOCK_SIZE - 1) >> BLOCK_SIZE_BITS;
    goto done;
}
</source>
<source file="/cmpt816/tmp/init/do_mounts_rd.c.ifdefed" startline="110" endline="116">
{
    printk (KERN_NOTICE "RAMDISK: Minix filesystem found at block %d\n", start_block);
    nblocks = minixsb->s_nzones << minixsb->s_log_zone_size;
    goto done;
}
</source>
<source file="/cmpt816/tmp/init/do_mounts_rd.c.ifdefed" startline="119" endline="126">
{
    printk (KERN_NOTICE "RAMDISK: ext2 filesystem found at block %d\n", start_block);
    nblocks = le32_to_cpu (ext2sb->s_blocks_count) << le32_to_cpu (ext2sb->s_log_block_size);
    goto done;
}
</source>
<source file="/cmpt816/tmp/init/do_mounts_rd.c.ifdefed" startline="139" endline="251">
{
    int res = 0;
    int in_fd, out_fd;
    unsigned long rd_blocks, devblocks;
    int nblocks, i, disk;
    char *buf = NULL;
    unsigned short rotate = 0;
    out_fd = sys_open ("/dev/ram", O_RDWR, 0);
    if (out_fd < 0)
        goto out;
    in_fd = sys_open (from, O_RDONLY, 0);
    if (in_fd < 0)
        goto noclose_input;
    nblocks = identify_ramdisk_image (in_fd, rd_image_start);
    if (nblocks < 0)
        goto done;
    if (nblocks == 0) {
        if (crd_load (in_fd, out_fd) == 0)
            goto successful_load;
        goto done;
    }
    if (sys_ioctl (out_fd, BLKGETSIZE, (unsigned long) &rd_blocks) < 0)
        rd_blocks = 0;
    else
        rd_blocks >>= 1;
    if (nblocks > rd_blocks) {
        printk ("RAMDISK: image too big! (%dKiB/%ldKiB)\n", nblocks, rd_blocks);
        goto done;
    }
    if (sys_ioctl (in_fd, BLKGETSIZE, (unsigned long) &devblocks) < 0)
        devblocks = 0;
    else
        devblocks >>= 1;
    if (strcmp (from, "/initrd.image") == 0)
        devblocks = nblocks;
    if (devblocks == 0) {
        printk (KERN_ERR "RAMDISK: could not determine device size\n");
        goto done;
    }
    buf = kmalloc (BLOCK_SIZE, GFP_KERNEL);
    if (!buf) {
        printk (KERN_ERR "RAMDISK: could not allocate buffer\n");
        goto done;
    }
    printk (KERN_NOTICE "RAMDISK: Loading %dKiB [%ld disk%s] into ram disk... ", nblocks, ((nblocks - 1) / devblocks) + 1, nblocks > devblocks ? "s" : "");
    for (i = 0, disk = 1; i < nblocks; i++) {
        if (i && (i % devblocks == 0)) {
            printk ("done disk #%d.\n", disk ++);
            rotate = 0;
            if (sys_close (in_fd)) {
                printk ("Error closing the disk.\n");
                goto noclose_input;
            }
            change_floppy ("disk #%d", disk);
            in_fd = sys_open (from, O_RDONLY, 0);
            if (in_fd < 0) {
                printk ("Error opening disk.\n");
                goto noclose_input;
            }
            printk ("Loading disk #%d... ", disk);
        }
        sys_read (in_fd, buf, BLOCK_SIZE);
        sys_write (out_fd, buf, BLOCK_SIZE);
    }
    printk ("done.\n");
successful_load :
    res = 1;
done :
    sys_close (in_fd);
noclose_input :
    sys_close (out_fd);
out :
    kfree (buf);
    sys_unlink ("/dev/ram");
    return res;
}
</source>
<source file="/cmpt816/tmp/init/do_mounts_rd.c.ifdefed" startline="162" endline="166">
{
    if (crd_load (in_fd, out_fd) == 0)
        goto successful_load;
    goto done;
}
</source>
<source file="/cmpt816/tmp/init/do_mounts_rd.c.ifdefed" startline="184" endline="188">
{
    printk ("RAMDISK: image too big! (%dKiB/%ldKiB)\n", nblocks, rd_blocks);
    goto done;
}
</source>
<source file="/cmpt816/tmp/init/do_mounts_rd.c.ifdefed" startline="201" endline="204">
{
    printk (KERN_ERR "RAMDISK: could not determine device size\n");
    goto done;
}
</source>
<source file="/cmpt816/tmp/init/do_mounts_rd.c.ifdefed" startline="207" endline="210">
{
    printk (KERN_ERR "RAMDISK: could not allocate buffer\n");
    goto done;
}
</source>
<source file="/cmpt816/tmp/init/do_mounts_rd.c.ifdefed" startline="214" endline="238">
{
    if (i && (i % devblocks == 0)) {
        printk ("done disk #%d.\n", disk ++);
        rotate = 0;
        if (sys_close (in_fd)) {
            printk ("Error closing the disk.\n");
            goto noclose_input;
        }
        change_floppy ("disk #%d", disk);
        in_fd = sys_open (from, O_RDONLY, 0);
        if (in_fd < 0) {
            printk ("Error opening disk.\n");
            goto noclose_input;
        }
        printk ("Loading disk #%d... ", disk);
    }
    sys_read (in_fd, buf, BLOCK_SIZE);
    sys_write (out_fd, buf, BLOCK_SIZE);
}
</source>
<source file="/cmpt816/tmp/init/do_mounts_rd.c.ifdefed" startline="215" endline="229">
{
    printk ("done disk #%d.\n", disk ++);
    rotate = 0;
    if (sys_close (in_fd)) {
        printk ("Error closing the disk.\n");
        goto noclose_input;
    }
    change_floppy ("disk #%d", disk);
    in_fd = sys_open (from, O_RDONLY, 0);
    if (in_fd < 0) {
        printk ("Error opening disk.\n");
        goto noclose_input;
    }
    printk ("Loading disk #%d... ", disk);
}
</source>
<source file="/cmpt816/tmp/init/do_mounts_rd.c.ifdefed" startline="218" endline="221">
{
    printk ("Error closing the disk.\n");
    goto noclose_input;
}
</source>
<source file="/cmpt816/tmp/init/do_mounts_rd.c.ifdefed" startline="224" endline="227">
{
    printk ("Error opening disk.\n");
    goto noclose_input;
}
</source>
<source file="/cmpt816/tmp/init/do_mounts_rd.c.ifdefed" startline="254" endline="260">
{
    if (rd_prompt)
        change_floppy ("root floppy disk to be loaded into RAM disk");
    create_dev ("/dev/root", ROOT_DEV);
    create_dev ("/dev/ram", MKDEV (RAMDISK_MAJOR, n));
    return rd_load_image ("/dev/root");
}
</source>
<source file="/cmpt816/tmp/init/do_mounts_rd.c.ifdefed" startline="318" endline="330">
{
    if (exit_code)
        return -1;
    insize = sys_read (crd_infd, inbuf, INBUFSIZ);
    if (insize == 0) {
        error ("RAMDISK: ran out of compressed data");
        return -1;
    }
    inptr = 1;
    return inbuf[0];
}
</source>
<source file="/cmpt816/tmp/init/do_mounts_rd.c.ifdefed" startline="322" endline="325">
{
    error ("RAMDISK: ran out of compressed data");
    return -1;
}
</source>
<source file="/cmpt816/tmp/init/do_mounts_rd.c.ifdefed" startline="337" endline="356">
{
    ulg c = crc;
    unsigned n, written;
    uch *in, ch;
    written = sys_write (crd_outfd, window, outcnt);
    if (written != outcnt && unzip_error == 0) {
        printk (KERN_ERR "RAMDISK: incomplete write (%d != %d) %ld\n", written, outcnt, bytes_out);
        unzip_error = 1;
    }
    in = window;
    for (n = 0; n < outcnt; n++) {
        ch = *in++;
        c = crc_32_tab[((int) c ^ ch) & 0xff] ^ (c >> 8);
    }
    crc = c;
    bytes_out += (ulg) outcnt;
    outcnt = 0;
}
</source>
<source file="/cmpt816/tmp/init/do_mounts_rd.c.ifdefed" startline="343" endline="347">
{
    printk (KERN_ERR "RAMDISK: incomplete write (%d != %d) %ld\n", written, outcnt, bytes_out);
    unzip_error = 1;
}
</source>
<source file="/cmpt816/tmp/init/do_mounts_rd.c.ifdefed" startline="349" endline="352">
{
    ch = *in++;
    c = crc_32_tab[((int) c ^ ch) & 0xff] ^ (c >> 8);
}
</source>
<source file="/cmpt816/tmp/init/do_mounts_rd.c.ifdefed" startline="359" endline="363">
{
    printk (KERN_ERR "%s\n", x);
    exit_code = 1;
    unzip_error = 1;
}
</source>
<source file="/cmpt816/tmp/init/do_mounts_rd.c.ifdefed" startline="366" endline="396">
{
    int result;
    insize = 0;
    inptr = 0;
    outcnt = 0;
    exit_code = 0;
    bytes_out = 0;
    crc = (ulg) 0xffffffffL;
    crd_infd = in_fd;
    crd_outfd = out_fd;
    inbuf = kmalloc (INBUFSIZ, GFP_KERNEL);
    if (!inbuf) {
        printk (KERN_ERR "RAMDISK: Couldn't allocate gzip buffer\n");
        return -1;
    }
    window = kmalloc (WSIZE, GFP_KERNEL);
    if (!window) {
        printk (KERN_ERR "RAMDISK: Couldn't allocate gzip window\n");
        kfree (inbuf);
        return -1;
    }
    makecrc ();
    result = gunzip ();
    if (unzip_error)
        result = 1;
    kfree (inbuf);
    kfree (window);
    return result;
}
</source>
<source file="/cmpt816/tmp/init/do_mounts_rd.c.ifdefed" startline="379" endline="382">
{
    printk (KERN_ERR "RAMDISK: Couldn't allocate gzip buffer\n");
    return -1;
}
</source>
<source file="/cmpt816/tmp/init/do_mounts_rd.c.ifdefed" startline="384" endline="388">
{
    printk (KERN_ERR "RAMDISK: Couldn't allocate gzip window\n");
    kfree (inbuf);
    return -1;
}
</source>
<source file="/cmpt816/tmp/init/do_mounts_md.c.ifdefed" startline="48" endline="108">
{
    int minor, level, factor, fault, partitioned = 0;
    char *pername = "";
    char *str1;
    int ent;
    if (*str == 'd') {
        partitioned = 1;
        str++;
    }
    if (get_option (&str, &minor) != 2) {
        printk (KERN_WARNING "md: Too few arguments supplied to md=.\n");
        return 0;
    }
    str1 = str;
    for (ent = 0; ent < md_setup_ents; ent++)
        if (md_setup_args[ent].minor == minor && md_setup_args[ent].partitioned == partitioned) {
            printk (KERN_WARNING "md: md=%s%d, Specified more than once. " "Replacing previous definition.\n", partitioned ? "d" : "", minor);
            break;
        }
    if (ent >= ARRAY_SIZE (md_setup_args)) {
        printk (KERN_WARNING "md: md=%s%d - too many md initialisations\n", partitioned ? "d" : "", minor);
        return 0;
    }
    if (ent >= md_setup_ents)
        md_setup_ents++;
    switch (get_option (&str, &level)) {
    case 2 :
        if (level == 0 || level == LEVEL_LINEAR) {
            if (get_option (&str, &factor) != 2 || get_option (&str, &fault) != 2) {
                printk (KERN_WARNING "md: Too few arguments supplied to md=.\n");
                return 0;
            }
            md_setup_args[ent].level = level;
            md_setup_args[ent].chunk = 1 << (factor + 12);
            if (level == LEVEL_LINEAR)
                pername = "linear";
            else
                pername = "raid0";
            break;
        }
    case 1 :
        str = str1;
    case 0 :
        md_setup_args[ent].level = LEVEL_NONE;
        pername = "super-block";
    }
    printk (KERN_INFO "md: Will configure md%d (%s) from %s, below.\n", minor, pername, str);
    md_setup_args[ent].device_names = str;
    md_setup_args[ent].partitioned = partitioned;
    md_setup_args[ent].minor = minor;
    return 1;
}
</source>
<source file="/cmpt816/tmp/init/do_mounts_md.c.ifdefed" startline="54" endline="57">
{
    partitioned = 1;
    str++;
}
</source>
<source file="/cmpt816/tmp/init/do_mounts_md.c.ifdefed" startline="58" endline="61">
{
    printk (KERN_WARNING "md: Too few arguments supplied to md=.\n");
    return 0;
}
</source>
<source file="/cmpt816/tmp/init/do_mounts_md.c.ifdefed" startline="65" endline="69">
{
    printk (KERN_WARNING "md: md=%s%d, Specified more than once. " "Replacing previous definition.\n", partitioned ? "d" : "", minor);
    break;
}
</source>
<source file="/cmpt816/tmp/init/do_mounts_md.c.ifdefed" startline="70" endline="73">
{
    printk (KERN_WARNING "md: md=%s%d - too many md initialisations\n", partitioned ? "d" : "", minor);
    return 0;
}
</source>
<source file="/cmpt816/tmp/init/do_mounts_md.c.ifdefed" startline="76" endline="99">
{
case 2 :
    if (level == 0 || level == LEVEL_LINEAR) {
        if (get_option (&str, &factor) != 2 || get_option (&str, &fault) != 2) {
            printk (KERN_WARNING "md: Too few arguments supplied to md=.\n");
            return 0;
        }
        md_setup_args[ent].level = level;
        md_setup_args[ent].chunk = 1 << (factor + 12);
        if (level == LEVEL_LINEAR)
            pername = "linear";
        else
            pername = "raid0";
        break;
    }
case 1 :
    str = str1;
case 0 :
    md_setup_args[ent].level = LEVEL_NONE;
    pername = "super-block";
}
</source>
<source file="/cmpt816/tmp/init/do_mounts_md.c.ifdefed" startline="78" endline="91">
{
    if (get_option (&str, &factor) != 2 || get_option (&str, &fault) != 2) {
        printk (KERN_WARNING "md: Too few arguments supplied to md=.\n");
        return 0;
    }
    md_setup_args[ent].level = level;
    md_setup_args[ent].chunk = 1 << (factor + 12);
    if (level == LEVEL_LINEAR)
        pername = "linear";
    else
        pername = "raid0";
    break;
}
</source>
<source file="/cmpt816/tmp/init/do_mounts_md.c.ifdefed" startline="80" endline="83">
{
    printk (KERN_WARNING "md: Too few arguments supplied to md=.\n");
    return 0;
}
</source>
<source file="/cmpt816/tmp/init/do_mounts_md.c.ifdefed" startline="113" endline="237">
{
    int minor, i, ent, partitioned;
    dev_t dev;
    dev_t devices [MD_SB_DISKS + 1];
    for (ent = 0; ent < md_setup_ents; ent++) {
        int fd;
        int err = 0;
        char *devname;
        mdu_disk_info_t dinfo;
        char name [16];
        minor = md_setup_args[ent].minor;
        partitioned = md_setup_args[ent].partitioned;
        devname = md_setup_args[ent].device_names;
        sprintf (name, "/dev/md%s%d", partitioned ? "_d" : "", minor);
        if (partitioned)
            dev = MKDEV (mdp_major, minor << MdpMinorShift);
        else
            dev = MKDEV (MD_MAJOR, minor);
        create_dev (name, dev);
        for (i = 0; i < MD_SB_DISKS && devname != NULL; i++) {
            char *p;
            char comp_name [64];
            u32 rdev;
            p = strchr (devname, ',');
            if (p)
                *p++ = 0;
            dev = name_to_dev_t (devname);
            if (strncmp (devname, "/dev/", 5) == 0)
                devname += 5;
            snprintf (comp_name, 63, "/dev/%s", devname);
            rdev = bstat (comp_name);
            if (rdev)
                dev = new_decode_dev (rdev);
            if (!dev) {
                printk (KERN_WARNING "md: Unknown device name: %s\n", devname);
                break;
            }
            devices[i] = dev;
            devname = p;
        }
        devices[i] = 0;
        if (!i)
            continue;
        printk (KERN_INFO "md: Loading md%s%d: %s\n", partitioned ? "_d" : "", minor, md_setup_args [ent].device_names);
        fd = sys_open (name, 0, 0);
        if (fd < 0) {
            printk (KERN_ERR "md: open failed - cannot start " "array %s\n", name);
            continue;
        }
        if (sys_ioctl (fd, SET_ARRAY_INFO, 0) == -EBUSY) {
            printk (KERN_WARNING "md: Ignoring md=%d, already autodetected. (Use raid=noautodetect)\n", minor);
            sys_close (fd);
            continue;
        }
        if (md_setup_args[ent].level != LEVEL_NONE) {
            mdu_array_info_t ainfo;
            ainfo.level = md_setup_args[ent].level;
            ainfo.size = 0;
            ainfo.nr_disks = 0;
            ainfo.raid_disks = 0;
            while (devices[ainfo.raid_disks])
                ainfo.raid_disks++;
            ainfo.md_minor = minor;
            ainfo.not_persistent = 1;
            ainfo.state = (1 << MD_SB_CLEAN);
            ainfo.layout = 0;
            ainfo.chunk_size = md_setup_args[ent].chunk;
            err = sys_ioctl (fd, SET_ARRAY_INFO, (long) &ainfo);
            for (i = 0; !err && i <= MD_SB_DISKS; i++) {
                dev = devices[i];
                if (!dev)
                    break;
                dinfo.number = i;
                dinfo.raid_disk = i;
                dinfo.state = (1 << MD_DISK_ACTIVE) | (1 << MD_DISK_SYNC);
                dinfo.major = MAJOR (dev);
                dinfo.minor = MINOR (dev);
                err = sys_ioctl (fd, ADD_NEW_DISK, (long) &dinfo);
            }
        }
        else {
            for (i = 0; i <= MD_SB_DISKS; i++) {
                dev = devices[i];
                if (!dev)
                    break;
                dinfo.major = MAJOR (dev);
                dinfo.minor = MINOR (dev);
                sys_ioctl (fd, ADD_NEW_DISK, (long) & dinfo);
            }
        }
        if (!err)
            err = sys_ioctl (fd, RUN_ARRAY, 0);
        if (err)
            printk (KERN_WARNING "md: starting md%d failed\n", minor);
        else {
            sys_close (fd);
            fd = sys_open (name, 0, 0);
            sys_ioctl (fd, BLKRRPART, 0);
        }
        sys_close (fd);
    }
}
</source>
<source file="/cmpt816/tmp/init/do_mounts_md.c.ifdefed" startline="118" endline="236">
{
    int fd;
    int err = 0;
    char *devname;
    mdu_disk_info_t dinfo;
    char name [16];
    minor = md_setup_args[ent].minor;
    partitioned = md_setup_args[ent].partitioned;
    devname = md_setup_args[ent].device_names;
    sprintf (name, "/dev/md%s%d", partitioned ? "_d" : "", minor);
    if (partitioned)
        dev = MKDEV (mdp_major, minor << MdpMinorShift);
    else
        dev = MKDEV (MD_MAJOR, minor);
    create_dev (name, dev);
    for (i = 0; i < MD_SB_DISKS && devname != NULL; i++) {
        char *p;
        char comp_name [64];
        u32 rdev;
        p = strchr (devname, ',');
        if (p)
            *p++ = 0;
        dev = name_to_dev_t (devname);
        if (strncmp (devname, "/dev/", 5) == 0)
            devname += 5;
        snprintf (comp_name, 63, "/dev/%s", devname);
        rdev = bstat (comp_name);
        if (rdev)
            dev = new_decode_dev (rdev);
        if (!dev) {
            printk (KERN_WARNING "md: Unknown device name: %s\n", devname);
            break;
        }
        devices[i] = dev;
        devname = p;
    }
    devices[i] = 0;
    if (!i)
        continue;
    printk (KERN_INFO "md: Loading md%s%d: %s\n", partitioned ? "_d" : "", minor, md_setup_args [ent].device_names);
    fd = sys_open (name, 0, 0);
    if (fd < 0) {
        printk (KERN_ERR "md: open failed - cannot start " "array %s\n", name);
        continue;
    }
    if (sys_ioctl (fd, SET_ARRAY_INFO, 0) == -EBUSY) {
        printk (KERN_WARNING "md: Ignoring md=%d, already autodetected. (Use raid=noautodetect)\n", minor);
        sys_close (fd);
        continue;
    }
    if (md_setup_args[ent].level != LEVEL_NONE) {
        mdu_array_info_t ainfo;
        ainfo.level = md_setup_args[ent].level;
        ainfo.size = 0;
        ainfo.nr_disks = 0;
        ainfo.raid_disks = 0;
        while (devices[ainfo.raid_disks])
            ainfo.raid_disks++;
        ainfo.md_minor = minor;
        ainfo.not_persistent = 1;
        ainfo.state = (1 << MD_SB_CLEAN);
        ainfo.layout = 0;
        ainfo.chunk_size = md_setup_args[ent].chunk;
        err = sys_ioctl (fd, SET_ARRAY_INFO, (long) &ainfo);
        for (i = 0; !err && i <= MD_SB_DISKS; i++) {
            dev = devices[i];
            if (!dev)
                break;
            dinfo.number = i;
            dinfo.raid_disk = i;
            dinfo.state = (1 << MD_DISK_ACTIVE) | (1 << MD_DISK_SYNC);
            dinfo.major = MAJOR (dev);
            dinfo.minor = MINOR (dev);
            err = sys_ioctl (fd, ADD_NEW_DISK, (long) &dinfo);
        }
    }
    else {
        for (i = 0; i <= MD_SB_DISKS; i++) {
            dev = devices[i];
            if (!dev)
                break;
            dinfo.major = MAJOR (dev);
            dinfo.minor = MINOR (dev);
            sys_ioctl (fd, ADD_NEW_DISK, (long) & dinfo);
        }
    }
    if (!err)
        err = sys_ioctl (fd, RUN_ARRAY, 0);
    if (err)
        printk (KERN_WARNING "md: starting md%d failed\n", minor);
    else {
        sys_close (fd);
        fd = sys_open (name, 0, 0);
        sys_ioctl (fd, BLKRRPART, 0);
    }
    sys_close (fd);
}
</source>
<source file="/cmpt816/tmp/init/do_mounts_md.c.ifdefed" startline="135" endline="159">
{
    char *p;
    char comp_name [64];
    u32 rdev;
    p = strchr (devname, ',');
    if (p)
        *p++ = 0;
    dev = name_to_dev_t (devname);
    if (strncmp (devname, "/dev/", 5) == 0)
        devname += 5;
    snprintf (comp_name, 63, "/dev/%s", devname);
    rdev = bstat (comp_name);
    if (rdev)
        dev = new_decode_dev (rdev);
    if (!dev) {
        printk (KERN_WARNING "md: Unknown device name: %s\n", devname);
        break;
    }
    devices[i] = dev;
    devname = p;
}
</source>
<source file="/cmpt816/tmp/init/do_mounts_md.c.ifdefed" startline="151" endline="154">
{
    printk (KERN_WARNING "md: Unknown device name: %s\n", devname);
    break;
}
</source>
<source file="/cmpt816/tmp/init/do_mounts_md.c.ifdefed" startline="170" endline="174">
{
    printk (KERN_ERR "md: open failed - cannot start " "array %s\n", name);
    continue;
}
</source>
<source file="/cmpt816/tmp/init/do_mounts_md.c.ifdefed" startline="175" endline="181">
{
    printk (KERN_WARNING "md: Ignoring md=%d, already autodetected. (Use raid=noautodetect)\n", minor);
    sys_close (fd);
    continue;
}
</source>
<source file="/cmpt816/tmp/init/do_mounts_md.c.ifdefed" startline="183" endline="210">
{
    mdu_array_info_t ainfo;
    ainfo.level = md_setup_args[ent].level;
    ainfo.size = 0;
    ainfo.nr_disks = 0;
    ainfo.raid_disks = 0;
    while (devices[ainfo.raid_disks])
        ainfo.raid_disks++;
    ainfo.md_minor = minor;
    ainfo.not_persistent = 1;
    ainfo.state = (1 << MD_SB_CLEAN);
    ainfo.layout = 0;
    ainfo.chunk_size = md_setup_args[ent].chunk;
    err = sys_ioctl (fd, SET_ARRAY_INFO, (long) &ainfo);
    for (i = 0; !err && i <= MD_SB_DISKS; i++) {
        dev = devices[i];
        if (!dev)
            break;
        dinfo.number = i;
        dinfo.raid_disk = i;
        dinfo.state = (1 << MD_DISK_ACTIVE) | (1 << MD_DISK_SYNC);
        dinfo.major = MAJOR (dev);
        dinfo.minor = MINOR (dev);
        err = sys_ioctl (fd, ADD_NEW_DISK, (long) &dinfo);
    }
}
</source>
<source file="/cmpt816/tmp/init/do_mounts_md.c.ifdefed" startline="199" endline="209">
{
    dev = devices[i];
    if (!dev)
        break;
    dinfo.number = i;
    dinfo.raid_disk = i;
    dinfo.state = (1 << MD_DISK_ACTIVE) | (1 << MD_DISK_SYNC);
    dinfo.major = MAJOR (dev);
    dinfo.minor = MINOR (dev);
    err = sys_ioctl (fd, ADD_NEW_DISK, (long) &dinfo);
}
</source>
<source file="/cmpt816/tmp/init/do_mounts_md.c.ifdefed" startline="210" endline="220">
{
    for (i = 0; i <= MD_SB_DISKS; i++) {
        dev = devices[i];
        if (!dev)
            break;
        dinfo.major = MAJOR (dev);
        dinfo.minor = MINOR (dev);
        sys_ioctl (fd, ADD_NEW_DISK, (long) & dinfo);
    }
}
</source>
<source file="/cmpt816/tmp/init/do_mounts_md.c.ifdefed" startline="212" endline="219">
{
    dev = devices[i];
    if (!dev)
        break;
    dinfo.major = MAJOR (dev);
    dinfo.minor = MINOR (dev);
    sys_ioctl (fd, ADD_NEW_DISK, (long) & dinfo);
}
</source>
<source file="/cmpt816/tmp/init/do_mounts_md.c.ifdefed" startline="225" endline="234">
{
    sys_close (fd);
    fd = sys_open (name, 0, 0);
    sys_ioctl (fd, BLKRRPART, 0);
}
</source>
<source file="/cmpt816/tmp/init/do_mounts_md.c.ifdefed" startline="240" endline="262">
{
    int len, pos;
    len = strlen (str) + 1;
    pos = 0;
    while (pos < len) {
        char *comma = strchr (str +pos, ',');
        int wlen;
        if (comma)
            wlen = (comma - str) - pos;
        else
            wlen = (len - 1) - pos;
        if (!strncmp (str, "noautodetect", wlen))
            raid_noautodetect = 1;
        if (strncmp (str, "partitionable", wlen) == 0)
            raid_autopart = 1;
        if (strncmp (str, "part", wlen) == 0)
            raid_autopart = 1;
        pos += wlen + 1;
    }
    return 1;
}
</source>
<source file="/cmpt816/tmp/init/do_mounts_md.c.ifdefed" startline="246" endline="260">
{
    char *comma = strchr (str +pos, ',');
    int wlen;
    if (comma)
        wlen = (comma - str) - pos;
    else
        wlen = (len - 1) - pos;
    if (!strncmp (str, "noautodetect", wlen))
        raid_noautodetect = 1;
    if (strncmp (str, "partitionable", wlen) == 0)
        raid_autopart = 1;
    if (strncmp (str, "part", wlen) == 0)
        raid_autopart = 1;
    pos += wlen + 1;
}
</source>
<source file="/cmpt816/tmp/init/do_mounts_md.c.ifdefed" startline="268" endline="280">
{
    create_dev ("/dev/md0", MKDEV (MD_MAJOR, 0));
    if (raid_noautodetect)
        printk (KERN_INFO "md: Skipping autodetection of RAID arrays. (raid=noautodetect)\n");
    else {
        int fd = sys_open ("/dev/md0", 0, 0);
        if (fd >= 0) {
            sys_ioctl (fd, RAID_AUTORUN, raid_autopart);
            sys_close (fd);
        }
    }
    md_setup_drive ();
}
</source>
<source file="/cmpt816/tmp/init/do_mounts_md.c.ifdefed" startline="272" endline="278">
{
    int fd = sys_open ("/dev/md0", 0, 0);
    if (fd >= 0) {
        sys_ioctl (fd, RAID_AUTORUN, raid_autopart);
        sys_close (fd);
    }
}
</source>
<source file="/cmpt816/tmp/init/do_mounts_md.c.ifdefed" startline="274" endline="277">
{
    sys_ioctl (fd, RAID_AUTORUN, raid_autopart);
    sys_close (fd);
}
</source>
<source file="/cmpt816/tmp/init/initramfs.c.ifdefed" startline="12" endline="15">
{
    if (!message)
        message = x;
}
</source>
<source file="/cmpt816/tmp/init/initramfs.c.ifdefed" startline="29" endline="33">
{
    unsigned long tmp = ino + minor + (major << 3);
    tmp += tmp >> 5;
    return tmp & 31;
}
</source>
<source file="/cmpt816/tmp/init/initramfs.c.ifdefed" startline="37" endline="61">
{
    struct hash **p, *q;
    for (p = head + hash (major, minor, ino); *p; p = &(*p)->next) {
        if ((*p)->ino != ino)
            continue;
        if ((*p)->minor != minor)
            continue;
        if ((*p)->major != major)
            continue;
        if (((*p)->mode ^ mode) & S_IFMT)
            continue;
        return (*p)->name;
    }
    q = kmalloc (sizeof (struct hash), GFP_KERNEL);
    if (!q)
        panic ("can't allocate link hash entry");
    q->major = major;
    q->minor = minor;
    q->ino = ino;
    q->mode = mode;
    strcpy (q -> name, name);
    q->next = NULL;
    *p = q;
    return NULL;
}
</source>
<source file="/cmpt816/tmp/init/initramfs.c.ifdefed" startline="39" endline="49">
{
    if ((*p)->ino != ino)
        continue;
    if ((*p)->minor != minor)
        continue;
    if ((*p)->major != major)
        continue;
    if (((*p)->mode ^ mode) & S_IFMT)
        continue;
    return (*p)->name;
}
</source>
<source file="/cmpt816/tmp/init/initramfs.c.ifdefed" startline="64" endline="73">
{
    struct hash **p, *q;
    for (p = head; p < head + 32; p++) {
        while (*p) {
            q = *p;
            *p = q->next;
            kfree (q);
        }
    }
}
</source>
<source file="/cmpt816/tmp/init/initramfs.c.ifdefed" startline="66" endline="72">
{
    while (*p) {
        q = *p;
        *p = q->next;
        kfree (q);
    }
}
</source>
<source file="/cmpt816/tmp/init/initramfs.c.ifdefed" startline="67" endline="71">
{
    q = *p;
    *p = q->next;
    kfree (q);
}
</source>
<source file="/cmpt816/tmp/init/initramfs.c.ifdefed" startline="85" endline="105">
{
    unsigned long parsed [12];
    char buf [9];
    int i;
    buf[8] = '\0';
    for (i = 0, s += 6; i < 12; i++, s += 8) {
        memcpy (buf, s, 8);
        parsed[i] = simple_strtoul (buf, NULL, 16);
    }
    ino = parsed[0];
    mode = parsed[1];
    uid = parsed[2];
    gid = parsed[3];
    nlink = parsed[4];
    body_len = parsed[6];
    major = parsed[7];
    minor = parsed[8];
    rdev = new_encode_dev (MKDEV (parsed[9], parsed[10]));
    name_len = parsed[11];
}
</source>
<source file="/cmpt816/tmp/init/initramfs.c.ifdefed" startline="91" endline="94">
{
    memcpy (buf, s, 8);
    parsed[i] = simple_strtoul (buf, NULL, 16);
}
</source>
<source file="/cmpt816/tmp/init/initramfs.c.ifdefed" startline="127" endline="131">
{
    victim += n;
    this_header += n;
    count -= n;
}
</source>
<source file="/cmpt816/tmp/init/initramfs.c.ifdefed" startline="138" endline="149">
{
    if (count >= size) {
        collected = victim;
        eat (size);
        state = next;
    }
    else {
        collect = collected = buf;
        remains = size;
        next_state = next;
        state = Collect;
    }
}
</source>
<source file="/cmpt816/tmp/init/initramfs.c.ifdefed" startline="139" endline="143">
{
    collected = victim;
    eat (size);
    state = next;
}
</source>
<source file="/cmpt816/tmp/init/initramfs.c.ifdefed" startline="143" endline="148">
{
    collect = collected = buf;
    remains = size;
    next_state = next;
    state = Collect;
}
</source>
<source file="/cmpt816/tmp/init/initramfs.c.ifdefed" startline="154" endline="157">
{
    read_into (header_buf, 110, GotHeader);
    return 0;
}
</source>
<source file="/cmpt816/tmp/init/initramfs.c.ifdefed" startline="160" endline="171">
{
    unsigned n = remains;
    if (count < n)
        n = count;
    memcpy (collect, victim, n);
    eat (n);
    collect += n;
    if ((remains -= n) != 0)
        return 1;
    state = next_state;
    return 0;
}
</source>
<source file="/cmpt816/tmp/init/initramfs.c.ifdefed" startline="174" endline="205">
{
    if (memcmp (collected, "070707", 6) == 0) {
        error ("incorrect cpio method used: use -H newc option");
        return 1;
    }
    if (memcmp (collected, "070701", 6)) {
        error ("no cpio magic");
        return 1;
    }
    parse_header (collected);
    next_header = this_header + N_ALIGN (name_len) + body_len;
    next_header = (next_header + 3) & ~3;
    if (dry_run) {
        read_into (name_buf, N_ALIGN (name_len), GotName);
        return 0;
    }
    state = SkipIt;
    if (name_len <= 0 || name_len > PATH_MAX)
        return 0;
    if (S_ISLNK (mode)) {
        if (body_len > PATH_MAX)
            return 0;
        collect = collected = symlink_buf;
        remains = N_ALIGN (name_len) + body_len;
        next_state = GotSymlink;
        state = Collect;
        return 0;
    }
    if (S_ISREG (mode) || !body_len)
        read_into (name_buf, N_ALIGN (name_len), GotName);
    return 0;
}
</source>
<source file="/cmpt816/tmp/init/initramfs.c.ifdefed" startline="175" endline="178">
{
    error ("incorrect cpio method used: use -H newc option");
    return 1;
}
</source>
<source file="/cmpt816/tmp/init/initramfs.c.ifdefed" startline="179" endline="182">
{
    error ("no cpio magic");
    return 1;
}
</source>
<source file="/cmpt816/tmp/init/initramfs.c.ifdefed" startline="186" endline="189">
{
    read_into (name_buf, N_ALIGN (name_len), GotName);
    return 0;
}
</source>
<source file="/cmpt816/tmp/init/initramfs.c.ifdefed" startline="193" endline="201">
{
    if (body_len > PATH_MAX)
        return 0;
    collect = collected = symlink_buf;
    remains = N_ALIGN (name_len) + body_len;
    next_state = GotSymlink;
    state = Collect;
    return 0;
}
</source>
<source file="/cmpt816/tmp/init/initramfs.c.ifdefed" startline="208" endline="217">
{
    if (this_header + count < next_header) {
        eat (count);
        return 1;
    }
    else {
        eat (next_header - this_header);
        state = next_state;
        return 0;
    }
}
</source>
<source file="/cmpt816/tmp/init/initramfs.c.ifdefed" startline="209" endline="212">
{
    eat (count);
    return 1;
}
</source>
<source file="/cmpt816/tmp/init/initramfs.c.ifdefed" startline="212" endline="216">
{
    eat (next_header - this_header);
    state = next_state;
    return 0;
}
</source>
<source file="/cmpt816/tmp/init/initramfs.c.ifdefed" startline="220" endline="226">
{
    while (count && *victim == '\0')
        eat (1);
    if (count && (this_header & 3))
        error ("broken padding");
    return 1;
}
</source>
<source file="/cmpt816/tmp/init/initramfs.c.ifdefed" startline="229" endline="236">
{
    if (nlink >= 2) {
        char *old = find_link (major, minor, ino, mode, collected);
        if (old)
            return (sys_link (old, collected) < 0) ? -1 : 1;
    }
    return 0;
}
</source>
<source file="/cmpt816/tmp/init/initramfs.c.ifdefed" startline="230" endline="234">
{
    char *old = find_link (major, minor, ino, mode, collected);
    if (old)
        return (sys_link (old, collected) < 0) ? -1 : 1;
}
</source>
<source file="/cmpt816/tmp/init/initramfs.c.ifdefed" startline="239" endline="248">
{
    struct stat st;
    if (!sys_newlstat (path, &st) && (st.st_mode ^ mode) & S_IFMT) {
        if (S_ISDIR (st.st_mode))
            sys_rmdir (path);
        else
            sys_unlink (path);
    }
}
</source>
<source file="/cmpt816/tmp/init/initramfs.c.ifdefed" startline="242" endline="247">
{
    if (S_ISDIR (st.st_mode))
        sys_rmdir (path);
    else
        sys_unlink (path);
}
</source>
<source file="/cmpt816/tmp/init/initramfs.c.ifdefed" startline="253" endline="290">
{
    state = SkipIt;
    next_state = Reset;
    if (strcmp (collected, "TRAILER!!!") == 0) {
        free_hash ();
        return 0;
    }
    if (dry_run)
        return 0;
    clean_path (collected, mode);
    if (S_ISREG (mode)) {
        int ml = maybe_link ();
        if (ml >= 0) {
            int openflags = O_WRONLY | O_CREAT;
            if (ml != 1)
                openflags |= O_TRUNC;
            wfd = sys_open (collected, openflags, mode);
            if (wfd >= 0) {
                sys_fchown (wfd, uid, gid);
                sys_fchmod (wfd, mode);
                state = CopyFile;
            }
        }
    }
    else if (S_ISDIR (mode)) {
        sys_mkdir (collected, mode);
        sys_chown (collected, uid, gid);
        sys_chmod (collected, mode);
    }
    else if (S_ISBLK (mode) || S_ISCHR (mode) || S_ISFIFO (mode) || S_ISSOCK (mode)) {
        if (maybe_link () == 0) {
            sys_mknod (collected, mode, rdev);
            sys_chown (collected, uid, gid);
            sys_chmod (collected, mode);
        }
    }
    return 0;
}
</source>
<source file="/cmpt816/tmp/init/initramfs.c.ifdefed" startline="256" endline="259">
{
    free_hash ();
    return 0;
}
</source>
<source file="/cmpt816/tmp/init/initramfs.c.ifdefed" startline="263" endline="277">
{
    int ml = maybe_link ();
    if (ml >= 0) {
        int openflags = O_WRONLY | O_CREAT;
        if (ml != 1)
            openflags |= O_TRUNC;
        wfd = sys_open (collected, openflags, mode);
        if (wfd >= 0) {
            sys_fchown (wfd, uid, gid);
            sys_fchmod (wfd, mode);
            state = CopyFile;
        }
    }
}
</source>
<source file="/cmpt816/tmp/init/initramfs.c.ifdefed" startline="265" endline="276">
{
    int openflags = O_WRONLY | O_CREAT;
    if (ml != 1)
        openflags |= O_TRUNC;
    wfd = sys_open (collected, openflags, mode);
    if (wfd >= 0) {
        sys_fchown (wfd, uid, gid);
        sys_fchmod (wfd, mode);
        state = CopyFile;
    }
}
</source>
<source file="/cmpt816/tmp/init/initramfs.c.ifdefed" startline="271" endline="275">
{
    sys_fchown (wfd, uid, gid);
    sys_fchmod (wfd, mode);
    state = CopyFile;
}
</source>
<source file="/cmpt816/tmp/init/initramfs.c.ifdefed" startline="277" endline="281">
{
    sys_mkdir (collected, mode);
    sys_chown (collected, uid, gid);
    sys_chmod (collected, mode);
}
</source>
<source file="/cmpt816/tmp/init/initramfs.c.ifdefed" startline="282" endline="288">
{
    if (maybe_link () == 0) {
        sys_mknod (collected, mode, rdev);
        sys_chown (collected, uid, gid);
        sys_chmod (collected, mode);
    }
}
</source>
<source file="/cmpt816/tmp/init/initramfs.c.ifdefed" startline="283" endline="287">
{
    sys_mknod (collected, mode, rdev);
    sys_chown (collected, uid, gid);
    sys_chmod (collected, mode);
}
</source>
<source file="/cmpt816/tmp/init/initramfs.c.ifdefed" startline="293" endline="306">
{
    if (count >= body_len) {
        sys_write (wfd, victim, body_len);
        sys_close (wfd);
        eat (body_len);
        state = SkipIt;
        return 0;
    }
    else {
        sys_write (wfd, victim, count);
        body_len -= count;
        eat (count);
        return 1;
    }
}
</source>
<source file="/cmpt816/tmp/init/initramfs.c.ifdefed" startline="294" endline="300">
{
    sys_write (wfd, victim, body_len);
    sys_close (wfd);
    eat (body_len);
    state = SkipIt;
    return 0;
}
</source>
<source file="/cmpt816/tmp/init/initramfs.c.ifdefed" startline="300" endline="305">
{
    sys_write (wfd, victim, count);
    body_len -= count;
    eat (count);
    return 1;
}
</source>
<source file="/cmpt816/tmp/init/initramfs.c.ifdefed" startline="309" endline="317">
{
    collected[N_ALIGN (name_len) + body_len] = '\0';
    clean_path (collected, 0);
    sys_symlink (collected + N_ALIGN (name_len), collected);
    sys_lchown (collected, uid, gid);
    state = SkipIt;
    next_state = Reset;
    return 0;
}
</source>
<source file="/cmpt816/tmp/init/initramfs.c.ifdefed" startline="331" endline="338">
{
    count = len;
    victim = buf;
    while (!actions[state] ())
        ;
    return len - count;
}
</source>
<source file="/cmpt816/tmp/init/initramfs.c.ifdefed" startline="341" endline="358">
{
    int written;
    if (message)
        return;
    while ((written = write_buffer (buf, len)) < len && !message) {
        char c = buf[written];
        if (c == '0') {
            buf += written;
            len -= written;
            state = Start;
        }
        else if (c == 0) {
            buf += written;
            len -= written;
            state = Reset;
        }
        else
            error ("junk in compressed archive");
    }
}
</source>
<source file="/cmpt816/tmp/init/initramfs.c.ifdefed" startline="345" endline="357">
{
    char c = buf[written];
    if (c == '0') {
        buf += written;
        len -= written;
        state = Start;
    }
    else if (c == 0) {
        buf += written;
        len -= written;
        state = Reset;
    }
    else
        error ("junk in compressed archive");
}
</source>
<source file="/cmpt816/tmp/init/initramfs.c.ifdefed" startline="347" endline="351">
{
    buf += written;
    len -= written;
    state = Start;
}
</source>
<source file="/cmpt816/tmp/init/initramfs.c.ifdefed" startline="351" endline="355">
{
    buf += written;
    len -= written;
    state = Reset;
}
</source>
<source file="/cmpt816/tmp/init/initramfs.c.ifdefed" startline="410" endline="424">
{
    ulg c = crc;
    unsigned n;
    uch *in, ch;
    flush_buffer (window, outcnt);
    in = window;
    for (n = 0; n < outcnt; n++) {
        ch = *in++;
        c = crc_32_tab[((int) c ^ ch) & 0xff] ^ (c >> 8);
    }
    crc = c;
    bytes_out += (ulg) outcnt;
    outcnt = 0;
}
</source>
<source file="/cmpt816/tmp/init/initramfs.c.ifdefed" startline="417" endline="420">
{
    ch = *in++;
    c = crc_32_tab[((int) c ^ ch) & 0xff] ^ (c >> 8);
}
</source>
<source file="/cmpt816/tmp/init/initramfs.c.ifdefed" startline="427" endline="474">
{
    int written;
    dry_run = check_only;
    header_buf = kmalloc (110, GFP_KERNEL);
    symlink_buf = kmalloc (PATH_MAX +N_ALIGN (PATH_MAX) + 1, GFP_KERNEL);
    name_buf = kmalloc (N_ALIGN (PATH_MAX), GFP_KERNEL);
    window = kmalloc (WSIZE, GFP_KERNEL);
    if (!window || !header_buf || !symlink_buf || !name_buf)
        panic ("can't allocate buffers");
    state = Start;
    this_header = 0;
    message = NULL;
    while (!message && len) {
        loff_t saved_offset = this_header;
        if (*buf == '0' && !(this_header & 3)) {
            state = Start;
            written = write_buffer (buf, len);
            buf += written;
            len -= written;
            continue;
        }
        if (!*buf) {
            buf++;
            len--;
            this_header++;
            continue;
        }
        this_header = 0;
        insize = len;
        inbuf = buf;
        inptr = 0;
        outcnt = 0;
        bytes_out = 0;
        crc = (ulg) 0xffffffffL;
        makecrc ();
        gunzip ();
        if (state != Reset)
            error ("junk in gzipped archive");
        this_header = saved_offset + inptr;
        buf += inptr;
        len -= inptr;
    }
    kfree (window);
    kfree (name_buf);
    kfree (symlink_buf);
    kfree (header_buf);
    return message;
}
</source>
<source file="/cmpt816/tmp/init/initramfs.c.ifdefed" startline="439" endline="468">
{
    loff_t saved_offset = this_header;
    if (*buf == '0' && !(this_header & 3)) {
        state = Start;
        written = write_buffer (buf, len);
        buf += written;
        len -= written;
        continue;
    }
    if (!*buf) {
        buf++;
        len--;
        this_header++;
        continue;
    }
    this_header = 0;
    insize = len;
    inbuf = buf;
    inptr = 0;
    outcnt = 0;
    bytes_out = 0;
    crc = (ulg) 0xffffffffL;
    makecrc ();
    gunzip ();
    if (state != Reset)
        error ("junk in gzipped archive");
    this_header = saved_offset + inptr;
    buf += inptr;
    len -= inptr;
}
</source>
<source file="/cmpt816/tmp/init/initramfs.c.ifdefed" startline="441" endline="447">
{
    state = Start;
    written = write_buffer (buf, len);
    buf += written;
    len -= written;
    continue;
}
</source>
<source file="/cmpt816/tmp/init/initramfs.c.ifdefed" startline="448" endline="453">
{
    buf++;
    len--;
    this_header++;
    continue;
}
</source>
<source file="/cmpt816/tmp/init/initramfs.c.ifdefed" startline="479" endline="484">
{
    if (*str)
        return 0;
    do_retain_initrd = 1;
    return 1;
}
</source>
<source file="/cmpt816/tmp/init/initramfs.c.ifdefed" startline="492" endline="521">
{
    if (do_retain_initrd)
        goto skip;
    free_initrd_mem (initrd_start, initrd_end);
skip :
    initrd_start = 0;
    initrd_end = 0;
}
</source>
<source file="/cmpt816/tmp/init/initramfs.c.ifdefed" startline="524" endline="561">
{
    char *err = unpack_to_rootfs (__initramfs_start, __initramfs_end -__initramfs_start, 0);
    if (err)
        panic (err);
    if (initrd_start) {
        printk (KERN_INFO "Unpacking initramfs...");
        err = unpack_to_rootfs ((char *) initrd_start, initrd_end -initrd_start, 0);
        if (err)
            panic (err);
        printk (" done\n");
        free_initrd ();
    }
    return 0;
}
</source>
<source file="/cmpt816/tmp/init/initramfs.c.ifdefed" startline="529" endline="559">
{
    printk (KERN_INFO "Unpacking initramfs...");
    err = unpack_to_rootfs ((char *) initrd_start, initrd_end -initrd_start, 0);
    if (err)
        panic (err);
    printk (" done\n");
    free_initrd ();
}
</source>
<source file="/cmpt816/tmp/init/do_mounts.c.ifdefed" startline="33" endline="36">
{
    rd_doload = simple_strtol (str, NULL, 0) & 3;
    return 1;
}
</source>
<source file="/cmpt816/tmp/init/do_mounts.c.ifdefed" startline="40" endline="45">
{
    if (*str)
        return 0;
    root_mountflags |= MS_RDONLY;
    return 1;
}
</source>
<source file="/cmpt816/tmp/init/do_mounts.c.ifdefed" startline="48" endline="53">
{
    if (*str)
        return 0;
    root_mountflags &= ~MS_RDONLY;
    return 1;
}
</source>
<source file="/cmpt816/tmp/init/do_mounts.c.ifdefed" startline="76" endline="143">
{
    char s [32];
    char *p;
    dev_t res = 0;
    int part;
    if (strncmp (name, "/dev/", 5) != 0) {
        unsigned maj, min;
        if (sscanf (name, "%u:%u", &maj, &min) == 2) {
            res = MKDEV (maj, min);
            if (maj != MAJOR (res) || min != MINOR (res))
                goto fail;
        }
        else {
            res = new_decode_dev (simple_strtoul (name, &p, 16));
            if (*p)
                goto fail;
        }
        goto done;
    }
    name += 5;
    res = Root_NFS;
    if (strcmp (name, "nfs") == 0)
        goto done;
    res = Root_RAM0;
    if (strcmp (name, "ram") == 0)
        goto done;
    if (strlen (name) > 31)
        goto fail;
    strcpy (s, name);
    for (p = s; *p; p++)
        if (*p == '/')
            *p = '!';
    res = blk_lookup_devt (s, 0);
    if (res)
        goto done;
    while (p > s && isdigit (p[-1]))
        p--;
    if (p == s || !*p || *p == '0')
        goto fail;
    part = simple_strtoul (p, NULL, 10);
    *p = '\0';
    res = blk_lookup_devt (s, part);
    if (res)
        goto done;
    if (p < s + 2 || !isdigit (p[-2]) || p[-1] != 'p')
        goto fail;
    p[-1] = '\0';
    res = blk_lookup_devt (s, part);
    if (res)
        goto done;
fail :
    return 0;
done :
    return res;
}
</source>
<source file="/cmpt816/tmp/init/do_mounts.c.ifdefed" startline="82" endline="95">
{
    unsigned maj, min;
    if (sscanf (name, "%u:%u", &maj, &min) == 2) {
        res = MKDEV (maj, min);
        if (maj != MAJOR (res) || min != MINOR (res))
            goto fail;
    }
    else {
        res = new_decode_dev (simple_strtoul (name, &p, 16));
        if (*p)
            goto fail;
    }
    goto done;
}
</source>
<source file="/cmpt816/tmp/init/do_mounts.c.ifdefed" startline="85" endline="89">
{
    res = MKDEV (maj, min);
    if (maj != MAJOR (res) || min != MINOR (res))
        goto fail;
}
</source>
<source file="/cmpt816/tmp/init/do_mounts.c.ifdefed" startline="89" endline="93">
{
    res = new_decode_dev (simple_strtoul (name, &p, 16));
    if (*p)
        goto fail;
}
</source>
<source file="/cmpt816/tmp/init/do_mounts.c.ifdefed" startline="146" endline="149">
{
    strlcpy (saved_root_name, line, sizeof (saved_root_name));
    return 1;
}
</source>
<source file="/cmpt816/tmp/init/do_mounts.c.ifdefed" startline="154" endline="159">
{
    if (*str)
        return 0;
    root_wait = 1;
    return 1;
}
</source>
<source file="/cmpt816/tmp/init/do_mounts.c.ifdefed" startline="165" endline="168">
{
    root_mount_data = str;
    return 1;
}
</source>
<source file="/cmpt816/tmp/init/do_mounts.c.ifdefed" startline="172" endline="175">
{
    root_fs_names = str;
    return 1;
}
</source>
<source file="/cmpt816/tmp/init/do_mounts.c.ifdefed" startline="179" endline="182">
{
    root_delay = simple_strtoul (str, NULL, 0);
    return 1;
}
</source>
<source file="/cmpt816/tmp/init/do_mounts.c.ifdefed" startline="189" endline="213">
{
    char *s = page;
    if (root_fs_names) {
        strcpy (page, root_fs_names);
        while (*s++) {
            if (s[-1] == ',')
                s[-1] = '\0';
        }
    }
    else {
        int len = get_filesystem_list (page);
        char *p, *next;
        page[len] = '\0';
        for (p = page - 1; p; p = next) {
            next = strchr (++p, '\n');
            if (*p++ != '\t')
                continue;
            while ((*s++ = *p++) != '\n')
                ;
            s[-1] = '\0';
        }
    }
    *s = '\0';
}
</source>
<source file="/cmpt816/tmp/init/do_mounts.c.ifdefed" startline="192" endline="198">
{
    strcpy (page, root_fs_names);
    while (*s++) {
        if (s[-1] == ',')
            s[-1] = '\0';
    }
}
</source>
<source file="/cmpt816/tmp/init/do_mounts.c.ifdefed" startline="194" endline="197">
{
    if (s[-1] == ',')
        s[-1] = '\0';
}
</source>
<source file="/cmpt816/tmp/init/do_mounts.c.ifdefed" startline="198" endline="211">
{
    int len = get_filesystem_list (page);
    char *p, *next;
    page[len] = '\0';
    for (p = page - 1; p; p = next) {
        next = strchr (++p, '\n');
        if (*p++ != '\t')
            continue;
        while ((*s++ = *p++) != '\n')
            ;
        s[-1] = '\0';
    }
}
</source>
<source file="/cmpt816/tmp/init/do_mounts.c.ifdefed" startline="203" endline="210">
{
    next = strchr (++p, '\n');
    if (*p++ != '\t')
        continue;
    while ((*s++ = *p++) != '\n')
        ;
    s[-1] = '\0';
}
</source>
<source file="/cmpt816/tmp/init/do_mounts.c.ifdefed" startline="216" endline="228">
{
    int err = sys_mount (name, "/root", fs, flags, data);
    if (err)
        return err;
    sys_chdir ("/root");
    ROOT_DEV = current->fs->pwd.mnt->mnt_sb->s_dev;
    printk ("VFS: Mounted root (%s filesystem)%s.\n", current -> fs -> pwd.mnt -> mnt_sb -> s_type -> name, current -> fs -> pwd.mnt -> mnt_sb -> s_flags & MS_RDONLY ? " readonly" : "");
    return 0;
}
</source>
<source file="/cmpt816/tmp/init/do_mounts.c.ifdefed" startline="231" endline="281">
{
    char *fs_names = __getname ();
    char *p;
    const char *b = name;
    get_fs_names (fs_names);
retry :
    for (p = fs_names; *p; p += strlen (p) + 1) {
        int err = do_mount_root (name, p, flags, root_mount_data);
        switch (err) {
        case 0 :
            goto out;
        case -EACCES :
            flags |= MS_RDONLY;
            goto retry;
        case -EINVAL :
            continue;
        }
        printk ("VFS: Cannot open root device \"%s\" or %s\n", root_device_name, b);
        printk ("Please append a correct \"root=\" boot option; here are the available partitions:\n");
        printk_all_partitions ();
        panic ("VFS: Unable to mount root fs on %s", b);
    }
    printk ("List of all partitions:\n");
    printk_all_partitions ();
    printk ("No filesystem could mount root, tried: ");
    for (p = fs_names; *p; p += strlen (p) + 1)
        printk (" %s", p);
    printk ("\n");
    panic ("VFS: Unable to mount root fs on %s", b);
out :
    putname (fs_names);
}
</source>
<source file="/cmpt816/tmp/init/do_mounts.c.ifdefed" startline="242" endline="267">
{
    int err = do_mount_root (name, p, flags, root_mount_data);
    switch (err) {
    case 0 :
        goto out;
    case -EACCES :
        flags |= MS_RDONLY;
        goto retry;
    case -EINVAL :
        continue;
    }
    printk ("VFS: Cannot open root device \"%s\" or %s\n", root_device_name, b);
    printk ("Please append a correct \"root=\" boot option; here are the available partitions:\n");
    printk_all_partitions ();
    panic ("VFS: Unable to mount root fs on %s", b);
}
</source>
<source file="/cmpt816/tmp/init/do_mounts.c.ifdefed" startline="244" endline="252">
{
case 0 :
    goto out;
case -EACCES :
    flags |= MS_RDONLY;
    goto retry;
case -EINVAL :
    continue;
}
</source>
<source file="/cmpt816/tmp/init/do_mounts.c.ifdefed" startline="327" endline="353">
{
}
</source>
<source file="/cmpt816/tmp/init/do_mounts.c.ifdefed" startline="359" endline="407">
{
    int is_floppy;
    if (root_delay) {
        printk (KERN_INFO "Waiting %dsec before mounting root device...\n", root_delay);
        ssleep (root_delay);
    }
    while (driver_probe_done () != 0)
        msleep (100);
    md_run_setup ();
    if (saved_root_name[0]) {
        root_device_name = saved_root_name;
        if (!strncmp (root_device_name, "mtd", 3) || !strncmp (root_device_name, "ubi", 3)) {
            mount_block_root (root_device_name, root_mountflags);
            goto out;
        }
        ROOT_DEV = name_to_dev_t (root_device_name);
        if (strncmp (root_device_name, "/dev/", 5) == 0)
            root_device_name += 5;
    }
    if (initrd_load ())
        goto out;
    if ((ROOT_DEV == 0) && root_wait) {
        printk (KERN_INFO "Waiting for root device %s...\n", saved_root_name);
        while (driver_probe_done () != 0 || (ROOT_DEV = name_to_dev_t (saved_root_name)) == 0)
            msleep (100);
    }
    is_floppy = MAJOR (ROOT_DEV) == FLOPPY_MAJOR;
    if (is_floppy && rd_doload && rd_load_disk (0))
        ROOT_DEV = Root_RAM0;
    mount_root ();
out :
    sys_mount (".", "/", NULL, MS_MOVE, NULL);
    sys_chroot (".");
}
</source>
<source file="/cmpt816/tmp/init/do_mounts.c.ifdefed" startline="362" endline="366">
{
    printk (KERN_INFO "Waiting %dsec before mounting root device...\n", root_delay);
    ssleep (root_delay);
}
</source>
<source file="/cmpt816/tmp/init/do_mounts.c.ifdefed" startline="374" endline="384">
{
    root_device_name = saved_root_name;
    if (!strncmp (root_device_name, "mtd", 3) || !strncmp (root_device_name, "ubi", 3)) {
        mount_block_root (root_device_name, root_mountflags);
        goto out;
    }
    ROOT_DEV = name_to_dev_t (root_device_name);
    if (strncmp (root_device_name, "/dev/", 5) == 0)
        root_device_name += 5;
}
</source>
<source file="/cmpt816/tmp/init/do_mounts.c.ifdefed" startline="377" endline="380">
{
    mount_block_root (root_device_name, root_mountflags);
    goto out;
}
</source>
<source file="/cmpt816/tmp/init/do_mounts.c.ifdefed" startline="390" endline="396">
{
    printk (KERN_INFO "Waiting for root device %s...\n", saved_root_name);
    while (driver_probe_done () != 0 || (ROOT_DEV = name_to_dev_t (saved_root_name)) == 0)
        msleep (100);
}
</source>
<source file="/cmpt816/tmp/init/calibrate.c.ifdefed" startline="16" endline="19">
{
    preset_lpj = simple_strtoul (str, NULL, 0);
    return 1;
}
</source>
<source file="/cmpt816/tmp/init/calibrate.c.ifdefed" startline="108" endline="108">
{
    return 0;
}
</source>
<source file="/cmpt816/tmp/init/calibrate.c.ifdefed" startline="123" endline="176">
{
    unsigned long ticks, loopbit;
    int lps_precision = LPS_PREC;
    if (preset_lpj) {
        loops_per_jiffy = preset_lpj;
        printk (KERN_INFO "Calibrating delay loop (skipped) preset value.. ");
    }
    else if ((smp_processor_id () == 0) && lpj_fine) {
        loops_per_jiffy = lpj_fine;
        printk (KERN_INFO "Calibrating delay loop (skipped), " "value calculated using timer frequency.. ");
    }
    else if ((loops_per_jiffy = calibrate_delay_direct ()) != 0) {
        printk (KERN_INFO "Calibrating delay using timer specific routine.. ");
    }
    else {
        loops_per_jiffy = (1 << 12);
        printk (KERN_INFO "Calibrating delay loop... ");
        while ((loops_per_jiffy <<= 1) != 0) {
            ticks = jiffies;
            while (ticks == jiffies)
                ;
            ticks = jiffies;
            __delay (loops_per_jiffy);
            ticks = jiffies - ticks;
            if (ticks)
                break;
        }
        loops_per_jiffy >>= 1;
        loopbit = loops_per_jiffy;
        while (lps_precision-- && (loopbit >>= 1)) {
            loops_per_jiffy |= loopbit;
            ticks = jiffies;
            while (ticks == jiffies)
                ;
            ticks = jiffies;
            __delay (loops_per_jiffy);
            if (jiffies != ticks)
                loops_per_jiffy &= ~loopbit;
        }
    }
    printk (KERN_CONT "%lu.%02lu BogoMIPS (lpj=%lu)\n", loops_per_jiffy / (500000 / HZ), (loops_per_jiffy / (5000 / HZ)) % 100, loops_per_jiffy);
}
</source>
<source file="/cmpt816/tmp/init/calibrate.c.ifdefed" startline="127" endline="131">
{
    loops_per_jiffy = preset_lpj;
    printk (KERN_INFO "Calibrating delay loop (skipped) preset value.. ");
}
</source>
<source file="/cmpt816/tmp/init/calibrate.c.ifdefed" startline="131" endline="136">
{
    loops_per_jiffy = lpj_fine;
    printk (KERN_INFO "Calibrating delay loop (skipped), " "value calculated using timer frequency.. ");
}
</source>
<source file="/cmpt816/tmp/init/calibrate.c.ifdefed" startline="136" endline="139">
{
    printk (KERN_INFO "Calibrating delay using timer specific routine.. ");
}
</source>
<source file="/cmpt816/tmp/init/calibrate.c.ifdefed" startline="139" endline="172">
{
    loops_per_jiffy = (1 << 12);
    printk (KERN_INFO "Calibrating delay loop... ");
    while ((loops_per_jiffy <<= 1) != 0) {
        ticks = jiffies;
        while (ticks == jiffies)
            ;
        ticks = jiffies;
        __delay (loops_per_jiffy);
        ticks = jiffies - ticks;
        if (ticks)
            break;
    }
    loops_per_jiffy >>= 1;
    loopbit = loops_per_jiffy;
    while (lps_precision-- && (loopbit >>= 1)) {
        loops_per_jiffy |= loopbit;
        ticks = jiffies;
        while (ticks == jiffies)
            ;
        ticks = jiffies;
        __delay (loops_per_jiffy);
        if (jiffies != ticks)
            loops_per_jiffy &= ~loopbit;
    }
}
</source>
<source file="/cmpt816/tmp/init/calibrate.c.ifdefed" startline="143" endline="154">
{
    ticks = jiffies;
    while (ticks == jiffies)
        ;
    ticks = jiffies;
    __delay (loops_per_jiffy);
    ticks = jiffies - ticks;
    if (ticks)
        break;
}
</source>
<source file="/cmpt816/tmp/init/calibrate.c.ifdefed" startline="162" endline="171">
{
    loops_per_jiffy |= loopbit;
    ticks = jiffies;
    while (ticks == jiffies)
        ;
    ticks = jiffies;
    __delay (loops_per_jiffy);
    if (jiffies != ticks)
        loops_per_jiffy &= ~loopbit;
}
</source>
<source file="/cmpt816/tmp/init/main.c.ifdefed" startline="95" endline="95">
{
}
</source>
<source file="/cmpt816/tmp/init/main.c.ifdefed" startline="98" endline="98">
{
}
</source>
<source file="/cmpt816/tmp/init/main.c.ifdefed" startline="183" endline="186">
{
    reset_devices = 1;
    return 1;
}
</source>
<source file="/cmpt816/tmp/init/main.c.ifdefed" startline="197" endline="223">
{
    struct obs_kernel_param *p;
    int had_early_param = 0;
    p = __setup_start;
    do {
        int n = strlen (p->str);
        if (!strncmp (line, p->str, n)) {
            if (p->early) {
                if (line[n] == '\0' || line[n] == '=')
                    had_early_param = 1;
            }
            else if (!p->setup_func) {
                printk (KERN_WARNING "Parameter %s is obsolete," " ignored\n", p -> str);
                return 1;
            }
            else if (p->setup_func (line +n))
                return 1;
        }
        p++;
    }
    while (p < __setup_end);
    return had_early_param;
}
</source>
<source file="/cmpt816/tmp/init/main.c.ifdefed" startline="202" endline="220">
{
    int n = strlen (p->str);
    if (!strncmp (line, p->str, n)) {
        if (p->early) {
            if (line[n] == '\0' || line[n] == '=')
                had_early_param = 1;
        }
        else if (!p->setup_func) {
            printk (KERN_WARNING "Parameter %s is obsolete," " ignored\n", p -> str);
            return 1;
        }
        else if (p->setup_func (line +n))
            return 1;
    }
    p++;
}
</source>
<source file="/cmpt816/tmp/init/main.c.ifdefed" startline="204" endline="218">
{
    if (p->early) {
        if (line[n] == '\0' || line[n] == '=')
            had_early_param = 1;
    }
    else if (!p->setup_func) {
        printk (KERN_WARNING "Parameter %s is obsolete," " ignored\n", p -> str);
        return 1;
    }
    else if (p->setup_func (line +n))
        return 1;
}
</source>
<source file="/cmpt816/tmp/init/main.c.ifdefed" startline="205" endline="212">
{
    if (line[n] == '\0' || line[n] == '=')
        had_early_param = 1;
}
</source>
<source file="/cmpt816/tmp/init/main.c.ifdefed" startline="212" endline="216">
{
    printk (KERN_WARNING "Parameter %s is obsolete," " ignored\n", p -> str);
    return 1;
}
</source>
<source file="/cmpt816/tmp/init/main.c.ifdefed" startline="234" endline="237">
{
    console_loglevel = 10;
    return 0;
}
</source>
<source file="/cmpt816/tmp/init/main.c.ifdefed" startline="240" endline="243">
{
    console_loglevel = 4;
    return 0;
}
</source>
<source file="/cmpt816/tmp/init/main.c.ifdefed" startline="249" endline="252">
{
    get_option (& str, & console_loglevel);
    return 0;
}
</source>
<source file="/cmpt816/tmp/init/main.c.ifdefed" startline="261" endline="315">
{
    if (val) {
        if (val == param + strlen (param) + 1)
            val[-1] = '=';
        else if (val == param + strlen (param) + 2) {
            val[-2] = '=';
            memmove (val - 1, val, strlen (val) + 1);
            val--;
        }
        else
            BUG ();
    }
    if (obsolete_checksetup (param))
        return 0;
    if (strchr (param, '.') && (!val || strchr (param, '.') < val)) {
        printk (KERN_ERR "Unknown boot option `%s': ignoring\n", param);
        return 0;
    }
    if (panic_later)
        return 0;
    if (val) {
        unsigned int i;
        for (i = 0; envp_init[i]; i++) {
            if (i == MAX_INIT_ENVS) {
                panic_later = "Too many boot env vars at `%s'";
                panic_param = param;
            }
            if (!strncmp (param, envp_init[i], val -param))
                break;
        }
        envp_init[i] = param;
    }
    else {
        unsigned int i;
        for (i = 0; argv_init[i]; i++) {
            if (i == MAX_INIT_ARGS) {
                panic_later = "Too many boot init vars at `%s'";
                panic_param = param;
            }
        }
        argv_init[i] = param;
    }
    return 0;
}
</source>
<source file="/cmpt816/tmp/init/main.c.ifdefed" startline="263" endline="273">
{
    if (val == param + strlen (param) + 1)
        val[-1] = '=';
    else if (val == param + strlen (param) + 2) {
        val[-2] = '=';
        memmove (val - 1, val, strlen (val) + 1);
        val--;
    }
    else
        BUG ();
}
</source>
<source file="/cmpt816/tmp/init/main.c.ifdefed" startline="267" endline="271">
{
    val[-2] = '=';
    memmove (val - 1, val, strlen (val) + 1);
    val--;
}
</source>
<source file="/cmpt816/tmp/init/main.c.ifdefed" startline="283" endline="286">
{
    printk (KERN_ERR "Unknown boot option `%s': ignoring\n", param);
    return 0;
}
</source>
<source file="/cmpt816/tmp/init/main.c.ifdefed" startline="291" endline="303">
{
    unsigned int i;
    for (i = 0; envp_init[i]; i++) {
        if (i == MAX_INIT_ENVS) {
            panic_later = "Too many boot env vars at `%s'";
            panic_param = param;
        }
        if (!strncmp (param, envp_init[i], val -param))
            break;
    }
    envp_init[i] = param;
}
</source>
<source file="/cmpt816/tmp/init/main.c.ifdefed" startline="294" endline="301">
{
    if (i == MAX_INIT_ENVS) {
        panic_later = "Too many boot env vars at `%s'";
        panic_param = param;
    }
    if (!strncmp (param, envp_init[i], val -param))
        break;
}
</source>
<source file="/cmpt816/tmp/init/main.c.ifdefed" startline="295" endline="298">
{
    panic_later = "Too many boot env vars at `%s'";
    panic_param = param;
}
</source>
<source file="/cmpt816/tmp/init/main.c.ifdefed" startline="303" endline="313">
{
    unsigned int i;
    for (i = 0; argv_init[i]; i++) {
        if (i == MAX_INIT_ARGS) {
            panic_later = "Too many boot init vars at `%s'";
            panic_param = param;
        }
    }
    argv_init[i] = param;
}
</source>
<source file="/cmpt816/tmp/init/main.c.ifdefed" startline="306" endline="311">
{
    if (i == MAX_INIT_ARGS) {
        panic_later = "Too many boot init vars at `%s'";
        panic_param = param;
    }
}
</source>
<source file="/cmpt816/tmp/init/main.c.ifdefed" startline="307" endline="310">
{
    panic_later = "Too many boot init vars at `%s'";
    panic_param = param;
}
</source>
<source file="/cmpt816/tmp/init/main.c.ifdefed" startline="322" endline="335">
{
    unsigned int i;
    execute_command = str;
    for (i = 1; i < MAX_INIT_ARGS; i++)
        argv_init[i] = NULL;
    return 1;
}
</source>
<source file="/cmpt816/tmp/init/main.c.ifdefed" startline="339" endline="347">
{
    unsigned int i;
    ramdisk_execute_command = str;
    for (i = 1; i < MAX_INIT_ARGS; i++)
        argv_init[i] = NULL;
    return 1;
}
</source>
<source file="/cmpt816/tmp/init/main.c.ifdefed" startline="361" endline="361">
{
}
</source>
<source file="/cmpt816/tmp/init/main.c.ifdefed" startline="362" endline="362">
{
}
</source>
<source file="/cmpt816/tmp/init/main.c.ifdefed" startline="363" endline="363">
{
}
</source>
<source file="/cmpt816/tmp/init/main.c.ifdefed" startline="444" endline="449">
{
    saved_command_line = alloc_bootmem (strlen (boot_command_line) +1);
    static_command_line = alloc_bootmem (strlen (command_line) +1);
    strcpy (saved_command_line, boot_command_line);
    strcpy (static_command_line, command_line);
}
</source>
<source file="/cmpt816/tmp/init/main.c.ifdefed" startline="462" endline="482">
{
    int pid;
    kernel_thread (kernel_init, NULL, CLONE_FS | CLONE_SIGHAND);
    numa_default_policy ();
    pid = kernel_thread (kthreadd, NULL, CLONE_FS | CLONE_FILES);
    kthreadd_task = find_task_by_pid_ns (pid, &init_pid_ns);
    unlock_kernel ();
    init_idle_bootup_task (current);
    preempt_enable_no_resched ();
    schedule ();
    preempt_disable ();
    cpu_idle ();
}
</source>
<source file="/cmpt816/tmp/init/main.c.ifdefed" startline="486" endline="501">
{
    struct obs_kernel_param *p;
    for (p = __setup_start; p < __setup_end; p++) {
        if ((p->early && strcmp (param, p->str) == 0) || (strcmp (param, "console") == 0 && strcmp (p->str, "earlycon") == 0)) {
            if (p->setup_func (val) != 0)
                printk (KERN_WARNING "Malformed early option '%s'\n", param);
        }
    }
    return 0;
}
</source>
<source file="/cmpt816/tmp/init/main.c.ifdefed" startline="489" endline="498">
{
    if ((p->early && strcmp (param, p->str) == 0) || (strcmp (param, "console") == 0 && strcmp (p->str, "earlycon") == 0)) {
        if (p->setup_func (val) != 0)
            printk (KERN_WARNING "Malformed early option '%s'\n", param);
    }
}
</source>
<source file="/cmpt816/tmp/init/main.c.ifdefed" startline="493" endline="497">
{
    if (p->setup_func (val) != 0)
        printk (KERN_WARNING "Malformed early option '%s'\n", param);
}
</source>
<source file="/cmpt816/tmp/init/main.c.ifdefed" startline="505" endline="516">
{
    static __initdata int done = 0;
    static __initdata char tmp_cmdline [COMMAND_LINE_SIZE];
    if (done)
        return;
    strlcpy (tmp_cmdline, boot_command_line, COMMAND_LINE_SIZE);
    parse_args ("early options", tmp_cmdline, NULL, 0, do_early_param);
    done = 1;
}
</source>
<source file="/cmpt816/tmp/init/main.c.ifdefed" startline="523" endline="529">
{
    int cpu = smp_processor_id ();
    cpu_set (cpu, cpu_online_map);
    cpu_set (cpu, cpu_present_map);
    cpu_set (cpu, cpu_possible_map);
}
</source>
<source file="/cmpt816/tmp/init/main.c.ifdefed" startline="532" endline="533">
{
}
</source>
<source file="/cmpt816/tmp/init/main.c.ifdefed" startline="536" endline="537">
{
}
</source>
<source file="/cmpt816/tmp/init/main.c.ifdefed" startline="540" endline="692">
{
    char *command_line;
    extern struct kernel_param __start___param [], __stop___param [];
    smp_setup_processor_id ();
    unwind_init ();
    lockdep_init ();
    debug_objects_early_init ();
    cgroup_init_early ();
    local_irq_disable ();
    early_boot_irqs_off ();
    early_init_irq_lock_class ();
    lock_kernel ();
    tick_init ();
    boot_cpu_init ();
    page_address_init ();
    printk (KERN_NOTICE);
    printk (linux_banner);
    setup_arch (& command_line);
    mm_init_owner (& init_mm, & init_task);
    setup_command_line (command_line);
    unwind_setup ();
    setup_per_cpu_areas ();
    setup_nr_cpu_ids ();
    smp_prepare_boot_cpu ();
    sched_init ();
    preempt_disable ();
    build_all_zonelists ();
    page_alloc_init ();
    printk (KERN_NOTICE "Kernel command line: %s\n", boot_command_line);
    parse_early_param ();
    parse_args ("Booting kernel", static_command_line, __start___param, __stop___param - __start___param, & unknown_bootoption);
    if (!irqs_disabled ()) {
        printk (KERN_WARNING "start_kernel(): bug: interrupts were " "enabled *very* early, fixing it\n");
        local_irq_disable ();
    }
    sort_main_extable ();
    trap_init ();
    rcu_init ();
    init_IRQ ();
    pidhash_init ();
    init_timers ();
    hrtimers_init ();
    softirq_init ();
    timekeeping_init ();
    time_init ();
    sched_clock_init ();
    profile_init ();
    if (!irqs_disabled ())
        printk ("start_kernel(): bug: interrupts were enabled early\n");
    early_boot_irqs_on ();
    local_irq_enable ();
    console_init ();
    if (panic_later)
        panic (panic_later, panic_param);
    lockdep_info ();
    locking_selftest ();
    vfs_caches_init_early ();
    cpuset_init_early ();
    mem_init ();
    enable_debug_pagealloc ();
    cpu_hotplug_init ();
    kmem_cache_init ();
    debug_objects_mem_init ();
    idr_init_cache ();
    setup_per_cpu_pageset ();
    numa_policy_init ();
    if (late_time_init)
        late_time_init ();
    calibrate_delay ();
    pidmap_init ();
    pgtable_cache_init ();
    prio_tree_init ();
    anon_vma_init ();
    thread_info_cache_init ();
    fork_init (num_physpages);
    proc_caches_init ();
    buffer_init ();
    unnamed_dev_init ();
    key_init ();
    security_init ();
    vfs_caches_init (num_physpages);
    radix_tree_init ();
    signals_init ();
    page_writeback_init ();
    cgroup_init ();
    cpuset_init ();
    taskstats_init_early ();
    delayacct_init ();
    check_bugs ();
    acpi_early_init ();
    rest_init ();
}
</source>
<source file="/cmpt816/tmp/init/main.c.ifdefed" startline="595" endline="599">
{
    printk (KERN_WARNING "start_kernel(): bug: interrupts were " "enabled *very* early, fixing it\n");
    local_irq_disable ();
}
</source>
<source file="/cmpt816/tmp/init/main.c.ifdefed" startline="697" endline="700">
{
    initcall_debug = 1;
    return 1;
}
</source>
<source file="/cmpt816/tmp/init/main.c.ifdefed" startline="704" endline="744">
{
    int count = preempt_count ();
    ktime_t t0, t1, delta;
    char msgbuf [64];
    int result;
    if (initcall_debug) {
        printk ("calling  %pF\n", fn);
        t0 = ktime_get ();
    }
    result = fn ();
    if (initcall_debug) {
        t1 = ktime_get ();
        delta = ktime_sub (t1, t0);
        printk ("initcall %pF returned %d after %Ld msecs\n", fn, result, (unsigned long long) delta.tv64 >> 20);
    }
    msgbuf[0] = 0;
    if (result && result != -ENODEV && initcall_debug)
        sprintf (msgbuf, "error code %d ", result);
    if (preempt_count () != count) {
        strlcat (msgbuf, "preemption imbalance ", sizeof (msgbuf));
        preempt_count () = count;
    }
    if (irqs_disabled ()) {
        strlcat (msgbuf, "disabled interrupts ", sizeof (msgbuf));
        local_irq_enable ();
    }
    if (msgbuf[0]) {
        printk ("initcall %pF returned with %s\n", fn, msgbuf);
    }
    return result;
}
</source>
<source file="/cmpt816/tmp/init/main.c.ifdefed" startline="710" endline="713">
{
    printk ("calling  %pF\n", fn);
    t0 = ktime_get ();
}
</source>
<source file="/cmpt816/tmp/init/main.c.ifdefed" startline="717" endline="724">
{
    t1 = ktime_get ();
    delta = ktime_sub (t1, t0);
    printk ("initcall %pF returned %d after %Ld msecs\n", fn, result, (unsigned long long) delta.tv64 >> 20);
}
</source>
<source file="/cmpt816/tmp/init/main.c.ifdefed" startline="731" endline="734">
{
    strlcat (msgbuf, "preemption imbalance ", sizeof (msgbuf));
    preempt_count () = count;
}
</source>
<source file="/cmpt816/tmp/init/main.c.ifdefed" startline="735" endline="738">
{
    strlcat (msgbuf, "disabled interrupts ", sizeof (msgbuf));
    local_irq_enable ();
}
</source>
<source file="/cmpt816/tmp/init/main.c.ifdefed" startline="739" endline="741">
{
    printk ("initcall %pF returned with %s\n", fn, msgbuf);
}
</source>
<source file="/cmpt816/tmp/init/main.c.ifdefed" startline="750" endline="758">
{
    initcall_t *call;
    for (call = __early_initcall_end; call < __initcall_end; call++)
        do_one_initcall (*call);
    flush_scheduled_work ();
}
</source>
<source file="/cmpt816/tmp/init/main.c.ifdefed" startline="768" endline="776">
{
    rcu_init_sched ();
    init_workqueues ();
    usermodehelper_init ();
    driver_init ();
    init_irq_proc ();
    do_initcalls ();
}
</source>
<source file="/cmpt816/tmp/init/main.c.ifdefed" startline="779" endline="784">
{
    initcall_t *call;
    for (call = __initcall_start; call < __early_initcall_end; call++)
        do_one_initcall (*call);
}
</source>
<source file="/cmpt816/tmp/init/main.c.ifdefed" startline="787" endline="790">
{
    argv_init[0] = init_filename;
    kernel_execve (init_filename, argv_init, envp_init);
}
</source>
<source file="/cmpt816/tmp/init/main.c.ifdefed" startline="796" endline="834">
{
    free_initmem ();
    unlock_kernel ();
    mark_rodata_ro ();
    system_state = SYSTEM_RUNNING;
    numa_default_policy ();
    if (sys_open ((const char __user *) "/dev/console", O_RDWR, 0) < 0)
        printk (KERN_WARNING "Warning: unable to open an initial console.\n");
    (void) sys_dup (0);
    (void) sys_dup (0);
    current->signal->flags |= SIGNAL_UNKILLABLE;
    if (ramdisk_execute_command) {
        run_init_process (ramdisk_execute_command);
        printk (KERN_WARNING "Failed to execute %s\n", ramdisk_execute_command);
    }
    if (execute_command) {
        run_init_process (execute_command);
        printk (KERN_WARNING "Failed to execute %s.  Attempting " "defaults...\n", execute_command);
    }
    run_init_process ("/sbin/init");
    run_init_process ("/etc/init");
    run_init_process ("/bin/init");
    run_init_process ("/bin/sh");
    panic ("No init found.  Try passing init= option to kernel.");
}
</source>
<source file="/cmpt816/tmp/init/main.c.ifdefed" startline="811" endline="815">
{
    run_init_process (ramdisk_execute_command);
    printk (KERN_WARNING "Failed to execute %s\n", ramdisk_execute_command);
}
</source>
<source file="/cmpt816/tmp/init/main.c.ifdefed" startline="823" endline="827">
{
    run_init_process (execute_command);
    printk (KERN_WARNING "Failed to execute %s.  Attempting " "defaults...\n", execute_command);
}
</source>
<source file="/cmpt816/tmp/init/main.c.ifdefed" startline="837" endline="886">
{
    lock_kernel ();
    set_cpus_allowed_ptr (current, CPU_MASK_ALL_PTR);
    init_pid_ns.child_reaper = current;
    cad_pid = task_pid (current);
    smp_prepare_cpus (setup_max_cpus);
    do_pre_smp_initcalls ();
    smp_init ();
    sched_init_smp ();
    cpuset_init_smp ();
    do_basic_setup ();
    if (!ramdisk_execute_command)
        ramdisk_execute_command = "/init";
    if (sys_access ((const char __user *) ramdisk_execute_command, 0) != 0) {
        ramdisk_execute_command = NULL;
        prepare_namespace ();
    }
    init_post ();
    return 0;
}
</source>
<source file="/cmpt816/tmp/init/main.c.ifdefed" startline="874" endline="877">
{
    ramdisk_execute_command = NULL;
    prepare_namespace ();
}
</source>
<source file="/cmpt816/tmp/arch/x86/vdso/vgetcpu.c.ifdefed" startline="18" endline="33">
{
    unsigned int p;
    if (*vdso_vgetcpu_mode == VGETCPU_RDTSCP) {
        native_read_tscp (& p);
    }
    else {
        asm ("lsl %1,%0"
            : "=r" (p)
            : "r" (__PER_CPU_SEG)
        )}
    if (cpu)
        *cpu = p & 0xfff;
    if (node)
        *node = p >> 12;
    return 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/vdso/vgetcpu.c.ifdefed" startline="21" endline="24">
{
    native_read_tscp (& p);
}
</source>
<source file="/cmpt816/tmp/arch/x86/vdso/vgetcpu.c.ifdefed" startline="24" endline="27">
{
    asm ("lsl %1,%0"
        : "=r" (p)
        : "r" (__PER_CPU_SEG)
    )}
</source>
<source file="/cmpt816/tmp/arch/x86/vdso/vma.c.ifdefed" startline="28" endline="34">
{
    if (*(void**) p != (void *) VMAGIC) {
        printk ("VDSO: variable %s broken\n", name);
        vdso_enabled = 0;
    }
    return p;
}
</source>
<source file="/cmpt816/tmp/arch/x86/vdso/vma.c.ifdefed" startline="29" endline="32">
{
    printk ("VDSO: variable %s broken\n", name);
    vdso_enabled = 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/vdso/vma.c.ifdefed" startline="37" endline="74">
{
    int npages = (vdso_end - vdso_start + PAGE_SIZE - 1) / PAGE_SIZE;
    int i;
    char *vbase;
    vdso_size = npages << PAGE_SHIFT;
    vdso_pages = kmalloc (sizeof (struct page *) * npages, GFP_KERNEL);
    if (!vdso_pages)
        goto oom;
    for (i = 0; i < npages; i++) {
        struct page *p;
        p = alloc_page (GFP_KERNEL);
        if (!p)
            goto oom;
        vdso_pages[i] = p;
        copy_page (page_address (p), vdso_start + i * PAGE_SIZE);
    }
    vbase = vmap (vdso_pages, npages, 0, PAGE_KERNEL);
    if (!vbase)
        goto oom;
    if (memcmp (vbase, "\177ELF", 4)) {
        printk ("VDSO: I'm broken; not ELF\n");
        vdso_enabled = 0;
    }
    return 0;
oom :
    printk ("Cannot allocate vdso\n");
    vdso_enabled = 0;
    return -ENOMEM;
}
</source>
<source file="/cmpt816/tmp/arch/x86/vdso/vma.c.ifdefed" startline="46" endline="53">
{
    struct page *p;
    p = alloc_page (GFP_KERNEL);
    if (!p)
        goto oom;
    vdso_pages[i] = p;
    copy_page (page_address (p), vdso_start + i * PAGE_SIZE);
}
</source>
<source file="/cmpt816/tmp/arch/x86/vdso/vma.c.ifdefed" startline="59" endline="62">
{
    printk ("VDSO: I'm broken; not ELF\n");
    vdso_enabled = 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/vdso/vma.c.ifdefed" startline="84" endline="97">
{
    unsigned long addr, end;
    unsigned offset;
    end = (start + PMD_SIZE - 1) & PMD_MASK;
    if (end >= TASK_SIZE64)
        end = TASK_SIZE64;
    end -= len;
    offset = get_random_int () & (PTRS_PER_PTE - 1);
    addr = start + (offset << PAGE_SHIFT);
    if (addr >= end)
        addr = end;
    return addr;
}
</source>
<source file="/cmpt816/tmp/arch/x86/vdso/vma.c.ifdefed" startline="102" endline="130">
{
    struct mm_struct *mm = current->mm;
    unsigned long addr;
    int ret;
    if (!vdso_enabled)
        return 0;
    down_write (& mm -> mmap_sem);
    addr = vdso_addr (mm->start_stack, vdso_size);
    addr = get_unmapped_area (NULL, addr, vdso_size, 0, 0);
    if (IS_ERR_VALUE (addr)) {
        ret = addr;
        goto up_fail;
    }
    ret = install_special_mapping (mm, addr, vdso_size, VM_READ | VM_EXEC | VM_MAYREAD | VM_MAYWRITE | VM_MAYEXEC | VM_ALWAYSDUMP, vdso_pages);
    if (ret)
        goto up_fail;
    current->mm->context.vdso = (void *) addr;
up_fail :
    up_write (&mm->mmap_sem);
    return ret;
}
</source>
<source file="/cmpt816/tmp/arch/x86/vdso/vma.c.ifdefed" startline="113" endline="116">
{
    ret = addr;
    goto up_fail;
}
</source>
<source file="/cmpt816/tmp/arch/x86/vdso/vma.c.ifdefed" startline="133" endline="136">
{
    vdso_enabled = simple_strtoul (s, NULL, 0);
    return 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/vdso/vclock_gettime.c.ifdefed" startline="27" endline="32">
{
    long ret;
    asm ("syscall"
        : "=a" (ret)
        : "0" (__NR_clock_gettime), "D" (clock), "S" (ts)
        : "memory"
    ) return ret;
}
</source>
<source file="/cmpt816/tmp/arch/x86/vdso/vclock_gettime.c.ifdefed" startline="35" endline="41">
{
    long v;
    cycles_t (*vread) (void);
    vread = gtod->clock.vread;
    v = (vread () - gtod->clock.cycle_last) & gtod->clock.mask;
    return (v * gtod->clock.mult) >> gtod->clock.shift;
}
</source>
<source file="/cmpt816/tmp/arch/x86/vdso/vclock_gettime.c.ifdefed" startline="44" endline="54">
{
    unsigned long seq, ns;
    do {
        seq = read_seqbegin (&gtod->lock);
        ts->tv_sec = gtod->wall_time_sec;
        ts->tv_nsec = gtod->wall_time_nsec;
        ns = vgetns ();
    }
    while (unlikely (read_seqretry (&gtod->lock, seq)));
    timespec_add_ns (ts, ns);
    return 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/vdso/vclock_gettime.c.ifdefed" startline="46" endline="51">
{
    seq = read_seqbegin (&gtod->lock);
    ts->tv_sec = gtod->wall_time_sec;
    ts->tv_nsec = gtod->wall_time_nsec;
    ns = vgetns ();
}
</source>
<source file="/cmpt816/tmp/arch/x86/vdso/vclock_gettime.c.ifdefed" startline="59" endline="70">
{
    while (nsec >= NSEC_PER_SEC) {
        nsec -= NSEC_PER_SEC;
        ++sec;
    }
    while (nsec < 0) {
        nsec += NSEC_PER_SEC;
        --sec;
    }
    ts->tv_sec = sec;
    ts->tv_nsec = nsec;
}
</source>
<source file="/cmpt816/tmp/arch/x86/vdso/vclock_gettime.c.ifdefed" startline="60" endline="63">
{
    nsec -= NSEC_PER_SEC;
    ++sec;
}
</source>
<source file="/cmpt816/tmp/arch/x86/vdso/vclock_gettime.c.ifdefed" startline="64" endline="67">
{
    nsec += NSEC_PER_SEC;
    --sec;
}
</source>
<source file="/cmpt816/tmp/arch/x86/vdso/vclock_gettime.c.ifdefed" startline="73" endline="84">
{
    unsigned long seq, ns, secs;
    do {
        seq = read_seqbegin (&gtod->lock);
        secs = gtod->wall_time_sec;
        ns = gtod->wall_time_nsec + vgetns ();
        secs += gtod->wall_to_monotonic.tv_sec;
        ns += gtod->wall_to_monotonic.tv_nsec;
    }
    while (unlikely (read_seqretry (&gtod->lock, seq)));
    vset_normalized_timespec (ts, secs, ns);
    return 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/vdso/vclock_gettime.c.ifdefed" startline="75" endline="81">
{
    seq = read_seqbegin (&gtod->lock);
    secs = gtod->wall_time_sec;
    ns = gtod->wall_time_nsec + vgetns ();
    secs += gtod->wall_to_monotonic.tv_sec;
    ns += gtod->wall_to_monotonic.tv_nsec;
}
</source>
<source file="/cmpt816/tmp/arch/x86/vdso/vclock_gettime.c.ifdefed" startline="87" endline="96">
{
    if (likely (gtod->sysctl_enabled && gtod->clock.vread))
        switch (clock) {
        case CLOCK_REALTIME :
            return do_realtime (ts);
        case CLOCK_MONOTONIC :
            return do_monotonic (ts);
        }
    return vdso_fallback_gettime (clock, ts);
}
</source>
<source file="/cmpt816/tmp/arch/x86/vdso/vclock_gettime.c.ifdefed" startline="89" endline="94">
{
case CLOCK_REALTIME :
    return do_realtime (ts);
case CLOCK_MONOTONIC :
    return do_monotonic (ts);
}
</source>
<source file="/cmpt816/tmp/arch/x86/vdso/vclock_gettime.c.ifdefed" startline="101" endline="119">
{
    long ret;
    if (likely (gtod->sysctl_enabled && gtod->clock.vread)) {
        BUILD_BUG_ON (offsetof (struct timeval, tv_usec) != offsetof (struct timespec, tv_nsec) || sizeof (* tv) != sizeof (struct timespec));
        do_realtime ((struct timespec *) tv);
        tv->tv_usec /= 1000;
        if (unlikely (tz != NULL)) {
            tz->tz_minuteswest = gtod->sys_tz.tz_minuteswest;
            tz->tz_dsttime = gtod->sys_tz.tz_dsttime;
        }
        return 0;
    }
    asm ("syscall"
        : "=a" (ret)
        : "0" (__NR_gettimeofday), "D" (tv), "S" (tz)
        : "memory"
    ) return ret;
}
</source>
<source file="/cmpt816/tmp/arch/x86/vdso/vclock_gettime.c.ifdefed" startline="103" endline="115">
{
    BUILD_BUG_ON (offsetof (struct timeval, tv_usec) != offsetof (struct timespec, tv_nsec) || sizeof (* tv) != sizeof (struct timespec));
    do_realtime ((struct timespec *) tv);
    tv->tv_usec /= 1000;
    if (unlikely (tz != NULL)) {
        tz->tz_minuteswest = gtod->sys_tz.tz_minuteswest;
        tz->tz_dsttime = gtod->sys_tz.tz_dsttime;
    }
    return 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/vdso/vclock_gettime.c.ifdefed" startline="109" endline="113">
{
    tz->tz_minuteswest = gtod->sys_tz.tz_minuteswest;
    tz->tz_dsttime = gtod->sys_tz.tz_dsttime;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/tsc.c.ifdefed" startline="38" endline="59">
{
    u64 this_offset;
    if (unlikely (tsc_disabled)) {
        return (jiffies_64 - INITIAL_JIFFIES) * (1000000000 / HZ);
    }
    rdtscll (this_offset);
    return cycles_2_ns (this_offset);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/tsc.c.ifdefed" startline="49" endline="52">
{
    return (jiffies_64 - INITIAL_JIFFIES) * (1000000000 / HZ);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/tsc.c.ifdefed" startline="74" endline="76">
{
    return tsc_unstable;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/tsc.c.ifdefed" startline="93" endline="96">
{
    setup_clear_cpu_cap (X86_FEATURE_TSC);
    return 1;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/tsc.c.ifdefed" startline="108" endline="123">
{
    u64 t1, t2;
    int i;
    for (i = 0; i < MAX_RETRIES; i++) {
        t1 = get_cycles ();
        if (hpet)
            *hpet = hpet_readl (HPET_COUNTER) & 0xFFFFFFFF;
        else
            *pm = acpi_pm_read_early ();
        t2 = get_cycles ();
        if ((t2 - t1) < SMI_TRESHOLD)
            return t2;
    }
    return ULLONG_MAX;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/tsc.c.ifdefed" startline="112" endline="121">
{
    t1 = get_cycles ();
    if (hpet)
        *hpet = hpet_readl (HPET_COUNTER) & 0xFFFFFFFF;
    else
        *pm = acpi_pm_read_early ();
    t2 = get_cycles ();
    if ((t2 - t1) < SMI_TRESHOLD)
        return t2;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/tsc.c.ifdefed" startline="133" endline="182">
{
    u64 tsc, t1, t2, delta;
    unsigned long tscmin, tscmax;
    int pitcnt;
    outb ((inb (0x61) & ~ 0x02) | 0x01, 0x61);
    outb (0xb0, 0x43);
    outb ((CLOCK_TICK_RATE / (1000 / 50)) & 0xff, 0x42);
    outb ((CLOCK_TICK_RATE / (1000 / 50)) >> 8, 0x42);
    tsc = t1 = t2 = get_cycles ();
    pitcnt = 0;
    tscmax = 0;
    tscmin = ULONG_MAX;
    while ((inb (0x61) & 0x20) == 0) {
        t2 = get_cycles ();
        delta = t2 - tsc;
        tsc = t2;
        if ((unsigned long) delta < tscmin)
            tscmin = (unsigned int) delta;
        if ((unsigned long) delta > tscmax)
            tscmax = (unsigned int) delta;
        pitcnt++;
    }
    if (pitcnt < 5000 || tscmax > 10 * tscmin)
        return ULONG_MAX;
    delta = t2 - t1;
    do_div (delta, 50);
    return delta;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/tsc.c.ifdefed" startline="155" endline="164">
{
    t2 = get_cycles ();
    delta = t2 - tsc;
    tsc = t2;
    if ((unsigned long) delta < tscmin)
        tscmin = (unsigned int) delta;
    if ((unsigned long) delta > tscmax)
        tscmax = (unsigned int) delta;
    pitcnt++;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/tsc.c.ifdefed" startline="189" endline="333">
{
    u64 tsc1, tsc2, delta, pm1, pm2, hpet1, hpet2;
    unsigned long tsc_pit_min = ULONG_MAX, tsc_ref_min = ULONG_MAX;
    unsigned long flags;
    int hpet = is_hpet_enabled (), i;
    for (i = 0; i < 5; i++) {
        unsigned long tsc_pit_khz;
        local_irq_save (flags);
        tsc1 = tsc_read_refs (&pm1, hpet ? &hpet1 : NULL);
        tsc_pit_khz = pit_calibrate_tsc ();
        tsc2 = tsc_read_refs (&pm2, hpet ? &hpet2 : NULL);
        local_irq_restore (flags);
        tsc_pit_min = min (tsc_pit_min, tsc_pit_khz);
        if (!hpet && !pm1 && !pm2)
            continue;
        if (tsc1 == ULLONG_MAX || tsc2 == ULLONG_MAX)
            continue;
        tsc2 = (tsc2 - tsc1) * 1000000LL;
        if (hpet) {
            if (hpet2 < hpet1)
                hpet2 += 0x100000000ULL;
            hpet2 -= hpet1;
            tsc1 = ((u64) hpet2 * hpet_readl (HPET_PERIOD));
            do_div (tsc1, 1000000);
        }
        else {
            if (pm2 < pm1)
                pm2 += (u64) ACPI_PM_OVRRUN;
            pm2 -= pm1;
            tsc1 = pm2 * 1000000000LL;
            do_div (tsc1, PMTMR_TICKS_PER_SEC);
        }
        do_div (tsc2, tsc1);
        tsc_ref_min = min (tsc_ref_min, (unsigned long) tsc2);
    }
    if (tsc_pit_min == ULONG_MAX) {
        printk (KERN_WARNING "TSC: Unable to calibrate against PIT\n");
        if (!hpet && !pm1 && !pm2) {
            printk ("TSC: No reference (HPET/PMTIMER) available\n");
            return 0;
        }
        if (tsc_ref_min == ULONG_MAX) {
            printk (KERN_WARNING "TSC: HPET/PMTIMER calibration " "failed due to SMI disturbance.\n");
            return 0;
        }
        printk (KERN_INFO "TSC: using %s reference calibration\n", hpet ? "HPET" : "PMTIMER");
        return tsc_ref_min;
    }
    if (!hpet && !pm1 && !pm2) {
        printk (KERN_INFO "TSC: Using PIT calibration value\n");
        return tsc_pit_min;
    }
    if (tsc_ref_min == ULONG_MAX) {
        printk (KERN_WARNING "TSC: HPET/PMTIMER calibration failed due " "to SMI disturbance. Using PIT calibration\n");
        return tsc_pit_min;
    }
    delta = ((u64) tsc_pit_min) * 100;
    do_div (delta, tsc_ref_min);
    if (delta >= 95 && delta <= 105) {
        printk (KERN_INFO "TSC: PIT calibration confirmed by %s.\n", hpet ? "HPET" : "PMTIMER");
        printk (KERN_INFO "TSC: using %s calibration value\n", tsc_pit_min <= tsc_ref_min ? "PIT" : hpet ? "HPET" : "PMTIMER");
        return tsc_pit_min <= tsc_ref_min ? tsc_pit_min : tsc_ref_min;
    }
    printk (KERN_WARNING "TSC: PIT calibration deviates from %s: %lu %lu.\n", hpet ? "HPET" : "PMTIMER", tsc_pit_min, tsc_ref_min);
    printk (KERN_INFO "TSC: Using PIT calibration value\n");
    return tsc_pit_min;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/tsc.c.ifdefed" startline="219" endline="263">
{
    unsigned long tsc_pit_khz;
    local_irq_save (flags);
    tsc1 = tsc_read_refs (&pm1, hpet ? &hpet1 : NULL);
    tsc_pit_khz = pit_calibrate_tsc ();
    tsc2 = tsc_read_refs (&pm2, hpet ? &hpet2 : NULL);
    local_irq_restore (flags);
    tsc_pit_min = min (tsc_pit_min, tsc_pit_khz);
    if (!hpet && !pm1 && !pm2)
        continue;
    if (tsc1 == ULLONG_MAX || tsc2 == ULLONG_MAX)
        continue;
    tsc2 = (tsc2 - tsc1) * 1000000LL;
    if (hpet) {
        if (hpet2 < hpet1)
            hpet2 += 0x100000000ULL;
        hpet2 -= hpet1;
        tsc1 = ((u64) hpet2 * hpet_readl (HPET_PERIOD));
        do_div (tsc1, 1000000);
    }
    else {
        if (pm2 < pm1)
            pm2 += (u64) ACPI_PM_OVRRUN;
        pm2 -= pm1;
        tsc1 = pm2 * 1000000000LL;
        do_div (tsc1, PMTMR_TICKS_PER_SEC);
    }
    do_div (tsc2, tsc1);
    tsc_ref_min = min (tsc_ref_min, (unsigned long) tsc2);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/tsc.c.ifdefed" startline="247" endline="253">
{
    if (hpet2 < hpet1)
        hpet2 += 0x100000000ULL;
    hpet2 -= hpet1;
    tsc1 = ((u64) hpet2 * hpet_readl (HPET_PERIOD));
    do_div (tsc1, 1000000);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/tsc.c.ifdefed" startline="253" endline="259">
{
    if (pm2 < pm1)
        pm2 += (u64) ACPI_PM_OVRRUN;
    pm2 -= pm1;
    tsc1 = pm2 * 1000000000LL;
    do_div (tsc1, PMTMR_TICKS_PER_SEC);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/tsc.c.ifdefed" startline="268" endline="290">
{
    printk (KERN_WARNING "TSC: Unable to calibrate against PIT\n");
    if (!hpet && !pm1 && !pm2) {
        printk ("TSC: No reference (HPET/PMTIMER) available\n");
        return 0;
    }
    if (tsc_ref_min == ULONG_MAX) {
        printk (KERN_WARNING "TSC: HPET/PMTIMER calibration " "failed due to SMI disturbance.\n");
        return 0;
    }
    printk (KERN_INFO "TSC: using %s reference calibration\n", hpet ? "HPET" : "PMTIMER");
    return tsc_ref_min;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/tsc.c.ifdefed" startline="273" endline="276">
{
    printk ("TSC: No reference (HPET/PMTIMER) available\n");
    return 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/tsc.c.ifdefed" startline="279" endline="283">
{
    printk (KERN_WARNING "TSC: HPET/PMTIMER calibration " "failed due to SMI disturbance.\n");
    return 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/tsc.c.ifdefed" startline="293" endline="296">
{
    printk (KERN_INFO "TSC: Using PIT calibration value\n");
    return tsc_pit_min;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/tsc.c.ifdefed" startline="299" endline="303">
{
    printk (KERN_WARNING "TSC: HPET/PMTIMER calibration failed due " "to SMI disturbance. Using PIT calibration\n");
    return tsc_pit_min;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/tsc.c.ifdefed" startline="314" endline="321">
{
    printk (KERN_INFO "TSC: PIT calibration confirmed by %s.\n", hpet ? "HPET" : "PMTIMER");
    printk (KERN_INFO "TSC: using %s calibration value\n", tsc_pit_min <= tsc_ref_min ? "PIT" : hpet ? "HPET" : "PMTIMER");
    return tsc_pit_min <= tsc_ref_min ? tsc_pit_min : tsc_ref_min;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/tsc.c.ifdefed" startline="385" endline="402">
{
    unsigned long long tsc_now, ns_now;
    unsigned long flags, *scale;
    local_irq_save (flags);
    sched_clock_idle_sleep_event ();
    scale = &per_cpu (cyc2ns, cpu);
    rdtscll (tsc_now);
    ns_now = __cycles_2_ns (tsc_now);
    if (cpu_khz)
        *scale = (NSEC_PER_MSEC << CYC2NS_SCALE_FACTOR) / cpu_khz;
    sched_clock_idle_wakeup_event (0);
    local_irq_restore (flags);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/tsc.c.ifdefed" startline="494" endline="499">
{
    cycle_t ret = (cycle_t) get_cycles ();
    return ret >= clocksource_tsc.cycle_last ? ret : clocksource_tsc.cycle_last;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/tsc.c.ifdefed" startline="525" endline="535">
{
    if (!tsc_unstable) {
        tsc_unstable = 1;
        printk ("Marking TSC unstable due to %s\n", reason);
        if (clocksource_tsc.mult)
            clocksource_change_rating (&clocksource_tsc, 0);
        else
            clocksource_tsc.rating = 0;
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/tsc.c.ifdefed" startline="526" endline="534">
{
    tsc_unstable = 1;
    printk ("Marking TSC unstable due to %s\n", reason);
    if (clocksource_tsc.mult)
        clocksource_change_rating (&clocksource_tsc, 0);
    else
        clocksource_tsc.rating = 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/tsc.c.ifdefed" startline="540" endline="545">
{
    printk (KERN_NOTICE "%s detected: marking TSC unstable.\n", d -> ident);
    tsc_unstable = 1;
    return 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/tsc.c.ifdefed" startline="576" endline="576">
{
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/tsc.c.ifdefed" startline="584" endline="606">
{
    if (!cpu_has_tsc || tsc_unstable)
        return 1;
    if (boot_cpu_has (X86_FEATURE_CONSTANT_TSC))
        return 0;
    if (boot_cpu_data.x86_vendor != X86_VENDOR_INTEL) {
        if (num_possible_cpus () > 1)
            tsc_unstable = 1;
    }
    return tsc_unstable;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/tsc.c.ifdefed" startline="599" endline="603">
{
    if (num_possible_cpus () > 1)
        tsc_unstable = 1;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/tsc.c.ifdefed" startline="609" endline="618">
{
    clocksource_tsc.mult = clocksource_khz2mult (tsc_khz, clocksource_tsc.shift);
    if (check_tsc_unstable ()) {
        clocksource_tsc.rating = 0;
        clocksource_tsc.flags &= ~CLOCK_SOURCE_IS_CONTINUOUS;
    }
    clocksource_register (& clocksource_tsc);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/tsc.c.ifdefed" startline="613" endline="616">
{
    clocksource_tsc.rating = 0;
    clocksource_tsc.flags &= ~CLOCK_SOURCE_IS_CONTINUOUS;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/tsc.c.ifdefed" startline="621" endline="674">
{
    u64 lpj;
    int cpu;
    if (!cpu_has_tsc)
        return;
    tsc_khz = calibrate_tsc ();
    cpu_khz = tsc_khz;
    if (!tsc_khz) {
        mark_tsc_unstable ("could not calculate TSC khz");
        return;
    }
    lpj = ((u64) tsc_khz * 1000);
    do_div (lpj, HZ);
    lpj_fine = lpj;
    printk ("Detected %lu.%03lu MHz processor.\n", (unsigned long) cpu_khz / 1000, (unsigned long) cpu_khz % 1000);
    for_each_possible_cpu (cpu)
    set_cyc2ns_scale (cpu_khz, cpu);
    if (tsc_disabled > 0)
        return;
    tsc_disabled = 0;
    use_tsc_delay ();
    dmi_check_system (bad_tsc_dmi_table);
    if (unsynchronized_tsc ())
        mark_tsc_unstable ("TSCs unsynchronized");
    check_geode_tsc_reliable ();
    init_tsc_clocksource ();
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/tsc.c.ifdefed" startline="631" endline="634">
{
    mark_tsc_unstable ("could not calculate TSC khz");
    return;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/head.c.ifdefed" startline="20" endline="55">
{
    unsigned int lowmem, ebda_addr;
    if (paravirt_enabled ())
        return;
    lowmem = *(unsignedshort*) __va (BIOS_LOWMEM_KILOBYTES);
    lowmem <<= 10;
    ebda_addr = get_bios_ebda ();
    if ((lowmem - ebda_addr) <= 0x10000)
        lowmem = ebda_addr;
    if ((ebda_addr == 0) && (lowmem >= 0x9f000))
        lowmem = 0x9f000;
    if ((lowmem == 0) || (lowmem >= 0x100000))
        lowmem = 0x9f000;
    reserve_early_overlap_ok (lowmem, 0x100000, "BIOS reserved");
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/amd_iommu.c.ifdefed" startline="48" endline="50">
{
    return iommu->cap & IOMMU_CAP_NPCACHE;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/amd_iommu.c.ifdefed" startline="63" endline="77">
{
    u32 tail, head;
    u8 *target;
    tail = readl (iommu->mmio_base + MMIO_CMD_TAIL_OFFSET);
    target = iommu->cmd_buf + tail;
    memcpy_toio (target, cmd, sizeof (* cmd));
    tail = (tail + sizeof (*cmd)) % iommu->cmd_buf_size;
    head = readl (iommu->mmio_base + MMIO_CMD_HEAD_OFFSET);
    if (tail == head)
        return -ENOMEM;
    writel (tail, iommu -> mmio_base + MMIO_CMD_TAIL_OFFSET);
    return 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/amd_iommu.c.ifdefed" startline="84" endline="93">
{
    unsigned long flags;
    int ret;
    spin_lock_irqsave (& iommu -> lock, flags);
    ret = __iommu_queue_command (iommu, cmd);
    spin_unlock_irqrestore (& iommu -> lock, flags);
    return ret;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/amd_iommu.c.ifdefed" startline="103" endline="139">
{
    int ret = 0, ready = 0;
    unsigned status = 0;
    struct iommu_cmd cmd;
    unsigned long flags, i = 0;
    memset (& cmd, 0, sizeof (cmd));
    cmd.data[0] = CMD_COMPL_WAIT_INT_MASK;
    CMD_SET_TYPE (& cmd, CMD_COMPL_WAIT);
    iommu->need_sync = 0;
    spin_lock_irqsave (& iommu -> lock, flags);
    ret = __iommu_queue_command (iommu, &cmd);
    if (ret)
        goto out;
    while (!ready && (i < EXIT_LOOP_COUNT)) {
        ++i;
        status = readl (iommu->mmio_base + MMIO_STATUS_OFFSET);
        ready = status & MMIO_STATUS_COM_WAIT_INT_MASK;
    }
    status &= ~MMIO_STATUS_COM_WAIT_INT_MASK;
    writel (status, iommu -> mmio_base + MMIO_STATUS_OFFSET);
    if (unlikely ((i == EXIT_LOOP_COUNT) && printk_ratelimit ()))
        printk (KERN_WARNING "AMD IOMMU: Completion wait loop failed\n");
out :
    spin_unlock_irqrestore (&iommu->lock, flags);
    return 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/amd_iommu.c.ifdefed" startline="122" endline="127">
{
    ++i;
    status = readl (iommu->mmio_base + MMIO_STATUS_OFFSET);
    ready = status & MMIO_STATUS_COM_WAIT_INT_MASK;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/amd_iommu.c.ifdefed" startline="145" endline="160">
{
    struct iommu_cmd cmd;
    int ret;
    BUG_ON (iommu == NULL);
    memset (& cmd, 0, sizeof (cmd));
    CMD_SET_TYPE (& cmd, CMD_INV_DEV_ENTRY);
    cmd.data[0] = devid;
    ret = iommu_queue_command (iommu, &cmd);
    iommu->need_sync = 1;
    return ret;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/amd_iommu.c.ifdefed" startline="167" endline="187">
{
    struct iommu_cmd cmd;
    int ret;
    memset (& cmd, 0, sizeof (cmd));
    address &= PAGE_MASK;
    CMD_SET_TYPE (& cmd, CMD_INV_IOMMU_PAGES);
    cmd.data[1] |= domid;
    cmd.data[2] = lower_32_bits (address);
    cmd.data[3] = upper_32_bits (address);
    if (s)
        cmd.data[2] |= CMD_INV_IOMMU_PAGES_SIZE_MASK;
    if (pde)
        cmd.data[2] |= CMD_INV_IOMMU_PAGES_PDE_MASK;
    ret = iommu_queue_command (iommu, &cmd);
    iommu->need_sync = 1;
    return ret;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/amd_iommu.c.ifdefed" startline="196" endline="214">
{
    int s = 0;
    unsigned pages = iommu_num_pages (address, size);
    address &= PAGE_MASK;
    if (pages > 1) {
        address = CMD_INV_IOMMU_ALL_PAGES_ADDRESS;
        s = 1;
    }
    iommu_queue_inv_iommu_pages (iommu, address, domid, 0, s);
    return 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/amd_iommu.c.ifdefed" startline="202" endline="209">
{
    address = CMD_INV_IOMMU_ALL_PAGES_ADDRESS;
    s = 1;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/amd_iommu.c.ifdefed" startline="234" endline="278">
{
    u64 __pte, *pte, *page;
    bus_addr = PAGE_ALIGN (bus_addr);
    phys_addr = PAGE_ALIGN (bus_addr);
    if (bus_addr > IOMMU_MAP_SIZE_L3 || !(prot & IOMMU_PROT_MASK))
        return -EINVAL;
    pte = &dom->pt_root[IOMMU_PTE_L2_INDEX (bus_addr)];
    if (!IOMMU_PTE_PRESENT (*pte)) {
        page = (u64 *) get_zeroed_page (GFP_KERNEL);
        if (!page)
            return -ENOMEM;
        *pte = IOMMU_L2_PDE (virt_to_phys (page));
    }
    pte = IOMMU_PTE_PAGE (*pte);
    pte = &pte[IOMMU_PTE_L1_INDEX (bus_addr)];
    if (!IOMMU_PTE_PRESENT (*pte)) {
        page = (u64 *) get_zeroed_page (GFP_KERNEL);
        if (!page)
            return -ENOMEM;
        *pte = IOMMU_L1_PDE (virt_to_phys (page));
    }
    pte = IOMMU_PTE_PAGE (*pte);
    pte = &pte[IOMMU_PTE_L0_INDEX (bus_addr)];
    if (IOMMU_PTE_PRESENT (*pte))
        return -EBUSY;
    __pte = phys_addr | IOMMU_PTE_P;
    if (prot & IOMMU_PROT_IR)
        __pte |= IOMMU_PTE_IR;
    if (prot & IOMMU_PROT_IW)
        __pte |= IOMMU_PTE_IW;
    *pte = __pte;
    return 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/amd_iommu.c.ifdefed" startline="246" endline="251">
{
    page = (u64 *) get_zeroed_page (GFP_KERNEL);
    if (!page)
        return -ENOMEM;
    *pte = IOMMU_L2_PDE (virt_to_phys (page));
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/amd_iommu.c.ifdefed" startline="256" endline="261">
{
    page = (u64 *) get_zeroed_page (GFP_KERNEL);
    if (!page)
        return -ENOMEM;
    *pte = IOMMU_L1_PDE (virt_to_phys (page));
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/amd_iommu.c.ifdefed" startline="286" endline="296">
{
    u16 bdf, i;
    for (i = entry->devid_start; i <= entry->devid_end; ++i) {
        bdf = amd_iommu_alias_table[i];
        if (amd_iommu_rlookup_table[bdf] == iommu)
            return 1;
    }
    return 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/amd_iommu.c.ifdefed" startline="289" endline="293">
{
    bdf = amd_iommu_alias_table[i];
    if (amd_iommu_rlookup_table[bdf] == iommu)
        return 1;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/amd_iommu.c.ifdefed" startline="305" endline="318">
{
    struct unity_map_entry *entry;
    int ret;
    list_for_each_entry (entry, &amd_iommu_unity_map, list) {
        if (!iommu_for_unity_map (iommu, entry))
            continue;
        ret = dma_ops_unity_map (iommu->default_dom, entry);
        if (ret)
            return ret;
    }
    return 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/amd_iommu.c.ifdefed" startline="309" endline="315">
{
    if (!iommu_for_unity_map (iommu, entry))
        continue;
    ret = dma_ops_unity_map (iommu->default_dom, entry);
    if (ret)
        return ret;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/amd_iommu.c.ifdefed" startline="326" endline="344">
{
    u64 addr;
    int ret;
    for (addr = e->address_start; addr < e->address_end; addr += PAGE_SIZE) {
        ret = iommu_map (&dma_dom->domain, addr, addr, e->prot);
        if (ret)
            return ret;
        if (addr < dma_dom->aperture_size)
            __set_bit (addr >> PAGE_SHIFT, dma_dom->bitmap);
    }
    return 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/amd_iommu.c.ifdefed" startline="331" endline="341">
{
    ret = iommu_map (&dma_dom->domain, addr, addr, e->prot);
    if (ret)
        return ret;
    if (addr < dma_dom->aperture_size)
        __set_bit (addr >> PAGE_SHIFT, dma_dom->bitmap);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/amd_iommu.c.ifdefed" startline="351" endline="364">
{
    struct unity_map_entry *e;
    int ret;
    list_for_each_entry (e, &amd_iommu_unity_map, list) {
        if (!(devid >= e->devid_start && devid <= e->devid_end))
            continue;
        ret = dma_ops_unity_map (dma_dom, e);
        if (ret)
            return ret;
    }
    return 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/amd_iommu.c.ifdefed" startline="355" endline="361">
{
    if (!(devid >= e->devid_start && devid <= e->devid_end))
        continue;
    ret = dma_ops_unity_map (dma_dom, e);
    if (ret)
        return ret;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/amd_iommu.c.ifdefed" startline="376" endline="379">
{
    return (mask >> PAGE_SHIFT) + (PAGE_ALIGN (mask &~PAGE_MASK) >> PAGE_SHIFT);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/amd_iommu.c.ifdefed" startline="389" endline="417">
{
    unsigned long limit = dma_mask_to_pages (*dev->dma_mask);
    unsigned long address;
    unsigned long size = dom->aperture_size >> PAGE_SHIFT;
    unsigned long boundary_size;
    boundary_size = ALIGN (dma_get_seg_boundary (dev) +1, PAGE_SIZE) >> PAGE_SHIFT;
    limit = limit < size ? limit : size;
    if (dom->next_bit >= limit)
        dom->next_bit = 0;
    address = iommu_area_alloc (dom->bitmap, limit, dom->next_bit, pages, 0, boundary_size, 0);
    if (address == -1)
        address = iommu_area_alloc (dom->bitmap, limit, 0, pages, 0, boundary_size, 0);
    if (likely (address != -1)) {
        dom->next_bit = address + pages;
        address <<= PAGE_SHIFT;
    }
    else
        address = bad_dma_address;
    WARN_ON ((address + (PAGE_SIZE * pages)) > dom -> aperture_size);
    return address;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/amd_iommu.c.ifdefed" startline="408" endline="411">
{
    dom->next_bit = address + pages;
    address <<= PAGE_SHIFT;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/amd_iommu.c.ifdefed" startline="427" endline="430">
{
    address >>= PAGE_SHIFT;
    iommu_area_free (dom -> bitmap, address, pages);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/amd_iommu.c.ifdefed" startline="443" endline="457">
{
    unsigned long flags;
    int id;
    write_lock_irqsave (& amd_iommu_devtable_lock, flags);
    id = find_first_zero_bit (amd_iommu_pd_alloc_bitmap, MAX_DOMAIN_ID);
    BUG_ON (id == 0);
    if (id > 0 && id < MAX_DOMAIN_ID)
        __set_bit (id, amd_iommu_pd_alloc_bitmap);
    else
        id = 0;
    write_unlock_irqrestore (& amd_iommu_devtable_lock, flags);
    return id;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/amd_iommu.c.ifdefed" startline="466" endline="473">
{
    unsigned int last_page = dom->aperture_size >> PAGE_SHIFT;
    if (start_page + pages > last_page)
        pages = last_page - start_page;
    set_bit_string (dom -> bitmap, start_page, pages);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/amd_iommu.c.ifdefed" startline="476" endline="501">
{
    int i, j;
    u64 *p1, *p2, *p3;
    p1 = dma_dom->domain.pt_root;
    if (!p1)
        return;
    for (i = 0; i < 512; ++i) {
        if (!IOMMU_PTE_PRESENT (p1[i]))
            continue;
        p2 = IOMMU_PTE_PAGE (p1[i]);
        for (j = 0; j < 512; ++i) {
            if (!IOMMU_PTE_PRESENT (p2[j]))
                continue;
            p3 = IOMMU_PTE_PAGE (p2[j]);
            free_page ((unsigned long) p3);
        }
        free_page ((unsigned long) p2);
    }
    free_page ((unsigned long) p1);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/amd_iommu.c.ifdefed" startline="485" endline="498">
{
    if (!IOMMU_PTE_PRESENT (p1[i]))
        continue;
    p2 = IOMMU_PTE_PAGE (p1[i]);
    for (j = 0; j < 512; ++i) {
        if (!IOMMU_PTE_PRESENT (p2[j]))
            continue;
        p3 = IOMMU_PTE_PAGE (p2[j]);
        free_page ((unsigned long) p3);
    }
    free_page ((unsigned long) p2);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/amd_iommu.c.ifdefed" startline="490" endline="495">
{
    if (!IOMMU_PTE_PRESENT (p2[j]))
        continue;
    p3 = IOMMU_PTE_PAGE (p2[j]);
    free_page ((unsigned long) p3);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/amd_iommu.c.ifdefed" startline="508" endline="519">
{
    if (!dom)
        return;
    dma_ops_free_pagetable (dom);
    kfree (dom -> pte_pages);
    kfree (dom -> bitmap);
    kfree (dom);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/amd_iommu.c.ifdefed" startline="528" endline="606">
{
    struct dma_ops_domain *dma_dom;
    unsigned i, num_pte_pages;
    u64 *l2_pde;
    u64 address;
    if ((order < 25) || (order > 30))
        return NULL;
    dma_dom = kzalloc (sizeof (struct dma_ops_domain), GFP_KERNEL);
    if (!dma_dom)
        return NULL;
    spin_lock_init (& dma_dom -> domain.lock);
    dma_dom->domain.id = domain_id_alloc ();
    if (dma_dom->domain.id == 0)
        goto free_dma_dom;
    dma_dom->domain.mode = PAGE_MODE_3_LEVEL;
    dma_dom->domain.pt_root = (void *) get_zeroed_page (GFP_KERNEL);
    dma_dom->domain.priv = dma_dom;
    if (!dma_dom->domain.pt_root)
        goto free_dma_dom;
    dma_dom->aperture_size = (1ULL << order);
    dma_dom->bitmap = kzalloc (dma_dom->aperture_size / (PAGE_SIZE * 8), GFP_KERNEL);
    if (!dma_dom->bitmap)
        goto free_dma_dom;
    dma_dom->bitmap[0] = 1;
    dma_dom->next_bit = 0;
    if (iommu->exclusion_start && iommu->exclusion_start < dma_dom->aperture_size) {
        unsigned long startpage = iommu->exclusion_start >> PAGE_SHIFT;
        int pages = iommu_num_pages (iommu->exclusion_start, iommu->exclusion_length);
        dma_ops_reserve_addresses (dma_dom, startpage, pages);
    }
    num_pte_pages = dma_dom->aperture_size / (PAGE_SIZE * 512);
    dma_dom->pte_pages = kzalloc (num_pte_pages * sizeof (void *), GFP_KERNEL);
    if (!dma_dom->pte_pages)
        goto free_dma_dom;
    l2_pde = (u64 *) get_zeroed_page (GFP_KERNEL);
    if (l2_pde == NULL)
        goto free_dma_dom;
    dma_dom->domain.pt_root[0] = IOMMU_L2_PDE (virt_to_phys (l2_pde));
    for (i = 0; i < num_pte_pages; ++i) {
        dma_dom->pte_pages[i] = (u64 *) get_zeroed_page (GFP_KERNEL);
        if (!dma_dom->pte_pages[i])
            goto free_dma_dom;
        address = virt_to_phys (dma_dom->pte_pages[i]);
        l2_pde[i] = IOMMU_L1_PDE (address);
    }
    return dma_dom;
free_dma_dom :
    dma_ops_domain_free (dma_dom);
    return NULL;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/amd_iommu.c.ifdefed" startline="568" endline="573">
{
    unsigned long startpage = iommu->exclusion_start >> PAGE_SHIFT;
    int pages = iommu_num_pages (iommu->exclusion_start, iommu->exclusion_length);
    dma_ops_reserve_addresses (dma_dom, startpage, pages);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/amd_iommu.c.ifdefed" startline="592" endline="598">
{
    dma_dom->pte_pages[i] = (u64 *) get_zeroed_page (GFP_KERNEL);
    if (!dma_dom->pte_pages[i])
        goto free_dma_dom;
    address = virt_to_phys (dma_dom->pte_pages[i]);
    l2_pde[i] = IOMMU_L1_PDE (address);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/amd_iommu.c.ifdefed" startline="613" endline="622">
{
    struct protection_domain *dom;
    unsigned long flags;
    read_lock_irqsave (& amd_iommu_devtable_lock, flags);
    dom = amd_iommu_pd_table[devid];
    read_unlock_irqrestore (& amd_iommu_devtable_lock, flags);
    return dom;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/amd_iommu.c.ifdefed" startline="631" endline="650">
{
    unsigned long flags;
    u64 pte_root = virt_to_phys (domain->pt_root);
    pte_root |= (domain->mode & 0x07) << 9;
    pte_root |= IOMMU_PTE_IR | IOMMU_PTE_IW | IOMMU_PTE_P | 2;
    write_lock_irqsave (& amd_iommu_devtable_lock, flags);
    amd_iommu_dev_table[devid].data[0] = pte_root;
    amd_iommu_dev_table[devid].data[1] = pte_root >> 32;
    amd_iommu_dev_table[devid].data[2] = domain->id;
    amd_iommu_pd_table[devid] = domain;
    write_unlock_irqrestore (& amd_iommu_devtable_lock, flags);
    iommu_queue_inv_dev_entry (iommu, devid);
    iommu->need_sync = 1;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/amd_iommu.c.ifdefed" startline="669" endline="703">
{
    struct dma_ops_domain *dma_dom;
    struct pci_dev *pcidev;
    u16 _bdf;
    BUG_ON (! dev || dev -> bus != & pci_bus_type || ! dev -> dma_mask);
    pcidev = to_pci_dev (dev);
    _bdf = calc_devid (pcidev->bus->number, pcidev->devfn);
    if (_bdf > amd_iommu_last_bdf) {
        *iommu = NULL;
        *domain = NULL;
        *bdf = 0xffff;
        return 0;
    }
    *bdf = amd_iommu_alias_table[_bdf];
    *iommu = amd_iommu_rlookup_table[*bdf];
    if (*iommu == NULL)
        return 0;
    dma_dom = (*iommu)->default_dom;
    *domain = domain_for_device (*bdf);
    if (*domain == NULL) {
        *domain = &dma_dom->domain;
        set_device_domain (* iommu, * domain, * bdf);
        printk (KERN_INFO "AMD IOMMU: Using protection domain %d for " "device ", (* domain) -> id);
        print_devid (_bdf, 1);
    }
    return 1;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/amd_iommu.c.ifdefed" startline="680" endline="685">
{
    *iommu = NULL;
    *domain = NULL;
    *bdf = 0xffff;
    return 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/amd_iommu.c.ifdefed" startline="694" endline="700">
{
    *domain = &dma_dom->domain;
    set_device_domain (* iommu, * domain, * bdf);
    printk (KERN_INFO "AMD IOMMU: Using protection domain %d for " "device ", (* domain) -> id);
    print_devid (_bdf, 1);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/amd_iommu.c.ifdefed" startline="714" endline="738">
{
    u64 *pte, __pte;
    WARN_ON (address > dom -> aperture_size);
    paddr &= PAGE_MASK;
    pte = dom->pte_pages[IOMMU_PTE_L1_INDEX (address)];
    pte += IOMMU_PTE_L0_INDEX (address);
    __pte = paddr | IOMMU_PTE_P | IOMMU_PTE_FC;
    if (direction == DMA_TO_DEVICE)
        __pte |= IOMMU_PTE_IR;
    else if (direction == DMA_FROM_DEVICE)
        __pte |= IOMMU_PTE_IW;
    else if (direction == DMA_BIDIRECTIONAL)
        __pte |= IOMMU_PTE_IR | IOMMU_PTE_IW;
    WARN_ON (*pte);
    *pte = __pte;
    return (dma_addr_t) address;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/amd_iommu.c.ifdefed" startline="746" endline="760">
{
    u64 *pte;
    if (address >= dom->aperture_size)
        return;
    WARN_ON (address & 0xfffULL || address > dom -> aperture_size);
    pte = dom->pte_pages[IOMMU_PTE_L1_INDEX (address)];
    pte += IOMMU_PTE_L0_INDEX (address);
    WARN_ON (! * pte);
    *pte = 0ULL;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/amd_iommu.c.ifdefed" startline="774" endline="797">
{
    dma_addr_t offset = paddr & ~PAGE_MASK;
    dma_addr_t address, start;
    unsigned int pages;
    int i;
    pages = iommu_num_pages (paddr, size);
    paddr &= PAGE_MASK;
    address = dma_ops_alloc_addresses (dev, dma_dom, pages);
    if (unlikely (address == bad_dma_address))
        goto out;
    start = address;
    for (i = 0; i < pages; ++i) {
        dma_ops_domain_map (iommu, dma_dom, start, paddr, dir);
        paddr += PAGE_SIZE;
        start += PAGE_SIZE;
    }
    address += offset;
out :
    return address;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/amd_iommu.c.ifdefed" startline="788" endline="792">
{
    dma_ops_domain_map (iommu, dma_dom, start, paddr, dir);
    paddr += PAGE_SIZE;
    start += PAGE_SIZE;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/amd_iommu.c.ifdefed" startline="808" endline="825">
{
    dma_addr_t i, start;
    unsigned int pages;
    if ((dma_addr == 0) || (dma_addr + size > dma_dom->aperture_size))
        return;
    pages = iommu_num_pages (dma_addr, size);
    dma_addr &= PAGE_MASK;
    start = dma_addr;
    for (i = 0; i < pages; ++i) {
        dma_ops_domain_unmap (iommu, dma_dom, start);
        start += PAGE_SIZE;
    }
    dma_ops_free_addresses (dma_dom, dma_addr, pages);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/amd_iommu.c.ifdefed" startline="819" endline="822">
{
    dma_ops_domain_unmap (iommu, dma_dom, start);
    start += PAGE_SIZE;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/amd_iommu.c.ifdefed" startline="832" endline="860">
{
    unsigned long flags;
    struct amd_iommu *iommu;
    struct protection_domain *domain;
    u16 devid;
    dma_addr_t addr;
    get_device_resources (dev, & iommu, & domain, & devid);
    if (iommu == NULL || domain == NULL)
        return (dma_addr_t) paddr;
    spin_lock_irqsave (& domain -> lock, flags);
    addr = __map_single (dev, iommu, domain->priv, paddr, size, dir);
    if (addr == bad_dma_address)
        goto out;
    if (iommu_has_npcache (iommu))
        iommu_flush_pages (iommu, domain->id, addr, size);
    if (iommu->need_sync)
        iommu_completion_wait (iommu);
out :
    spin_unlock_irqrestore (&domain->lock, flags);
    return addr;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/amd_iommu.c.ifdefed" startline="867" endline="887">
{
    unsigned long flags;
    struct amd_iommu *iommu;
    struct protection_domain *domain;
    u16 devid;
    if (!get_device_resources (dev, &iommu, &domain, &devid))
        return;
    spin_lock_irqsave (& domain -> lock, flags);
    __unmap_single (iommu, domain -> priv, dma_addr, size, dir);
    iommu_flush_pages (iommu, domain -> id, dma_addr, size);
    if (iommu->need_sync)
        iommu_completion_wait (iommu);
    spin_unlock_irqrestore (& domain -> lock, flags);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/amd_iommu.c.ifdefed" startline="895" endline="905">
{
    struct scatterlist *s;
    int i;

    for_each_sg (sglist, s, nelems, i) {
        s->dma_address = (dma_addr_t) sg_phys (s);
        s->dma_length = s->length;
    }

    return nelems;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/amd_iommu.c.ifdefed" startline="899" endline="902">
{
    s->dma_address = (dma_addr_t) sg_phys (s);
    s->dma_length = s->length;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/amd_iommu.c.ifdefed" startline="913" endline="964">
{
    unsigned long flags;
    struct amd_iommu *iommu;
    struct protection_domain *domain;
    u16 devid;
    int i;
    struct scatterlist *s;
    phys_addr_t paddr;
    int mapped_elems = 0;
    get_device_resources (dev, & iommu, & domain, & devid);
    if (!iommu || !domain)
        return map_sg_no_iommu (dev, sglist, nelems, dir);
    spin_lock_irqsave (& domain -> lock, flags);

    for_each_sg (sglist, s, nelems, i) {
        paddr = sg_phys (s);
        s->dma_address = __map_single (dev, iommu, domain->priv, paddr, s->length, dir);
        if (s->dma_address) {
            s->dma_length = s->length;
            mapped_elems++;
        }
        else
            goto unmap;
        if (iommu_has_npcache (iommu))
            iommu_flush_pages (iommu, domain->id, s->dma_address, s->dma_length);
    }

    if (iommu->need_sync)
        iommu_completion_wait (iommu);
out :
    spin_unlock_irqrestore (&domain->lock, flags);
    return mapped_elems;
unmap :

    for_each_sg (sglist, s, mapped_elems, i) {
        if (s->dma_address)
            __unmap_single (iommu, domain->priv, s->dma_address, s->dma_length, dir);
        s->dma_address = s->dma_length = 0;
    }

    mapped_elems = 0;
    goto out;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/amd_iommu.c.ifdefed" startline="930" endline="944">
{
    paddr = sg_phys (s);
    s->dma_address = __map_single (dev, iommu, domain->priv, paddr, s->length, dir);
    if (s->dma_address) {
        s->dma_length = s->length;
        mapped_elems++;
    }
    else
        goto unmap;
    if (iommu_has_npcache (iommu))
        iommu_flush_pages (iommu, domain->id, s->dma_address, s->dma_length);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/amd_iommu.c.ifdefed" startline="936" endline="939">
{
    s->dma_length = s->length;
    mapped_elems++;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/amd_iommu.c.ifdefed" startline="954" endline="959">
{
    if (s->dma_address)
        __unmap_single (iommu, domain->priv, s->dma_address, s->dma_length, dir);
    s->dma_address = s->dma_length = 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/amd_iommu.c.ifdefed" startline="972" endline="997">
{
    unsigned long flags;
    struct amd_iommu *iommu;
    struct protection_domain *domain;
    struct scatterlist *s;
    u16 devid;
    int i;
    if (!get_device_resources (dev, &iommu, &domain, &devid))
        return;
    spin_lock_irqsave (& domain -> lock, flags);

    for_each_sg (sglist, s, nelems, i) {
        __unmap_single (iommu, domain -> priv, s -> dma_address, s -> dma_length, dir);
        iommu_flush_pages (iommu, domain -> id, s -> dma_address, s -> dma_length);
        s->dma_address = s->dma_length = 0;
    }

    if (iommu->need_sync)
        iommu_completion_wait (iommu);
    spin_unlock_irqrestore (& domain -> lock, flags);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/amd_iommu.c.ifdefed" startline="985" endline="991">
{
    __unmap_single (iommu, domain -> priv, s -> dma_address, s -> dma_length, dir);
    iommu_flush_pages (iommu, domain -> id, s -> dma_address, s -> dma_length);
    s->dma_address = s->dma_length = 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/amd_iommu.c.ifdefed" startline="1004" endline="1047">
{
    unsigned long flags;
    void *virt_addr;
    struct amd_iommu *iommu;
    struct protection_domain *domain;
    u16 devid;
    phys_addr_t paddr;
    virt_addr = (void *) __get_free_pages (flag, get_order (size));
    if (!virt_addr)
        return 0;
    memset (virt_addr, 0, size);
    paddr = virt_to_phys (virt_addr);
    get_device_resources (dev, & iommu, & domain, & devid);
    if (!iommu || !domain) {
        *dma_addr = (dma_addr_t) paddr;
        return virt_addr;
    }
    spin_lock_irqsave (& domain -> lock, flags);
    *dma_addr = __map_single (dev, iommu, domain->priv, paddr, size, DMA_BIDIRECTIONAL);
    if (*dma_addr == bad_dma_address) {
        free_pages ((unsigned long) virt_addr, get_order (size));
        virt_addr = NULL;
        goto out;
    }
    if (iommu_has_npcache (iommu))
        iommu_flush_pages (iommu, domain->id, *dma_addr, size);
    if (iommu->need_sync)
        iommu_completion_wait (iommu);
out :
    spin_unlock_irqrestore (&domain->lock, flags);
    return virt_addr;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/amd_iommu.c.ifdefed" startline="1021" endline="1024">
{
    *dma_addr = (dma_addr_t) paddr;
    return virt_addr;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/amd_iommu.c.ifdefed" startline="1031" endline="1035">
{
    free_pages ((unsigned long) virt_addr, get_order (size));
    virt_addr = NULL;
    goto out;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/amd_iommu.c.ifdefed" startline="1056" endline="1079">
{
    unsigned long flags;
    struct amd_iommu *iommu;
    struct protection_domain *domain;
    u16 devid;
    get_device_resources (dev, & iommu, & domain, & devid);
    if (!iommu || !domain)
        goto free_mem;
    spin_lock_irqsave (& domain -> lock, flags);
    __unmap_single (iommu, domain -> priv, dma_addr, size, DMA_BIDIRECTIONAL);
    iommu_flush_pages (iommu, domain -> id, dma_addr, size);
    if (iommu->need_sync)
        iommu_completion_wait (iommu);
    spin_unlock_irqrestore (& domain -> lock, flags);
free_mem :
    free_pages ((unsigned long) virt_addr, get_order (size));
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/amd_iommu.c.ifdefed" startline="1089" endline="1115">
{
    struct pci_dev *dev = NULL;
    struct dma_ops_domain *dma_dom;
    struct amd_iommu *iommu;
    int order = amd_iommu_aperture_order;
    u16 devid;
    while ((dev = pci_get_device (PCI_ANY_ID, PCI_ANY_ID, dev)) != NULL) {
        devid = (dev->bus->number << 8) | dev->devfn;
        if (devid > amd_iommu_last_bdf)
            continue;
        devid = amd_iommu_alias_table[devid];
        if (domain_for_device (devid))
            continue;
        iommu = amd_iommu_rlookup_table[devid];
        if (!iommu)
            continue;
        dma_dom = dma_ops_domain_alloc (iommu, order);
        if (!dma_dom)
            continue;
        init_unity_mappings_for_device (dma_dom, devid);
        set_device_domain (iommu, & dma_dom -> domain, devid);
        printk (KERN_INFO "AMD IOMMU: Allocated domain %d for device ", dma_dom -> domain.id);
        print_devid (devid, 1);
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/amd_iommu.c.ifdefed" startline="1096" endline="1114">
{
    devid = (dev->bus->number << 8) | dev->devfn;
    if (devid > amd_iommu_last_bdf)
        continue;
    devid = amd_iommu_alias_table[devid];
    if (domain_for_device (devid))
        continue;
    iommu = amd_iommu_rlookup_table[devid];
    if (!iommu)
        continue;
    dma_dom = dma_ops_domain_alloc (iommu, order);
    if (!dma_dom)
        continue;
    init_unity_mappings_for_device (dma_dom, devid);
    set_device_domain (iommu, & dma_dom -> domain, devid);
    printk (KERN_INFO "AMD IOMMU: Allocated domain %d for device ", dma_dom -> domain.id);
    print_devid (devid, 1);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/amd_iommu.c.ifdefed" startline="1130" endline="1177">
{
    struct amd_iommu *iommu;
    int order = amd_iommu_aperture_order;
    int ret;
    list_for_each_entry (iommu, &amd_iommu_list, list) {
        iommu->default_dom = dma_ops_domain_alloc (iommu, order);
        if (iommu->default_dom == NULL)
            return -ENOMEM;
        ret = iommu_init_unity_mappings (iommu);
        if (ret)
            goto free_domains;
    }
    if (amd_iommu_isolate)
        prealloc_protection_domains ();
    iommu_detected = 1;
    force_iommu = 1;
    bad_dma_address = 0;
    dma_ops = &amd_iommu_dma_ops;
    return 0;
free_domains :
    list_for_each_entry (iommu, &amd_iommu_list, list) {
        if (iommu->default_dom)
            dma_ops_domain_free (iommu->default_dom);
    }
    return ret;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/amd_iommu.c.ifdefed" startline="1140" endline="1147">
{
    iommu->default_dom = dma_ops_domain_alloc (iommu, order);
    if (iommu->default_dom == NULL)
        return -ENOMEM;
    ret = iommu_init_unity_mappings (iommu);
    if (ret)
        goto free_domains;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/amd_iommu.c.ifdefed" startline="1171" endline="1174">
{
    if (iommu->default_dom)
        dma_ops_domain_free (iommu->default_dom);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/crash.c.ifdefed" startline="116" endline="118">
{
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/crash.c.ifdefed" startline="122" endline="145">
{
    local_irq_disable ();
    crashing_cpu = safe_smp_processor_id ();
    nmi_shootdown_cpus ();
    lapic_shutdown ();
    crash_save_cpu (regs, safe_smp_processor_id ());
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/ldt.c.ifdefed" startline="31" endline="82">
{
    void *oldldt, *newldt;
    int oldsize;
    if (mincount <= pc->size)
        return 0;
    oldsize = pc->size;
    mincount = (mincount + (PAGE_SIZE / LDT_ENTRY_SIZE - 1)) & (~(PAGE_SIZE / LDT_ENTRY_SIZE - 1));
    if (mincount * LDT_ENTRY_SIZE > PAGE_SIZE)
        newldt = vmalloc (mincount *LDT_ENTRY_SIZE);
    else
        newldt = (void *) __get_free_page (GFP_KERNEL);
    if (!newldt)
        return -ENOMEM;
    if (oldsize)
        memcpy (newldt, pc->ldt, oldsize *LDT_ENTRY_SIZE);
    oldldt = pc->ldt;
    memset (newldt + oldsize * LDT_ENTRY_SIZE, 0, (mincount - oldsize) * LDT_ENTRY_SIZE);
    pc->ldt = newldt;
    wmb ();
    pc->size = mincount;
    wmb ();
    if (reload) {
        load_LDT (pc);
    }
    if (oldsize) {
        if (oldsize * LDT_ENTRY_SIZE > PAGE_SIZE)
            vfree (oldldt);
        else
            put_page (virt_to_page (oldldt));
    }
    return 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/ldt.c.ifdefed" startline="63" endline="74">
{
    load_LDT (pc);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/ldt.c.ifdefed" startline="75" endline="80">
{
    if (oldsize * LDT_ENTRY_SIZE > PAGE_SIZE)
        vfree (oldldt);
    else
        put_page (virt_to_page (oldldt));
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/ldt.c.ifdefed" startline="85" endline="92">
{
    int err = alloc_ldt (new, old->size, 0);
    if (err < 0)
        return err;
    memcpy (new -> ldt, old -> ldt, old -> size * LDT_ENTRY_SIZE);
    return 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/ldt.c.ifdefed" startline="99" endline="112">
{
    struct mm_struct *old_mm;
    int retval = 0;
    mutex_init (& mm -> context.lock);
    mm->context.size = 0;
    old_mm = current->mm;
    if (old_mm && old_mm->context.size > 0) {
        mutex_lock (& old_mm -> context.lock);
        retval = copy_ldt (&mm->context, &old_mm->context);
        mutex_unlock (& old_mm -> context.lock);
    }
    return retval;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/ldt.c.ifdefed" startline="106" endline="110">
{
    mutex_lock (& old_mm -> context.lock);
    retval = copy_ldt (&mm->context, &old_mm->context);
    mutex_unlock (& old_mm -> context.lock);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/ldt.c.ifdefed" startline="120" endline="133">
{
    if (mm->context.size) {
        if (mm->context.size * LDT_ENTRY_SIZE > PAGE_SIZE)
            vfree (mm->context.ldt);
        else
            put_page (virt_to_page (mm->context.ldt));
        mm->context.size = 0;
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/ldt.c.ifdefed" startline="121" endline="132">
{
    if (mm->context.size * LDT_ENTRY_SIZE > PAGE_SIZE)
        vfree (mm->context.ldt);
    else
        put_page (virt_to_page (mm->context.ldt));
    mm->context.size = 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/ldt.c.ifdefed" startline="136" endline="167">
{
    int err;
    unsigned long size;
    struct mm_struct *mm = current->mm;
    if (!mm->context.size)
        return 0;
    if (bytecount > LDT_ENTRY_SIZE * LDT_ENTRIES)
        bytecount = LDT_ENTRY_SIZE * LDT_ENTRIES;
    mutex_lock (& mm -> context.lock);
    size = mm->context.size * LDT_ENTRY_SIZE;
    if (size > bytecount)
        size = bytecount;
    err = 0;
    if (copy_to_user (ptr, mm->context.ldt, size))
        err = -EFAULT;
    mutex_unlock (& mm -> context.lock);
    if (err < 0)
        goto error_return;
    if (size != bytecount) {
        if (clear_user (ptr +size, bytecount -size) != 0) {
            err = -EFAULT;
            goto error_return;
        }
    }
    return bytecount;
error_return :
    return err;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/ldt.c.ifdefed" startline="157" endline="163">
{
    if (clear_user (ptr +size, bytecount -size) != 0) {
        err = -EFAULT;
        goto error_return;
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/ldt.c.ifdefed" startline="159" endline="162">
{
    err = -EFAULT;
    goto error_return;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/ldt.c.ifdefed" startline="170" endline="182">
{
    unsigned long size = 128;
    if (bytecount > size)
        bytecount = size;
    if (clear_user (ptr, bytecount))
        return -EFAULT;
    return bytecount;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/ldt.c.ifdefed" startline="185" endline="237">
{
    struct mm_struct *mm = current->mm;
    struct desc_struct ldt;
    int error;
    struct user_desc ldt_info;
    error = -EINVAL;
    if (bytecount != sizeof (ldt_info))
        goto out;
    error = -EFAULT;
    if (copy_from_user (&ldt_info, ptr, sizeof (ldt_info)))
        goto out;
    error = -EINVAL;
    if (ldt_info.entry_number >= LDT_ENTRIES)
        goto out;
    if (ldt_info.contents == 3) {
        if (oldmode)
            goto out;
        if (ldt_info.seg_not_present == 0)
            goto out;
    }
    mutex_lock (& mm -> context.lock);
    if (ldt_info.entry_number >= mm->context.size) {
        error = alloc_ldt (&current->mm->context, ldt_info.entry_number + 1, 1);
        if (error < 0)
            goto out_unlock;
    }
    if (ldt_info.base_addr == 0 && ldt_info.limit == 0) {
        if (oldmode || LDT_empty (&ldt_info)) {
            memset (& ldt, 0, sizeof (ldt));
            goto install;
        }
    }
    fill_ldt (& ldt, & ldt_info);
    if (oldmode)
        ldt.avl = 0;
install :
    write_ldt_entry (mm->context.ldt, ldt_info.entry_number, &ldt);
    error = 0;
out_unlock :
    mutex_unlock (&mm->context.lock);
out :
    return error;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/ldt.c.ifdefed" startline="201" endline="206">
{
    if (oldmode)
        goto out;
    if (ldt_info.seg_not_present == 0)
        goto out;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/ldt.c.ifdefed" startline="209" endline="214">
{
    error = alloc_ldt (&current->mm->context, ldt_info.entry_number + 1, 1);
    if (error < 0)
        goto out_unlock;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/ldt.c.ifdefed" startline="217" endline="222">
{
    if (oldmode || LDT_empty (&ldt_info)) {
        memset (& ldt, 0, sizeof (ldt));
        goto install;
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/ldt.c.ifdefed" startline="218" endline="221">
{
    memset (& ldt, 0, sizeof (ldt));
    goto install;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/ldt.c.ifdefed" startline="241" endline="259">
{
    int ret = -ENOSYS;
    switch (func) {
    case 0 :
        ret = read_ldt (ptr, bytecount);
        break;
    case 1 :
        ret = write_ldt (ptr, bytecount, 1);
        break;
    case 2 :
        ret = read_default_ldt (ptr, bytecount);
        break;
    case 0x11 :
        ret = write_ldt (ptr, bytecount, 0);
        break;
    }
    return ret;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/ldt.c.ifdefed" startline="244" endline="257">
{
case 0 :
    ret = read_ldt (ptr, bytecount);
    break;
case 1 :
    ret = write_ldt (ptr, bytecount, 1);
    break;
case 2 :
    ret = read_default_ldt (ptr, bytecount);
    break;
case 0x11 :
    ret = write_ldt (ptr, bytecount, 0);
    break;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/amd_iommu_init.c.ifdefed" startline="166" endline="169">
{
    if (devid > amd_iommu_last_bdf)
        amd_iommu_last_bdf = devid;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/amd_iommu_init.c.ifdefed" startline="172" endline="177">
{
    unsigned shift = PAGE_SHIFT + get_order (amd_iommu_last_bdf *entry_size);
    return 1UL << shift;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/amd_iommu_init.c.ifdefed" startline="193" endline="208">
{
    u64 start = iommu->exclusion_start & PAGE_MASK;
    u64 limit = (start + iommu->exclusion_length) & PAGE_MASK;
    u64 entry;
    if (!iommu->exclusion_start)
        return;
    entry = start | MMIO_EXCL_ENABLE_MASK;
    memcpy_toio (iommu -> mmio_base + MMIO_EXCL_BASE_OFFSET, & entry, sizeof (entry));
    entry = limit;
    memcpy_toio (iommu -> mmio_base + MMIO_EXCL_LIMIT_OFFSET, & entry, sizeof (entry));
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/amd_iommu_init.c.ifdefed" startline="212" endline="221">
{
    u32 entry;
    BUG_ON (iommu -> mmio_base == NULL);
    entry = virt_to_phys (amd_iommu_dev_table);
    entry |= (dev_table_size >> 12) - 1;
    memcpy_toio (iommu -> mmio_base + MMIO_DEV_TABLE_OFFSET, & entry, sizeof (entry));
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/amd_iommu_init.c.ifdefed" startline="225" endline="231">
{
    u32 ctrl;
    ctrl = readl (iommu->mmio_base + MMIO_CONTROL_OFFSET);
    ctrl |= (1 << bit);
    writel (ctrl, iommu -> mmio_base + MMIO_CONTROL_OFFSET);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/amd_iommu_init.c.ifdefed" startline="234" endline="240">
{
    u32 ctrl;
    ctrl = (u64) readl (iommu->mmio_base + MMIO_CONTROL_OFFSET);
    ctrl &= ~(1 << bit);
    writel (ctrl, iommu -> mmio_base + MMIO_CONTROL_OFFSET);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/amd_iommu_init.c.ifdefed" startline="244" endline="250">
{
    printk (KERN_INFO "AMD IOMMU: Enabling IOMMU at ");
    print_devid (iommu -> devid, 0);
    printk (" cap 0x%hx\n", iommu -> cap_ptr);
    iommu_feature_enable (iommu, CONTROL_IOMMU_EN);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/amd_iommu_init.c.ifdefed" startline="257" endline="270">
{
    u8 *ret;
    if (!request_mem_region (address, MMIO_REGION_LENGTH, "amd_iommu"))
        return NULL;
    ret = ioremap_nocache (address, MMIO_REGION_LENGTH);
    if (ret != NULL)
        return ret;
    release_mem_region (address, MMIO_REGION_LENGTH);
    return NULL;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/amd_iommu_init.c.ifdefed" startline="273" endline="277">
{
    if (iommu->mmio_base)
        iounmap (iommu->mmio_base);
    release_mem_region (iommu -> mmio_phys, MMIO_REGION_LENGTH);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/amd_iommu_init.c.ifdefed" startline="293" endline="300">
{
    u32 cap;
    cap = read_pci_config (bus, dev, fn, cap_ptr +MMIO_RANGE_OFFSET);
    update_last_devid (calc_devid (MMIO_GET_BUS (cap), MMIO_GET_LD (cap)));
    return 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/amd_iommu_init.c.ifdefed" startline="307" endline="338">
{
    u8 *p = (void *) h, *end = (void *) h;
    struct ivhd_entry *dev;
    p += sizeof (*h);
    end += h->length;
    find_last_devid_on_pci (PCI_BUS (h -> devid), PCI_SLOT (h -> devid), PCI_FUNC (h -> devid), h -> cap_ptr);
    while (p < end) {
        dev = (struct ivhd_entry *) p;
        switch (dev->type) {
        case IVHD_DEV_SELECT :
        case IVHD_DEV_RANGE_END :
        case IVHD_DEV_ALIAS :
        case IVHD_DEV_EXT_SELECT :
            update_last_devid (dev->devid);
            break;
        default :
            break;
        }
        p += 0x04 << (*p >> 6);
    }
    WARN_ON (p != end);
    return 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/amd_iommu_init.c.ifdefed" startline="319" endline="333">
{
    dev = (struct ivhd_entry *) p;
    switch (dev->type) {
    case IVHD_DEV_SELECT :
    case IVHD_DEV_RANGE_END :
    case IVHD_DEV_ALIAS :
    case IVHD_DEV_EXT_SELECT :
        update_last_devid (dev->devid);
        break;
    default :
        break;
    }
    p += 0x04 << (*p >> 6);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/amd_iommu_init.c.ifdefed" startline="321" endline="331">
{
case IVHD_DEV_SELECT :
case IVHD_DEV_RANGE_END :
case IVHD_DEV_ALIAS :
case IVHD_DEV_EXT_SELECT :
    update_last_devid (dev->devid);
    break;
default :
    break;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/amd_iommu_init.c.ifdefed" startline="346" endline="378">
{
    int i;
    u8 checksum = 0, *p = (u8 *) table, *end = (u8 *) table;
    struct ivhd_header *h;
    for (i = 0; i < table->length; ++i)
        checksum += p[i];
    if (checksum != 0)
        return -ENODEV;
    p += IVRS_HEADER_LENGTH;
    end += table->length;
    while (p < end) {
        h = (struct ivhd_header *) p;
        switch (h->type) {
        case ACPI_IVHD_TYPE :
            find_last_devid_from_ivhd (h);
            break;
        default :
            break;
        }
        p += h->length;
    }
    WARN_ON (p != end);
    return 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/amd_iommu_init.c.ifdefed" startline="364" endline="374">
{
    h = (struct ivhd_header *) p;
    switch (h->type) {
    case ACPI_IVHD_TYPE :
        find_last_devid_from_ivhd (h);
        break;
    default :
        break;
    }
    p += h->length;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/amd_iommu_init.c.ifdefed" startline="366" endline="372">
{
case ACPI_IVHD_TYPE :
    find_last_devid_from_ivhd (h);
    break;
default :
    break;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/amd_iommu_init.c.ifdefed" startline="395" endline="413">
{
    u8 *cmd_buf = (u8 *) __get_free_pages (GFP_KERNEL | __GFP_ZERO, get_order (CMD_BUFFER_SIZE));
    u64 entry;
    if (cmd_buf == NULL)
        return NULL;
    iommu->cmd_buf_size = CMD_BUFFER_SIZE;
    entry = (u64) virt_to_phys (cmd_buf);
    entry |= MMIO_CMD_SIZE_512;
    memcpy_toio (iommu -> mmio_base + MMIO_CMD_BUF_OFFSET, & entry, sizeof (entry));
    iommu_feature_enable (iommu, CONTROL_CMDBUF_EN);
    return cmd_buf;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/amd_iommu_init.c.ifdefed" startline="416" endline="418">
{
    free_pages ((unsigned long) iommu -> cmd_buf, get_order (CMD_BUFFER_SIZE));
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/amd_iommu_init.c.ifdefed" startline="422" endline="427">
{
    int i = (bit >> 5) & 0x07;
    int _bit = bit & 0x1f;
    amd_iommu_dev_table[devid].data[i] |= (1 << _bit);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/amd_iommu_init.c.ifdefed" startline="431" endline="433">
{
    amd_iommu_rlookup_table[devid] = iommu;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/amd_iommu_init.c.ifdefed" startline="441" endline="458">
{
    if (flags & ACPI_DEVFLAG_INITPASS)
        set_dev_entry_bit (devid, DEV_ENTRY_INIT_PASS);
    if (flags & ACPI_DEVFLAG_EXTINT)
        set_dev_entry_bit (devid, DEV_ENTRY_EINT_PASS);
    if (flags & ACPI_DEVFLAG_NMI)
        set_dev_entry_bit (devid, DEV_ENTRY_NMI_PASS);
    if (flags & ACPI_DEVFLAG_SYSMGT1)
        set_dev_entry_bit (devid, DEV_ENTRY_SYSMGT1);
    if (flags & ACPI_DEVFLAG_SYSMGT2)
        set_dev_entry_bit (devid, DEV_ENTRY_SYSMGT2);
    if (flags & ACPI_DEVFLAG_LINT0)
        set_dev_entry_bit (devid, DEV_ENTRY_LINT0_PASS);
    if (flags & ACPI_DEVFLAG_LINT1)
        set_dev_entry_bit (devid, DEV_ENTRY_LINT1_PASS);
    set_iommu_for_device (iommu, devid);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/amd_iommu_init.c.ifdefed" startline="465" endline="481">
{
    struct amd_iommu *iommu = amd_iommu_rlookup_table[devid];
    if (!(m->flags & IVMD_FLAG_EXCL_RANGE))
        return;
    if (iommu) {
        set_dev_entry_bit (m -> devid, DEV_ENTRY_EX);
        iommu->exclusion_start = m->range_start;
        iommu->exclusion_length = m->range_length;
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/amd_iommu_init.c.ifdefed" startline="471" endline="480">
{
    set_dev_entry_bit (m -> devid, DEV_ENTRY_EX);
    iommu->exclusion_start = m->range_start;
    iommu->exclusion_length = m->range_length;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/amd_iommu_init.c.ifdefed" startline="489" endline="503">
{
    int bus = PCI_BUS (iommu->devid);
    int dev = PCI_SLOT (iommu->devid);
    int fn = PCI_FUNC (iommu->devid);
    int cap_ptr = iommu->cap_ptr;
    u32 range;
    iommu->cap = read_pci_config (bus, dev, fn, cap_ptr +MMIO_CAP_HDR_OFFSET);
    range = read_pci_config (bus, dev, fn, cap_ptr +MMIO_RANGE_OFFSET);
    iommu->first_device = calc_devid (MMIO_GET_BUS (range), MMIO_GET_FD (range));
    iommu->last_device = calc_devid (MMIO_GET_BUS (range), MMIO_GET_LD (range));
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/amd_iommu_init.c.ifdefed" startline="511" endline="609">
{
    u8 *p = (u8 *) h;
    u8 *end = p, flags = 0;
    u16 dev_i, devid = 0, devid_start = 0, devid_to = 0;
    u32 ext_flags = 0;
    bool alias = false;
    struct ivhd_entry *e;
    h->flags & IVHD_FLAG_HT_TUN_EN ? iommu_feature_enable (iommu, CONTROL_HT_TUN_EN) : iommu_feature_disable (iommu, CONTROL_HT_TUN_EN);
    h->flags & IVHD_FLAG_PASSPW_EN ? iommu_feature_enable (iommu, CONTROL_PASSPW_EN) : iommu_feature_disable (iommu, CONTROL_PASSPW_EN);
    h->flags & IVHD_FLAG_RESPASSPW_EN ? iommu_feature_enable (iommu, CONTROL_RESPASSPW_EN) : iommu_feature_disable (iommu, CONTROL_RESPASSPW_EN);
    h->flags & IVHD_FLAG_ISOC_EN ? iommu_feature_enable (iommu, CONTROL_ISOC_EN) : iommu_feature_disable (iommu, CONTROL_ISOC_EN);
    iommu_feature_enable (iommu, CONTROL_COHERENT_EN);
    p += sizeof (struct ivhd_header);
    end += h->length;
    while (p < end) {
        e = (struct ivhd_entry *) p;
        switch (e->type) {
        case IVHD_DEV_ALL :
            for (dev_i = iommu->first_device; dev_i <= iommu->last_device; ++dev_i)
                set_dev_entry_from_acpi (iommu, dev_i, e->flags, 0);
            break;
        case IVHD_DEV_SELECT :
            devid = e->devid;
            set_dev_entry_from_acpi (iommu, devid, e -> flags, 0);
            break;
        case IVHD_DEV_SELECT_RANGE_START :
            devid_start = e->devid;
            flags = e->flags;
            ext_flags = 0;
            alias = false;
            break;
        case IVHD_DEV_ALIAS :
            devid = e->devid;
            devid_to = e->ext >> 8;
            set_dev_entry_from_acpi (iommu, devid, e -> flags, 0);
            amd_iommu_alias_table[devid] = devid_to;
            break;
        case IVHD_DEV_ALIAS_RANGE :
            devid_start = e->devid;
            flags = e->flags;
            devid_to = e->ext >> 8;
            ext_flags = 0;
            alias = true;
            break;
        case IVHD_DEV_EXT_SELECT :
            devid = e->devid;
            set_dev_entry_from_acpi (iommu, devid, e -> flags, e -> ext);
            break;
        case IVHD_DEV_EXT_SELECT_RANGE :
            devid_start = e->devid;
            flags = e->flags;
            ext_flags = e->ext;
            alias = false;
            break;
        case IVHD_DEV_RANGE_END :
            devid = e->devid;
            for (dev_i = devid_start; dev_i <= devid; ++dev_i) {
                if (alias)
                    amd_iommu_alias_table[dev_i] = devid_to;
                set_dev_entry_from_acpi (iommu, amd_iommu_alias_table [dev_i], flags, ext_flags);
            }
            break;
        default :
            break;
        }
        p += 0x04 << (e->type >> 6);
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/amd_iommu_init.c.ifdefed" startline="550" endline="608">
{
    e = (struct ivhd_entry *) p;
    switch (e->type) {
    case IVHD_DEV_ALL :
        for (dev_i = iommu->first_device; dev_i <= iommu->last_device; ++dev_i)
            set_dev_entry_from_acpi (iommu, dev_i, e->flags, 0);
        break;
    case IVHD_DEV_SELECT :
        devid = e->devid;
        set_dev_entry_from_acpi (iommu, devid, e -> flags, 0);
        break;
    case IVHD_DEV_SELECT_RANGE_START :
        devid_start = e->devid;
        flags = e->flags;
        ext_flags = 0;
        alias = false;
        break;
    case IVHD_DEV_ALIAS :
        devid = e->devid;
        devid_to = e->ext >> 8;
        set_dev_entry_from_acpi (iommu, devid, e -> flags, 0);
        amd_iommu_alias_table[devid] = devid_to;
        break;
    case IVHD_DEV_ALIAS_RANGE :
        devid_start = e->devid;
        flags = e->flags;
        devid_to = e->ext >> 8;
        ext_flags = 0;
        alias = true;
        break;
    case IVHD_DEV_EXT_SELECT :
        devid = e->devid;
        set_dev_entry_from_acpi (iommu, devid, e -> flags, e -> ext);
        break;
    case IVHD_DEV_EXT_SELECT_RANGE :
        devid_start = e->devid;
        flags = e->flags;
        ext_flags = e->ext;
        alias = false;
        break;
    case IVHD_DEV_RANGE_END :
        devid = e->devid;
        for (dev_i = devid_start; dev_i <= devid; ++dev_i) {
            if (alias)
                amd_iommu_alias_table[dev_i] = devid_to;
            set_dev_entry_from_acpi (iommu, amd_iommu_alias_table [dev_i], flags, ext_flags);
        }
        break;
    default :
        break;
    }
    p += 0x04 << (e->type >> 6);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/amd_iommu_init.c.ifdefed" startline="552" endline="605">
{
case IVHD_DEV_ALL :
    for (dev_i = iommu->first_device; dev_i <= iommu->last_device; ++dev_i)
        set_dev_entry_from_acpi (iommu, dev_i, e->flags, 0);
    break;
case IVHD_DEV_SELECT :
    devid = e->devid;
    set_dev_entry_from_acpi (iommu, devid, e -> flags, 0);
    break;
case IVHD_DEV_SELECT_RANGE_START :
    devid_start = e->devid;
    flags = e->flags;
    ext_flags = 0;
    alias = false;
    break;
case IVHD_DEV_ALIAS :
    devid = e->devid;
    devid_to = e->ext >> 8;
    set_dev_entry_from_acpi (iommu, devid, e -> flags, 0);
    amd_iommu_alias_table[devid] = devid_to;
    break;
case IVHD_DEV_ALIAS_RANGE :
    devid_start = e->devid;
    flags = e->flags;
    devid_to = e->ext >> 8;
    ext_flags = 0;
    alias = true;
    break;
case IVHD_DEV_EXT_SELECT :
    devid = e->devid;
    set_dev_entry_from_acpi (iommu, devid, e -> flags, e -> ext);
    break;
case IVHD_DEV_EXT_SELECT_RANGE :
    devid_start = e->devid;
    flags = e->flags;
    ext_flags = e->ext;
    alias = false;
    break;
case IVHD_DEV_RANGE_END :
    devid = e->devid;
    for (dev_i = devid_start; dev_i <= devid; ++dev_i) {
        if (alias)
            amd_iommu_alias_table[dev_i] = devid_to;
        set_dev_entry_from_acpi (iommu, amd_iommu_alias_table [dev_i], flags, ext_flags);
    }
    break;
default :
    break;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/amd_iommu_init.c.ifdefed" startline="595" endline="601">
{
    if (alias)
        amd_iommu_alias_table[dev_i] = devid_to;
    set_dev_entry_from_acpi (iommu, amd_iommu_alias_table [dev_i], flags, ext_flags);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/amd_iommu_init.c.ifdefed" startline="613" endline="620">
{
    u16 i;
    for (i = iommu->first_device; i <= iommu->last_device; ++i)
        set_iommu_for_device (iommu, i);
    return 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/amd_iommu_init.c.ifdefed" startline="623" endline="626">
{
    free_command_buffer (iommu);
    iommu_unmap_mmio_space (iommu);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/amd_iommu_init.c.ifdefed" startline="629" endline="637">
{
    struct amd_iommu *iommu, *next;
    list_for_each_entry_safe (iommu, next, &amd_iommu_list, list) {
        list_del (& iommu -> list);
        free_iommu_one (iommu);
        kfree (iommu);
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/amd_iommu_init.c.ifdefed" startline="632" endline="636">
{
    list_del (& iommu -> list);
    free_iommu_one (iommu);
    kfree (iommu);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/amd_iommu_init.c.ifdefed" startline="645" endline="669">
{
    spin_lock_init (& iommu -> lock);
    list_add_tail (& iommu -> list, & amd_iommu_list);
    iommu->devid = h->devid;
    iommu->cap_ptr = h->cap_ptr;
    iommu->mmio_phys = h->mmio_phys;
    iommu->mmio_base = iommu_map_mmio_space (h->mmio_phys);
    if (!iommu->mmio_base)
        return -ENOMEM;
    iommu_set_device_table (iommu);
    iommu->cmd_buf = alloc_command_buffer (iommu);
    if (!iommu->cmd_buf)
        return -ENOMEM;
    init_iommu_from_pci (iommu);
    init_iommu_from_acpi (iommu, h);
    init_iommu_devices (iommu);
    return 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/amd_iommu_init.c.ifdefed" startline="676" endline="705">
{
    u8 *p = (u8 *) table, *end = (u8 *) table;
    struct ivhd_header *h;
    struct amd_iommu *iommu;
    int ret;
    end += table->length;
    p += IVRS_HEADER_LENGTH;
    while (p < end) {
        h = (struct ivhd_header *) p;
        switch (*p) {
        case ACPI_IVHD_TYPE :
            iommu = kzalloc (sizeof (struct amd_iommu), GFP_KERNEL);
            if (iommu == NULL)
                return -ENOMEM;
            ret = init_iommu_one (iommu, h);
            if (ret)
                return ret;
            break;
        default :
            break;
        }
        p += h->length;
    }
    WARN_ON (p != end);
    return 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/amd_iommu_init.c.ifdefed" startline="685" endline="701">
{
    h = (struct ivhd_header *) p;
    switch (*p) {
    case ACPI_IVHD_TYPE :
        iommu = kzalloc (sizeof (struct amd_iommu), GFP_KERNEL);
        if (iommu == NULL)
            return -ENOMEM;
        ret = init_iommu_one (iommu, h);
        if (ret)
            return ret;
        break;
    default :
        break;
    }
    p += h->length;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/amd_iommu_init.c.ifdefed" startline="687" endline="698">
{
case ACPI_IVHD_TYPE :
    iommu = kzalloc (sizeof (struct amd_iommu), GFP_KERNEL);
    if (iommu == NULL)
        return -ENOMEM;
    ret = init_iommu_one (iommu, h);
    if (ret)
        return ret;
    break;
default :
    break;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/amd_iommu_init.c.ifdefed" startline="716" endline="723">
{
    struct unity_map_entry *entry, *next;
    list_for_each_entry_safe (entry, next, &amd_iommu_unity_map, list) {
        list_del (& entry -> list);
        kfree (entry);
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/amd_iommu_init.c.ifdefed" startline="719" endline="722">
{
    list_del (& entry -> list);
    kfree (entry);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/amd_iommu_init.c.ifdefed" startline="727" endline="747">
{
    int i;
    switch (m->type) {
    case ACPI_IVMD_TYPE :
        set_device_exclusion_range (m->devid, m);
        break;
    case ACPI_IVMD_TYPE_ALL :
        for (i = 0; i <= amd_iommu_last_bdf; ++i)
            set_device_exclusion_range (i, m);
        break;
    case ACPI_IVMD_TYPE_RANGE :
        for (i = m->devid; i <= m->aux; ++i)
            set_device_exclusion_range (i, m);
        break;
    default :
        break;
    }
    return 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/amd_iommu_init.c.ifdefed" startline="730" endline="744">
{
case ACPI_IVMD_TYPE :
    set_device_exclusion_range (m->devid, m);
    break;
case ACPI_IVMD_TYPE_ALL :
    for (i = 0; i <= amd_iommu_last_bdf; ++i)
        set_device_exclusion_range (i, m);
    break;
case ACPI_IVMD_TYPE_RANGE :
    for (i = m->devid; i <= m->aux; ++i)
        set_device_exclusion_range (i, m);
    break;
default :
    break;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/amd_iommu_init.c.ifdefed" startline="751" endline="779">
{
    struct unity_map_entry *e = 0;
    e = kzalloc (sizeof (*e), GFP_KERNEL);
    if (e == NULL)
        return -ENOMEM;
    switch (m->type) {
    default :
    case ACPI_IVMD_TYPE :
        e->devid_start = e->devid_end = m->devid;
        break;
    case ACPI_IVMD_TYPE_ALL :
        e->devid_start = 0;
        e->devid_end = amd_iommu_last_bdf;
        break;
    case ACPI_IVMD_TYPE_RANGE :
        e->devid_start = m->devid;
        e->devid_end = m->aux;
        break;
    }
    e->address_start = PAGE_ALIGN (m->range_start);
    e->address_end = e->address_start + PAGE_ALIGN (m->range_length);
    e->prot = m->flags >> 1;
    list_add_tail (& e -> list, & amd_iommu_unity_map);
    return 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/amd_iommu_init.c.ifdefed" startline="758" endline="771">
{
default :
case ACPI_IVMD_TYPE :
    e->devid_start = e->devid_end = m->devid;
    break;
case ACPI_IVMD_TYPE_ALL :
    e->devid_start = 0;
    e->devid_end = amd_iommu_last_bdf;
    break;
case ACPI_IVMD_TYPE_RANGE :
    e->devid_start = m->devid;
    e->devid_end = m->aux;
    break;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/amd_iommu_init.c.ifdefed" startline="783" endline="801">
{
    u8 *p = (u8 *) table, *end = (u8 *) table;
    struct ivmd_header *m;
    end += table->length;
    p += IVRS_HEADER_LENGTH;
    while (p < end) {
        m = (struct ivmd_header *) p;
        if (m->flags & IVMD_FLAG_EXCL_RANGE)
            init_exclusion_range (m);
        else if (m->flags & IVMD_FLAG_UNITY_MAP)
            init_unity_map_range (m);
        p += m->length;
    }
    return 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/amd_iommu_init.c.ifdefed" startline="790" endline="798">
{
    m = (struct ivmd_header *) p;
    if (m->flags & IVMD_FLAG_EXCL_RANGE)
        init_exclusion_range (m);
    else if (m->flags & IVMD_FLAG_UNITY_MAP)
        init_unity_map_range (m);
    p += m->length;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/amd_iommu_init.c.ifdefed" startline="808" endline="816">
{
    u16 devid;
    for (devid = 0; devid <= amd_iommu_last_bdf; ++devid) {
        set_dev_entry_bit (devid, DEV_ENTRY_VALID);
        set_dev_entry_bit (devid, DEV_ENTRY_TRANSLATION);
        set_dev_entry_bit (devid, DEV_ENTRY_NO_PAGE_FAULT);
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/amd_iommu_init.c.ifdefed" startline="811" endline="815">
{
    set_dev_entry_bit (devid, DEV_ENTRY_VALID);
    set_dev_entry_bit (devid, DEV_ENTRY_TRANSLATION);
    set_dev_entry_bit (devid, DEV_ENTRY_NO_PAGE_FAULT);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/amd_iommu_init.c.ifdefed" startline="823" endline="830">
{
    struct amd_iommu *iommu;
    list_for_each_entry (iommu, &amd_iommu_list, list) {
        iommu_set_exclusion_range (iommu);
        iommu_enable (iommu);
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/amd_iommu_init.c.ifdefed" startline="826" endline="829">
{
    iommu_set_exclusion_range (iommu);
    iommu_enable (iommu);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/amd_iommu_init.c.ifdefed" startline="838" endline="840">
{
    return 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/amd_iommu_init.c.ifdefed" startline="843" endline="845">
{
    return -EINVAL;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/amd_iommu_init.c.ifdefed" startline="887" endline="1021">
{
    int i, ret = 0;
    if (no_iommu) {
        printk (KERN_INFO "AMD IOMMU disabled by kernel command line\n");
        return 0;
    }
    if (!amd_iommu_detected)
        return -ENODEV;
    if (acpi_table_parse ("IVRS", find_last_devid_acpi) != 0)
        return -ENODEV;
    dev_table_size = tbl_size (DEV_TABLE_ENTRY_SIZE);
    alias_table_size = tbl_size (ALIAS_TABLE_ENTRY_SIZE);
    rlookup_table_size = tbl_size (RLOOKUP_TABLE_ENTRY_SIZE);
    ret = -ENOMEM;
    amd_iommu_dev_table = (void *) __get_free_pages (GFP_KERNEL | __GFP_ZERO, get_order (dev_table_size));
    if (amd_iommu_dev_table == NULL)
        goto out;
    amd_iommu_alias_table = (void *) __get_free_pages (GFP_KERNEL, get_order (alias_table_size));
    if (amd_iommu_alias_table == NULL)
        goto free;
    amd_iommu_rlookup_table = (void *) __get_free_pages (GFP_KERNEL, get_order (rlookup_table_size));
    if (amd_iommu_rlookup_table == NULL)
        goto free;
    amd_iommu_pd_table = (void *) __get_free_pages (GFP_KERNEL | __GFP_ZERO, get_order (rlookup_table_size));
    if (amd_iommu_pd_table == NULL)
        goto free;
    amd_iommu_pd_alloc_bitmap = (void *) __get_free_pages (GFP_KERNEL | __GFP_ZERO, get_order (MAX_DOMAIN_ID / 8));
    if (amd_iommu_pd_alloc_bitmap == NULL)
        goto free;
    init_device_table ();
    for (i = 0; i <= amd_iommu_last_bdf; ++i)
        amd_iommu_alias_table[i] = i;
    amd_iommu_pd_alloc_bitmap[0] = 1;
    ret = -ENODEV;
    if (acpi_table_parse ("IVRS", init_iommu_all) != 0)
        goto free;
    if (acpi_table_parse ("IVRS", init_memory_definitions) != 0)
        goto free;
    ret = sysdev_class_register (&amd_iommu_sysdev_class);
    if (ret)
        goto free;
    ret = sysdev_register (&device_amd_iommu);
    if (ret)
        goto free;
    ret = amd_iommu_init_dma_ops ();
    if (ret)
        goto free;
    enable_iommus ();
    printk (KERN_INFO "AMD IOMMU: aperture size is %d MB\n", (1 << (amd_iommu_aperture_order - 20)));
    printk (KERN_INFO "AMD IOMMU: device isolation ");
    if (amd_iommu_isolate)
        printk ("enabled\n");
    else
        printk ("disabled\n");
out :
    return ret;
free :
    free_pages ((unsigned long) amd_iommu_pd_alloc_bitmap, 1);
    free_pages ((unsigned long) amd_iommu_pd_table, get_order (rlookup_table_size));
    free_pages ((unsigned long) amd_iommu_rlookup_table, get_order (rlookup_table_size));
    free_pages ((unsigned long) amd_iommu_alias_table, get_order (alias_table_size));
    free_pages ((unsigned long) amd_iommu_dev_table, get_order (dev_table_size));
    free_iommu_all ();
    free_unity_maps ();
    goto out;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/amd_iommu_init.c.ifdefed" startline="891" endline="894">
{
    printk (KERN_INFO "AMD IOMMU disabled by kernel command line\n");
    return 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/amd_iommu_init.c.ifdefed" startline="1031" endline="1033">
{
    return 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/amd_iommu_init.c.ifdefed" startline="1036" endline="1048">
{
    if (swiotlb || no_iommu || (iommu_detected && !gart_iommu_aperture))
        return;
    if (acpi_table_parse ("IVRS", early_amd_iommu_detect) == 0) {
        iommu_detected = 1;
        amd_iommu_detected = 1;
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/amd_iommu_init.c.ifdefed" startline="1040" endline="1047">
{
    iommu_detected = 1;
    amd_iommu_detected = 1;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/amd_iommu_init.c.ifdefed" startline="1058" endline="1065">
{
    for (; *str; ++str) {
        if (strcmp (str, "isolate") == 0)
            amd_iommu_isolate = 1;
    }
    return 1;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/amd_iommu_init.c.ifdefed" startline="1059" endline="1062">
{
    if (strcmp (str, "isolate") == 0)
        amd_iommu_isolate = 1;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/amd_iommu_init.c.ifdefed" startline="1068" endline="1075">
{
    unsigned order = PAGE_SHIFT + get_order (memparse (str, &str));
    if ((order > 24) && (order < 31))
        amd_iommu_aperture_order = order;
    return 1;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/efi.c.ifdefed" startline="61" endline="64">
{
    efi_enabled = 0;
    return 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/efi.c.ifdefed" startline="71" endline="74">
{
    add_efi_memmap = 1;
    return 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/efi.c.ifdefed" startline="79" endline="81">
{
    return efi_call_virt2 (get_time, tm, tc);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/efi.c.ifdefed" startline="84" endline="86">
{
    return efi_call_virt1 (set_time, tm);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/efi.c.ifdefed" startline="91" endline="94">
{
    return efi_call_virt3 (get_wakeup_time, enabled, pending, tm);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/efi.c.ifdefed" startline="97" endline="100">
{
    return efi_call_virt2 (set_wakeup_time, enabled, tm);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/efi.c.ifdefed" startline="107" endline="111">
{
    return efi_call_virt5 (get_variable, name, vendor, attr, data_size, data);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/efi.c.ifdefed" startline="116" endline="119">
{
    return efi_call_virt3 (get_next_variable, name_size, name, vendor);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/efi.c.ifdefed" startline="126" endline="130">
{
    return efi_call_virt5 (set_variable, name, vendor, attr, data_size, data);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/efi.c.ifdefed" startline="133" endline="135">
{
    return efi_call_virt1 (get_next_high_mono_count, count);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/efi.c.ifdefed" startline="141" endline="144">
{
    efi_call_virt4 (reset_system, reset_type, status, data_size, data);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/efi.c.ifdefed" startline="151" endline="155">
{
    return efi_call_virt4 (set_virtual_address_map, memory_map_size, descriptor_size, descriptor_version, virtual_map);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/efi.c.ifdefed" startline="162" endline="171">
{
    efi_status_t status;
    efi_call_phys_prelog ();
    status = efi_call_phys4 (efi_phys.set_virtual_address_map, memory_map_size, descriptor_size, descriptor_version, virtual_map);
    efi_call_phys_epilog ();
    return status;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/efi.c.ifdefed" startline="175" endline="182">
{
    efi_status_t status;
    efi_call_phys_prelog ();
    status = efi_call_phys2 (efi_phys.get_time, tm, tc);
    efi_call_phys_epilog ();
    return status;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/efi.c.ifdefed" startline="185" endline="211">
{
    int real_seconds, real_minutes;
    efi_status_t status;
    efi_time_t eft;
    efi_time_cap_t cap;
    status = efi.get_time (&eft, &cap);
    if (status != EFI_SUCCESS) {
        printk (KERN_ERR "Oops: efitime: can't read time!\n");
        return -1;
    }
    real_seconds = nowtime % 60;
    real_minutes = nowtime / 60;
    if (((abs (real_minutes -eft.minute) + 15) / 30) & 1)
        real_minutes += 30;
    real_minutes %= 60;
    eft.minute = real_minutes;
    eft.second = real_seconds;
    status = efi.set_time (&eft);
    if (status != EFI_SUCCESS) {
        printk (KERN_ERR "Oops: efitime: can't write time!\n");
        return -1;
    }
    return 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/efi.c.ifdefed" startline="192" endline="195">
{
    printk (KERN_ERR "Oops: efitime: can't read time!\n");
    return -1;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/efi.c.ifdefed" startline="206" endline="209">
{
    printk (KERN_ERR "Oops: efitime: can't write time!\n");
    return -1;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/efi.c.ifdefed" startline="214" endline="225">
{
    efi_status_t status;
    efi_time_t eft;
    efi_time_cap_t cap;
    status = efi.get_time (&eft, &cap);
    if (status != EFI_SUCCESS)
        printk (KERN_ERR "Oops: efitime: can't read time!\n");
    return mktime (eft.year, eft.month, eft.day, eft.hour, eft.minute, eft.second);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/efi.c.ifdefed" startline="234" endline="250">
{
    void *p;
    for (p = memmap.map; p < memmap.map_end; p += memmap.desc_size) {
        efi_memory_desc_t *md = p;
        unsigned long long start = md->phys_addr;
        unsigned long long size = md->num_pages << EFI_PAGE_SHIFT;
        int e820_type;
        if (md->attribute & EFI_MEMORY_WB)
            e820_type = E820_RAM;
        else
            e820_type = E820_RESERVED;
        e820_add_region (start, size, e820_type);
    }
    sanitize_e820_map (e820.map, ARRAY_SIZE (e820.map), & e820.nr_map);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/efi.c.ifdefed" startline="237" endline="248">
{
    efi_memory_desc_t *md = p;
    unsigned long long start = md->phys_addr;
    unsigned long long size = md->num_pages << EFI_PAGE_SHIFT;
    int e820_type;
    if (md->attribute & EFI_MEMORY_WB)
        e820_type = E820_RAM;
    else
        e820_type = E820_RESERVED;
    e820_add_region (start, size, e820_type);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/efi.c.ifdefed" startline="253" endline="269">
{
    unsigned long pmap;
    pmap = (boot_params.efi_info.efi_memmap | ((__u64) boot_params.efi_info.efi_memmap_hi << 32));
    memmap.phys_map = (void *) pmap;
    memmap.nr_map = boot_params.efi_info.efi_memmap_size / boot_params.efi_info.efi_memdesc_size;
    memmap.desc_version = boot_params.efi_info.efi_memdesc_version;
    memmap.desc_size = boot_params.efi_info.efi_memdesc_size;
    reserve_early (pmap, pmap + memmap.nr_map * memmap.desc_size, "EFI memmap");
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/efi.c.ifdefed" startline="292" endline="429">
{
    efi_config_table_t *config_tables;
    efi_runtime_services_t *runtime;
    efi_char16_t *c16;
    char vendor [100] = "unknown";
    int i = 0;
    void *tmp;
    efi_phys.systab = (efi_system_table_t *) (boot_params.efi_info.efi_systab | ((__u64) boot_params.efi_info.efi_systab_hi << 32));
    efi.systab = early_ioremap ((unsigned long) efi_phys.systab, sizeof (efi_system_table_t));
    if (efi.systab == NULL)
        printk (KERN_ERR "Couldn't map the EFI system table!\n");
    memcpy (& efi_systab, efi.systab, sizeof (efi_system_table_t));
    early_iounmap (efi.systab, sizeof (efi_system_table_t));
    efi.systab = &efi_systab;
    if (efi.systab->hdr.signature != EFI_SYSTEM_TABLE_SIGNATURE)
        printk (KERN_ERR "EFI system table signature incorrect!\n");
    if ((efi.systab->hdr.revision >> 16) == 0)
        printk (KERN_ERR "Warning: EFI system table version " "%d.%02d, expected 1.00 or greater!\n", efi.systab->hdr.revision >> 16, efi.systab->hdr.revision & 0xffff);
    c16 = tmp = early_ioremap (efi.systab->fw_vendor, 2);
    if (c16) {
        for (i = 0; i < sizeof (vendor) && *c16; ++i)
            vendor[i] = *c16++;
        vendor[i] = '\0';
    }
    else
        printk (KERN_ERR PFX "Could not map the firmware vendor!\n");
    early_iounmap (tmp, 2);
    printk (KERN_INFO "EFI v%u.%.02u by %s \n", efi.systab -> hdr.revision >> 16, efi.systab -> hdr.revision & 0xffff, vendor);
    config_tables = early_ioremap (efi.systab->tables, efi.systab->nr_tables * sizeof (efi_config_table_t));
    if (config_tables == NULL)
        printk (KERN_ERR "Could not map EFI Configuration Table!\n");
    printk (KERN_INFO);
    for (i = 0; i < efi.systab->nr_tables; i++) {
        if (!efi_guidcmp (config_tables[i].guid, MPS_TABLE_GUID)) {
            efi.mps = config_tables[i].table;
            printk (" MPS=0x%lx ", config_tables [i].table);
        }
        else if (!efi_guidcmp (config_tables[i].guid, ACPI_20_TABLE_GUID)) {
            efi.acpi20 = config_tables[i].table;
            printk (" ACPI 2.0=0x%lx ", config_tables [i].table);
        }
        else if (!efi_guidcmp (config_tables[i].guid, ACPI_TABLE_GUID)) {
            efi.acpi = config_tables[i].table;
            printk (" ACPI=0x%lx ", config_tables [i].table);
        }
        else if (!efi_guidcmp (config_tables[i].guid, SMBIOS_TABLE_GUID)) {
            efi.smbios = config_tables[i].table;
            printk (" SMBIOS=0x%lx ", config_tables [i].table);
        }
        else if (!efi_guidcmp (config_tables[i].guid, HCDP_TABLE_GUID)) {
            efi.hcdp = config_tables[i].table;
            printk (" HCDP=0x%lx ", config_tables [i].table);
        }
        else if (!efi_guidcmp (config_tables[i].guid, UGA_IO_PROTOCOL_GUID)) {
            efi.uga = config_tables[i].table;
            printk (" UGA=0x%lx ", config_tables [i].table);
        }
    }
    printk ("\n");
    early_iounmap (config_tables, efi.systab -> nr_tables * sizeof (efi_config_table_t));
    runtime = early_ioremap ((unsigned long) efi.systab->runtime, sizeof (efi_runtime_services_t));
    if (runtime != NULL) {
        efi_phys.get_time = (efi_get_time_t *) runtime->get_time;
        efi_phys.set_virtual_address_map = (efi_set_virtual_address_map_t *) runtime->set_virtual_address_map;
        efi.get_time = phys_efi_get_time;
    }
    else
        printk (KERN_ERR "Could not map the EFI runtime service " "table!\n");
    early_iounmap (runtime, sizeof (efi_runtime_services_t));
    memmap.map = early_ioremap ((unsigned long) memmap.phys_map, memmap.nr_map * memmap.desc_size);
    if (memmap.map == NULL)
        printk (KERN_ERR "Could not map the EFI memory map!\n");
    memmap.map_end = memmap.map + (memmap.nr_map * memmap.desc_size);
    if (memmap.desc_size != sizeof (efi_memory_desc_t))
        printk (KERN_WARNING "Kernel-defined memdesc" "doesn't match the one from EFI!\n");
    if (add_efi_memmap)
        do_add_efi_memmap ();
    reboot_type = BOOT_EFI;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/efi.c.ifdefed" startline="331" endline="335">
{
    for (i = 0; i < sizeof (vendor) && *c16; ++i)
        vendor[i] = *c16++;
    vendor[i] = '\0';
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/efi.c.ifdefed" startline="353" endline="378">
{
    if (!efi_guidcmp (config_tables[i].guid, MPS_TABLE_GUID)) {
        efi.mps = config_tables[i].table;
        printk (" MPS=0x%lx ", config_tables [i].table);
    }
    else if (!efi_guidcmp (config_tables[i].guid, ACPI_20_TABLE_GUID)) {
        efi.acpi20 = config_tables[i].table;
        printk (" ACPI 2.0=0x%lx ", config_tables [i].table);
    }
    else if (!efi_guidcmp (config_tables[i].guid, ACPI_TABLE_GUID)) {
        efi.acpi = config_tables[i].table;
        printk (" ACPI=0x%lx ", config_tables [i].table);
    }
    else if (!efi_guidcmp (config_tables[i].guid, SMBIOS_TABLE_GUID)) {
        efi.smbios = config_tables[i].table;
        printk (" SMBIOS=0x%lx ", config_tables [i].table);
    }
    else if (!efi_guidcmp (config_tables[i].guid, HCDP_TABLE_GUID)) {
        efi.hcdp = config_tables[i].table;
        printk (" HCDP=0x%lx ", config_tables [i].table);
    }
    else if (!efi_guidcmp (config_tables[i].guid, UGA_IO_PROTOCOL_GUID)) {
        efi.uga = config_tables[i].table;
        printk (" UGA=0x%lx ", config_tables [i].table);
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/efi.c.ifdefed" startline="354" endline="357">
{
    efi.mps = config_tables[i].table;
    printk (" MPS=0x%lx ", config_tables [i].table);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/efi.c.ifdefed" startline="358" endline="361">
{
    efi.acpi20 = config_tables[i].table;
    printk (" ACPI 2.0=0x%lx ", config_tables [i].table);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/efi.c.ifdefed" startline="362" endline="365">
{
    efi.acpi = config_tables[i].table;
    printk (" ACPI=0x%lx ", config_tables [i].table);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/efi.c.ifdefed" startline="366" endline="369">
{
    efi.smbios = config_tables[i].table;
    printk (" SMBIOS=0x%lx ", config_tables [i].table);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/efi.c.ifdefed" startline="370" endline="373">
{
    efi.hcdp = config_tables[i].table;
    printk (" HCDP=0x%lx ", config_tables [i].table);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/efi.c.ifdefed" startline="374" endline="377">
{
    efi.uga = config_tables[i].table;
    printk (" UGA=0x%lx ", config_tables [i].table);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/efi.c.ifdefed" startline="391" endline="406">
{
    efi_phys.get_time = (efi_get_time_t *) runtime->get_time;
    efi_phys.set_virtual_address_map = (efi_set_virtual_address_map_t *) runtime->set_virtual_address_map;
    efi.get_time = phys_efi_get_time;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/efi.c.ifdefed" startline="432" endline="449">
{
    efi_memory_desc_t *md;
    void *p;
    u64 addr, npages;
    for (p = memmap.map; p < memmap.map_end; p += memmap.desc_size) {
        md = p;
        if (md->type != EFI_RUNTIME_SERVICES_CODE)
            continue;
        addr = md->virt_addr;
        npages = md->num_pages;
        memrange_efi_to_native (& addr, & npages);
        set_memory_x (addr, npages);
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/efi.c.ifdefed" startline="438" endline="448">
{
    md = p;
    if (md->type != EFI_RUNTIME_SERVICES_CODE)
        continue;
    addr = md->virt_addr;
    npages = md->num_pages;
    memrange_efi_to_native (& addr, & npages);
    set_memory_x (addr, npages);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/efi.c.ifdefed" startline="460" endline="537">
{
    efi_memory_desc_t *md;
    efi_status_t status;
    unsigned long size;
    u64 end, systab, addr, npages;
    void *p, *va;
    efi.systab = NULL;
    for (p = memmap.map; p < memmap.map_end; p += memmap.desc_size) {
        md = p;
        if (!(md->attribute & EFI_MEMORY_RUNTIME))
            continue;
        size = md->num_pages << EFI_PAGE_SHIFT;
        end = md->phys_addr + size;
        if (PFN_UP (end) <= max_low_pfn_mapped)
            va = __va (md->phys_addr);
        else
            va = efi_ioremap (md->phys_addr, size);
        md->virt_addr = (u64) (unsigned long) va;
        if (!va) {
            printk (KERN_ERR PFX "ioremap of 0x%llX failed!\n", (unsigned long long) md -> phys_addr);
            continue;
        }
        if (!(md->attribute & EFI_MEMORY_WB)) {
            addr = md->virt_addr;
            npages = md->num_pages;
            memrange_efi_to_native (& addr, & npages);
            set_memory_uc (addr, npages);
        }
        systab = (u64) (unsigned long) efi_phys.systab;
        if (md->phys_addr <= systab && systab < end) {
            systab += md->virt_addr - md->phys_addr;
            efi.systab = (efi_system_table_t *) (unsigned long) systab;
        }
    }
    BUG_ON (! efi.systab);
    status = phys_efi_set_virtual_address_map (memmap.desc_size * memmap.nr_map, memmap.desc_size, memmap.desc_version, memmap.phys_map);
    if (status != EFI_SUCCESS) {
        printk (KERN_ALERT "Unable to switch EFI into virtual mode " "(status=%lx)!\n", status);
        panic ("EFI call to SetVirtualAddressMap() failed!");
    }
    efi.get_time = virt_efi_get_time;
    efi.set_time = virt_efi_set_time;
    efi.get_wakeup_time = virt_efi_get_wakeup_time;
    efi.set_wakeup_time = virt_efi_set_wakeup_time;
    efi.get_variable = virt_efi_get_variable;
    efi.get_next_variable = virt_efi_get_next_variable;
    efi.set_variable = virt_efi_set_variable;
    efi.get_next_high_mono_count = virt_efi_get_next_high_mono_count;
    efi.reset_system = virt_efi_reset_system;
    efi.set_virtual_address_map = virt_efi_set_virtual_address_map;
    if (__supported_pte_mask & _PAGE_NX)
        runtime_code_page_mkexec ();
    early_iounmap (memmap.map, memmap.nr_map * memmap.desc_size);
    memmap.map = NULL;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/efi.c.ifdefed" startline="468" endline="501">
{
    md = p;
    if (!(md->attribute & EFI_MEMORY_RUNTIME))
        continue;
    size = md->num_pages << EFI_PAGE_SHIFT;
    end = md->phys_addr + size;
    if (PFN_UP (end) <= max_low_pfn_mapped)
        va = __va (md->phys_addr);
    else
        va = efi_ioremap (md->phys_addr, size);
    md->virt_addr = (u64) (unsigned long) va;
    if (!va) {
        printk (KERN_ERR PFX "ioremap of 0x%llX failed!\n", (unsigned long long) md -> phys_addr);
        continue;
    }
    if (!(md->attribute & EFI_MEMORY_WB)) {
        addr = md->virt_addr;
        npages = md->num_pages;
        memrange_efi_to_native (& addr, & npages);
        set_memory_uc (addr, npages);
    }
    systab = (u64) (unsigned long) efi_phys.systab;
    if (md->phys_addr <= systab && systab < end) {
        systab += md->virt_addr - md->phys_addr;
        efi.systab = (efi_system_table_t *) (unsigned long) systab;
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/efi.c.ifdefed" startline="483" endline="487">
{
    printk (KERN_ERR PFX "ioremap of 0x%llX failed!\n", (unsigned long long) md -> phys_addr);
    continue;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/efi.c.ifdefed" startline="489" endline="494">
{
    addr = md->virt_addr;
    npages = md->num_pages;
    memrange_efi_to_native (& addr, & npages);
    set_memory_uc (addr, npages);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/efi.c.ifdefed" startline="497" endline="500">
{
    systab += md->virt_addr - md->phys_addr;
    efi.systab = (efi_system_table_t *) (unsigned long) systab;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/efi.c.ifdefed" startline="511" endline="515">
{
    printk (KERN_ALERT "Unable to switch EFI into virtual mode " "(status=%lx)!\n", status);
    panic ("EFI call to SetVirtualAddressMap() failed!");
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/efi.c.ifdefed" startline="543" endline="555">
{
    efi_memory_desc_t *md;
    void *p;
    for (p = memmap.map; p < memmap.map_end; p += memmap.desc_size) {
        md = p;
        if ((md->phys_addr <= phys_addr) && (phys_addr < (md->phys_addr + (md->num_pages << EFI_PAGE_SHIFT))))
            return md->type;
    }
    return 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/efi.c.ifdefed" startline="547" endline="553">
{
    md = p;
    if ((md->phys_addr <= phys_addr) && (phys_addr < (md->phys_addr + (md->num_pages << EFI_PAGE_SHIFT))))
        return md->type;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/efi.c.ifdefed" startline="558" endline="570">
{
    efi_memory_desc_t *md;
    void *p;
    for (p = memmap.map; p < memmap.map_end; p += memmap.desc_size) {
        md = p;
        if ((md->phys_addr <= phys_addr) && (phys_addr < (md->phys_addr + (md->num_pages << EFI_PAGE_SHIFT))))
            return md->attribute;
    }
    return 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/efi.c.ifdefed" startline="562" endline="568">
{
    md = p;
    if ((md->phys_addr <= phys_addr) && (phys_addr < (md->phys_addr + (md->num_pages << EFI_PAGE_SHIFT))))
        return md->attribute;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpuid.c.ifdefed" startline="56" endline="61">
{
    struct cpuid_regs *cmd = (struct cpuid_regs *) cmd_block;
    cpuid_count (cmd -> eax, cmd -> ecx, & cmd -> eax, & cmd -> ebx, & cmd -> ecx, & cmd -> edx);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpuid.c.ifdefed" startline="64" endline="83">
{
    loff_t ret;
    struct inode *inode = file->f_mapping->host;
    mutex_lock (& inode -> i_mutex);
    switch (orig) {
    case 0 :
        file->f_pos = offset;
        ret = file->f_pos;
        break;
    case 1 :
        file->f_pos += offset;
        ret = file->f_pos;
        break;
    default :
        ret = -EINVAL;
    }
    mutex_unlock (& inode -> i_mutex);
    return ret;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpuid.c.ifdefed" startline="69" endline="80">
{
case 0 :
    file->f_pos = offset;
    ret = file->f_pos;
    break;
case 1 :
    file->f_pos += offset;
    ret = file->f_pos;
    break;
default :
    ret = -EINVAL;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpuid.c.ifdefed" startline="87" endline="114">
{
    char __user *tmp = buf;
    struct cpuid_regs cmd;
    int cpu = iminor (file->f_path.dentry->d_inode);
    u64 pos = *ppos;
    ssize_t bytes = 0;
    int err = 0;
    if (count % 16)
        return -EINVAL;
    for (; count; count -= 16) {
        cmd.eax = pos;
        cmd.ecx = pos >> 32;
        err = smp_call_function_single (cpu, cpuid_smp_cpuid, &cmd, 1);
        if (err)
            break;
        if (copy_to_user (tmp, &cmd, 16)) {
            err = -EFAULT;
            break;
        }
        tmp += 16;
        bytes += 16;
        *ppos = ++pos;
    }
    return bytes ? bytes : err;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpuid.c.ifdefed" startline="98" endline="111">
{
    cmd.eax = pos;
    cmd.ecx = pos >> 32;
    err = smp_call_function_single (cpu, cpuid_smp_cpuid, &cmd, 1);
    if (err)
        break;
    if (copy_to_user (tmp, &cmd, 16)) {
        err = -EFAULT;
        break;
    }
    tmp += 16;
    bytes += 16;
    *ppos = ++pos;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpuid.c.ifdefed" startline="104" endline="107">
{
    err = -EFAULT;
    break;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpuid.c.ifdefed" startline="117" endline="135">
{
    unsigned int cpu;
    struct cpuinfo_x86 *c;
    int ret = 0;
    lock_kernel ();
    cpu = iminor (file->f_path.dentry->d_inode);
    if (cpu >= NR_CPUS || !cpu_online (cpu)) {
        ret = -ENXIO;
        goto out;
    }
    c = &cpu_data (cpu);
    if (c->cpuid_level < 0)
        ret = -EIO;
out :
    unlock_kernel ();
    return ret;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpuid.c.ifdefed" startline="125" endline="128">
{
    ret = -ENXIO;
    goto out;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpuid.c.ifdefed" startline="148" endline="154">
{
    struct device *dev;
    dev = device_create_drvdata (cpuid_class, NULL, MKDEV (CPUID_MAJOR, cpu), NULL, "cpu%d", cpu);
    return IS_ERR (dev) ? PTR_ERR (dev) : 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpuid.c.ifdefed" startline="157" endline="159">
{
    device_destroy (cpuid_class, MKDEV (CPUID_MAJOR, cpu));
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpuid.c.ifdefed" startline="164" endline="179">
{
    unsigned int cpu = (unsigned long) hcpu;
    int err = 0;
    switch (action) {
    case CPU_UP_PREPARE :
        err = cpuid_device_create (cpu);
        break;
    case CPU_UP_CANCELED :
    case CPU_UP_CANCELED_FROZEN :
    case CPU_DEAD :
        cpuid_device_destroy (cpu);
        break;
    }
    return err ? NOTIFY_BAD : NOTIFY_OK;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpuid.c.ifdefed" startline="168" endline="177">
{
case CPU_UP_PREPARE :
    err = cpuid_device_create (cpu);
    break;
case CPU_UP_CANCELED :
case CPU_UP_CANCELED_FROZEN :
case CPU_DEAD :
    cpuid_device_destroy (cpu);
    break;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpuid.c.ifdefed" startline="187" endline="222">
{
    int i, err = 0;
    i = 0;
    if (register_chrdev (CPUID_MAJOR, "cpu/cpuid", &cpuid_fops)) {
        printk (KERN_ERR "cpuid: unable to get major %d for cpuid\n", CPUID_MAJOR);
        err = -EBUSY;
        goto out;
    }
    cpuid_class = class_create (THIS_MODULE, "cpuid");
    if (IS_ERR (cpuid_class)) {
        err = PTR_ERR (cpuid_class);
        goto out_chrdev;
    }

    for_each_online_cpu (i) {
        err = cpuid_device_create (i);
        if (err != 0)
            goto out_class;
    }

    register_hotcpu_notifier (& cpuid_class_cpu_notifier);
    err = 0;
    goto out;
out_class :
    i = 0;

    for_each_online_cpu (i) {
        cpuid_device_destroy (i);
    }

    class_destroy (cpuid_class);
out_chrdev :
    unregister_chrdev (CPUID_MAJOR, "cpu/cpuid");
out :
    return err;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpuid.c.ifdefed" startline="191" endline="196">
{
    printk (KERN_ERR "cpuid: unable to get major %d for cpuid\n", CPUID_MAJOR);
    err = -EBUSY;
    goto out;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpuid.c.ifdefed" startline="198" endline="201">
{
    err = PTR_ERR (cpuid_class);
    goto out_chrdev;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpuid.c.ifdefed" startline="202" endline="206">
{
    err = cpuid_device_create (i);
    if (err != 0)
        goto out_class;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpuid.c.ifdefed" startline="214" endline="216">
{
    cpuid_device_destroy (i);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpuid.c.ifdefed" startline="225" endline="233">
{
    int cpu = 0;
    for_each_online_cpu (cpu)
    cpuid_device_destroy (cpu);
    class_destroy (cpuid_class);
    unregister_chrdev (CPUID_MAJOR, "cpu/cpuid");
    unregister_hotcpu_notifier (& cpuid_class_cpu_notifier);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/ioport.c.ifdefed" startline="21" endline="30">
{
    unsigned int i;
    for (i = base; i < base + extent; i++) {
        if (new_value)
            __set_bit (i, bitmap);
        else
            __clear_bit (i, bitmap);
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/ioport.c.ifdefed" startline="24" endline="29">
{
    if (new_value)
        __set_bit (i, bitmap);
    else
        __clear_bit (i, bitmap);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/ioport.c.ifdefed" startline="36" endline="104">
{
    struct thread_struct *t = &current->thread;
    struct tss_struct *tss;
    unsigned int i, max_long, bytes, bytes_updated;
    if ((from + num <= from) || (from + num > IO_BITMAP_BITS))
        return -EINVAL;
    if (turn_on && !capable (CAP_SYS_RAWIO))
        return -EPERM;
    if (!t->io_bitmap_ptr) {
        unsigned long *bitmap = kmalloc (IO_BITMAP_BYTES, GFP_KERNEL);
        if (!bitmap)
            return -ENOMEM;
        memset (bitmap, 0xff, IO_BITMAP_BYTES);
        t->io_bitmap_ptr = bitmap;
        set_thread_flag (TIF_IO_BITMAP);
    }
    tss = &per_cpu (init_tss, get_cpu ());
    set_bitmap (t -> io_bitmap_ptr, from, num, ! turn_on);
    max_long = 0;
    for (i = 0; i < IO_BITMAP_LONGS; i++)
        if (t->io_bitmap_ptr[i] != ~0UL)
            max_long = i;
    bytes = (max_long + 1) * sizeof (unsigned long);
    bytes_updated = max (bytes, t->io_bitmap_max);
    t->io_bitmap_max = bytes;
    memcpy (tss -> io_bitmap, t -> io_bitmap_ptr, bytes_updated);
    put_cpu ();
    return 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/ioport.c.ifdefed" startline="51" endline="60">
{
    unsigned long *bitmap = kmalloc (IO_BITMAP_BYTES, GFP_KERNEL);
    if (!bitmap)
        return -ENOMEM;
    memset (bitmap, 0xff, IO_BITMAP_BYTES);
    t->io_bitmap_ptr = bitmap;
    set_thread_flag (TIF_IO_BITMAP);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/ioport.c.ifdefed" startline="117" endline="130">
{
    unsigned int old = (regs->flags >> 12) & 3;
    if (level > 3)
        return -EINVAL;
    if (level > old) {
        if (!capable (CAP_SYS_RAWIO))
            return -EPERM;
    }
    regs->flags = (regs->flags & ~X86_EFLAGS_IOPL) | (level << 12);
    return 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/ioport.c.ifdefed" startline="123" endline="126">
{
    if (!capable (CAP_SYS_RAWIO))
        return -EPERM;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/ioport.c.ifdefed" startline="151" endline="153">
{
    return do_iopl (level, regs);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/mmconf-fam10h_64.c.ifdefed" startline="40" endline="49">
{
    const struct range *r1 = x1;
    const struct range *r2 = x2;
    int start1, start2;
    start1 = r1->start >> 32;
    start2 = r2->start >> 32;
    return start1 - start2;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/mmconf-fam10h_64.c.ifdefed" startline="56" endline="176">
{
    int i;
    unsigned bus;
    unsigned slot;
    int found;
    u64 val;
    u32 address;
    u64 tom2;
    u64 base = FAM10H_PCI_MMCONF_BASE;
    int hi_mmio_num;
    struct range range [8];
    if (fam10h_pci_mmconf_base_status)
        return;
    if (!early_pci_allowed ())
        goto fail;
    found = 0;
    for (i = 0; i < ARRAY_SIZE (pci_probes); i++) {
        u32 id;
        u16 device;
        u16 vendor;
        bus = pci_probes[i].bus;
        slot = pci_probes[i].slot;
        id = read_pci_config (bus, slot, 0, PCI_VENDOR_ID);
        vendor = id & 0xffff;
        device = (id >> 16) & 0xffff;
        if (pci_probes[i].vendor == vendor && pci_probes[i].device == device) {
            found = 1;
            break;
        }
    }
    if (!found)
        goto fail;
    address = MSR_K8_SYSCFG;
    rdmsrl (address, val);
    if (!(val & (1 << 21))) {
        tom2 = 0;
    }
    else {
        address = MSR_K8_TOP_MEM2;
        rdmsrl (address, val);
        tom2 = val & (0xffffULL << 32);
    }
    if (base <= tom2)
        base = tom2 + (1ULL << 32);
    hi_mmio_num = 0;
    for (i = 0; i < 8; i++) {
        u32 reg;
        u64 start;
        u64 end;
        reg = read_pci_config (bus, slot, 1, 0x80 + (i << 3));
        if (!(reg & 3))
            continue;
        start = (((u64) reg) << 8) & (0xffULL << 32);
        reg = read_pci_config (bus, slot, 1, 0x84 + (i << 3));
        end = (((u64) reg) << 8) & (0xffULL << 32);
        if (!end)
            continue;
        range[hi_mmio_num].start = start;
        range[hi_mmio_num].end = end;
        hi_mmio_num++;
    }
    if (!hi_mmio_num)
        goto out;
    sort (range, hi_mmio_num, sizeof (struct range), cmp_range, NULL);
    if (range[hi_mmio_num - 1].end < base)
        goto out;
    if (range[0].start > base)
        goto out;
    base = range[0].start - (1ULL << 32);
    if ((base > tom2) && BASE_VALID (base))
        goto out;
    base = range[hi_mmio_num - 1].end + (1ULL << 32);
    if ((base > tom2) && BASE_VALID (base))
        goto out;
    if (hi_mmio_num > 1)
        for (i = 0; i < hi_mmio_num - 1; i++) {
            if (range[i + 1].start > (range[i].end + (1ULL << 32))) {
                base = range[i].end + (1ULL << 32);
                if ((base > tom2) && BASE_VALID (base))
                    goto out;
            }
        }
fail :
    fam10h_pci_mmconf_base_status = -1;
    return;
out :
    fam10h_pci_mmconf_base = base;
    fam10h_pci_mmconf_base_status = 1;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/mmconf-fam10h_64.c.ifdefed" startline="79" endline="95">
{
    u32 id;
    u16 device;
    u16 vendor;
    bus = pci_probes[i].bus;
    slot = pci_probes[i].slot;
    id = read_pci_config (bus, slot, 0, PCI_VENDOR_ID);
    vendor = id & 0xffff;
    device = (id >> 16) & 0xffff;
    if (pci_probes[i].vendor == vendor && pci_probes[i].device == device) {
        found = 1;
        break;
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/mmconf-fam10h_64.c.ifdefed" startline="91" endline="94">
{
    found = 1;
    break;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/mmconf-fam10h_64.c.ifdefed" startline="105" endline="107">
{
    tom2 = 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/mmconf-fam10h_64.c.ifdefed" startline="107" endline="112">
{
    address = MSR_K8_TOP_MEM2;
    rdmsrl (address, val);
    tom2 = val & (0xffffULL << 32);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/mmconf-fam10h_64.c.ifdefed" startline="122" endline="140">
{
    u32 reg;
    u64 start;
    u64 end;
    reg = read_pci_config (bus, slot, 1, 0x80 + (i << 3));
    if (!(reg & 3))
        continue;
    start = (((u64) reg) << 8) & (0xffULL << 32);
    reg = read_pci_config (bus, slot, 1, 0x84 + (i << 3));
    end = (((u64) reg) << 8) & (0xffULL << 32);
    if (!end)
        continue;
    range[hi_mmio_num].start = start;
    range[hi_mmio_num].end = end;
    hi_mmio_num++;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/mmconf-fam10h_64.c.ifdefed" startline="162" endline="168">
{
    if (range[i + 1].start > (range[i].end + (1ULL << 32))) {
        base = range[i].end + (1ULL << 32);
        if ((base > tom2) && BASE_VALID (base))
            goto out;
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/mmconf-fam10h_64.c.ifdefed" startline="163" endline="167">
{
    base = range[i].end + (1ULL << 32);
    if ((base > tom2) && BASE_VALID (base))
        goto out;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/mmconf-fam10h_64.c.ifdefed" startline="179" endline="222">
{
    u64 val;
    u32 address;
    if (!(pci_probe & PCI_CHECK_ENABLE_AMD_MMCONF))
        return;
    address = MSR_FAM10H_MMIO_CONF_BASE;
    rdmsrl (address, val);
    if (val & FAM10H_MMIO_CONF_ENABLE) {
        unsigned busnbits;
        busnbits = (val >> FAM10H_MMIO_CONF_BUSRANGE_SHIFT) & FAM10H_MMIO_CONF_BUSRANGE_MASK;
        if (!acpi_pci_disabled || busnbits >= 8) {
            u64 base;
            base = val & (0xffffULL << 32);
            if (fam10h_pci_mmconf_base_status <= 0) {
                fam10h_pci_mmconf_base = base;
                fam10h_pci_mmconf_base_status = 1;
                return;
            }
            else if (fam10h_pci_mmconf_base == base)
                return;
        }
    }
    get_fam10h_pci_mmconf_base ();
    if (fam10h_pci_mmconf_base_status <= 0)
        return;
    printk (KERN_INFO "Enable MMCONFIG on AMD Family 10h\n");
    val &= ~((FAM10H_MMIO_CONF_BASE_MASK << FAM10H_MMIO_CONF_BASE_SHIFT) | (FAM10H_MMIO_CONF_BUSRANGE_MASK << FAM10H_MMIO_CONF_BUSRANGE_SHIFT));
    val |= fam10h_pci_mmconf_base | (8 << FAM10H_MMIO_CONF_BUSRANGE_SHIFT) | FAM10H_MMIO_CONF_ENABLE;
    wrmsrl (address, val);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/mmconf-fam10h_64.c.ifdefed" startline="190" endline="206">
{
    unsigned busnbits;
    busnbits = (val >> FAM10H_MMIO_CONF_BUSRANGE_SHIFT) & FAM10H_MMIO_CONF_BUSRANGE_MASK;
    if (!acpi_pci_disabled || busnbits >= 8) {
        u64 base;
        base = val & (0xffffULL << 32);
        if (fam10h_pci_mmconf_base_status <= 0) {
            fam10h_pci_mmconf_base = base;
            fam10h_pci_mmconf_base_status = 1;
            return;
        }
        else if (fam10h_pci_mmconf_base == base)
            return;
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/mmconf-fam10h_64.c.ifdefed" startline="196" endline="205">
{
    u64 base;
    base = val & (0xffffULL << 32);
    if (fam10h_pci_mmconf_base_status <= 0) {
        fam10h_pci_mmconf_base = base;
        fam10h_pci_mmconf_base_status = 1;
        return;
    }
    else if (fam10h_pci_mmconf_base == base)
        return;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/mmconf-fam10h_64.c.ifdefed" startline="199" endline="203">
{
    fam10h_pci_mmconf_base = base;
    fam10h_pci_mmconf_base_status = 1;
    return;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/mmconf-fam10h_64.c.ifdefed" startline="225" endline="228">
{
    pci_probe |= PCI_CHECK_ENABLE_AMD_MMCONF;
    return 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/mmconf-fam10h_64.c.ifdefed" startline="242" endline="244">
{
    dmi_check_system (mmconf_dmi_table);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/alternative.c.ifdefed" startline="35" endline="38">
{
    debug_alternative = 1;
    return 1;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/alternative.c.ifdefed" startline="44" endline="47">
{
    noreplace_smp = 1;
    return 1;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/alternative.c.ifdefed" startline="158" endline="167">
{
    if (boot_cpu_has (X86_FEATURE_K8))
        return k8_nops;
    else if (boot_cpu_has (X86_FEATURE_K7))
        return k7_nops;
    else if (boot_cpu_has (X86_FEATURE_NOPL))
        return p6_nops;
    else
        return intel_nops;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/alternative.c.ifdefed" startline="173" endline="184">
{
    const unsigned char * const *noptable = find_nop_table ();
    while (len > 0) {
        unsigned int noplen = len;
        if (noplen > ASM_NOP_MAX)
            noplen = ASM_NOP_MAX;
        memcpy (insns, noptable [noplen], noplen);
        insns += noplen;
        len -= noplen;
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/alternative.c.ifdefed" startline="176" endline="183">
{
    unsigned int noplen = len;
    if (noplen > ASM_NOP_MAX)
        noplen = ASM_NOP_MAX;
    memcpy (insns, noptable [noplen], noplen);
    insns += noplen;
    len -= noplen;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/alternative.c.ifdefed" startline="197" endline="221">
{
    struct alt_instr *a;
    char insnbuf [MAX_PATCH_LEN];
    DPRINTK ("%s: alt table %p -> %p\n", __func__, start, end);
    for (a = start; a < end; a++) {
        u8 *instr = a->instr;
        BUG_ON (a -> replacementlen > a -> instrlen);
        BUG_ON (a -> instrlen > sizeof (insnbuf));
        if (!boot_cpu_has (a->cpuid))
            continue;
        memcpy (insnbuf, a -> replacement, a -> replacementlen);
        add_nops (insnbuf + a -> replacementlen, a -> instrlen - a -> replacementlen);
        text_poke_early (instr, insnbuf, a -> instrlen);
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/alternative.c.ifdefed" startline="202" endline="220">
{
    u8 *instr = a->instr;
    BUG_ON (a -> replacementlen > a -> instrlen);
    BUG_ON (a -> instrlen > sizeof (insnbuf));
    if (!boot_cpu_has (a->cpuid))
        continue;
    memcpy (insnbuf, a -> replacement, a -> replacementlen);
    add_nops (insnbuf + a -> replacementlen, a -> instrlen - a -> replacementlen);
    text_poke_early (instr, insnbuf, a -> instrlen);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/alternative.c.ifdefed" startline="412" endline="462">
{
    stop_nmi ();
    apply_alternatives (__alt_instructions, __alt_instructions_end);
    apply_paravirt (__parainstructions, __parainstructions_end);
    if (smp_alt_once)
        free_init_pages ("SMP alternatives", (unsigned long) __smp_locks, (unsigned long) __smp_locks_end);
    restart_nmi ();
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/alternative.c.ifdefed" startline="477" endline="486">
{
    unsigned long flags;
    local_irq_save (flags);
    memcpy (addr, opcode, len);
    local_irq_restore (flags);
    sync_core ();
    return addr;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/alternative.c.ifdefed" startline="500" endline="530">
{
    unsigned long flags;
    char *vaddr;
    int nr_pages = 2;
    struct page *pages [2];
    int i;
    if (!core_kernel_text ((unsigned long) addr)) {
        pages[0] = vmalloc_to_page (addr);
        pages[1] = vmalloc_to_page (addr +PAGE_SIZE);
    }
    else {
        pages[0] = virt_to_page (addr);
        WARN_ON (! PageReserved (pages [0]));
        pages[1] = virt_to_page (addr +PAGE_SIZE);
    }
    BUG_ON (! pages [0]);
    if (!pages[1])
        nr_pages = 1;
    vaddr = vmap (pages, nr_pages, VM_MAP, PAGE_KERNEL);
    BUG_ON (! vaddr);
    local_irq_save (flags);
    memcpy (& vaddr [(unsigned long) addr & ~ PAGE_MASK], opcode, len);
    local_irq_restore (flags);
    vunmap (vaddr);
    sync_core ();
    for (i = 0; i < len; i++)
        BUG_ON (((char *) addr)[i] != ((char *) opcode)[i]);
    return addr;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/alternative.c.ifdefed" startline="507" endline="510">
{
    pages[0] = vmalloc_to_page (addr);
    pages[1] = vmalloc_to_page (addr +PAGE_SIZE);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/alternative.c.ifdefed" startline="510" endline="514">
{
    pages[0] = virt_to_page (addr);
    WARN_ON (! PageReserved (pages [0]));
    pages[1] = virt_to_page (addr +PAGE_SIZE);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/efi_64.c.ifdefed" startline="46" endline="56">
{
    unsigned long num_pages;
    start &= PMD_MASK;
    end = (end + PMD_SIZE - 1) & PMD_MASK;
    num_pages = (end - start) >> PAGE_SHIFT;
    if (executable)
        set_memory_x ((unsigned long) __va (start), num_pages);
    else
        set_memory_nx ((unsigned long) __va (start), num_pages);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/efi_64.c.ifdefed" startline="59" endline="75">
{
    efi_memory_desc_t *md;
    void *p;
    if (!(__supported_pte_mask & _PAGE_NX))
        return;
    for (p = memmap.map; p < memmap.map_end; p += memmap.desc_size) {
        md = p;
        if (md->type == EFI_RUNTIME_SERVICES_CODE) {
            unsigned long end;
            end = md->phys_addr + (md->num_pages << EFI_PAGE_SHIFT);
            early_mapping_set_exec (md -> phys_addr, end, executable);
        }
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/efi_64.c.ifdefed" startline="67" endline="74">
{
    md = p;
    if (md->type == EFI_RUNTIME_SERVICES_CODE) {
        unsigned long end;
        end = md->phys_addr + (md->num_pages << EFI_PAGE_SHIFT);
        early_mapping_set_exec (md -> phys_addr, end, executable);
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/efi_64.c.ifdefed" startline="69" endline="73">
{
    unsigned long end;
    end = md->phys_addr + (md->num_pages << EFI_PAGE_SHIFT);
    early_mapping_set_exec (md -> phys_addr, end, executable);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/efi_64.c.ifdefed" startline="78" endline="87">
{
    unsigned long vaddress;
    early_runtime_code_mapping_set_exec (1);
    local_irq_save (efi_flags);
    vaddress = (unsigned long) __va (0x0UL);
    save_pgd = *pgd_offset_k (0x0UL);
    set_pgd (pgd_offset_k (0x0UL), * pgd_offset_k (vaddress));
    __flush_tlb_all ();
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/efi_64.c.ifdefed" startline="90" endline="98">
{
    set_pgd (pgd_offset_k (0x0UL), save_pgd);
    __flush_tlb_all ();
    local_irq_restore (efi_flags);
    early_runtime_code_mapping_set_exec (0);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/efi_64.c.ifdefed" startline="101" endline="122">
{
    static unsigned pages_mapped __initdata;
    unsigned i, pages;
    unsigned long offset;
    pages = PFN_UP (phys_addr +size) - PFN_DOWN (phys_addr);
    offset = phys_addr & ~PAGE_MASK;
    phys_addr &= PAGE_MASK;
    if (pages_mapped + pages > MAX_EFI_IO_PAGES)
        return NULL;
    for (i = 0; i < pages; i++) {
        __set_fixmap (FIX_EFI_IO_MAP_FIRST_PAGE - pages_mapped, phys_addr, PAGE_KERNEL);
        phys_addr += PAGE_SIZE;
        pages_mapped++;
    }
    return (void __iomem *) __fix_to_virt (FIX_EFI_IO_MAP_FIRST_PAGE - \ (pages_mapped - pages)) + offset;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/efi_64.c.ifdefed" startline="113" endline="118">
{
    __set_fixmap (FIX_EFI_IO_MAP_FIRST_PAGE - pages_mapped, phys_addr, PAGE_KERNEL);
    phys_addr += PAGE_SIZE;
    pages_mapped++;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/tlb_uv.c.ifdefed" startline="46" endline="55">
{
    unsigned long dw;
    dw = (1 << (resource + UV_SW_ACK_NPENDING)) | (1 << resource);
    msg->replied_to = 1;
    msg->sw_ack_vector = 0;
    if (msp)
        msp->seen_by.bits = 0;
    uv_write_local_mmr (UVH_LB_BAU_INTD_SOFTWARE_ACKNOWLEDGE_ALIAS, dw);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/tlb_uv.c.ifdefed" startline="63" endline="93">
{
    unsigned long this_cpu_mask;
    struct bau_msg_status *msp;
    int cpu;
    msp = __get_cpu_var (bau_control).msg_statuses + msg_slot;
    cpu = uv_blade_processor_id ();
    msg->number_of_cpus = uv_blade_nr_online_cpus (uv_node_to_blade_id (numa_node_id ()));
    this_cpu_mask = 1UL << cpu;
    if (msp->seen_by.bits & this_cpu_mask)
        return;
    atomic_or_long (& msp -> seen_by.bits, this_cpu_mask);
    if (msg->replied_to == 1)
        return;
    if (msg->address == TLB_FLUSH_ALL) {
        local_flush_tlb ();
        __get_cpu_var (ptcstats).alltlb++;
    }
    else {
        __flush_tlb_one (msg -> address);
        __get_cpu_var (ptcstats).onetlb++;
    }
    __get_cpu_var (ptcstats).requestee++;
    atomic_inc_short (& msg -> acknowledge_count);
    if (msg->number_of_cpus == msg->acknowledge_count)
        uv_reply_to_message (sw_ack_slot, msg, msp);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/tlb_uv.c.ifdefed" startline="80" endline="83">
{
    local_flush_tlb ();
    __get_cpu_var (ptcstats).alltlb++;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/tlb_uv.c.ifdefed" startline="83" endline="86">
{
    __flush_tlb_one (msg -> address);
    __get_cpu_var (ptcstats).onetlb++;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/tlb_uv.c.ifdefed" startline="102" endline="127">
{
    struct bau_payload_queue_entry *msg;
    struct bau_msg_status *msp;
    int count = 0;
    int i;
    int j;
    for (msg = bau_tablesp->va_queue_first, i = 0; i < DEST_Q_SIZE; msg++, i++) {
        if ((msg->sending_cpu == sender) && (!msg->replied_to)) {
            msp = bau_tablesp->msg_statuses + i;
            printk (KERN_DEBUG "blade %d: address:%#lx %d of %d, not cpu(s): ", i, msg -> address, msg -> acknowledge_count, msg -> number_of_cpus);
            for (j = 0; j < msg->number_of_cpus; j++) {
                if (!((1L << j) & msp->seen_by.bits)) {
                    count++;
                    printk ("%d ", j);
                }
            }
            printk ("\n");
        }
    }
    return count;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/tlb_uv.c.ifdefed" startline="110" endline="125">
{
    if ((msg->sending_cpu == sender) && (!msg->replied_to)) {
        msp = bau_tablesp->msg_statuses + i;
        printk (KERN_DEBUG "blade %d: address:%#lx %d of %d, not cpu(s): ", i, msg -> address, msg -> acknowledge_count, msg -> number_of_cpus);
        for (j = 0; j < msg->number_of_cpus; j++) {
            if (!((1L << j) & msp->seen_by.bits)) {
                count++;
                printk ("%d ", j);
            }
        }
        printk ("\n");
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/tlb_uv.c.ifdefed" startline="111" endline="124">
{
    msp = bau_tablesp->msg_statuses + i;
    printk (KERN_DEBUG "blade %d: address:%#lx %d of %d, not cpu(s): ", i, msg -> address, msg -> acknowledge_count, msg -> number_of_cpus);
    for (j = 0; j < msg->number_of_cpus; j++) {
        if (!((1L << j) & msp->seen_by.bits)) {
            count++;
            printk ("%d ", j);
        }
    }
    printk ("\n");
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/tlb_uv.c.ifdefed" startline="117" endline="122">
{
    if (!((1L << j) & msp->seen_by.bits)) {
        count++;
        printk ("%d ", j);
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/tlb_uv.c.ifdefed" startline="118" endline="121">
{
    count++;
    printk ("%d ", j);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/tlb_uv.c.ifdefed" startline="136" endline="148">
{
    int sender;
    int i;
    int count = 0;
    sender = smp_processor_id ();
    for (i = 0; i < sizeof (struct bau_target_nodemask) * BITSPERBYTE; i++) {
        if (!bau_node_isset (i, distribution))
            continue;
        count += uv_examine_destination (uv_bau_table_bases[i], sender);
    }
    return count;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/tlb_uv.c.ifdefed" startline="142" endline="146">
{
    if (!bau_node_isset (i, distribution))
        continue;
    count += uv_examine_destination (uv_bau_table_bases[i], sender);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/tlb_uv.c.ifdefed" startline="157" endline="205">
{
    int exams = 0;
    long destination_timeouts = 0;
    long source_timeouts = 0;
    unsigned long descriptor_status;
    while ((descriptor_status = (((unsigned long) uv_read_local_mmr (mmr_offset) >> right_shift) & UV_ACT_STATUS_MASK)) != DESC_STATUS_IDLE) {
        if (descriptor_status == DESC_STATUS_SOURCE_TIMEOUT) {
            source_timeouts++;
            if (source_timeouts > SOURCE_TIMEOUT_LIMIT)
                source_timeouts = 0;
            __get_cpu_var (ptcstats).s_retry++;
            return FLUSH_RETRY;
        }
        if (descriptor_status == DESC_STATUS_DESTINATION_TIMEOUT) {
            destination_timeouts++;
            if (destination_timeouts > DESTINATION_TIMEOUT_LIMIT) {
                if (uv_examine_destinations (&bau_desc->distribution) == 0) {
                    __get_cpu_var (ptcstats).d_retry++;
                    return FLUSH_RETRY;
                }
                exams++;
                if (exams >= uv_bau_retry_limit) {
                    printk (KERN_DEBUG "uv_flush_tlb_others");
                    printk ("giving up on cpu %d\n", smp_processor_id ());
                    return FLUSH_GIVEUP;
                }
                destination_timeouts = 0;
            }
        }
    }
    return FLUSH_COMPLETE;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/tlb_uv.c.ifdefed" startline="166" endline="203">
{
    if (descriptor_status == DESC_STATUS_SOURCE_TIMEOUT) {
        source_timeouts++;
        if (source_timeouts > SOURCE_TIMEOUT_LIMIT)
            source_timeouts = 0;
        __get_cpu_var (ptcstats).s_retry++;
        return FLUSH_RETRY;
    }
    if (descriptor_status == DESC_STATUS_DESTINATION_TIMEOUT) {
        destination_timeouts++;
        if (destination_timeouts > DESTINATION_TIMEOUT_LIMIT) {
            if (uv_examine_destinations (&bau_desc->distribution) == 0) {
                __get_cpu_var (ptcstats).d_retry++;
                return FLUSH_RETRY;
            }
            exams++;
            if (exams >= uv_bau_retry_limit) {
                printk (KERN_DEBUG "uv_flush_tlb_others");
                printk ("giving up on cpu %d\n", smp_processor_id ());
                return FLUSH_GIVEUP;
            }
            destination_timeouts = 0;
        }
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/tlb_uv.c.ifdefed" startline="167" endline="173">
{
    source_timeouts++;
    if (source_timeouts > SOURCE_TIMEOUT_LIMIT)
        source_timeouts = 0;
    __get_cpu_var (ptcstats).s_retry++;
    return FLUSH_RETRY;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/tlb_uv.c.ifdefed" startline="177" endline="202">
{
    destination_timeouts++;
    if (destination_timeouts > DESTINATION_TIMEOUT_LIMIT) {
        if (uv_examine_destinations (&bau_desc->distribution) == 0) {
            __get_cpu_var (ptcstats).d_retry++;
            return FLUSH_RETRY;
        }
        exams++;
        if (exams >= uv_bau_retry_limit) {
            printk (KERN_DEBUG "uv_flush_tlb_others");
            printk ("giving up on cpu %d\n", smp_processor_id ());
            return FLUSH_GIVEUP;
        }
        destination_timeouts = 0;
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/tlb_uv.c.ifdefed" startline="179" endline="201">
{
    if (uv_examine_destinations (&bau_desc->distribution) == 0) {
        __get_cpu_var (ptcstats).d_retry++;
        return FLUSH_RETRY;
    }
    exams++;
    if (exams >= uv_bau_retry_limit) {
        printk (KERN_DEBUG "uv_flush_tlb_others");
        printk ("giving up on cpu %d\n", smp_processor_id ());
        return FLUSH_GIVEUP;
    }
    destination_timeouts = 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/tlb_uv.c.ifdefed" startline="184" endline="187">
{
    __get_cpu_var (ptcstats).d_retry++;
    return FLUSH_RETRY;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/tlb_uv.c.ifdefed" startline="189" endline="195">
{
    printk (KERN_DEBUG "uv_flush_tlb_others");
    printk ("giving up on cpu %d\n", smp_processor_id ());
    return FLUSH_GIVEUP;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/tlb_uv.c.ifdefed" startline="220" endline="275">
{
    int completion_status = 0;
    int right_shift;
    int tries = 0;
    int blade;
    int bit;
    unsigned long mmr_offset;
    unsigned long index;
    cycles_t time1;
    cycles_t time2;
    if (cpu < UV_CPUS_PER_ACT_STATUS) {
        mmr_offset = UVH_LB_BAU_SB_ACTIVATION_STATUS_0;
        right_shift = cpu * UV_ACT_STATUS_SIZE;
    }
    else {
        mmr_offset = UVH_LB_BAU_SB_ACTIVATION_STATUS_1;
        right_shift = ((cpu - UV_CPUS_PER_ACT_STATUS) * UV_ACT_STATUS_SIZE);
    }
    time1 = get_cycles ();
    do {
        tries++;
        index = (1UL << UVH_LB_BAU_SB_ACTIVATION_CONTROL_PUSH_SHFT) | cpu;
        uv_write_local_mmr (UVH_LB_BAU_SB_ACTIVATION_CONTROL, index);
        completion_status = uv_wait_completion (bau_desc, mmr_offset, right_shift);
    }
    while (completion_status == FLUSH_RETRY);
    time2 = get_cycles ();
    __get_cpu_var (ptcstats).sflush += (time2 - time1);
    if (tries > 1)
        __get_cpu_var (ptcstats).retriesok++;
    if (completion_status == FLUSH_GIVEUP) {
        __get_cpu_var (ptcstats).ptc_i++;
        return 0;
    }
    for_each_cpu_mask (bit, * cpumaskp)
    {
        blade = uv_cpu_to_blade_id (bit);
        if (blade == this_blade)
            continue;
        cpu_clear (bit, * cpumaskp);
    }
    if (!cpus_empty (*cpumaskp))
        return 0;
    return 1;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/tlb_uv.c.ifdefed" startline="231" endline="234">
{
    mmr_offset = UVH_LB_BAU_SB_ACTIVATION_STATUS_0;
    right_shift = cpu * UV_ACT_STATUS_SIZE;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/tlb_uv.c.ifdefed" startline="234" endline="238">
{
    mmr_offset = UVH_LB_BAU_SB_ACTIVATION_STATUS_1;
    right_shift = ((cpu - UV_CPUS_PER_ACT_STATUS) * UV_ACT_STATUS_SIZE);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/tlb_uv.c.ifdefed" startline="240" endline="247">
{
    tries++;
    index = (1UL << UVH_LB_BAU_SB_ACTIVATION_CONTROL_PUSH_SHFT) | cpu;
    uv_write_local_mmr (UVH_LB_BAU_SB_ACTIVATION_CONTROL, index);
    completion_status = uv_wait_completion (bau_desc, mmr_offset, right_shift);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/tlb_uv.c.ifdefed" startline="253" endline="260">
{
    __get_cpu_var (ptcstats).ptc_i++;
    return 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/tlb_uv.c.ifdefed" startline="266" endline="271">
{
    blade = uv_cpu_to_blade_id (bit);
    if (blade == this_blade)
        continue;
    cpu_clear (bit, * cpumaskp);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/tlb_uv.c.ifdefed" startline="301" endline="344">
{
    int i;
    int bit;
    int blade;
    int cpu;
    int this_blade;
    int locals = 0;
    struct bau_desc *bau_desc;
    cpu = uv_blade_processor_id ();
    this_blade = uv_numa_blade_id ();
    bau_desc = __get_cpu_var (bau_control).descriptor_base;
    bau_desc += UV_ITEMS_PER_DESCRIPTOR * cpu;
    bau_nodes_clear (& bau_desc -> distribution, UV_DISTRIBUTION_SIZE);
    i = 0;
    for_each_cpu_mask (bit, * cpumaskp)
    {
        blade = uv_cpu_to_blade_id (bit);
        BUG_ON (blade > (UV_DISTRIBUTION_SIZE - 1));
        if (blade == this_blade) {
            locals++;
            continue;
        }
        bau_node_set (blade, & bau_desc -> distribution);
        i++;
    }
    if (i == 0) {
        if (locals)
            return 0;
        else
            return 1;
    }
    __get_cpu_var (ptcstats).requestor++;
    __get_cpu_var (ptcstats).ntargeted += i;
    bau_desc->payload.address = va;
    bau_desc->payload.sending_cpu = smp_processor_id ();
    return uv_flush_send_and_wait (cpu, this_blade, bau_desc, cpumaskp);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/tlb_uv.c.ifdefed" startline="318" endline="327">
{
    blade = uv_cpu_to_blade_id (bit);
    BUG_ON (blade > (UV_DISTRIBUTION_SIZE - 1));
    if (blade == this_blade) {
        locals++;
        continue;
    }
    bau_node_set (blade, & bau_desc -> distribution);
    i++;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/tlb_uv.c.ifdefed" startline="321" endline="324">
{
    locals++;
    continue;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/tlb_uv.c.ifdefed" startline="328" endline="336">
{
    if (locals)
        return 0;
    else
        return 1;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/tlb_uv.c.ifdefed" startline="361" endline="409">
{
    struct bau_payload_queue_entry *va_queue_first;
    struct bau_payload_queue_entry *va_queue_last;
    struct bau_payload_queue_entry *msg;
    struct pt_regs *old_regs = set_irq_regs (regs);
    cycles_t time1;
    cycles_t time2;
    int msg_slot;
    int sw_ack_slot;
    int fw;
    int count = 0;
    unsigned long local_pnode;
    ack_APIC_irq ();
    exit_idle ();
    irq_enter ();
    time1 = get_cycles ();
    local_pnode = uv_blade_to_pnode (uv_numa_blade_id ());
    va_queue_first = __get_cpu_var (bau_control).va_queue_first;
    va_queue_last = __get_cpu_var (bau_control).va_queue_last;
    msg = __get_cpu_var (bau_control).bau_msg_head;
    while (msg->sw_ack_vector) {
        count++;
        fw = msg->sw_ack_vector;
        msg_slot = msg - va_queue_first;
        sw_ack_slot = ffs (fw) - 1;
        uv_bau_process_message (msg, msg_slot, sw_ack_slot);
        msg++;
        if (msg > va_queue_last)
            msg = va_queue_first;
        __get_cpu_var (bau_control).bau_msg_head = msg;
    }
    if (!count)
        __get_cpu_var (ptcstats).nomsg++;
    else if (count > 1)
        __get_cpu_var (ptcstats).multmsg++;
    time2 = get_cycles ();
    __get_cpu_var (ptcstats).dflush += (time2 - time1);
    irq_exit ();
    set_irq_regs (old_regs);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/tlb_uv.c.ifdefed" startline="386" endline="398">
{
    count++;
    fw = msg->sw_ack_vector;
    msg_slot = msg - va_queue_first;
    sw_ack_slot = ffs (fw) - 1;
    uv_bau_process_message (msg, msg_slot, sw_ack_slot);
    msg++;
    if (msg > va_queue_last)
        msg = va_queue_first;
    __get_cpu_var (bau_control).bau_msg_head = msg;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/tlb_uv.c.ifdefed" startline="412" endline="430">
{
    int i;
    int blade;
    int last_blade;
    int pnode;
    int cur_cpu = 0;
    unsigned long apicid;
    last_blade = -1;

    for_each_online_node (i) {
        blade = uv_node_to_blade_id (i);
        if (blade == last_blade)
            continue;
        last_blade = blade;
        apicid = per_cpu (x86_cpu_to_apicid, cur_cpu);
        pnode = uv_blade_to_pnode (blade);
        cur_cpu += uv_blade_nr_possible_cpus (i);
    }

}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/tlb_uv.c.ifdefed" startline="421" endline="429">
{
    blade = uv_node_to_blade_id (i);
    if (blade == last_blade)
        continue;
    last_blade = blade;
    apicid = per_cpu (x86_cpu_to_apicid, cur_cpu);
    pnode = uv_blade_to_pnode (blade);
    cur_cpu += uv_blade_nr_possible_cpus (i);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/tlb_uv.c.ifdefed" startline="433" endline="437">
{
    if (*offset < num_possible_cpus ())
        return offset;
    return NULL;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/tlb_uv.c.ifdefed" startline="440" endline="445">
{
    (*offset)++;
    if (*offset < num_possible_cpus ())
        return offset;
    return NULL;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/tlb_uv.c.ifdefed" startline="448" endline="449">
{
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/tlb_uv.c.ifdefed" startline="456" endline="484">
{
    struct ptc_stats *stat;
    int cpu;
    cpu = *(loff_t*) data;
    if (!cpu) {
        seq_printf (file, "# cpu requestor requestee one all sretry dretry ptc_i ");
        seq_printf (file, "sw_ack sflush dflush sok dnomsg dmult starget\n");
    }
    if (cpu < num_possible_cpus () && cpu_online (cpu)) {
        stat = &per_cpu (ptcstats, cpu);
        seq_printf (file, "cpu %d %ld %ld %ld %ld %ld %ld %ld ", cpu, stat -> requestor, stat -> requestee, stat -> onetlb, stat -> alltlb, stat -> s_retry, stat -> d_retry, stat -> ptc_i);
        seq_printf (file, "%lx %ld %ld %ld %ld %ld %ld\n", uv_read_global_mmr64 (uv_blade_to_pnode (uv_cpu_to_blade_id (cpu)), UVH_LB_BAU_INTD_SOFTWARE_ACKNOWLEDGE), stat -> sflush, stat -> dflush, stat -> retriesok, stat -> nomsg, stat -> multmsg, stat -> ntargeted);
    }
    return 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/tlb_uv.c.ifdefed" startline="462" endline="467">
{
    seq_printf (file, "# cpu requestor requestee one all sretry dretry ptc_i ");
    seq_printf (file, "sw_ack sflush dflush sok dnomsg dmult starget\n");
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/tlb_uv.c.ifdefed" startline="468" endline="481">
{
    stat = &per_cpu (ptcstats, cpu);
    seq_printf (file, "cpu %d %ld %ld %ld %ld %ld %ld %ld ", cpu, stat -> requestor, stat -> requestee, stat -> onetlb, stat -> alltlb, stat -> s_retry, stat -> d_retry, stat -> ptc_i);
    seq_printf (file, "%lx %ld %ld %ld %ld %ld %ld\n", uv_read_global_mmr64 (uv_blade_to_pnode (uv_cpu_to_blade_id (cpu)), UVH_LB_BAU_INTD_SOFTWARE_ACKNOWLEDGE), stat -> sflush, stat -> dflush, stat -> retriesok, stat -> nomsg, stat -> multmsg, stat -> ntargeted);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/tlb_uv.c.ifdefed" startline="492" endline="540">
{
    long newmode;
    char optstr [64];
    if (count == 0 || count > sizeof (optstr))
        return -EINVAL;
    if (copy_from_user (optstr, user, count))
        return -EFAULT;
    optstr[count - 1] = '\0';
    if (strict_strtoul (optstr, 10, &newmode) < 0) {
        printk (KERN_DEBUG "%s is invalid\n", optstr);
        return -EINVAL;
    }
    if (newmode == 0) {
        printk (KERN_DEBUG "# cpu:      cpu number\n");
        printk (KERN_DEBUG "requestor:  times this cpu was the flush requestor\n");
        printk (KERN_DEBUG "requestee:  times this cpu was requested to flush its TLBs\n");
        printk (KERN_DEBUG "one:        times requested to flush a single address\n");
        printk (KERN_DEBUG "all:        times requested to flush all TLB's\n");
        printk (KERN_DEBUG "sretry:     number of retries of source-side timeouts\n");
        printk (KERN_DEBUG "dretry:     number of retries of destination-side timeouts\n");
        printk (KERN_DEBUG "ptc_i:      times UV fell through to IPI-style flushes\n");
        printk (KERN_DEBUG "sw_ack:     image of UVH_LB_BAU_INTD_SOFTWARE_ACKNOWLEDGE\n");
        printk (KERN_DEBUG "sflush_us:  cycles spent in uv_flush_tlb_others()\n");
        printk (KERN_DEBUG "dflush_us:  cycles spent in handling flush requests\n");
        printk (KERN_DEBUG "sok:        successes on retry\n");
        printk (KERN_DEBUG "dnomsg:     interrupts with no message\n");
        printk (KERN_DEBUG "dmult:      interrupts with multiple messages\n");
        printk (KERN_DEBUG "starget:    nodes targeted\n");
    }
    else {
        uv_bau_retry_limit = newmode;
        printk (KERN_DEBUG "timeout retry limit:%d\n", uv_bau_retry_limit);
    }
    return count;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/tlb_uv.c.ifdefed" startline="501" endline="504">
{
    printk (KERN_DEBUG "%s is invalid\n", optstr);
    return -EINVAL;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/tlb_uv.c.ifdefed" startline="506" endline="533">
{
    printk (KERN_DEBUG "# cpu:      cpu number\n");
    printk (KERN_DEBUG "requestor:  times this cpu was the flush requestor\n");
    printk (KERN_DEBUG "requestee:  times this cpu was requested to flush its TLBs\n");
    printk (KERN_DEBUG "one:        times requested to flush a single address\n");
    printk (KERN_DEBUG "all:        times requested to flush all TLB's\n");
    printk (KERN_DEBUG "sretry:     number of retries of source-side timeouts\n");
    printk (KERN_DEBUG "dretry:     number of retries of destination-side timeouts\n");
    printk (KERN_DEBUG "ptc_i:      times UV fell through to IPI-style flushes\n");
    printk (KERN_DEBUG "sw_ack:     image of UVH_LB_BAU_INTD_SOFTWARE_ACKNOWLEDGE\n");
    printk (KERN_DEBUG "sflush_us:  cycles spent in uv_flush_tlb_others()\n");
    printk (KERN_DEBUG "dflush_us:  cycles spent in handling flush requests\n");
    printk (KERN_DEBUG "sok:        successes on retry\n");
    printk (KERN_DEBUG "dnomsg:     interrupts with no message\n");
    printk (KERN_DEBUG "dmult:      interrupts with multiple messages\n");
    printk (KERN_DEBUG "starget:    nodes targeted\n");
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/tlb_uv.c.ifdefed" startline="533" endline="537">
{
    uv_bau_retry_limit = newmode;
    printk (KERN_DEBUG "timeout retry limit:%d\n", uv_bau_retry_limit);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/tlb_uv.c.ifdefed" startline="550" endline="552">
{
    return seq_open (file, &uv_ptc_seq_ops);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/tlb_uv.c.ifdefed" startline="563" endline="581">
{
    struct proc_dir_entry *proc_uv_ptc;
    if (!is_uv_system ())
        return 0;
    if (!proc_mkdir ("sgi_uv", NULL))
        return -EINVAL;
    proc_uv_ptc = create_proc_entry (UV_PTC_BASENAME, 0444, NULL);
    if (!proc_uv_ptc) {
        printk (KERN_ERR "unable to create %s proc entry\n", UV_PTC_BASENAME);
        remove_proc_entry ("sgi_uv", NULL);
        return -EINVAL;
    }
    proc_uv_ptc->proc_fops = &proc_uv_ptc_operations;
    return 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/tlb_uv.c.ifdefed" startline="573" endline="578">
{
    printk (KERN_ERR "unable to create %s proc entry\n", UV_PTC_BASENAME);
    remove_proc_entry ("sgi_uv", NULL);
    return -EINVAL;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/tlb_uv.c.ifdefed" startline="587" endline="616">
{
    int i;
    int *ip;
    struct bau_msg_status *msp;
    struct bau_control *bau_tabp;
    bau_tabp = kmalloc_node (sizeof (struct bau_control), GFP_KERNEL, node);
    BUG_ON (! bau_tabp);
    bau_tabp->msg_statuses = kmalloc_node (sizeof (struct bau_msg_status) * DEST_Q_SIZE, GFP_KERNEL, node);
    BUG_ON (! bau_tabp -> msg_statuses);
    for (i = 0, msp = bau_tabp->msg_statuses; i < DEST_Q_SIZE; i++, msp++)
        bau_cpubits_clear (&msp->seen_by, (int) uv_blade_nr_possible_cpus (blade));
    bau_tabp->watching = kmalloc_node (sizeof (int) * DEST_NUM_RESOURCES, GFP_KERNEL, node);
    BUG_ON (! bau_tabp -> watching);
    for (i = 0, ip = bau_tabp->watching; i < DEST_Q_SIZE; i++, ip++)
        *ip = 0;
    uv_bau_table_bases[blade] = bau_tabp;
    return bau_tabp;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/tlb_uv.c.ifdefed" startline="625" endline="639">
{
    struct bau_control *bcp;
    int i;
    for (i = cur_cpu; i < cur_cpu + uv_blade_nr_possible_cpus (blade); i++) {
        bcp = (struct bau_control *) &per_cpu (bau_control, i);
        bcp->bau_msg_head = bau_tablesp->va_queue_first;
        bcp->va_queue_first = bau_tablesp->va_queue_first;
        bcp->va_queue_last = bau_tablesp->va_queue_last;
        bcp->watching = bau_tablesp->watching;
        bcp->msg_statuses = bau_tablesp->msg_statuses;
        bcp->descriptor_base = adp;
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/tlb_uv.c.ifdefed" startline="629" endline="638">
{
    bcp = (struct bau_control *) &per_cpu (bau_control, i);
    bcp->bau_msg_head = bau_tablesp->va_queue_first;
    bcp->va_queue_first = bau_tablesp->va_queue_first;
    bcp->va_queue_last = bau_tablesp->va_queue_last;
    bcp->watching = bau_tablesp->watching;
    bcp->msg_statuses = bau_tablesp->msg_statuses;
    bcp->descriptor_base = adp;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/tlb_uv.c.ifdefed" startline="646" endline="683">
{
    int i;
    unsigned long pa;
    unsigned long m;
    unsigned long n;
    unsigned long mmr_image;
    struct bau_desc *adp;
    struct bau_desc *ad2;
    adp = (struct bau_desc *) kmalloc_node (16384, GFP_KERNEL, node);
    BUG_ON (! adp);
    pa = __pa ((unsigned long) adp);
    n = pa >> uv_nshift;
    m = pa & uv_mmask;
    mmr_image = uv_read_global_mmr64 (pnode, UVH_LB_BAU_SB_DESCRIPTOR_BASE);
    if (mmr_image) {
        uv_write_global_mmr64 (pnode, (unsigned long) UVH_LB_BAU_SB_DESCRIPTOR_BASE, (n << UV_DESC_BASE_PNODE_SHIFT | m));
    }
    for (i = 0, ad2 = adp; i < UV_ACTIVATION_DESCRIPTOR_SIZE; i++, ad2++) {
        memset (ad2, 0, sizeof (struct bau_desc));
        ad2->header.sw_ack_flag = 1;
        ad2->header.base_dest_nodeid = uv_blade_to_pnode (uv_cpu_to_blade_id (0));
        ad2->header.command = UV_NET_ENDPOINT_INTD;
        ad2->header.int_both = 1;
    }
    return adp;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/tlb_uv.c.ifdefed" startline="664" endline="668">
{
    uv_write_global_mmr64 (pnode, (unsigned long) UVH_LB_BAU_SB_DESCRIPTOR_BASE, (n << UV_DESC_BASE_PNODE_SHIFT | m));
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/tlb_uv.c.ifdefed" startline="670" endline="681">
{
    memset (ad2, 0, sizeof (struct bau_desc));
    ad2->header.sw_ack_flag = 1;
    ad2->header.base_dest_nodeid = uv_blade_to_pnode (uv_cpu_to_blade_id (0));
    ad2->header.command = UV_NET_ENDPOINT_INTD;
    ad2->header.int_both = 1;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/tlb_uv.c.ifdefed" startline="690" endline="716">
{
    struct bau_payload_queue_entry *pqp;
    char *cp;
    pqp = (struct bau_payload_queue_entry *) kmalloc_node ((DEST_Q_SIZE + 1) * sizeof (struct bau_payload_queue_entry), GFP_KERNEL, node);
    BUG_ON (! pqp);
    cp = (char *) pqp + 31;
    pqp = (struct bau_payload_queue_entry *) (((unsigned long) cp >> 5) << 5);
    bau_tablesp->va_queue_first = pqp;
    uv_write_global_mmr64 (pnode, UVH_LB_BAU_INTD_PAYLOAD_QUEUE_FIRST, ((unsigned long) pnode << UV_PAYLOADQ_PNODE_SHIFT) | uv_physnodeaddr (pqp));
    uv_write_global_mmr64 (pnode, UVH_LB_BAU_INTD_PAYLOAD_QUEUE_TAIL, uv_physnodeaddr (pqp));
    bau_tablesp->va_queue_last = pqp + (DEST_Q_SIZE - 1);
    uv_write_global_mmr64 (pnode, UVH_LB_BAU_INTD_PAYLOAD_QUEUE_LAST, (unsigned long) uv_physnodeaddr (bau_tablesp -> va_queue_last));
    memset (pqp, 0, sizeof (struct bau_payload_queue_entry) * DEST_Q_SIZE);
    return pqp;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/tlb_uv.c.ifdefed" startline="722" endline="746">
{
    int pnode;
    unsigned long pa;
    unsigned long apicid;
    struct bau_desc *adp;
    struct bau_payload_queue_entry *pqp;
    struct bau_control *bau_tablesp;
    bau_tablesp = uv_table_bases_init (blade, node);
    pnode = uv_blade_to_pnode (blade);
    adp = uv_activation_descriptor_init (node, pnode);
    pqp = uv_payload_queue_init (node, pnode, bau_tablesp);
    uv_table_bases_finish (blade, node, cur_cpu, bau_tablesp, adp);
    apicid = per_cpu (x86_cpu_to_apicid, cur_cpu);
    pa = uv_read_global_mmr64 (pnode, UVH_BAU_DATA_CONFIG);
    if ((pa & 0xff) != UV_BAU_MESSAGE) {
        uv_write_global_mmr64 (pnode, UVH_BAU_DATA_CONFIG, ((apicid << 32) | UV_BAU_MESSAGE));
    }
    return 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/tlb_uv.c.ifdefed" startline="741" endline="744">
{
    uv_write_global_mmr64 (pnode, UVH_BAU_DATA_CONFIG, ((apicid << 32) | UV_BAU_MESSAGE));
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/tlb_uv.c.ifdefed" startline="752" endline="791">
{
    int blade;
    int node;
    int nblades;
    int last_blade;
    int cur_cpu = 0;
    if (!is_uv_system ())
        return 0;
    uv_bau_retry_limit = 1;
    uv_nshift = uv_hub_info->n_val;
    uv_mmask = (1UL << uv_hub_info->n_val) - 1;
    nblades = 0;
    last_blade = -1;

    for_each_online_node (node) {
        blade = uv_node_to_blade_id (node);
        if (blade == last_blade)
            continue;
        last_blade = blade;
        nblades++;
    }

    uv_bau_table_bases = (struct bau_control **) kmalloc (nblades * sizeof (struct bau_control *), GFP_KERNEL);
    BUG_ON (! uv_bau_table_bases);
    last_blade = -1;

    for_each_online_node (node) {
        blade = uv_node_to_blade_id (node);
        if (blade == last_blade)
            continue;
        last_blade = blade;
        uv_init_blade (blade, node, cur_cpu);
        cur_cpu += uv_blade_nr_possible_cpus (blade);
    }

    alloc_intr_gate (UV_BAU_MESSAGE, uv_bau_message_intr1);
    uv_enable_timeouts ();
    return 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/tlb_uv.c.ifdefed" startline="767" endline="773">
{
    blade = uv_node_to_blade_id (node);
    if (blade == last_blade)
        continue;
    last_blade = blade;
    nblades++;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/tlb_uv.c.ifdefed" startline="779" endline="786">
{
    blade = uv_node_to_blade_id (node);
    if (blade == last_blade)
        continue;
    last_blade = blade;
    uv_init_blade (blade, node, cur_cpu);
    cur_cpu += uv_blade_nr_possible_cpus (blade);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/i8253.c.ifdefed" startline="24" endline="24">
{
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/i8253.c.ifdefed" startline="40" endline="73">
{
    spin_lock (& i8253_lock);
    switch (mode) {
    case CLOCK_EVT_MODE_PERIODIC :
        outb_pit (0x34, PIT_MODE);
        outb_pit (LATCH & 0xff, PIT_CH0);
        outb_pit (LATCH >> 8, PIT_CH0);
        break;
    case CLOCK_EVT_MODE_SHUTDOWN :
    case CLOCK_EVT_MODE_UNUSED :
        if (evt->mode == CLOCK_EVT_MODE_PERIODIC || evt->mode == CLOCK_EVT_MODE_ONESHOT) {
            outb_pit (0x30, PIT_MODE);
            outb_pit (0, PIT_CH0);
            outb_pit (0, PIT_CH0);
        }
        pit_disable_clocksource ();
        break;
    case CLOCK_EVT_MODE_ONESHOT :
        pit_disable_clocksource ();
        outb_pit (0x38, PIT_MODE);
        break;
    case CLOCK_EVT_MODE_RESUME :
        break;
    }
    spin_unlock (& i8253_lock);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/i8253.c.ifdefed" startline="43" endline="71">
{
case CLOCK_EVT_MODE_PERIODIC :
    outb_pit (0x34, PIT_MODE);
    outb_pit (LATCH & 0xff, PIT_CH0);
    outb_pit (LATCH >> 8, PIT_CH0);
    break;
case CLOCK_EVT_MODE_SHUTDOWN :
case CLOCK_EVT_MODE_UNUSED :
    if (evt->mode == CLOCK_EVT_MODE_PERIODIC || evt->mode == CLOCK_EVT_MODE_ONESHOT) {
        outb_pit (0x30, PIT_MODE);
        outb_pit (0, PIT_CH0);
        outb_pit (0, PIT_CH0);
    }
    pit_disable_clocksource ();
    break;
case CLOCK_EVT_MODE_ONESHOT :
    pit_disable_clocksource ();
    outb_pit (0x38, PIT_MODE);
    break;
case CLOCK_EVT_MODE_RESUME :
    break;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/i8253.c.ifdefed" startline="54" endline="58">
{
    outb_pit (0x30, PIT_MODE);
    outb_pit (0, PIT_CH0);
    outb_pit (0, PIT_CH0);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/i8253.c.ifdefed" startline="81" endline="88">
{
    spin_lock (& i8253_lock);
    outb_pit (delta & 0xff, PIT_CH0);
    outb_pit (delta >> 8, PIT_CH0);
    spin_unlock (& i8253_lock);
    return 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/i8253.c.ifdefed" startline="112" endline="126">
{
    pit_clockevent.cpumask = cpumask_of_cpu (smp_processor_id ());
    pit_clockevent.mult = div_sc (CLOCK_TICK_RATE, NSEC_PER_SEC, pit_clockevent.shift);
    pit_clockevent.max_delta_ns = clockevent_delta2ns (0x7FFF, &pit_clockevent);
    pit_clockevent.min_delta_ns = clockevent_delta2ns (0xF, &pit_clockevent);
    clockevents_register_device (& pit_clockevent);
    global_clock_event = &pit_clockevent;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/i8253.c.ifdefed" startline="135" endline="193">
{
    unsigned long flags;
    int count;
    u32 jifs;
    static int old_count;
    static u32 old_jifs;
    spin_lock_irqsave (& i8253_lock, flags);
    jifs = jiffies;
    outb_pit (0x00, PIT_MODE);
    count = inb_pit (PIT_CH0);
    count |= inb_pit (PIT_CH0) << 8;
    if (count > LATCH) {
        outb_pit (0x34, PIT_MODE);
        outb_pit (LATCH & 0xff, PIT_CH0);
        outb_pit (LATCH >> 8, PIT_CH0);
        count = LATCH - 1;
    }
    if (count > old_count && jifs == old_jifs) {
        count = old_count;
    }
    old_count = count;
    old_jifs = jifs;
    spin_unlock_irqrestore (& i8253_lock, flags);
    count = (LATCH - 1) - count;
    return (cycle_t) (jifs * LATCH) +count;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/i8253.c.ifdefed" startline="162" endline="167">
{
    outb_pit (0x34, PIT_MODE);
    outb_pit (LATCH & 0xff, PIT_CH0);
    outb_pit (LATCH >> 8, PIT_CH0);
    count = LATCH - 1;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/i8253.c.ifdefed" startline="182" endline="184">
{
    count = old_count;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/i8253.c.ifdefed" startline="205" endline="213">
{
    if (clocksource_pit.mult) {
        clocksource_unregister (& clocksource_pit);
        clocksource_pit.mult = 0;
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/i8253.c.ifdefed" startline="209" endline="212">
{
    clocksource_unregister (& clocksource_pit);
    clocksource_pit.mult = 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/i8253.c.ifdefed" startline="216" endline="231">
{
    if (num_possible_cpus () > 1 || is_hpet_enabled () || pit_clockevent.mode != CLOCK_EVT_MODE_PERIODIC)
        return 0;
    clocksource_pit.mult = clocksource_hz2mult (CLOCK_TICK_RATE, clocksource_pit.shift);
    return clocksource_register (&clocksource_pit);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/genapic_flat_64.c.ifdefed" startline="23" endline="25">
{
    return cpu_online_map;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/genapic_flat_64.c.ifdefed" startline="28" endline="39">
{
    cpumask_t domain = {{
            [0] = APIC_ALL_CPUS,
        }
    };
    return domain;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/genapic_flat_64.c.ifdefed" startline="49" endline="59">
{
    unsigned long val;
    unsigned long num, id;
    num = smp_processor_id ();
    id = 1UL << num;
    apic_write (APIC_DFR, APIC_DFR_FLAT);
    val = apic_read (APIC_LDR) & ~APIC_LDR_MASK;
    val |= SET_APIC_LOGICAL_ID (id);
    apic_write (APIC_LDR, val);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/genapic_flat_64.c.ifdefed" startline="62" endline="69">
{
    unsigned long mask = cpus_addr (cpumask)[0];
    unsigned long flags;
    local_irq_save (flags);
    __send_IPI_dest_field (mask, vector, APIC_DEST_LOGICAL);
    local_irq_restore (flags);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/genapic_flat_64.c.ifdefed" startline="72" endline="88">
{
    int hotplug = 0;
    if (hotplug || vector == NMI_VECTOR) {
        cpumask_t allbutme = cpu_online_map;
        cpu_clear (smp_processor_id (), allbutme);
        if (!cpus_empty (allbutme))
            flat_send_IPI_mask (allbutme, vector);
    }
    else if (num_online_cpus () > 1) {
        __send_IPI_shortcut (APIC_DEST_ALLBUT, vector, APIC_DEST_LOGICAL);
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/genapic_flat_64.c.ifdefed" startline="78" endline="85">
{
    cpumask_t allbutme = cpu_online_map;
    cpu_clear (smp_processor_id (), allbutme);
    if (!cpus_empty (allbutme))
        flat_send_IPI_mask (allbutme, vector);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/genapic_flat_64.c.ifdefed" startline="85" endline="87">
{
    __send_IPI_shortcut (APIC_DEST_ALLBUT, vector, APIC_DEST_LOGICAL);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/genapic_flat_64.c.ifdefed" startline="91" endline="96">
{
    if (vector == NMI_VECTOR)
        flat_send_IPI_mask (cpu_online_map, vector);
    else
        __send_IPI_shortcut (APIC_DEST_ALLINC, vector, APIC_DEST_LOGICAL);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/genapic_flat_64.c.ifdefed" startline="99" endline="101">
{
    return physid_isset (GET_APIC_ID (read_apic_id ()), phys_cpu_present_map);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/genapic_flat_64.c.ifdefed" startline="104" endline="106">
{
    return cpus_addr (cpumask)[0] & APIC_ALL_CPUS;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/genapic_flat_64.c.ifdefed" startline="109" endline="111">
{
    return hard_smp_processor_id () >> index_msb;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/genapic_flat_64.c.ifdefed" startline="135" endline="137">
{
    return cpu_online_map;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/genapic_flat_64.c.ifdefed" startline="140" endline="142">
{
    return cpumask_of_cpu (cpu);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/genapic_flat_64.c.ifdefed" startline="145" endline="147">
{
    send_IPI_mask_sequence (cpumask, vector);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/genapic_flat_64.c.ifdefed" startline="150" endline="155">
{
    cpumask_t allbutme = cpu_online_map;
    cpu_clear (smp_processor_id (), allbutme);
    physflat_send_IPI_mask (allbutme, vector);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/genapic_flat_64.c.ifdefed" startline="158" endline="160">
{
    physflat_send_IPI_mask (cpu_online_map, vector);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/genapic_flat_64.c.ifdefed" startline="163" endline="175">
{
    int cpu;
    cpu = first_cpu (cpumask);
    if ((unsigned) cpu < nr_cpu_ids)
        return per_cpu (x86_cpu_to_apicid, cpu);
    else
        return BAD_APICID;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/ds.c.ifdefed" startline="115" endline="117">
{
    return *(unsignedlong*) (base + ds_cfg.bts_buffer_base.offset);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/ds.c.ifdefed" startline="119" endline="121">
{
    (*(unsignedlong*) (base + ds_cfg.bts_buffer_base.offset)) = value;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/ds.c.ifdefed" startline="123" endline="125">
{
    return *(unsignedlong*) (base + ds_cfg.bts_index.offset);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/ds.c.ifdefed" startline="127" endline="129">
{
    (*(unsignedlong*) (base + ds_cfg.bts_index.offset)) = value;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/ds.c.ifdefed" startline="131" endline="133">
{
    return *(unsignedlong*) (base + ds_cfg.bts_absolute_maximum.offset);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/ds.c.ifdefed" startline="135" endline="137">
{
    (*(unsignedlong*) (base + ds_cfg.bts_absolute_maximum.offset)) = value;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/ds.c.ifdefed" startline="139" endline="141">
{
    return *(unsignedlong*) (base + ds_cfg.bts_interrupt_threshold.offset);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/ds.c.ifdefed" startline="143" endline="145">
{
    (*(unsignedlong*) (base + ds_cfg.bts_interrupt_threshold.offset)) = value;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/ds.c.ifdefed" startline="147" endline="149">
{
    return *(unsignedlong*) (base + ds_cfg.from_ip.offset);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/ds.c.ifdefed" startline="151" endline="153">
{
    (*(unsignedlong*) (base + ds_cfg.from_ip.offset)) = value;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/ds.c.ifdefed" startline="155" endline="157">
{
    return *(unsignedlong*) (base + ds_cfg.to_ip.offset);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/ds.c.ifdefed" startline="159" endline="161">
{
    (*(unsignedlong*) (base + ds_cfg.to_ip.offset)) = value;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/ds.c.ifdefed" startline="163" endline="165">
{
    return *(unsignedchar*) (base + ds_cfg.info_type.offset);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/ds.c.ifdefed" startline="167" endline="169">
{
    (*(unsignedchar*) (base + ds_cfg.info_type.offset)) = value;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/ds.c.ifdefed" startline="171" endline="173">
{
    return *(unsignedlong*) (base + ds_cfg.info_data.offset);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/ds.c.ifdefed" startline="175" endline="177">
{
    (*(unsignedlong*) (base + ds_cfg.info_data.offset)) = value;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/ds.c.ifdefed" startline="181" endline="219">
{
    size_t bts_size_in_records;
    unsigned long bts;
    void *ds;
    if (!ds_cfg.sizeof_ds || !ds_cfg.sizeof_bts)
        return -EOPNOTSUPP;
    if (bts_size_in_bytes < 0)
        return -EINVAL;
    bts_size_in_records = bts_size_in_bytes / ds_cfg.sizeof_bts;
    bts_size_in_bytes = bts_size_in_records * ds_cfg.sizeof_bts;
    if (bts_size_in_bytes <= 0)
        return -EINVAL;
    bts = (unsigned long) kzalloc (bts_size_in_bytes, GFP_KERNEL);
    if (!bts)
        return -ENOMEM;
    ds = kzalloc (ds_cfg.sizeof_ds, GFP_KERNEL);
    if (!ds) {
        kfree ((void *) bts);
        return -ENOMEM;
    }
    set_bts_buffer_base (ds, bts);
    set_bts_index (ds, bts);
    set_bts_absolute_maximum (ds, bts + bts_size_in_bytes);
    set_bts_interrupt_threshold (ds, bts + bts_size_in_bytes + 1);
    *dsp = ds;
    return 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/ds.c.ifdefed" startline="207" endline="210">
{
    kfree ((void *) bts);
    return -ENOMEM;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/ds.c.ifdefed" startline="222" endline="229">
{
    if (*dsp) {
        kfree ((void *) get_bts_buffer_base (* dsp));
        kfree (*dsp);
        *dsp = NULL;
    }
    return 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/ds.c.ifdefed" startline="223" endline="227">
{
    kfree ((void *) get_bts_buffer_base (* dsp));
    kfree (*dsp);
    *dsp = NULL;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/ds.c.ifdefed" startline="232" endline="245">
{
    int size_in_bytes;
    if (!ds_cfg.sizeof_ds || !ds_cfg.sizeof_bts)
        return -EOPNOTSUPP;
    if (!ds)
        return 0;
    size_in_bytes = get_bts_absolute_maximum (ds) - get_bts_buffer_base (ds);
    return size_in_bytes;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/ds.c.ifdefed" startline="248" endline="255">
{
    int size_in_bytes = ds_get_bts_size (ds);
    if (size_in_bytes <= 0)
        return size_in_bytes;
    return size_in_bytes / ds_cfg.sizeof_bts;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/ds.c.ifdefed" startline="258" endline="269">
{
    int index_offset_in_bytes;
    if (!ds_cfg.sizeof_ds || !ds_cfg.sizeof_bts)
        return -EOPNOTSUPP;
    index_offset_in_bytes = get_bts_index (ds) - get_bts_buffer_base (ds);
    return index_offset_in_bytes / ds_cfg.sizeof_bts;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/ds.c.ifdefed" startline="272" endline="281">
{
    switch (method) {
    case DS_O_SIGNAL :
        return -EOPNOTSUPP;
    case DS_O_WRAP :
        return 0;
    default :
        return -EINVAL;
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/ds.c.ifdefed" startline="273" endline="280">
{
case DS_O_SIGNAL :
    return -EOPNOTSUPP;
case DS_O_WRAP :
    return 0;
default :
    return -EINVAL;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/ds.c.ifdefed" startline="284" endline="286">
{
    return DS_O_WRAP;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/ds.c.ifdefed" startline="289" endline="301">
{
    int bts_size = ds_get_bts_size (ds);
    unsigned long bts_base;
    if (bts_size <= 0)
        return bts_size;
    bts_base = get_bts_buffer_base (ds);
    memset ((void *) bts_base, 0, bts_size);
    set_bts_index (ds, bts_base);
    return 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/ds.c.ifdefed" startline="304" endline="329">
{
    void *bts;
    if (!ds_cfg.sizeof_ds || !ds_cfg.sizeof_bts)
        return -EOPNOTSUPP;
    if (index < 0)
        return -EINVAL;
    if (index >= ds_get_bts_size (ds))
        return -EINVAL;
    bts = (void *) (get_bts_buffer_base (ds) + (index * ds_cfg.sizeof_bts));
    memset (out, 0, sizeof (* out));
    if (get_from_ip (bts) == BTS_ESCAPE_ADDRESS) {
        out->qualifier = get_info_type (bts);
        out->variant.jiffies = get_info_data (bts);
    }
    else {
        out->qualifier = BTS_BRANCH;
        out->variant.lbr.from_ip = get_from_ip (bts);
        out->variant.lbr.to_ip = get_to_ip (bts);
    }
    return sizeof (*out);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/ds.c.ifdefed" startline="319" endline="322">
{
    out->qualifier = get_info_type (bts);
    out->variant.jiffies = get_info_data (bts);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/ds.c.ifdefed" startline="322" endline="326">
{
    out->qualifier = BTS_BRANCH;
    out->variant.lbr.from_ip = get_from_ip (bts);
    out->variant.lbr.to_ip = get_to_ip (bts);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/ds.c.ifdefed" startline="332" endline="370">
{
    unsigned long bts;
    if (!ds_cfg.sizeof_ds || !ds_cfg.sizeof_bts)
        return -EOPNOTSUPP;
    if (ds_get_bts_size (ds) <= 0)
        return -ENXIO;
    bts = get_bts_index (ds);
    memset ((void *) bts, 0, ds_cfg.sizeof_bts);
    switch (in->qualifier) {
    case BTS_INVALID :
        break;
    case BTS_BRANCH :
        set_from_ip ((void *) bts, in->variant.lbr.from_ip);
        set_to_ip ((void *) bts, in -> variant.lbr.to_ip);
        break;
    case BTS_TASK_ARRIVES :
    case BTS_TASK_DEPARTS :
        set_from_ip ((void *) bts, BTS_ESCAPE_ADDRESS);
        set_info_type ((void *) bts, in -> qualifier);
        set_info_data ((void *) bts, in -> variant.jiffies);
        break;
    default :
        return -EINVAL;
    }
    bts = bts + ds_cfg.sizeof_bts;
    if (bts >= get_bts_absolute_maximum (ds))
        bts = get_bts_buffer_base (ds);
    set_bts_index (ds, bts);
    return ds_cfg.sizeof_bts;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/ds.c.ifdefed" startline="344" endline="362">
{
case BTS_INVALID :
    break;
case BTS_BRANCH :
    set_from_ip ((void *) bts, in->variant.lbr.from_ip);
    set_to_ip ((void *) bts, in -> variant.lbr.to_ip);
    break;
case BTS_TASK_ARRIVES :
case BTS_TASK_DEPARTS :
    set_from_ip ((void *) bts, BTS_ESCAPE_ADDRESS);
    set_info_type ((void *) bts, in -> qualifier);
    set_info_data ((void *) bts, in -> variant.jiffies);
    break;
default :
    return -EINVAL;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/ds.c.ifdefed" startline="373" endline="375">
{
    return ds_cfg.debugctl_mask;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/ds.c.ifdefed" startline="423" endline="425">
{
    ds_cfg = *cfg;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/ds.c.ifdefed" startline="428" endline="464">
{
    switch (c->x86) {
    case 0x6 :
        switch (c->x86_model) {
        case 0xF :
            ds_configure (&ds_cfg_core2);
            break;
        default :
            break;
        }
        break;
    case 0xF :
        switch (c->x86_model) {
        default :
            break;
        }
        break;
    default :
        break;
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/ds.c.ifdefed" startline="429" endline="463">
{
case 0x6 :
    switch (c->x86_model) {
    case 0xF :
        ds_configure (&ds_cfg_core2);
        break;
    default :
        break;
    }
    break;
case 0xF :
    switch (c->x86_model) {
    default :
        break;
    }
    break;
default :
    break;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/ds.c.ifdefed" startline="431" endline="444">
{
case 0xF :
    ds_configure (&ds_cfg_core2);
    break;
default :
    break;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/ds.c.ifdefed" startline="447" endline="458">
{
default :
    break;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/pci-swiotlb_64.c.ifdefed" startline="17" endline="19">
{
    return swiotlb_map_single (hwdev, phys_to_virt (paddr), size, direction);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/pci-swiotlb_64.c.ifdefed" startline="39" endline="50">
{
    if (!iommu_detected && !no_iommu && max_pfn > MAX_DMA32_PFN)
        swiotlb = 1;
    if (swiotlb_force)
        swiotlb = 1;
    if (swiotlb) {
        printk (KERN_INFO "PCI-DMA: Using software bounce buffering for IO (SWIOTLB)\n");
        swiotlb_init ();
        dma_ops = &swiotlb_dma_ops;
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/pci-swiotlb_64.c.ifdefed" startline="45" endline="49">
{
    printk (KERN_INFO "PCI-DMA: Using software bounce buffering for IO (SWIOTLB)\n");
    swiotlb_init ();
    dma_ops = &swiotlb_dma_ops;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/rtc.c.ifdefed" startline="40" endline="95">
{
    int retval = 0;
    int real_seconds, real_minutes, cmos_minutes;
    unsigned char save_control, save_freq_select;
    save_control = CMOS_READ (RTC_CONTROL);
    CMOS_WRITE ((save_control | RTC_SET), RTC_CONTROL);
    save_freq_select = CMOS_READ (RTC_FREQ_SELECT);
    CMOS_WRITE ((save_freq_select | RTC_DIV_RESET2), RTC_FREQ_SELECT);
    cmos_minutes = CMOS_READ (RTC_MINUTES);
    if (!(save_control & RTC_DM_BINARY) || RTC_ALWAYS_BCD)
        BCD_TO_BIN (cmos_minutes);
    real_seconds = nowtime % 60;
    real_minutes = nowtime / 60;
    if (((abs (real_minutes -cmos_minutes) + 15) / 30) & 1)
        real_minutes += 30;
    real_minutes %= 60;
    if (abs (real_minutes -cmos_minutes) < 30) {
        if (!(save_control & RTC_DM_BINARY) || RTC_ALWAYS_BCD) {
            BIN_TO_BCD (real_seconds);
            BIN_TO_BCD (real_minutes);
        }
        CMOS_WRITE (real_seconds, RTC_SECONDS);
        CMOS_WRITE (real_minutes, RTC_MINUTES);
    }
    else {
        printk (KERN_WARNING "set_rtc_mmss: can't update from %d to %d\n", cmos_minutes, real_minutes);
        retval = -1;
    }
    CMOS_WRITE (save_control, RTC_CONTROL);
    CMOS_WRITE (save_freq_select, RTC_FREQ_SELECT);
    return retval;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/rtc.c.ifdefed" startline="70" endline="77">
{
    if (!(save_control & RTC_DM_BINARY) || RTC_ALWAYS_BCD) {
        BIN_TO_BCD (real_seconds);
        BIN_TO_BCD (real_minutes);
    }
    CMOS_WRITE (real_seconds, RTC_SECONDS);
    CMOS_WRITE (real_minutes, RTC_MINUTES);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/rtc.c.ifdefed" startline="71" endline="74">
{
    BIN_TO_BCD (real_seconds);
    BIN_TO_BCD (real_minutes);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/rtc.c.ifdefed" startline="77" endline="82">
{
    printk (KERN_WARNING "set_rtc_mmss: can't update from %d to %d\n", cmos_minutes, real_minutes);
    retval = -1;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/rtc.c.ifdefed" startline="98" endline="143">
{
    unsigned int status, year, mon, day, hour, min, sec, century = 0;
    while ((CMOS_READ (RTC_FREQ_SELECT) & RTC_UIP))
        cpu_relax ();
    sec = CMOS_READ (RTC_SECONDS);
    min = CMOS_READ (RTC_MINUTES);
    hour = CMOS_READ (RTC_HOURS);
    day = CMOS_READ (RTC_DAY_OF_MONTH);
    mon = CMOS_READ (RTC_MONTH);
    year = CMOS_READ (RTC_YEAR);
    status = CMOS_READ (RTC_CONTROL);
    WARN_ON_ONCE (RTC_ALWAYS_BCD && (status & RTC_DM_BINARY));
    if (RTC_ALWAYS_BCD || !(status & RTC_DM_BINARY)) {
        BCD_TO_BIN (sec);
        BCD_TO_BIN (min);
        BCD_TO_BIN (hour);
        BCD_TO_BIN (day);
        BCD_TO_BIN (mon);
        BCD_TO_BIN (year);
    }
    if (century) {
        BCD_TO_BIN (century);
        year += century * 100;
        printk (KERN_INFO "Extended CMOS year: %d\n", century * 100);
    }
    else
        year += CMOS_YEARS_OFFS;
    return mktime (year, mon, day, hour, min, sec);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/rtc.c.ifdefed" startline="126" endline="133">
{
    BCD_TO_BIN (sec);
    BCD_TO_BIN (min);
    BCD_TO_BIN (hour);
    BCD_TO_BIN (day);
    BCD_TO_BIN (mon);
    BCD_TO_BIN (year);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/rtc.c.ifdefed" startline="135" endline="139">
{
    BCD_TO_BIN (century);
    year += century * 100;
    printk (KERN_INFO "Extended CMOS year: %d\n", century * 100);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/rtc.c.ifdefed" startline="147" endline="155">
{
    unsigned char val;
    lock_cmos_prefix (addr);
    outb (addr, RTC_PORT (0));
    val = inb (RTC_PORT (1));
    lock_cmos_suffix (addr);
    return val;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/rtc.c.ifdefed" startline="159" endline="164">
{
    lock_cmos_prefix (addr);
    outb (addr, RTC_PORT (0));
    outb (val, RTC_PORT (1));
    lock_cmos_suffix (addr);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/rtc.c.ifdefed" startline="168" endline="177">
{
    int retval;
    unsigned long flags;
    spin_lock_irqsave (& rtc_lock, flags);
    retval = set_wallclock (nowtime);
    spin_unlock_irqrestore (& rtc_lock, flags);
    return retval;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/rtc.c.ifdefed" startline="181" endline="189">
{
    unsigned long retval, flags;
    spin_lock_irqsave (& rtc_lock, flags);
    retval = get_wallclock ();
    spin_unlock_irqrestore (& rtc_lock, flags);
    return retval;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/rtc.c.ifdefed" startline="192" endline="194">
{
    return set_rtc_mmss (now.tv_sec);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/rtc.c.ifdefed" startline="197" endline="199">
{
    return __native_read_tsc ();
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/rtc.c.ifdefed" startline="224" endline="232">
{
    platform_device_register (& rtc_device);
    return 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/sys_x86_64.c.ifdefed" startline="22" endline="46">
{
    long error;
    struct file *file;
    error = -EINVAL;
    if (off & ~PAGE_MASK)
        goto out;
    error = -EBADF;
    file = NULL;
    flags &= ~(MAP_EXECUTABLE | MAP_DENYWRITE);
    if (!(flags & MAP_ANONYMOUS)) {
        file = fget (fd);
        if (!file)
            goto out;
    }
    down_write (& current -> mm -> mmap_sem);
    error = do_mmap_pgoff (file, addr, len, prot, flags, off >> PAGE_SHIFT);
    up_write (& current -> mm -> mmap_sem);
    if (file)
        fput (file);
out :
    return error;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/sys_x86_64.c.ifdefed" startline="33" endline="37">
{
    file = fget (fd);
    if (!file)
        goto out;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/sys_x86_64.c.ifdefed" startline="50" endline="71">
{
    if (!test_thread_flag (TIF_IA32) && (flags & MAP_32BIT)) {
        unsigned long new_begin;
        *begin = 0x40000000;
        *end = 0x80000000;
        if (current->flags & PF_RANDOMIZE) {
            new_begin = randomize_range (*begin, *begin + 0x02000000, 0);
            if (new_begin)
                *begin = new_begin;
        }
    }
    else {
        *begin = TASK_UNMAPPED_BASE;
        *end = TASK_SIZE;
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/sys_x86_64.c.ifdefed" startline="51" endline="67">
{
    unsigned long new_begin;
    *begin = 0x40000000;
    *end = 0x80000000;
    if (current->flags & PF_RANDOMIZE) {
        new_begin = randomize_range (*begin, *begin + 0x02000000, 0);
        if (new_begin)
            *begin = new_begin;
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/sys_x86_64.c.ifdefed" startline="62" endline="66">
{
    new_begin = randomize_range (*begin, *begin + 0x02000000, 0);
    if (new_begin)
        *begin = new_begin;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/sys_x86_64.c.ifdefed" startline="67" endline="70">
{
    *begin = TASK_UNMAPPED_BASE;
    *end = TASK_SIZE;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/sys_x86_64.c.ifdefed" startline="76" endline="134">
{
    struct mm_struct *mm = current->mm;
    struct vm_area_struct *vma;
    unsigned long start_addr;
    unsigned long begin, end;
    if (flags & MAP_FIXED)
        return addr;
    find_start_end (flags, & begin, & end);
    if (len > end)
        return -ENOMEM;
    if (addr) {
        addr = PAGE_ALIGN (addr);
        vma = find_vma (mm, addr);
        if (end - len >= addr && (!vma || addr + len <= vma->vm_start))
            return addr;
    }
    if (((flags & MAP_32BIT) || test_thread_flag (TIF_IA32)) && len <= mm->cached_hole_size) {
        mm->cached_hole_size = 0;
        mm->free_area_cache = begin;
    }
    addr = mm->free_area_cache;
    if (addr < begin)
        addr = begin;
    start_addr = addr;
full_search :
    for (vma = find_vma (mm, addr);; vma = vma->vm_next) {
        if (end - len < addr) {
            if (start_addr != begin) {
                start_addr = addr = begin;
                mm->cached_hole_size = 0;
                goto full_search;
            }
            return -ENOMEM;
        }
        if (!vma || addr + len <= vma->vm_start) {
            mm->free_area_cache = addr + len;
            return addr;
        }
        if (addr + mm->cached_hole_size < vma->vm_start)
            mm->cached_hole_size = vma->vm_start - addr;
        addr = vma->vm_end;
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/sys_x86_64.c.ifdefed" startline="90" endline="96">
{
    addr = PAGE_ALIGN (addr);
    vma = find_vma (mm, addr);
    if (end - len >= addr && (!vma || addr + len <= vma->vm_start))
        return addr;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/sys_x86_64.c.ifdefed" startline="98" endline="101">
{
    mm->cached_hole_size = 0;
    mm->free_area_cache = begin;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/sys_x86_64.c.ifdefed" startline="108" endline="133">
{
    if (end - len < addr) {
        if (start_addr != begin) {
            start_addr = addr = begin;
            mm->cached_hole_size = 0;
            goto full_search;
        }
        return -ENOMEM;
    }
    if (!vma || addr + len <= vma->vm_start) {
        mm->free_area_cache = addr + len;
        return addr;
    }
    if (addr + mm->cached_hole_size < vma->vm_start)
        mm->cached_hole_size = vma->vm_start - addr;
    addr = vma->vm_end;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/sys_x86_64.c.ifdefed" startline="110" endline="121">
{
    if (start_addr != begin) {
        start_addr = addr = begin;
        mm->cached_hole_size = 0;
        goto full_search;
    }
    return -ENOMEM;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/sys_x86_64.c.ifdefed" startline="115" endline="119">
{
    start_addr = addr = begin;
    mm->cached_hole_size = 0;
    goto full_search;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/sys_x86_64.c.ifdefed" startline="122" endline="128">
{
    mm->free_area_cache = addr + len;
    return addr;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/sys_x86_64.c.ifdefed" startline="141" endline="224">
{
    struct vm_area_struct *vma;
    struct mm_struct *mm = current->mm;
    unsigned long addr = addr0;
    if (len > TASK_SIZE)
        return -ENOMEM;
    if (flags & MAP_FIXED)
        return addr;
    if (!test_thread_flag (TIF_IA32) && (flags & MAP_32BIT))
        goto bottomup;
    if (addr) {
        addr = PAGE_ALIGN (addr);
        vma = find_vma (mm, addr);
        if (TASK_SIZE - len >= addr && (!vma || addr + len <= vma->vm_start))
            return addr;
    }
    if (len <= mm->cached_hole_size) {
        mm->cached_hole_size = 0;
        mm->free_area_cache = mm->mmap_base;
    }
    addr = mm->free_area_cache;
    if (addr > len) {
        vma = find_vma (mm, addr -len);
        if (!vma || addr <= vma->vm_start)
            return (mm->free_area_cache = addr - len);
    }
    if (mm->mmap_base < len)
        goto bottomup;
    addr = mm->mmap_base - len;
    do {
        vma = find_vma (mm, addr);
        if (!vma || addr + len <= vma->vm_start)
            return (mm->free_area_cache = addr);
        if (addr + mm->cached_hole_size < vma->vm_start)
            mm->cached_hole_size = vma->vm_start - addr;
        addr = vma->vm_start - len;
    }
    while (len < vma->vm_start);
bottomup :
    mm->cached_hole_size = ~0UL;
    mm->free_area_cache = TASK_UNMAPPED_BASE;
    addr = arch_get_unmapped_area (filp, addr0, len, pgoff, flags);
    mm->free_area_cache = mm->mmap_base;
    mm->cached_hole_size = ~0UL;
    return addr;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/sys_x86_64.c.ifdefed" startline="158" endline="164">
{
    addr = PAGE_ALIGN (addr);
    vma = find_vma (mm, addr);
    if (TASK_SIZE - len >= addr && (!vma || addr + len <= vma->vm_start))
        return addr;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/sys_x86_64.c.ifdefed" startline="167" endline="170">
{
    mm->cached_hole_size = 0;
    mm->free_area_cache = mm->mmap_base;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/sys_x86_64.c.ifdefed" startline="176" endline="181">
{
    vma = find_vma (mm, addr -len);
    if (!vma || addr <= vma->vm_start)
        return (mm->free_area_cache = addr - len);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/sys_x86_64.c.ifdefed" startline="188" endline="205">
{
    vma = find_vma (mm, addr);
    if (!vma || addr + len <= vma->vm_start)
        return (mm->free_area_cache = addr);
    if (addr + mm->cached_hole_size < vma->vm_start)
        mm->cached_hole_size = vma->vm_start - addr;
    addr = vma->vm_start - len;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/sys_x86_64.c.ifdefed" startline="228" endline="236">
{
    int err;
    down_read (& uts_sem);
    err = copy_to_user (name, utsname (), sizeof (*name));
    up_read (& uts_sem);
    if (personality (current->personality) == PER_LINUX32)
        err |= copy_to_user (&name->machine, "i686", 5);
    return err ? -EFAULT : 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/pmtimer_64.c.ifdefed" startline="30" endline="40">
{
    cycles *= 286;
    return (cycles >> 10);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/pmtimer_64.c.ifdefed" startline="43" endline="50">
{
    u32 a, b;
    for (a = b = inl (pmtmr_ioport) & ACPI_PM_MASK; a == b; b = inl (pmtmr_ioport) & ACPI_PM_MASK)
        cpu_relax ();
    return b;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/pmtimer_64.c.ifdefed" startline="54" endline="61">
{
    u32 a, b;
    a = pmtimer_wait_tick ();
    do {
        b = inl (pmtmr_ioport);
        cpu_relax ();
    }
    while (cyc2us (b -a) < us);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/pmtimer_64.c.ifdefed" startline="57" endline="60">
{
    b = inl (pmtmr_ioport);
    cpu_relax ();
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/pmtimer_64.c.ifdefed" startline="64" endline="67">
{
    pmtmr_ioport = 0;
    return 1;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/traps_64.c.ifdefed" startline="65" endline="68">
{
    if (regs->flags & X86_EFLAGS_IF)
        local_irq_enable ();
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/traps_64.c.ifdefed" startline="71" endline="75">
{
    inc_preempt_count ();
    if (regs->flags & X86_EFLAGS_IF)
        local_irq_enable ();
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/traps_64.c.ifdefed" startline="78" endline="84">
{
    if (regs->flags & X86_EFLAGS_IF)
        local_irq_disable ();
    dec_preempt_count ();
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/traps_64.c.ifdefed" startline="87" endline="89">
{
    printk (" [<%016lx>] %s%pS\n", address, reliable ? "" : "? ", (void *) address);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/traps_64.c.ifdefed" startline="93" endline="163">
{
    static char ids [] [8] = {
        [DEBUG_STACK - 1] = "#DB",
        [NMI_STACK - 1] = "NMI",
        [DOUBLEFAULT_STACK - 1] = "#DF",
        [STACKFAULT_STACK - 1] = "#SS",
        [MCE_STACK - 1] = "#MC",
    };
    unsigned k;
    for (k = 0; k < N_EXCEPTION_STACKS; k++) {
        unsigned long end = per_cpu (orig_ist, cpu).ist[k];
        if (stack >= end)
            continue;
        if (stack >= end - EXCEPTION_STKSZ) {
            if (*usedp & (1U << k))
                break;
            *usedp |= 1U << k;
            *idp = ids[k];
            return (unsigned long *) end;
        }
    }
    return NULL;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/traps_64.c.ifdefed" startline="110" endline="161">
{
    unsigned long end = per_cpu (orig_ist, cpu).ist[k];
    if (stack >= end)
        continue;
    if (stack >= end - EXCEPTION_STKSZ) {
        if (*usedp & (1U << k))
            break;
        *usedp |= 1U << k;
        *idp = ids[k];
        return (unsigned long *) end;
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/traps_64.c.ifdefed" startline="122" endline="134">
{
    if (*usedp & (1U << k))
        break;
    *usedp |= 1U << k;
    *idp = ids[k];
    return (unsigned long *) end;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/traps_64.c.ifdefed" startline="174" endline="183">
{
    void *t = tinfo;
    if (end) {
        if (p < end && p >= (end - THREAD_SIZE))
            return 1;
        else
            return 0;
    }
    return p > t && p < t + THREAD_SIZE - size;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/traps_64.c.ifdefed" startline="176" endline="181">
{
    if (p < end && p >= (end - THREAD_SIZE))
        return 1;
    else
        return 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/traps_64.c.ifdefed" startline="196" endline="215">
{
    struct stack_frame *frame = (struct stack_frame *) bp;
    while (valid_stack_ptr (tinfo, stack, sizeof (*stack), end)) {
        unsigned long addr;
        addr = *stack;
        if (__kernel_text_address (addr)) {
            if ((unsigned long) stack == bp + 8) {
                ops->address (data, addr, 1);
                frame = frame->next_frame;
                bp = (unsigned long) frame;
            }
            else {
                ops->address (data, addr, bp == 0);
            }
        }
        stack++;
    }
    return bp;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/traps_64.c.ifdefed" startline="199" endline="213">
{
    unsigned long addr;
    addr = *stack;
    if (__kernel_text_address (addr)) {
        if ((unsigned long) stack == bp + 8) {
            ops->address (data, addr, 1);
            frame = frame->next_frame;
            bp = (unsigned long) frame;
        }
        else {
            ops->address (data, addr, bp == 0);
        }
    }
    stack++;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/traps_64.c.ifdefed" startline="203" endline="211">
{
    if ((unsigned long) stack == bp + 8) {
        ops->address (data, addr, 1);
        frame = frame->next_frame;
        bp = (unsigned long) frame;
    }
    else {
        ops->address (data, addr, bp == 0);
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/traps_64.c.ifdefed" startline="204" endline="208">
{
    ops->address (data, addr, 1);
    frame = frame->next_frame;
    bp = (unsigned long) frame;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/traps_64.c.ifdefed" startline="208" endline="210">
{
    ops->address (data, addr, bp == 0);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/traps_64.c.ifdefed" startline="220" endline="304">
{
    const unsigned cpu = get_cpu ();
    unsigned long *irqstack_end = (unsigned long *) cpu_pda (cpu)->irqstackptr;
    unsigned used = 0;
    struct thread_info *tinfo;
    if (!task)
        task = current;
    if (!stack) {
        unsigned long dummy;
        stack = &dummy;
        if (task && task != current)
            stack = (unsigned long *) task->thread.sp;
    }
    tinfo = task_thread_info (task);
    for (;;) {
        char *id;
        unsigned long *estack_end;
        estack_end = in_exception_stack (cpu, (unsigned long) stack, &used, &id);
        if (estack_end) {
            if (ops->stack (data, id) < 0)
                break;
            bp = print_context_stack (tinfo, stack, bp, ops, data, estack_end);
            ops->stack (data, "<EOE>");
            stack = (unsigned long *) estack_end[-2];
            continue;
        }
        if (irqstack_end) {
            unsigned long *irqstack;
            irqstack = irqstack_end - (IRQSTACKSIZE - 64) / sizeof (*irqstack);
            if (stack >= irqstack && stack < irqstack_end) {
                if (ops->stack (data, "IRQ") < 0)
                    break;
                bp = print_context_stack (tinfo, stack, bp, ops, data, irqstack_end);
                stack = (unsigned long *) (irqstack_end[-1]);
                irqstack_end = NULL;
                ops->stack (data, "EOI");
                continue;
            }
        }
        break;
    }
    bp = print_context_stack (tinfo, stack, bp, ops, data, NULL);
    put_cpu ();
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/traps_64.c.ifdefed" startline="229" endline="234">
{
    unsigned long dummy;
    stack = &dummy;
    if (task && task != current)
        stack = (unsigned long *) task->thread.sp;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/traps_64.c.ifdefed" startline="254" endline="297">
{
    char *id;
    unsigned long *estack_end;
    estack_end = in_exception_stack (cpu, (unsigned long) stack, &used, &id);
    if (estack_end) {
        if (ops->stack (data, id) < 0)
            break;
        bp = print_context_stack (tinfo, stack, bp, ops, data, estack_end);
        ops->stack (data, "<EOE>");
        stack = (unsigned long *) estack_end[-2];
        continue;
    }
    if (irqstack_end) {
        unsigned long *irqstack;
        irqstack = irqstack_end - (IRQSTACKSIZE - 64) / sizeof (*irqstack);
        if (stack >= irqstack && stack < irqstack_end) {
            if (ops->stack (data, "IRQ") < 0)
                break;
            bp = print_context_stack (tinfo, stack, bp, ops, data, irqstack_end);
            stack = (unsigned long *) (irqstack_end[-1]);
            irqstack_end = NULL;
            ops->stack (data, "EOI");
            continue;
        }
    }
    break;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/traps_64.c.ifdefed" startline="260" endline="274">
{
    if (ops->stack (data, id) < 0)
        break;
    bp = print_context_stack (tinfo, stack, bp, ops, data, estack_end);
    ops->stack (data, "<EOE>");
    stack = (unsigned long *) estack_end[-2];
    continue;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/traps_64.c.ifdefed" startline="275" endline="295">
{
    unsigned long *irqstack;
    irqstack = irqstack_end - (IRQSTACKSIZE - 64) / sizeof (*irqstack);
    if (stack >= irqstack && stack < irqstack_end) {
        if (ops->stack (data, "IRQ") < 0)
            break;
        bp = print_context_stack (tinfo, stack, bp, ops, data, irqstack_end);
        stack = (unsigned long *) (irqstack_end[-1]);
        irqstack_end = NULL;
        ops->stack (data, "EOI");
        continue;
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/traps_64.c.ifdefed" startline="280" endline="294">
{
    if (ops->stack (data, "IRQ") < 0)
        break;
    bp = print_context_stack (tinfo, stack, bp, ops, data, irqstack_end);
    stack = (unsigned long *) (irqstack_end[-1]);
    irqstack_end = NULL;
    ops->stack (data, "EOI");
    continue;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/traps_64.c.ifdefed" startline="309" endline="312">
{
    print_symbol (msg, symbol);
    printk ("\n");
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/traps_64.c.ifdefed" startline="315" endline="317">
{
    printk ("%s\n", msg);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/traps_64.c.ifdefed" startline="320" endline="323">
{
    printk (" <%s> ", name);
    return 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/traps_64.c.ifdefed" startline="326" endline="329">
{
    touch_nmi_watchdog ();
    printk_address (addr, reliable);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/traps_64.c.ifdefed" startline="341" endline="345">
{
    printk ("\nCall Trace:\n");
    dump_trace (task, regs, stack, bp, & print_trace_ops, log_lvl);
    printk ("\n");
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/traps_64.c.ifdefed" startline="349" endline="351">
{
    show_trace_log_lvl (task, regs, stack, bp, "");
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/traps_64.c.ifdefed" startline="356" endline="390">
{
    unsigned long *stack;
    int i;
    const int cpu = smp_processor_id ();
    unsigned long *irqstack_end = (unsigned long *) (cpu_pda (cpu)->irqstackptr);
    unsigned long *irqstack = (unsigned long *) (cpu_pda (cpu)->irqstackptr - IRQSTACKSIZE);
    if (sp == NULL) {
        if (task)
            sp = (unsigned long *) task->thread.sp;
        else
            sp = (unsigned long *) &sp;
    }
    stack = sp;
    for (i = 0; i < kstack_depth_to_print; i++) {
        if (stack >= irqstack && stack <= irqstack_end) {
            if (stack == irqstack_end) {
                stack = (unsigned long *) (irqstack_end[-1]);
                printk (" <EOI> ");
            }
        }
        else {
            if (((long) stack & (THREAD_SIZE - 1)) == 0)
                break;
        }
        if (i && ((i % 4) == 0))
            printk ("\n");
        printk (" %016lx", * stack ++);
        touch_nmi_watchdog ();
    }
    show_trace_log_lvl (task, regs, sp, bp, log_lvl);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/traps_64.c.ifdefed" startline="366" endline="371">
{
    if (task)
        sp = (unsigned long *) task->thread.sp;
    else
        sp = (unsigned long *) &sp;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/traps_64.c.ifdefed" startline="374" endline="388">
{
    if (stack >= irqstack && stack <= irqstack_end) {
        if (stack == irqstack_end) {
            stack = (unsigned long *) (irqstack_end[-1]);
            printk (" <EOI> ");
        }
    }
    else {
        if (((long) stack & (THREAD_SIZE - 1)) == 0)
            break;
    }
    if (i && ((i % 4) == 0))
        printk ("\n");
    printk (" %016lx", * stack ++);
    touch_nmi_watchdog ();
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/traps_64.c.ifdefed" startline="375" endline="380">
{
    if (stack == irqstack_end) {
        stack = (unsigned long *) (irqstack_end[-1]);
        printk (" <EOI> ");
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/traps_64.c.ifdefed" startline="376" endline="379">
{
    stack = (unsigned long *) (irqstack_end[-1]);
    printk (" <EOI> ");
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/traps_64.c.ifdefed" startline="380" endline="383">
{
    if (((long) stack & (THREAD_SIZE - 1)) == 0)
        break;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/traps_64.c.ifdefed" startline="393" endline="395">
{
    show_stack_log_lvl (task, NULL, sp, 0, "");
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/traps_64.c.ifdefed" startline="401" endline="416">
{
    unsigned long bp = 0;
    unsigned long stack;
    printk ("Pid: %d, comm: %.20s %s %s %.*s\n", current -> pid, current -> comm, print_tainted (), init_utsname () -> release, (int) strcspn (init_utsname () -> version, " "), init_utsname () -> version);
    show_trace (NULL, NULL, & stack, bp);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/traps_64.c.ifdefed" startline="421" endline="469">
{
    int i;
    unsigned long sp;
    const int cpu = smp_processor_id ();
    struct task_struct *cur = cpu_pda (cpu)->pcurrent;
    sp = regs->sp;
    printk ("CPU %d ", cpu);
    __show_regs (regs);
    printk ("Process %s (pid: %d, threadinfo %p, task %p)\n", cur -> comm, cur -> pid, task_thread_info (cur), cur);
    if (!user_mode (regs)) {
        unsigned int code_prologue = code_bytes * 43 / 64;
        unsigned int code_len = code_bytes;
        unsigned char c;
        u8 *ip;
        printk ("Stack: ");
        show_stack_log_lvl (NULL, regs, (unsigned long *) sp, regs -> bp, "");
        printk ("\n");
        printk (KERN_EMERG "Code: ");
        ip = (u8 *) regs->ip - code_prologue;
        if (ip < (u8 *) PAGE_OFFSET || probe_kernel_address (ip, c)) {
            ip = (u8 *) regs->ip;
            code_len = code_len - code_prologue + 1;
        }
        for (i = 0; i < code_len; i++, ip++) {
            if (ip < (u8 *) PAGE_OFFSET || probe_kernel_address (ip, c)) {
                printk (" Bad RIP value.");
                break;
            }
            if (ip == (u8 *) regs->ip)
                printk ("<%02x> ", c);
            else
                printk ("%02x ", c);
        }
    }
    printk ("\n");
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/traps_64.c.ifdefed" startline="437" endline="467">
{
    unsigned int code_prologue = code_bytes * 43 / 64;
    unsigned int code_len = code_bytes;
    unsigned char c;
    u8 *ip;
    printk ("Stack: ");
    show_stack_log_lvl (NULL, regs, (unsigned long *) sp, regs -> bp, "");
    printk ("\n");
    printk (KERN_EMERG "Code: ");
    ip = (u8 *) regs->ip - code_prologue;
    if (ip < (u8 *) PAGE_OFFSET || probe_kernel_address (ip, c)) {
        ip = (u8 *) regs->ip;
        code_len = code_len - code_prologue + 1;
    }
    for (i = 0; i < code_len; i++, ip++) {
        if (ip < (u8 *) PAGE_OFFSET || probe_kernel_address (ip, c)) {
            printk (" Bad RIP value.");
            break;
        }
        if (ip == (u8 *) regs->ip)
            printk ("<%02x> ", c);
        else
            printk ("%02x ", c);
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/traps_64.c.ifdefed" startline="451" endline="455">
{
    ip = (u8 *) regs->ip;
    code_len = code_len - code_prologue + 1;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/traps_64.c.ifdefed" startline="456" endline="466">
{
    if (ip < (u8 *) PAGE_OFFSET || probe_kernel_address (ip, c)) {
        printk (" Bad RIP value.");
        break;
    }
    if (ip == (u8 *) regs->ip)
        printk ("<%02x> ", c);
    else
        printk ("%02x ", c);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/traps_64.c.ifdefed" startline="458" endline="461">
{
    printk (" Bad RIP value.");
    break;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/traps_64.c.ifdefed" startline="472" endline="479">
{
    unsigned short ud2;
    if (__copy_from_user (&ud2, (const void __user *) ip, sizeof (ud2)))
        return 0;
    return ud2 == 0x0b0f;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/traps_64.c.ifdefed" startline="486" endline="506">
{
    int cpu;
    unsigned long flags;
    oops_enter ();
    raw_local_irq_save (flags);
    cpu = smp_processor_id ();
    if (!__raw_spin_trylock (&die_lock)) {
        if (cpu == die_owner)
            ;
        else
            __raw_spin_lock (&die_lock);
    }
    die_nest_count++;
    die_owner = cpu;
    console_verbose ();
    bust_spinlocks (1);
    return flags;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/traps_64.c.ifdefed" startline="495" endline="500">
{
    if (cpu == die_owner)
        ;
    else
        __raw_spin_lock (&die_lock);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/traps_64.c.ifdefed" startline="509" endline="525">
{
    die_owner = -1;
    bust_spinlocks (0);
    die_nest_count--;
    if (!die_nest_count)
        __raw_spin_unlock (&die_lock);
    raw_local_irq_restore (flags);
    if (!regs) {
        oops_exit ();
        return;
    }
    if (panic_on_oops)
        panic ("Fatal exception");
    oops_exit ();
    do_exit (signr);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/traps_64.c.ifdefed" startline="517" endline="520">
{
    oops_exit ();
    return;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/traps_64.c.ifdefed" startline="528" endline="553">
{
    printk (KERN_EMERG "%s: %04lx [%u] ", str, err & 0xffff, ++ die_counter);
    printk ("\n");
    if (notify_die (DIE_OOPS, str, regs, err, current->thread.trap_no, SIGSEGV) == NOTIFY_STOP)
        return 1;
    show_registers (regs);
    add_taint (TAINT_DIE);
    printk (KERN_ALERT "RIP ");
    printk_address (regs -> ip, 1);
    printk (" RSP <%016lx>\n", regs -> sp);
    if (kexec_should_crash (current))
        crash_kexec (regs);
    return 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/traps_64.c.ifdefed" startline="556" endline="565">
{
    unsigned long flags = oops_begin ();
    if (!user_mode (regs))
        report_bug (regs->ip, regs);
    if (__die (str, regs, err))
        regs = NULL;
    oops_end (flags, regs, SIGSEGV);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/traps_64.c.ifdefed" startline="569" endline="592">
{
    unsigned long flags;
    if (notify_die (DIE_NMIWATCHDOG, str, regs, 0, 2, SIGINT) == NOTIFY_STOP)
        return;
    flags = oops_begin ();
    printk (KERN_EMERG "%s", str);
    printk (" on CPU%d, ip %08lx, registers:\n", smp_processor_id (), regs -> ip);
    show_registers (regs);
    if (kexec_should_crash (current))
        crash_kexec (regs);
    if (do_panic || panic_on_oops)
        panic ("Non maskable interrupt");
    oops_end (flags, NULL, SIGBUS);
    nmi_exit ();
    local_irq_enable ();
    do_exit (SIGBUS);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/traps_64.c.ifdefed" startline="597" endline="638">
{
    struct task_struct *tsk = current;
    if (!user_mode (regs))
        goto kernel_trap;
    tsk->thread.error_code = error_code;
    tsk->thread.trap_no = trapnr;
    if (show_unhandled_signals && unhandled_signal (tsk, signr) && printk_ratelimit ()) {
        printk (KERN_INFO "%s[%d] trap %s ip:%lx sp:%lx error:%lx", tsk -> comm, tsk -> pid, str, regs -> ip, regs -> sp, error_code);
        print_vma_addr (" in ", regs -> ip);
        printk ("\n");
    }
    if (info)
        force_sig_info (signr, info, tsk);
    else
        force_sig (signr, tsk);
    return;
kernel_trap :
    if (!fixup_exception (regs)) {
        tsk->thread.error_code = error_code;
        tsk->thread.trap_no = trapnr;
        die (str, regs, error_code);
    }
    return;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/traps_64.c.ifdefed" startline="616" endline="623">
{
    printk (KERN_INFO "%s[%d] trap %s ip:%lx sp:%lx error:%lx", tsk -> comm, tsk -> pid, str, regs -> ip, regs -> sp, error_code);
    print_vma_addr (" in ", regs -> ip);
    printk ("\n");
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/traps_64.c.ifdefed" startline="632" endline="636">
{
    tsk->thread.error_code = error_code;
    tsk->thread.trap_no = trapnr;
    die (str, regs, error_code);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/traps_64.c.ifdefed" startline="677" endline="684">
{
    if (notify_die (DIE_TRAP, "stack segment", regs, error_code, 12, SIGBUS) == NOTIFY_STOP)
        return;
    preempt_conditional_sti (regs);
    do_trap (12, SIGBUS, "stack segment", regs, error_code, NULL);
    preempt_conditional_cli (regs);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/traps_64.c.ifdefed" startline="687" endline="701">
{
    static const char str [] = "double fault";
    struct task_struct *tsk = current;
    notify_die (DIE_TRAP, str, regs, error_code, 8, SIGSEGV);
    tsk->thread.error_code = error_code;
    tsk->thread.trap_no = 8;
    for (;;)
        die (str, regs, error_code);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/traps_64.c.ifdefed" startline="705" endline="740">
{
    struct task_struct *tsk;
    conditional_sti (regs);
    tsk = current;
    if (!user_mode (regs))
        goto gp_in_kernel;
    tsk->thread.error_code = error_code;
    tsk->thread.trap_no = 13;
    if (show_unhandled_signals && unhandled_signal (tsk, SIGSEGV) && printk_ratelimit ()) {
        printk (KERN_INFO "%s[%d] general protection ip:%lx sp:%lx error:%lx", tsk -> comm, tsk -> pid, regs -> ip, regs -> sp, error_code);
        print_vma_addr (" in ", regs -> ip);
        printk ("\n");
    }
    force_sig (SIGSEGV, tsk);
    return;
gp_in_kernel :
    if (fixup_exception (regs))
        return;
    tsk->thread.error_code = error_code;
    tsk->thread.trap_no = 13;
    if (notify_die (DIE_GPF, "general protection fault", regs, error_code, 13, SIGSEGV) == NOTIFY_STOP)
        return;
    die ("general protection fault", regs, error_code);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/traps_64.c.ifdefed" startline="718" endline="725">
{
    printk (KERN_INFO "%s[%d] general protection ip:%lx sp:%lx error:%lx", tsk -> comm, tsk -> pid, regs -> ip, regs -> sp, error_code);
    print_vma_addr (" in ", regs -> ip);
    printk ("\n");
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/traps_64.c.ifdefed" startline="744" endline="764">
{
    printk (KERN_EMERG "Uhhuh. NMI received for unknown reason %02x.\n", reason);
    printk (KERN_EMERG "You have some hardware problem, likely on the PCI bus.\n");
    if (panic_on_unrecovered_nmi)
        panic ("NMI: Not continuing");
    printk (KERN_EMERG "Dazed and confused, but trying to continue\n");
    reason = (reason & 0xf) | 4;
    outb (reason, 0x61);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/traps_64.c.ifdefed" startline="768" endline="778">
{
    printk ("NMI: IOCK error (debug interrupt?)\n");
    show_registers (regs);
    reason = (reason & 0xf) | 8;
    outb (reason, 0x61);
    mdelay (2000);
    reason &= ~8;
    outb (reason, 0x61);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/traps_64.c.ifdefed" startline="782" endline="793">
{
    if (notify_die (DIE_NMIUNKNOWN, "nmi", regs, reason, 2, SIGINT) == NOTIFY_STOP)
        return;
    printk (KERN_EMERG "Uhhuh. NMI received for unknown reason %02x.\n", reason);
    printk (KERN_EMERG "Do you have a strange power saving mode enabled?\n");
    if (panic_on_unrecovered_nmi)
        panic ("NMI: Not continuing");
    printk (KERN_EMERG "Dazed and confused, but trying to continue\n");
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/traps_64.c.ifdefed" startline="798" endline="831">
{
    unsigned char reason = 0;
    int cpu;
    cpu = smp_processor_id ();
    if (!cpu)
        reason = get_nmi_reason ();
    if (!(reason & 0xc0)) {
        if (notify_die (DIE_NMI_IPI, "nmi_ipi", regs, reason, 2, SIGINT) == NOTIFY_STOP)
            return;
        if (nmi_watchdog_tick (regs, reason))
            return;
        if (!do_nmi_callback (regs, cpu))
            unknown_nmi_error (reason, regs);
        return;
    }
    if (notify_die (DIE_NMI, "nmi", regs, reason, 2, SIGINT) == NOTIFY_STOP)
        return;
    if (reason & 0x80)
        mem_parity_error (reason, regs);
    if (reason & 0x40)
        io_check_error (reason, regs);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/traps_64.c.ifdefed" startline="808" endline="822">
{
    if (notify_die (DIE_NMI_IPI, "nmi_ipi", regs, reason, 2, SIGINT) == NOTIFY_STOP)
        return;
    if (nmi_watchdog_tick (regs, reason))
        return;
    if (!do_nmi_callback (regs, cpu))
        unknown_nmi_error (reason, regs);
    return;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/traps_64.c.ifdefed" startline="835" endline="844">
{
    nmi_enter ();
    add_pda (__nmi_count, 1);
    if (!ignore_nmis)
        default_do_nmi (regs);
    nmi_exit ();
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/traps_64.c.ifdefed" startline="847" endline="850">
{
    acpi_nmi_disable ();
    ignore_nmis++;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/traps_64.c.ifdefed" startline="853" endline="856">
{
    ignore_nmis--;
    acpi_nmi_enable ();
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/traps_64.c.ifdefed" startline="860" endline="870">
{
    trace_hardirqs_fixup ();
    if (notify_die (DIE_INT3, "int3", regs, error_code, 3, SIGTRAP) == NOTIFY_STOP)
        return;
    preempt_conditional_sti (regs);
    do_trap (3, SIGTRAP, "int3", regs, error_code, NULL);
    preempt_conditional_cli (regs);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/traps_64.c.ifdefed" startline="876" endline="891">
{
    struct pt_regs *regs = eregs;
    if (eregs == (struct pt_regs *) eregs->sp)
        ;
    else if (user_mode (eregs))
        regs = task_pt_regs (current);
    else if (eregs->flags & X86_EFLAGS_IF)
        regs = (struct pt_regs *) (eregs->sp -= sizeof (struct pt_regs));
    if (eregs != regs)
        *regs = *eregs;
    return regs;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/traps_64.c.ifdefed" startline="896" endline="953">
{
    struct task_struct *tsk = current;
    unsigned long condition;
    siginfo_t info;
    trace_hardirqs_fixup ();
    get_debugreg (condition, 6);
    clear_tsk_thread_flag (tsk, TIF_DEBUGCTLMSR);
    tsk->thread.debugctlmsr = 0;
    if (notify_die (DIE_DEBUG, "debug", regs, condition, error_code, SIGTRAP) == NOTIFY_STOP)
        return;
    preempt_conditional_sti (regs);
    if (condition & (DR_TRAP0 | DR_TRAP1 | DR_TRAP2 | DR_TRAP3)) {
        if (!tsk->thread.debugreg7)
            goto clear_dr7;
    }
    tsk->thread.debugreg6 = condition;
    if (condition & DR_STEP) {
        if (!user_mode (regs))
            goto clear_TF_reenable;
    }
    tsk->thread.trap_no = 1;
    tsk->thread.error_code = error_code;
    info.si_signo = SIGTRAP;
    info.si_errno = 0;
    info.si_code = TRAP_BRKPT;
    info.si_addr = user_mode (regs) ? (void __user *) regs->ip : NULL;
    force_sig_info (SIGTRAP, & info, tsk);
clear_dr7 :
    set_debugreg (0, 7);
    preempt_conditional_cli (regs);
    return;
clear_TF_reenable :
    set_tsk_thread_flag (tsk, TIF_SINGLESTEP);
    regs->flags &= ~X86_EFLAGS_TF;
    preempt_conditional_cli (regs);
    return;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/traps_64.c.ifdefed" startline="918" endline="921">
{
    if (!tsk->thread.debugreg7)
        goto clear_dr7;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/traps_64.c.ifdefed" startline="929" endline="932">
{
    if (!user_mode (regs))
        goto clear_TF_reenable;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/traps_64.c.ifdefed" startline="956" endline="965">
{
    if (fixup_exception (regs))
        return 1;
    notify_die (DIE_GPF, str, regs, 0, trapnr, SIGFPE);
    current->thread.trap_no = trapnr;
    die (str, regs, 0);
    return 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/traps_64.c.ifdefed" startline="973" endline="1034">
{
    void __user *ip = (void __user *) (regs->ip);
    struct task_struct *task;
    siginfo_t info;
    unsigned short cwd, swd;
    conditional_sti (regs);
    if (!user_mode (regs) && kernel_math_error (regs, "kernel x87 math error", 16))
        return;
    task = current;
    save_init_fpu (task);
    task->thread.trap_no = 16;
    task->thread.error_code = 0;
    info.si_signo = SIGFPE;
    info.si_errno = 0;
    info.si_code = __SI_FAULT;
    info.si_addr = ip;
    cwd = get_fpu_cwd (task);
    swd = get_fpu_swd (task);
    switch (swd & ~cwd & 0x3f) {
    case 0x000 :
    default :
        break;
    case 0x001 :
        info.si_code = FPE_FLTINV;
        break;
    case 0x002 :
    case 0x010 :
        info.si_code = FPE_FLTUND;
        break;
    case 0x004 :
        info.si_code = FPE_FLTDIV;
        break;
    case 0x008 :
        info.si_code = FPE_FLTOVF;
        break;
    case 0x020 :
        info.si_code = FPE_FLTRES;
        break;
    }
    force_sig_info (SIGFPE, & info, task);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/traps_64.c.ifdefed" startline="1007" endline="1032">
{
case 0x000 :
default :
    break;
case 0x001 :
    info.si_code = FPE_FLTINV;
    break;
case 0x002 :
case 0x010 :
    info.si_code = FPE_FLTUND;
    break;
case 0x004 :
    info.si_code = FPE_FLTDIV;
    break;
case 0x008 :
    info.si_code = FPE_FLTOVF;
    break;
case 0x020 :
    info.si_code = FPE_FLTRES;
    break;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/traps_64.c.ifdefed" startline="1037" endline="1039">
{
    printk ("bad interrupt");
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/traps_64.c.ifdefed" startline="1042" endline="1093">
{
    void __user *ip = (void __user *) (regs->ip);
    struct task_struct *task;
    siginfo_t info;
    unsigned short mxcsr;
    conditional_sti (regs);
    if (!user_mode (regs) && kernel_math_error (regs, "kernel simd math error", 19))
        return;
    task = current;
    save_init_fpu (task);
    task->thread.trap_no = 19;
    task->thread.error_code = 0;
    info.si_signo = SIGFPE;
    info.si_errno = 0;
    info.si_code = __SI_FAULT;
    info.si_addr = ip;
    mxcsr = get_fpu_mxcsr (task);
    switch (~((mxcsr & 0x1f80) >> 7) & (mxcsr & 0x3f)) {
    case 0x000 :
    default :
        break;
    case 0x001 :
        info.si_code = FPE_FLTINV;
        break;
    case 0x002 :
    case 0x010 :
        info.si_code = FPE_FLTUND;
        break;
    case 0x004 :
        info.si_code = FPE_FLTDIV;
        break;
    case 0x008 :
        info.si_code = FPE_FLTOVF;
        break;
    case 0x020 :
        info.si_code = FPE_FLTRES;
        break;
    }
    force_sig_info (SIGFPE, & info, task);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/traps_64.c.ifdefed" startline="1071" endline="1091">
{
case 0x000 :
default :
    break;
case 0x001 :
    info.si_code = FPE_FLTINV;
    break;
case 0x002 :
case 0x010 :
    info.si_code = FPE_FLTUND;
    break;
case 0x004 :
    info.si_code = FPE_FLTDIV;
    break;
case 0x008 :
    info.si_code = FPE_FLTOVF;
    break;
case 0x020 :
    info.si_code = FPE_FLTRES;
    break;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/traps_64.c.ifdefed" startline="1096" endline="1097">
{
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/traps_64.c.ifdefed" startline="1100" endline="1101">
{
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/traps_64.c.ifdefed" startline="1104" endline="1105">
{
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/traps_64.c.ifdefed" startline="1115" endline="1144">
{
    struct task_struct *me = current;
    if (!used_math ()) {
        local_irq_enable ();
        if (init_fpu (me)) {
            do_group_exit (SIGKILL);
            return;
        }
        local_irq_disable ();
    }
    clts ();
    if (unlikely (restore_fpu_checking (&me->thread.xstate->fxsave))) {
        stts ();
        force_sig (SIGSEGV, me);
        return;
    }
    task_thread_info (me)->status |= TS_USEDFPU;
    me->fpu_counter++;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/traps_64.c.ifdefed" startline="1118" endline="1131">
{
    local_irq_enable ();
    if (init_fpu (me)) {
        do_group_exit (SIGKILL);
        return;
    }
    local_irq_disable ();
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/traps_64.c.ifdefed" startline="1123" endline="1129">
{
    do_group_exit (SIGKILL);
    return;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/traps_64.c.ifdefed" startline="1137" endline="1141">
{
    stts ();
    force_sig (SIGSEGV, me);
    return;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/traps_64.c.ifdefed" startline="1148" endline="1183">
{
    set_intr_gate (0, & divide_error);
    set_intr_gate_ist (1, & debug, DEBUG_STACK);
    set_intr_gate_ist (2, & nmi, NMI_STACK);
    set_system_gate_ist (3, & int3, DEBUG_STACK);
    set_system_gate (4, & overflow);
    set_intr_gate (5, & bounds);
    set_intr_gate (6, & invalid_op);
    set_intr_gate (7, & device_not_available);
    set_intr_gate_ist (8, & double_fault, DOUBLEFAULT_STACK);
    set_intr_gate (9, & coprocessor_segment_overrun);
    set_intr_gate (10, & invalid_TSS);
    set_intr_gate (11, & segment_not_present);
    set_intr_gate_ist (12, & stack_segment, STACKFAULT_STACK);
    set_intr_gate (13, & general_protection);
    set_intr_gate (14, & page_fault);
    set_intr_gate (15, & spurious_interrupt_bug);
    set_intr_gate (16, & coprocessor_error);
    set_intr_gate (17, & alignment_check);
    set_intr_gate (19, & simd_coprocessor_error);
    init_thread_xstate ();
    cpu_init ();
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/traps_64.c.ifdefed" startline="1186" endline="1192">
{
    if (!s)
        return -EINVAL;
    if (!strcmp (s, "panic"))
        panic_on_oops = 1;
    return 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/traps_64.c.ifdefed" startline="1196" endline="1201">
{
    if (!s)
        return -EINVAL;
    kstack_depth_to_print = simple_strtoul (s, NULL, 0);
    return 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/traps_64.c.ifdefed" startline="1205" endline="1211">
{
    code_bytes = simple_strtoul (s, NULL, 0);
    if (code_bytes > 8192)
        code_bytes = 8192;
    return 1;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/genx2apic_uv_x.c.ifdefed" startline="50" endline="52">
{
    return cpumask_of_cpu (0);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/genx2apic_uv_x.c.ifdefed" startline="55" endline="59">
{
    cpumask_t domain = CPU_MASK_NONE;
    cpu_set (cpu, domain);
    return domain;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/genx2apic_uv_x.c.ifdefed" startline="62" endline="80">
{
    unsigned long val;
    int pnode;
    pnode = uv_apicid_to_pnode (phys_apicid);
    val = (1UL << UVH_IPI_INT_SEND_SHFT) | (phys_apicid << UVH_IPI_INT_APIC_ID_SHFT) | (((long) start_rip << UVH_IPI_INT_VECTOR_SHFT) >> 12) | APIC_DM_INIT;
    uv_write_global_mmr64 (pnode, UVH_IPI_INT, val);
    mdelay (10);
    val = (1UL << UVH_IPI_INT_SEND_SHFT) | (phys_apicid << UVH_IPI_INT_APIC_ID_SHFT) | (((long) start_rip << UVH_IPI_INT_VECTOR_SHFT) >> 12) | APIC_DM_STARTUP;
    uv_write_global_mmr64 (pnode, UVH_IPI_INT, val);
    return 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/genx2apic_uv_x.c.ifdefed" startline="83" endline="95">
{
    unsigned long val, apicid, lapicid;
    int pnode;
    apicid = per_cpu (x86_cpu_to_apicid, cpu);
    lapicid = apicid & 0x3f;
    pnode = uv_apicid_to_pnode (apicid);
    val = (1UL << UVH_IPI_INT_SEND_SHFT) | (lapicid << UVH_IPI_INT_APIC_ID_SHFT) | (vector << UVH_IPI_INT_VECTOR_SHFT);
    uv_write_global_mmr64 (pnode, UVH_IPI_INT, val);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/genx2apic_uv_x.c.ifdefed" startline="98" endline="104">
{
    unsigned int cpu;
    for_each_possible_cpu (cpu)
    if (cpu_isset (cpu, mask))
        uv_send_IPI_one (cpu, vector);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/genx2apic_uv_x.c.ifdefed" startline="107" endline="114">
{
    cpumask_t mask = cpu_online_map;
    cpu_clear (smp_processor_id (), mask);
    if (!cpus_empty (mask))
        uv_send_IPI_mask (mask, vector);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/genx2apic_uv_x.c.ifdefed" startline="117" endline="119">
{
    uv_send_IPI_mask (cpu_online_map, vector);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/genx2apic_uv_x.c.ifdefed" startline="122" endline="124">
{
    return 1;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/genx2apic_uv_x.c.ifdefed" startline="127" endline="139">
{
    int cpu;
    cpu = first_cpu (cpumask);
    if ((unsigned) cpu < nr_cpu_ids)
        return per_cpu (x86_cpu_to_apicid, cpu);
    else
        return BAD_APICID;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/genx2apic_uv_x.c.ifdefed" startline="142" endline="144">
{
    return GET_APIC_ID (read_apic_id ()) >> index_msb;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/genx2apic_uv_x.c.ifdefed" startline="169" endline="171">
{
    __get_cpu_var (x2apic_extra_bits) = (pnode << 6);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/genx2apic_uv_x.c.ifdefed" startline="177" endline="184">
{
    int blade;
    for (blade = 0; blade < uv_num_possible_blades (); blade++)
        if (pnode == uv_blade_info[blade].pnode)
            return blade;
    BUG ();
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/genx2apic_uv_x.c.ifdefed" startline="200" endline="215">
{
    union uvh_si_alias0_overlay_config_u alias;
    union uvh_rh_gam_alias210_redirect_config_2_mmr_u redirect;
    int i;
    for (i = 0; i < ARRAY_SIZE (redir_addrs); i++) {
        alias.v = uv_read_local_mmr (redir_addrs[i].alias);
        if (alias.s.base == 0) {
            *size = (1UL << alias.s.m_alias);
            redirect.v = uv_read_local_mmr (redir_addrs[i].redirect);
            *base = (unsigned long) redirect.s.dest_base << DEST_SHIFT;
            return;
        }
    }
    BUG ();
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/genx2apic_uv_x.c.ifdefed" startline="205" endline="213">
{
    alias.v = uv_read_local_mmr (redir_addrs[i].alias);
    if (alias.s.base == 0) {
        *size = (1UL << alias.s.m_alias);
        redirect.v = uv_read_local_mmr (redir_addrs[i].redirect);
        *base = (unsigned long) redirect.s.dest_base << DEST_SHIFT;
        return;
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/genx2apic_uv_x.c.ifdefed" startline="207" endline="212">
{
    *size = (1UL << alias.s.m_alias);
    redirect.v = uv_read_local_mmr (redir_addrs[i].redirect);
    *base = (unsigned long) redirect.s.dest_base << DEST_SHIFT;
    return;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/genx2apic_uv_x.c.ifdefed" startline="218" endline="221">
{
    init_extra_mapping_uc (UV_GLOBAL_MMR32_BASE, UV_GLOBAL_MMR32_SIZE);
    init_extra_mapping_uc (UV_LOCAL_MMR_BASE, UV_LOCAL_MMR_SIZE);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/genx2apic_uv_x.c.ifdefed" startline="226" endline="238">
{
    unsigned long bytes, paddr;
    paddr = base << shift;
    bytes = (1UL << shift);
    printk (KERN_INFO "UV: Map %s_HI 0x%lx - 0x%lx\n", id, paddr, paddr + bytes);
    if (map_type == map_uc)
        init_extra_mapping_uc (paddr, bytes);
    else
        init_extra_mapping_wb (paddr, bytes);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/genx2apic_uv_x.c.ifdefed" startline="240" endline="247">
{
    union uvh_rh_gam_gru_overlay_config_mmr_u gru;
    int shift = UVH_RH_GAM_GRU_OVERLAY_CONFIG_MMR_BASE_SHFT;
    gru.v = uv_read_local_mmr (UVH_RH_GAM_GRU_OVERLAY_CONFIG_MMR);
    if (gru.s.enable)
        map_high ("GRU", gru.s.base, shift, map_wb);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/genx2apic_uv_x.c.ifdefed" startline="250" endline="257">
{
    union uvh_rh_gam_cfg_overlay_config_mmr_u cfg;
    int shift = UVH_RH_GAM_CFG_OVERLAY_CONFIG_MMR_BASE_SHFT;
    cfg.v = uv_read_local_mmr (UVH_RH_GAM_CFG_OVERLAY_CONFIG_MMR);
    if (cfg.s.enable)
        map_high ("CONFIG", cfg.s.base, shift, map_uc);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/genx2apic_uv_x.c.ifdefed" startline="260" endline="267">
{
    union uvh_rh_gam_mmr_overlay_config_mmr_u mmr;
    int shift = UVH_RH_GAM_MMR_OVERLAY_CONFIG_MMR_BASE_SHFT;
    mmr.v = uv_read_local_mmr (UVH_RH_GAM_MMR_OVERLAY_CONFIG_MMR);
    if (mmr.s.enable)
        map_high ("MMR", mmr.s.base, shift, map_uc);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/genx2apic_uv_x.c.ifdefed" startline="270" endline="277">
{
    union uvh_rh_gam_mmioh_overlay_config_mmr_u mmioh;
    int shift = UVH_RH_GAM_MMIOH_OVERLAY_CONFIG_MMR_BASE_SHFT;
    mmioh.v = uv_read_local_mmr (UVH_RH_GAM_MMIOH_OVERLAY_CONFIG_MMR);
    if (mmioh.s.enable)
        map_high ("MMIOH", mmioh.s.base, shift, map_uc);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/genx2apic_uv_x.c.ifdefed" startline="280" endline="294">
{
    long status, ticks_per_sec, drift;
    status = x86_bios_freq_base (BIOS_FREQ_BASE_REALTIME_CLOCK, &ticks_per_sec, &drift);
    if (status != 0 || ticks_per_sec < 100000) {
        printk (KERN_WARNING "unable to determine platform RTC clock frequency, " "guessing.\n");
        sn_rtc_cycles_per_second = 1000000000000UL / 30000UL;
    }
    else
        sn_rtc_cycles_per_second = ticks_per_sec;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/genx2apic_uv_x.c.ifdefed" startline="286" endline="292">
{
    printk (KERN_WARNING "unable to determine platform RTC clock frequency, " "guessing.\n");
    sn_rtc_cycles_per_second = 1000000000000UL / 30000UL;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/genx2apic_uv_x.c.ifdefed" startline="299" endline="389">
{
    union uvh_si_addr_map_config_u m_n_config;
    union uvh_node_id_u node_id;
    unsigned long gnode_upper, lowmem_redir_base, lowmem_redir_size;
    int bytes, nid, cpu, lcpu, pnode, blade, i, j, m_val, n_val;
    int max_pnode = 0;
    unsigned long mmr_base, present;
    map_low_mmrs ();
    m_n_config.v = uv_read_local_mmr (UVH_SI_ADDR_MAP_CONFIG);
    m_val = m_n_config.s.m_skt;
    n_val = m_n_config.s.n_skt;
    mmr_base = uv_read_local_mmr (UVH_RH_GAM_MMR_OVERLAY_CONFIG_MMR) & ~UV_MMR_ENABLE;
    printk (KERN_DEBUG "UV: global MMR base 0x%lx\n", mmr_base);
    for (i = 0; i < UVH_NODE_PRESENT_TABLE_DEPTH; i++)
        uv_possible_blades += hweight64 (uv_read_local_mmr (UVH_NODE_PRESENT_TABLE + i * 8));
    printk (KERN_DEBUG "UV: Found %d blades\n", uv_num_possible_blades ());
    bytes = sizeof (struct uv_blade_info) * uv_num_possible_blades ();
    uv_blade_info = alloc_bootmem_pages (bytes);
    get_lowmem_redirect (& lowmem_redir_base, & lowmem_redir_size);
    bytes = sizeof (uv_node_to_blade[0]) * num_possible_nodes ();
    uv_node_to_blade = alloc_bootmem_pages (bytes);
    memset (uv_node_to_blade, 255, bytes);
    bytes = sizeof (uv_cpu_to_blade[0]) * num_possible_cpus ();
    uv_cpu_to_blade = alloc_bootmem_pages (bytes);
    memset (uv_cpu_to_blade, 255, bytes);
    blade = 0;
    for (i = 0; i < UVH_NODE_PRESENT_TABLE_DEPTH; i++) {
        present = uv_read_local_mmr (UVH_NODE_PRESENT_TABLE +i * 8);
        for (j = 0; j < 64; j++) {
            if (!test_bit (j, &present))
                continue;
            uv_blade_info[blade].pnode = (i * 64 + j);
            uv_blade_info[blade].nr_possible_cpus = 0;
            uv_blade_info[blade].nr_online_cpus = 0;
            blade++;
        }
    }
    node_id.v = uv_read_local_mmr (UVH_NODE_ID);
    gnode_upper = (((unsigned long) node_id.s.node_id) & ~((1 << n_val) - 1)) << m_val;
    uv_rtc_init ();

    for_each_present_cpu (cpu) {
        nid = cpu_to_node (cpu);
        pnode = uv_apicid_to_pnode (per_cpu (x86_cpu_to_apicid, cpu));
        blade = boot_pnode_to_blade (pnode);
        lcpu = uv_blade_info[blade].nr_possible_cpus;
        uv_blade_info[blade].nr_possible_cpus++;
        uv_cpu_hub_info (cpu)->lowmem_remap_base = lowmem_redir_base;
        uv_cpu_hub_info (cpu)->lowmem_remap_top = lowmem_redir_base + lowmem_redir_size;
        uv_cpu_hub_info (cpu)->m_val = m_val;
        uv_cpu_hub_info (cpu)->n_val = m_val;
        uv_cpu_hub_info (cpu)->numa_blade_id = blade;
        uv_cpu_hub_info (cpu)->blade_processor_id = lcpu;
        uv_cpu_hub_info (cpu)->pnode = pnode;
        uv_cpu_hub_info (cpu)->pnode_mask = (1 << n_val) - 1;
        uv_cpu_hub_info (cpu)->gpa_mask = (1 << (m_val + n_val)) - 1;
        uv_cpu_hub_info (cpu)->gnode_upper = gnode_upper;
        uv_cpu_hub_info (cpu)->global_mmr_base = mmr_base;
        uv_cpu_hub_info (cpu)->coherency_domain_number = 0;
        uv_node_to_blade[nid] = blade;
        uv_cpu_to_blade[cpu] = blade;
        max_pnode = max (pnode, max_pnode);
        printk (KERN_DEBUG "UV: cpu %d, apicid 0x%x, pnode %d, nid %d, " "lcpu %d, blade %d\n", cpu, per_cpu (x86_cpu_to_apicid, cpu), pnode, nid, lcpu, blade);
    }

    map_gru_high (max_pnode);
    map_mmr_high (max_pnode);
    map_config_high (max_pnode);
    map_mmioh_high (max_pnode);
    uv_system_inited = true;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/genx2apic_uv_x.c.ifdefed" startline="336" endline="346">
{
    present = uv_read_local_mmr (UVH_NODE_PRESENT_TABLE +i * 8);
    for (j = 0; j < 64; j++) {
        if (!test_bit (j, &present))
            continue;
        uv_blade_info[blade].pnode = (i * 64 + j);
        uv_blade_info[blade].nr_possible_cpus = 0;
        uv_blade_info[blade].nr_online_cpus = 0;
        blade++;
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/genx2apic_uv_x.c.ifdefed" startline="338" endline="345">
{
    if (!test_bit (j, &present))
        continue;
    uv_blade_info[blade].pnode = (i * 64 + j);
    uv_blade_info[blade].nr_possible_cpus = 0;
    uv_blade_info[blade].nr_online_cpus = 0;
    blade++;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/genx2apic_uv_x.c.ifdefed" startline="354" endline="382">
{
    nid = cpu_to_node (cpu);
    pnode = uv_apicid_to_pnode (per_cpu (x86_cpu_to_apicid, cpu));
    blade = boot_pnode_to_blade (pnode);
    lcpu = uv_blade_info[blade].nr_possible_cpus;
    uv_blade_info[blade].nr_possible_cpus++;
    uv_cpu_hub_info (cpu)->lowmem_remap_base = lowmem_redir_base;
    uv_cpu_hub_info (cpu)->lowmem_remap_top = lowmem_redir_base + lowmem_redir_size;
    uv_cpu_hub_info (cpu)->m_val = m_val;
    uv_cpu_hub_info (cpu)->n_val = m_val;
    uv_cpu_hub_info (cpu)->numa_blade_id = blade;
    uv_cpu_hub_info (cpu)->blade_processor_id = lcpu;
    uv_cpu_hub_info (cpu)->pnode = pnode;
    uv_cpu_hub_info (cpu)->pnode_mask = (1 << n_val) - 1;
    uv_cpu_hub_info (cpu)->gpa_mask = (1 << (m_val + n_val)) - 1;
    uv_cpu_hub_info (cpu)->gnode_upper = gnode_upper;
    uv_cpu_hub_info (cpu)->global_mmr_base = mmr_base;
    uv_cpu_hub_info (cpu)->coherency_domain_number = 0;
    uv_node_to_blade[nid] = blade;
    uv_cpu_to_blade[cpu] = blade;
    max_pnode = max (pnode, max_pnode);
    printk (KERN_DEBUG "UV: cpu %d, apicid 0x%x, pnode %d, nid %d, " "lcpu %d, blade %d\n", cpu, per_cpu (x86_cpu_to_apicid, cpu), pnode, nid, lcpu, blade);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/genx2apic_uv_x.c.ifdefed" startline="396" endline="403">
{
    BUG_ON (! uv_system_inited);
    uv_blade_info[uv_numa_blade_id ()].nr_online_cpus++;
    if (get_uv_system_type () == UV_NON_UNIQUE_APIC)
        set_x2apic_extra_bits (uv_hub_info->pnode);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/acpi/sleep.c.ifdefed" startline="36" endline="107">
{
    struct wakeup_header *header;
    if (!acpi_realmode) {
        printk (KERN_ERR "Could not allocate memory during boot, " "S3 disabled\n");
        return -ENOMEM;
    }
    memcpy ((void *) acpi_realmode, & wakeup_code_start, WAKEUP_SIZE);
    header = (struct wakeup_header *) (acpi_realmode + HEADER_OFFSET);
    if (header->signature != 0x51ee1111) {
        printk (KERN_ERR "wakeup header does not match\n");
        return -EINVAL;
    }
    header->video_mode = saved_video_mode;
    header->wakeup_jmp_seg = acpi_wakeup_address >> 4;
    header->wakeup_gdt[0] = (u64) (sizeof (header->wakeup_gdt) - 1) + ((u64) (acpi_wakeup_address + ((char *) &header->wakeup_gdt - (char *) acpi_realmode)) << 16);
    header->wakeup_gdt[1] = GDT_ENTRY (0x809b, acpi_wakeup_address, 0xfffff);
    header->wakeup_gdt[2] = GDT_ENTRY (0x8093, acpi_wakeup_address, 0xfffff);
    store_gdt ((struct desc_ptr *) & header -> pmode_gdt);
    header->pmode_efer_low = nx_enabled;
    if (header->pmode_efer_low & 1) {
        rdmsr (MSR_EFER, header -> pmode_efer_low, header -> pmode_efer_high);
    }
    header->pmode_cr0 = read_cr0 ();
    header->pmode_cr4 = read_cr4_safe ();
    header->realmode_flags = acpi_realmode_flags;
    header->real_magic = 0x12345678;
    header->pmode_entry = (u32) &wakeup_pmode_return;
    header->pmode_cr3 = (u32) (swsusp_pg_dir - __PAGE_OFFSET);
    saved_magic = 0x12345678;
    return 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/acpi/sleep.c.ifdefed" startline="39" endline="43">
{
    printk (KERN_ERR "Could not allocate memory during boot, " "S3 disabled\n");
    return -ENOMEM;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/acpi/sleep.c.ifdefed" startline="47" endline="50">
{
    printk (KERN_ERR "wakeup header does not match\n");
    return -EINVAL;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/acpi/sleep.c.ifdefed" startline="81" endline="85">
{
    rdmsr (MSR_EFER, header -> pmode_efer_low, header -> pmode_efer_high);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/acpi/sleep.c.ifdefed" startline="113" endline="114">
{
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/acpi/sleep.c.ifdefed" startline="126" endline="141">
{
    if ((&wakeup_code_end - &wakeup_code_start) > WAKEUP_SIZE) {
        printk (KERN_ERR "ACPI: Wakeup code way too big, S3 disabled.\n");
        return;
    }
    acpi_realmode = (unsigned long) alloc_bootmem_low (WAKEUP_SIZE);
    if (!acpi_realmode) {
        printk (KERN_ERR "ACPI: Cannot allocate lowmem, S3 disabled.\n");
        return;
    }
    acpi_wakeup_address = virt_to_phys ((void *) acpi_realmode);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/acpi/sleep.c.ifdefed" startline="127" endline="131">
{
    printk (KERN_ERR "ACPI: Wakeup code way too big, S3 disabled.\n");
    return;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/acpi/sleep.c.ifdefed" startline="135" endline="138">
{
    printk (KERN_ERR "ACPI: Cannot allocate lowmem, S3 disabled.\n");
    return;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/acpi/sleep.c.ifdefed" startline="145" endline="164">
{
    while ((str != NULL) && (*str != '\0')) {
        if (strncmp (str, "s3_bios", 7) == 0)
            acpi_realmode_flags |= 1;
        if (strncmp (str, "s3_mode", 7) == 0)
            acpi_realmode_flags |= 2;
        if (strncmp (str, "s3_beep", 7) == 0)
            acpi_realmode_flags |= 4;
        if (strncmp (str, "old_ordering", 12) == 0)
            acpi_old_suspend_ordering ();
        str = strchr (str, ',');
        if (str != NULL)
            str += strspn (str, ", \t");
    }
    return 1;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/acpi/sleep.c.ifdefed" startline="146" endline="162">
{
    if (strncmp (str, "s3_bios", 7) == 0)
        acpi_realmode_flags |= 1;
    if (strncmp (str, "s3_mode", 7) == 0)
        acpi_realmode_flags |= 2;
    if (strncmp (str, "s3_beep", 7) == 0)
        acpi_realmode_flags |= 4;
    if (strncmp (str, "old_ordering", 12) == 0)
        acpi_old_suspend_ordering ();
    str = strchr (str, ',');
    if (str != NULL)
        str += strspn (str, ", \t");
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/acpi/cstate.c.ifdefed" startline="29" endline="43">
{
    struct cpuinfo_x86 *c = &cpu_data (cpu);
    flags->bm_check = 0;
    if (num_online_cpus () == 1)
        flags->bm_check = 1;
    else if (c->x86_vendor == X86_VENDOR_INTEL) {
        flags->bm_check = 1;
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/acpi/cstate.c.ifdefed" startline="35" endline="42">
{
    flags->bm_check = 1;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/acpi/cstate.c.ifdefed" startline="71" endline="133">
{
    struct cstate_entry *percpu_entry;
    struct cpuinfo_x86 *c = &cpu_data (cpu);
    cpumask_t saved_mask;
    int retval;
    unsigned int eax, ebx, ecx, edx;
    unsigned int edx_part;
    unsigned int cstate_type;
    unsigned int num_cstate_subtype;
    if (!cpu_cstate_entry || c->cpuid_level < CPUID_MWAIT_LEAF)
        return -1;
    if (reg->bit_offset != NATIVE_CSTATE_BEYOND_HALT)
        return -1;
    percpu_entry = per_cpu_ptr (cpu_cstate_entry, cpu);
    percpu_entry->states[cx->index].eax = 0;
    percpu_entry->states[cx->index].ecx = 0;
    saved_mask = current->cpus_allowed;
    retval = set_cpus_allowed_ptr (current, &cpumask_of_cpu (cpu));
    if (retval)
        return -1;
    cpuid (CPUID_MWAIT_LEAF, & eax, & ebx, & ecx, & edx);
    cstate_type = (cx->address >> MWAIT_SUBSTATE_SIZE) + 1;
    edx_part = edx >> (cstate_type * MWAIT_SUBSTATE_SIZE);
    num_cstate_subtype = edx_part & MWAIT_SUBSTATE_MASK;
    retval = 0;
    if (num_cstate_subtype < (cx->address & MWAIT_SUBSTATE_MASK)) {
        retval = -1;
        goto out;
    }
    if (!(ecx & CPUID5_ECX_EXTENSIONS_SUPPORTED) || !(ecx & CPUID5_ECX_INTERRUPT_BREAK)) {
        retval = -1;
        goto out;
    }
    percpu_entry->states[cx->index].ecx = MWAIT_ECX_INTERRUPT_BREAK;
    percpu_entry->states[cx->index].eax = cx->address;
    if (!mwait_supported[cstate_type]) {
        mwait_supported[cstate_type] = 1;
        printk (KERN_DEBUG "Monitor-Mwait will be used to enter C-%d " "state\n", cx -> type);
    }
    snprintf (cx -> desc, ACPI_CX_DESC_LEN, "ACPI FFH INTEL MWAIT 0x%x", cx -> address);
out :
    set_cpus_allowed_ptr (current, &saved_mask);
    return retval;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/acpi/cstate.c.ifdefed" startline="106" endline="109">
{
    retval = -1;
    goto out;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/acpi/cstate.c.ifdefed" startline="113" endline="116">
{
    retval = -1;
    goto out;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/acpi/cstate.c.ifdefed" startline="122" endline="126">
{
    mwait_supported[cstate_type] = 1;
    printk (KERN_DEBUG "Monitor-Mwait will be used to enter C-%d " "state\n", cx -> type);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/acpi/cstate.c.ifdefed" startline="137" endline="144">
{
    unsigned int cpu = smp_processor_id ();
    struct cstate_entry *percpu_entry;
    percpu_entry = per_cpu_ptr (cpu_cstate_entry, cpu);
    mwait_idle_with_hints (percpu_entry -> states [cx -> index].eax, percpu_entry -> states [cx -> index].ecx);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/acpi/cstate.c.ifdefed" startline="148" endline="155">
{
    struct cpuinfo_x86 *c = &boot_cpu_data;
    if (c->x86_vendor != X86_VENDOR_INTEL)
        return -1;
    cpu_cstate_entry = alloc_percpu (struct cstate_entry);
    return 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/acpi/cstate.c.ifdefed" startline="158" endline="161">
{
    free_percpu (cpu_cstate_entry);
    cpu_cstate_entry = NULL;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/acpi/realmode/wakemain.c.ifdefed" startline="5" endline="8">
{
    while (loops--)
        io_delay ();
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/acpi/realmode/wakemain.c.ifdefed" startline="11" endline="32">
{
    u8 enable;
    if (!hz) {
        enable = 0x00;
    }
    else {
        u16 div = 1193181 / hz;
        outb (0xb6, 0x43);
        io_delay ();
        outb (div, 0x42);
        io_delay ();
        outb (div >> 8, 0x42);
        io_delay ();
        enable = 0x03;
    }
    inb (0x61);
    io_delay ();
    outb (enable, 0x61);
    io_delay ();
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/acpi/realmode/wakemain.c.ifdefed" startline="14" endline="16">
{
    enable = 0x00;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/acpi/realmode/wakemain.c.ifdefed" startline="16" endline="27">
{
    u16 div = 1193181 / hz;
    outb (0xb6, 0x43);
    io_delay ();
    outb (div, 0x42);
    io_delay ();
    outb (div >> 8, 0x42);
    io_delay ();
    enable = 0x03;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/acpi/realmode/wakemain.c.ifdefed" startline="40" endline="62">
{
    char s;
    while ((s = *pattern++)) {
        switch (s) {
        case '.' :
            beep (DOT_HZ);
            udelay (US_PER_DOT);
            beep (0);
            udelay (US_PER_DOT);
            break;
        case '-' :
            beep (DASH_HZ);
            udelay (US_PER_DOT * 3);
            beep (0);
            udelay (US_PER_DOT);
            break;
        default :
            udelay (US_PER_DOT *3);
            break;
        }
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/acpi/realmode/wakemain.c.ifdefed" startline="43" endline="61">
{
    switch (s) {
    case '.' :
        beep (DOT_HZ);
        udelay (US_PER_DOT);
        beep (0);
        udelay (US_PER_DOT);
        break;
    case '-' :
        beep (DASH_HZ);
        udelay (US_PER_DOT * 3);
        beep (0);
        udelay (US_PER_DOT);
        break;
    default :
        udelay (US_PER_DOT *3);
        break;
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/acpi/realmode/wakemain.c.ifdefed" startline="44" endline="60">
{
case '.' :
    beep (DOT_HZ);
    udelay (US_PER_DOT);
    beep (0);
    udelay (US_PER_DOT);
    break;
case '-' :
    beep (DASH_HZ);
    udelay (US_PER_DOT * 3);
    beep (0);
    udelay (US_PER_DOT);
    break;
default :
    udelay (US_PER_DOT *3);
    break;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/acpi/realmode/wakemain.c.ifdefed" startline="65" endline="81">
{
    if (wakeup_header.real_magic != 0x12345678)
        while (1)
            ;
    if (wakeup_header.realmode_flags & 4)
        send_morse ("...-");
    if (wakeup_header.realmode_flags & 1)
        asm volatile ("lcallw   $0xc000,$3"
        );
    if (wakeup_header.realmode_flags & 2) {
        probe_cards (0);
        set_mode (wakeup_header.video_mode);
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/acpi/realmode/wakemain.c.ifdefed" startline="76" endline="80">
{
    probe_cards (0);
    set_mode (wakeup_header.video_mode);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/acpi/processor.c.ifdefed" startline="16" endline="73">
{
    struct acpi_object_list *obj_list;
    union acpi_object *obj;
    u32 *buf;
    obj_list = kmalloc (sizeof (struct acpi_object_list), GFP_KERNEL);
    if (!obj_list) {
        printk (KERN_ERR "Memory allocation error\n");
        return;
    }
    obj = kmalloc (sizeof (union acpi_object), GFP_KERNEL);
    if (!obj) {
        printk (KERN_ERR "Memory allocation error\n");
        kfree (obj_list);
        return;
    }
    buf = kmalloc (12, GFP_KERNEL);
    if (!buf) {
        printk (KERN_ERR "Memory allocation error\n");
        kfree (obj);
        kfree (obj_list);
        return;
    }
    buf[0] = ACPI_PDC_REVISION_ID;
    buf[1] = 1;
    buf[2] = ACPI_PDC_C_CAPABILITY_SMP;
    buf[2] |= ACPI_PDC_SMP_T_SWCOORD;
    if (cpu_has (c, X86_FEATURE_EST))
        buf[2] |= ACPI_PDC_EST_CAPABILITY_SWSMP;
    if (cpu_has (c, X86_FEATURE_ACPI))
        buf[2] |= ACPI_PDC_T_FFH;
    if (!cpu_has (c, X86_FEATURE_MWAIT))
        buf[2] &= ~(ACPI_PDC_C_C2C3_FFH);
    obj->type = ACPI_TYPE_BUFFER;
    obj->buffer.length = 12;
    obj->buffer.pointer = (u8 *) buf;
    obj_list->count = 1;
    obj_list->pointer = obj;
    pr->pdc = obj_list;
    return;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/acpi/processor.c.ifdefed" startline="23" endline="26">
{
    printk (KERN_ERR "Memory allocation error\n");
    return;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/acpi/processor.c.ifdefed" startline="29" endline="33">
{
    printk (KERN_ERR "Memory allocation error\n");
    kfree (obj_list);
    return;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/acpi/processor.c.ifdefed" startline="36" endline="41">
{
    printk (KERN_ERR "Memory allocation error\n");
    kfree (obj);
    kfree (obj_list);
    return;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/acpi/processor.c.ifdefed" startline="77" endline="85">
{
    struct cpuinfo_x86 *c = &cpu_data (pr->id);
    pr->pdc = NULL;
    if (c->x86_vendor == X86_VENDOR_INTEL)
        init_intel_pdc (pr, c);
    return;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/acpi/boot.c.ifdefed" startline="126" endline="156">
{
    unsigned long base, offset, mapped_size;
    int idx;
    if (!phys || !size)
        return NULL;
    if (phys + size <= (max_low_pfn_mapped << PAGE_SHIFT))
        return __va (phys);
    offset = phys & (PAGE_SIZE - 1);
    mapped_size = PAGE_SIZE - offset;
    clear_fixmap (FIX_ACPI_END);
    set_fixmap (FIX_ACPI_END, phys);
    base = fix_to_virt (FIX_ACPI_END);
    idx = FIX_ACPI_END;
    while (mapped_size < size) {
        if (--idx < FIX_ACPI_BEGIN)
            return NULL;
        phys += PAGE_SIZE;
        clear_fixmap (idx);
        set_fixmap (idx, phys);
        mapped_size += PAGE_SIZE;
    }
    return ((unsigned char *) base + offset);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/acpi/boot.c.ifdefed" startline="146" endline="153">
{
    if (--idx < FIX_ACPI_BEGIN)
        return NULL;
    phys += PAGE_SIZE;
    clear_fixmap (idx);
    set_fixmap (idx, phys);
    mapped_size += PAGE_SIZE;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/acpi/boot.c.ifdefed" startline="464" endline="497">
{
    unsigned int mask = 1 << irq;
    unsigned int old, new;
    old = inb (0x4d0) | (inb (0x4d1) << 8);
    new = acpi_noirq ? old : 0;
    switch (trigger) {
    case 1 :
        new &= ~mask;
        break;
    case 3 :
        new |= mask;
        break;
    }
    if (old == new)
        return;
    printk (PREFIX "setting ELCR to %04x (from %04x)\n", new, old);
    outb (new, 0x4d0);
    outb (new >> 8, 0x4d1);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/acpi/boot.c.ifdefed" startline="482" endline="489">
{
case 1 :
    new &= ~mask;
    break;
case 3 :
    new |= mask;
    break;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/acpi/boot.c.ifdefed" startline="500" endline="503">
{
    *irq = gsi;
    return 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/acpi/boot.c.ifdefed" startline="510" endline="531">
{
    unsigned int irq;
    unsigned int plat_gsi = gsi;
    acpi_gsi_to_irq (plat_gsi, & irq);
    return irq;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/acpi/boot.c.ifdefed" startline="613" endline="616">
{
    return -EINVAL;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/acpi/boot.c.ifdefed" startline="621" endline="624">
{
    return -EINVAL;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/acpi/boot.c.ifdefed" startline="629" endline="641">
{
    struct acpi_table_boot *sb;
    sb = (struct acpi_table_boot *) table;
    if (!sb) {
        printk (KERN_WARNING PREFIX "Unable to map SBF\n");
        return -ENODEV;
    }
    sbf_port = sb->cmos_index;
    return 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/acpi/boot.c.ifdefed" startline="633" endline="636">
{
    printk (KERN_WARNING PREFIX "Unable to map SBF\n");
    return -ENODEV;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/acpi/boot.c.ifdefed" startline="737" endline="764">
{
    return 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/acpi/boot.c.ifdefed" startline="1295" endline="1297">
{
    return -1;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/acpi/boot.c.ifdefed" startline="1301" endline="1325">
{
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/acpi/boot.c.ifdefed" startline="1328" endline="1368">
{
    return;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/acpi/boot.c.ifdefed" startline="1371" endline="1378">
{
    if (!acpi_force) {
        printk (KERN_NOTICE "%s detected: force use of acpi=noirq\n", d -> ident);
        acpi_noirq_set ();
    }
    return 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/acpi/boot.c.ifdefed" startline="1372" endline="1376">
{
    printk (KERN_NOTICE "%s detected: force use of acpi=noirq\n", d -> ident);
    acpi_noirq_set ();
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/acpi/boot.c.ifdefed" startline="1381" endline="1388">
{
    if (!acpi_force) {
        printk (KERN_NOTICE "%s detected: force use of pci=noacpi\n", d -> ident);
        acpi_disable_pci ();
    }
    return 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/acpi/boot.c.ifdefed" startline="1382" endline="1386">
{
    printk (KERN_NOTICE "%s detected: force use of pci=noacpi\n", d -> ident);
    acpi_disable_pci ();
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/acpi/boot.c.ifdefed" startline="1391" endline="1400">
{
    if (!acpi_force) {
        printk (KERN_NOTICE "%s detected: acpi off\n", d -> ident);
        disable_acpi ();
    }
    else {
        printk (KERN_NOTICE "Warning: DMI blacklist says broken, but acpi forced\n");
    }
    return 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/acpi/boot.c.ifdefed" startline="1392" endline="1395">
{
    printk (KERN_NOTICE "%s detected: acpi off\n", d -> ident);
    disable_acpi ();
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/acpi/boot.c.ifdefed" startline="1395" endline="1398">
{
    printk (KERN_NOTICE "Warning: DMI blacklist says broken, but acpi forced\n");
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/acpi/boot.c.ifdefed" startline="1406" endline="1417">
{
    if (!acpi_force) {
        printk (KERN_NOTICE "%s detected: force use of acpi=ht\n", d -> ident);
        disable_acpi ();
        acpi_ht = 1;
    }
    else {
        printk (KERN_NOTICE "Warning: acpi=force overrules DMI blacklist: acpi=ht\n");
    }
    return 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/acpi/boot.c.ifdefed" startline="1407" endline="1412">
{
    printk (KERN_NOTICE "%s detected: force use of acpi=ht\n", d -> ident);
    disable_acpi ();
    acpi_ht = 1;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/acpi/boot.c.ifdefed" startline="1412" endline="1415">
{
    printk (KERN_NOTICE "Warning: acpi=force overrules DMI blacklist: acpi=ht\n");
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/acpi/boot.c.ifdefed" startline="1423" endline="1427">
{
    pr_notice ("%s detected: Ignoring BIOS IRQ0 pin2 override\n", d -> ident);
    acpi_skip_timer_override = 1;
    return 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/acpi/boot.c.ifdefed" startline="1665" endline="1703">
{
    int error;
    dmi_check_system (acpi_dmi_table);
    if (acpi_disabled && !acpi_ht)
        return 1;
    error = acpi_table_init ();
    if (error) {
        disable_acpi ();
        return error;
    }
    acpi_table_parse (ACPI_SIG_BOOT, acpi_parse_sbf);
    error = acpi_blacklisted ();
    if (error) {
        if (acpi_force) {
            printk (KERN_WARNING PREFIX "acpi=force override\n");
        }
        else {
            printk (KERN_WARNING PREFIX "Disabling ACPI support\n");
            disable_acpi ();
            return error;
        }
    }
    return 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/acpi/boot.c.ifdefed" startline="1681" endline="1684">
{
    disable_acpi ();
    return error;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/acpi/boot.c.ifdefed" startline="1692" endline="1700">
{
    if (acpi_force) {
        printk (KERN_WARNING PREFIX "acpi=force override\n");
    }
    else {
        printk (KERN_WARNING PREFIX "Disabling ACPI support\n");
        disable_acpi ();
        return error;
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/acpi/boot.c.ifdefed" startline="1693" endline="1695">
{
    printk (KERN_WARNING PREFIX "acpi=force override\n");
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/acpi/boot.c.ifdefed" startline="1695" endline="1699">
{
    printk (KERN_WARNING PREFIX "Disabling ACPI support\n");
    disable_acpi ();
    return error;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/acpi/boot.c.ifdefed" startline="1706" endline="1720">
{
    if (acpi_disabled && !acpi_ht)
        return 1;
    early_acpi_process_madt ();
    return 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/acpi/boot.c.ifdefed" startline="1723" endline="1746">
{
    if (acpi_disabled && !acpi_ht)
        return 1;
    acpi_table_parse (ACPI_SIG_BOOT, acpi_parse_sbf);
    acpi_table_parse (ACPI_SIG_FADT, acpi_parse_fadt);
    acpi_process_madt ();
    acpi_table_parse (ACPI_SIG_HPET, acpi_parse_hpet);
    return 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/acpi/boot.c.ifdefed" startline="1749" endline="1781">
{
    if (!arg)
        return -EINVAL;
    if (strcmp (arg, "off") == 0) {
        disable_acpi ();
    }
    else if (strcmp (arg, "force") == 0) {
        acpi_force = 1;
        acpi_ht = 1;
        acpi_disabled = 0;
    }
    else if (strcmp (arg, "strict") == 0) {
        acpi_strict = 1;
    }
    else if (strcmp (arg, "ht") == 0) {
        if (!acpi_force)
            disable_acpi ();
        acpi_ht = 1;
    }
    else if (strcmp (arg, "noirq") == 0) {
        acpi_noirq_set ();
    }
    else {
        return -EINVAL;
    }
    return 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/acpi/boot.c.ifdefed" startline="1754" endline="1756">
{
    disable_acpi ();
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/acpi/boot.c.ifdefed" startline="1758" endline="1762">
{
    acpi_force = 1;
    acpi_ht = 1;
    acpi_disabled = 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/acpi/boot.c.ifdefed" startline="1764" endline="1766">
{
    acpi_strict = 1;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/acpi/boot.c.ifdefed" startline="1768" endline="1772">
{
    if (!acpi_force)
        disable_acpi ();
    acpi_ht = 1;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/acpi/boot.c.ifdefed" startline="1774" endline="1776">
{
    acpi_noirq_set ();
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/acpi/boot.c.ifdefed" startline="1776" endline="1779">
{
    return -EINVAL;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/acpi/boot.c.ifdefed" startline="1786" endline="1790">
{
    if (arg && strcmp (arg, "noacpi") == 0)
        acpi_disable_pci ();
    return 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/acpi/boot.c.ifdefed" startline="1794" endline="1805">
{
    return 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/acpi/boot.c.ifdefed" startline="1824" endline="1842">
{
    if (!s)
        return -EINVAL;
    if (!strcmp (s, "edge"))
        acpi_sci_flags = ACPI_MADT_TRIGGER_EDGE | (acpi_sci_flags & ~ACPI_MADT_TRIGGER_MASK);
    else if (!strcmp (s, "level"))
        acpi_sci_flags = ACPI_MADT_TRIGGER_LEVEL | (acpi_sci_flags & ~ACPI_MADT_TRIGGER_MASK);
    else if (!strcmp (s, "high"))
        acpi_sci_flags = ACPI_MADT_POLARITY_ACTIVE_HIGH | (acpi_sci_flags & ~ACPI_MADT_POLARITY_MASK);
    else if (!strcmp (s, "low"))
        acpi_sci_flags = ACPI_MADT_POLARITY_ACTIVE_LOW | (acpi_sci_flags & ~ACPI_MADT_POLARITY_MASK);
    else
        return -EINVAL;
    return 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/acpi/boot.c.ifdefed" startline="1846" endline="1854">
{
    unsigned int old, new, val;
    do {
        old = *lock;
        new = (((old & ~0x3) + 2) + ((old >> 1) & 0x1));
        val = cmpxchg (lock, old, new);
    }
    while (unlikely (val != old));
    return (new < 3) ? -1 : 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/acpi/boot.c.ifdefed" startline="1848" endline="1852">
{
    old = *lock;
    new = (((old & ~0x3) + 2) + ((old >> 1) & 0x1));
    val = cmpxchg (lock, old, new);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/acpi/boot.c.ifdefed" startline="1857" endline="1865">
{
    unsigned int old, new, val;
    do {
        old = *lock;
        new = old & ~0x3;
        val = cmpxchg (lock, old, new);
    }
    while (unlikely (val != old));
    return old & 0x1;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/acpi/boot.c.ifdefed" startline="1859" endline="1863">
{
    old = *lock;
    new = old & ~0x3;
    val = cmpxchg (lock, old, new);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/apic_64.c.ifdefed" startline="97" endline="99">
{
    return GET_APIC_VERSION (apic_read (APIC_LVR));
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/apic_64.c.ifdefed" startline="105" endline="107">
{
    return 1;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/apic_64.c.ifdefed" startline="113" endline="119">
{
    if (boot_cpu_data.x86_vendor == X86_VENDOR_AMD && boot_cpu_data.x86 >= 0xf)
        return 1;
    return lapic_get_version () >= 0x14;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/apic_64.c.ifdefed" startline="122" endline="125">
{
    while (apic_read (APIC_ICR) & APIC_ICR_BUSY)
        cpu_relax ();
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/apic_64.c.ifdefed" startline="128" endline="141">
{
    u32 send_status;
    int timeout;
    timeout = 0;
    do {
        send_status = apic_read (APIC_ICR) & APIC_ICR_BUSY;
        if (!send_status)
            break;
        udelay (100);
    }
    while (timeout++ < 1000);
    return send_status;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/apic_64.c.ifdefed" startline="133" endline="138">
{
    send_status = apic_read (APIC_ICR) & APIC_ICR_BUSY;
    if (!send_status)
        break;
    udelay (100);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/apic_64.c.ifdefed" startline="147" endline="153">
{
    unsigned int v;
    v = APIC_DM_NMI;
    apic_write (APIC_LVT0, v);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/apic_64.c.ifdefed" startline="159" endline="165">
{
    unsigned int v, maxlvt;
    v = apic_read (APIC_LVR);
    maxlvt = GET_APIC_MAXLVT (v);
    return maxlvt;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/apic_64.c.ifdefed" startline="179" endline="200">
{
    unsigned int lvtt_value, tmp_value;
    lvtt_value = LOCAL_TIMER_VECTOR;
    if (!oneshot)
        lvtt_value |= APIC_LVT_TIMER_PERIODIC;
    if (!irqen)
        lvtt_value |= APIC_LVT_MASKED;
    apic_write (APIC_LVTT, lvtt_value);
    tmp_value = apic_read (APIC_TDCR);
    apic_write (APIC_TDCR, (tmp_value & ~ (APIC_TDR_DIV_1 | APIC_TDR_DIV_TMBASE)) | APIC_TDR_DIV_16);
    if (!oneshot)
        apic_write (APIC_TMICT, clocks);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/apic_64.c.ifdefed" startline="213" endline="218">
{
    unsigned long reg = (lvt_off << 4) + APIC_EILVT0;
    unsigned int v = (mask << 16) | (msg_type << 8) | vector;
    apic_write (reg, v);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/apic_64.c.ifdefed" startline="221" endline="224">
{
    setup_APIC_eilvt (APIC_EILVT_LVTOFF_MCE, vector, msg_type, mask);
    return APIC_EILVT_LVTOFF_MCE;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/apic_64.c.ifdefed" startline="227" endline="230">
{
    setup_APIC_eilvt (APIC_EILVT_LVTOFF_IBS, vector, msg_type, mask);
    return APIC_EILVT_LVTOFF_IBS;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/apic_64.c.ifdefed" startline="237" endline="240">
{
    apic_write (APIC_TMICT, delta);
    return 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/apic_64.c.ifdefed" startline="247" endline="275">
{
    unsigned long flags;
    unsigned int v;
    if (evt->features & CLOCK_EVT_FEAT_DUMMY)
        return;
    local_irq_save (flags);
    switch (mode) {
    case CLOCK_EVT_MODE_PERIODIC :
    case CLOCK_EVT_MODE_ONESHOT :
        __setup_APIC_LVTT (calibration_result, mode != CLOCK_EVT_MODE_PERIODIC, 1);
        break;
    case CLOCK_EVT_MODE_UNUSED :
    case CLOCK_EVT_MODE_SHUTDOWN :
        v = apic_read (APIC_LVTT);
        v |= (APIC_LVT_MASKED | LOCAL_TIMER_VECTOR);
        apic_write (APIC_LVTT, v);
        break;
    case CLOCK_EVT_MODE_RESUME :
        break;
    }
    local_irq_restore (flags);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/apic_64.c.ifdefed" startline="257" endline="272">
{
case CLOCK_EVT_MODE_PERIODIC :
case CLOCK_EVT_MODE_ONESHOT :
    __setup_APIC_LVTT (calibration_result, mode != CLOCK_EVT_MODE_PERIODIC, 1);
    break;
case CLOCK_EVT_MODE_UNUSED :
case CLOCK_EVT_MODE_SHUTDOWN :
    v = apic_read (APIC_LVTT);
    v |= (APIC_LVT_MASKED | LOCAL_TIMER_VECTOR);
    apic_write (APIC_LVTT, v);
    break;
case CLOCK_EVT_MODE_RESUME :
    break;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/apic_64.c.ifdefed" startline="281" endline="285">
{
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/apic_64.c.ifdefed" startline="292" endline="299">
{
    struct clock_event_device *levt = &__get_cpu_var (lapic_events);
    memcpy (levt, & lapic_clockevent, sizeof (* levt));
    levt->cpumask = cpumask_of_cpu (smp_processor_id ());
    clockevents_register_device (levt);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/apic_64.c.ifdefed" startline="317" endline="381">
{
    unsigned apic, apic_start;
    unsigned long tsc, tsc_start;
    int result;
    local_irq_disable ();
    __setup_APIC_LVTT (250000000, 0, 0);
    apic_start = apic_read (APIC_TMCCT);
    {
        rdtscll (tsc_start);
        do {
            apic = apic_read (APIC_TMCCT);
            rdtscll (tsc);
        }
        while ((tsc - tsc_start) < TICK_COUNT && (apic_start - apic) < TICK_COUNT);
        result = (apic_start - apic) * 1000L * tsc_khz / (tsc - tsc_start);
    }
    local_irq_enable ();
    printk (KERN_DEBUG "APIC timer calibration result %d\n", result);
    printk (KERN_INFO "Detected %d.%03d MHz APIC timer.\n", result / 1000 / 1000, result / 1000 % 1000);
    lapic_clockevent.mult = div_sc (result, NSEC_PER_SEC, lapic_clockevent.shift);
    lapic_clockevent.max_delta_ns = clockevent_delta2ns (0x7FFFFF, &lapic_clockevent);
    lapic_clockevent.min_delta_ns = clockevent_delta2ns (0xF, &lapic_clockevent);
    calibration_result = result / HZ;
    if (calibration_result < (1000000 / HZ)) {
        printk (KERN_WARNING "APIC frequency too slow, disabling apic timer\n");
        return -1;
    }
    return 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/apic_64.c.ifdefed" startline="341" endline="352">
{
    rdtscll (tsc_start);
    do {
        apic = apic_read (APIC_TMCCT);
        rdtscll (tsc);
    }
    while ((tsc - tsc_start) < TICK_COUNT && (apic_start - apic) < TICK_COUNT);
    result = (apic_start - apic) * 1000L * tsc_khz / (tsc - tsc_start);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/apic_64.c.ifdefed" startline="344" endline="347">
{
    apic = apic_read (APIC_TMCCT);
    rdtscll (tsc);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/apic_64.c.ifdefed" startline="374" endline="378">
{
    printk (KERN_WARNING "APIC frequency too slow, disabling apic timer\n");
    return -1;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/apic_64.c.ifdefed" startline="389" endline="426">
{
    if (disable_apic_timer) {
        printk (KERN_INFO "Disabling APIC timer\n");
        if (num_possible_cpus () > 1) {
            lapic_clockevent.mult = 1;
            setup_APIC_timer ();
        }
        return;
    }
    printk (KERN_INFO "Using local APIC timer interrupts.\n");
    if (calibrate_APIC_clock ()) {
        if (num_possible_cpus () > 1)
            setup_APIC_timer ();
        return;
    }
    if (nmi_watchdog != NMI_IO_APIC)
        lapic_clockevent.features &= ~CLOCK_EVT_FEAT_DUMMY;
    else
        printk (KERN_WARNING "APIC timer registered as dummy," " due to nmi_watchdog=%d!\n", nmi_watchdog);
    setup_APIC_timer ();
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/apic_64.c.ifdefed" startline="396" endline="404">
{
    printk (KERN_INFO "Disabling APIC timer\n");
    if (num_possible_cpus () > 1) {
        lapic_clockevent.mult = 1;
        setup_APIC_timer ();
    }
    return;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/apic_64.c.ifdefed" startline="399" endline="402">
{
    lapic_clockevent.mult = 1;
    setup_APIC_timer ();
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/apic_64.c.ifdefed" startline="407" endline="412">
{
    if (num_possible_cpus () > 1)
        setup_APIC_timer ();
    return;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/apic_64.c.ifdefed" startline="429" endline="431">
{
    setup_APIC_timer ();
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/apic_64.c.ifdefed" startline="437" endline="466">
{
    int cpu = smp_processor_id ();
    struct clock_event_device *evt = &per_cpu (lapic_events, cpu);
    if (!evt->event_handler) {
        printk (KERN_WARNING "Spurious LAPIC timer interrupt on cpu %d\n", cpu);
        lapic_timer_setup (CLOCK_EVT_MODE_SHUTDOWN, evt);
        return;
    }
    add_pda (apic_timer_irqs, 1);
    evt->event_handler (evt);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/apic_64.c.ifdefed" startline="452" endline="458">
{
    printk (KERN_WARNING "Spurious LAPIC timer interrupt on cpu %d\n", cpu);
    lapic_timer_setup (CLOCK_EVT_MODE_SHUTDOWN, evt);
    return;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/apic_64.c.ifdefed" startline="477" endline="495">
{
    struct pt_regs *old_regs = set_irq_regs (regs);
    ack_APIC_irq ();
    exit_idle ();
    irq_enter ();
    local_apic_timer_interrupt ();
    irq_exit ();
    set_irq_regs (old_regs);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/apic_64.c.ifdefed" startline="498" endline="500">
{
    return -EINVAL;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/apic_64.c.ifdefed" startline="515" endline="559">
{
    int maxlvt;
    u32 v;
    if (!apic_phys)
        return;
    maxlvt = lapic_get_maxlvt ();
    if (maxlvt >= 3) {
        v = ERROR_APIC_VECTOR;
        apic_write (APIC_LVTERR, v | APIC_LVT_MASKED);
    }
    v = apic_read (APIC_LVTT);
    apic_write (APIC_LVTT, v | APIC_LVT_MASKED);
    v = apic_read (APIC_LVT0);
    apic_write (APIC_LVT0, v | APIC_LVT_MASKED);
    v = apic_read (APIC_LVT1);
    apic_write (APIC_LVT1, v | APIC_LVT_MASKED);
    if (maxlvt >= 4) {
        v = apic_read (APIC_LVTPC);
        apic_write (APIC_LVTPC, v | APIC_LVT_MASKED);
    }
    apic_write (APIC_LVTT, APIC_LVT_MASKED);
    apic_write (APIC_LVT0, APIC_LVT_MASKED);
    apic_write (APIC_LVT1, APIC_LVT_MASKED);
    if (maxlvt >= 3)
        apic_write (APIC_LVTERR, APIC_LVT_MASKED);
    if (maxlvt >= 4)
        apic_write (APIC_LVTPC, APIC_LVT_MASKED);
    apic_write (APIC_ESR, 0);
    apic_read (APIC_ESR);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/apic_64.c.ifdefed" startline="528" endline="531">
{
    v = ERROR_APIC_VECTOR;
    apic_write (APIC_LVTERR, v | APIC_LVT_MASKED);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/apic_64.c.ifdefed" startline="542" endline="545">
{
    v = apic_read (APIC_LVTPC);
    apic_write (APIC_LVTPC, v | APIC_LVT_MASKED);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/apic_64.c.ifdefed" startline="565" endline="577">
{
    unsigned int value;
    clear_local_APIC ();
    value = apic_read (APIC_SPIV);
    value &= ~APIC_SPIV_APIC_ENABLED;
    apic_write (APIC_SPIV, value);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/apic_64.c.ifdefed" startline="580" endline="591">
{
    unsigned long flags;
    if (!cpu_has_apic)
        return;
    local_irq_save (flags);
    disable_local_APIC ();
    local_irq_restore (flags);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/apic_64.c.ifdefed" startline="599" endline="652">
{
    unsigned int reg0, reg1;
    reg0 = apic_read (APIC_LVR);
    apic_printk (APIC_DEBUG, "Getting VERSION: %x\n", reg0);
    apic_write (APIC_LVR, reg0 ^ APIC_LVR_MASK);
    reg1 = apic_read (APIC_LVR);
    apic_printk (APIC_DEBUG, "Getting VERSION: %x\n", reg1);
    if (reg1 != reg0)
        return 0;
    reg1 = GET_APIC_VERSION (reg0);
    if (reg1 == 0x00 || reg1 == 0xff)
        return 0;
    reg1 = lapic_get_maxlvt ();
    if (reg1 < 0x02 || reg1 == 0xff)
        return 0;
    reg0 = read_apic_id ();
    apic_printk (APIC_DEBUG, "Getting ID: %x\n", reg0);
    apic_write (APIC_ID, reg0 ^ APIC_ID_MASK);
    reg1 = read_apic_id ();
    apic_printk (APIC_DEBUG, "Getting ID: %x\n", reg1);
    apic_write (APIC_ID, reg0);
    if (reg1 != (reg0 ^ APIC_ID_MASK))
        return 0;
    reg0 = apic_read (APIC_LVT0);
    apic_printk (APIC_DEBUG, "Getting LVT0: %x\n", reg0);
    reg1 = apic_read (APIC_LVT1);
    apic_printk (APIC_DEBUG, "Getting LVT1: %x\n", reg1);
    return 1;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/apic_64.c.ifdefed" startline="658" endline="671">
{
    if (modern_apic ())
        return;
    apic_wait_icr_idle ();
    apic_printk (APIC_DEBUG, "Synchronizing Arb IDs.\n");
    apic_write (APIC_ICR, APIC_DEST_ALLINC | APIC_INT_LEVELTRIG | APIC_DM_INIT);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/apic_64.c.ifdefed" startline="677" endline="710">
{
    unsigned int value;
    if (smp_found_config || !cpu_has_apic)
        return;
    value = apic_read (APIC_LVR);
    clear_local_APIC ();
    value = apic_read (APIC_SPIV);
    value &= ~APIC_VECTOR_MASK;
    value |= APIC_SPIV_APIC_ENABLED;
    value |= APIC_SPIV_FOCUS_DISABLED;
    value |= SPURIOUS_APIC_VECTOR;
    apic_write (APIC_SPIV, value);
    apic_write (APIC_LVT0, APIC_DM_EXTINT);
    value = APIC_DM_NMI;
    apic_write (APIC_LVT1, value);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/apic_64.c.ifdefed" startline="716" endline="815">
{
    unsigned int value;
    int i, j;
    preempt_disable ();
    value = apic_read (APIC_LVR);
    BUILD_BUG_ON ((SPURIOUS_APIC_VECTOR & 0x0f) != 0x0f);
    if (!apic_id_registered ())
        BUG ();
    init_apic_ldr ();
    value = apic_read (APIC_TASKPRI);
    value &= ~APIC_TPRI_MASK;
    apic_write (APIC_TASKPRI, value);
    for (i = APIC_ISR_NR - 1; i >= 0; i--) {
        value = apic_read (APIC_ISR +i * 0x10);
        for (j = 31; j >= 0; j--) {
            if (value & (1 << j))
                ack_APIC_irq ();
        }
    }
    value = apic_read (APIC_SPIV);
    value &= ~APIC_VECTOR_MASK;
    value |= APIC_SPIV_APIC_ENABLED;
    value |= SPURIOUS_APIC_VECTOR;
    apic_write (APIC_SPIV, value);
    value = apic_read (APIC_LVT0) & APIC_LVT_MASKED;
    if (!smp_processor_id () && !value) {
        value = APIC_DM_EXTINT;
        apic_printk (APIC_VERBOSE, "enabled ExtINT on CPU#%d\n", smp_processor_id ());
    }
    else {
        value = APIC_DM_EXTINT | APIC_LVT_MASKED;
        apic_printk (APIC_VERBOSE, "masked ExtINT on CPU#%d\n", smp_processor_id ());
    }
    apic_write (APIC_LVT0, value);
    if (!smp_processor_id ())
        value = APIC_DM_NMI;
    else
        value = APIC_DM_NMI | APIC_LVT_MASKED;
    apic_write (APIC_LVT1, value);
    preempt_enable ();
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/apic_64.c.ifdefed" startline="758" endline="764">
{
    value = apic_read (APIC_ISR +i * 0x10);
    for (j = 31; j >= 0; j--) {
        if (value & (1 << j))
            ack_APIC_irq ();
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/apic_64.c.ifdefed" startline="760" endline="763">
{
    if (value & (1 << j))
        ack_APIC_irq ();
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/apic_64.c.ifdefed" startline="795" endline="799">
{
    value = APIC_DM_EXTINT;
    apic_printk (APIC_VERBOSE, "enabled ExtINT on CPU#%d\n", smp_processor_id ());
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/apic_64.c.ifdefed" startline="799" endline="803">
{
    value = APIC_DM_EXTINT | APIC_LVT_MASKED;
    apic_printk (APIC_VERBOSE, "masked ExtINT on CPU#%d\n", smp_processor_id ());
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/apic_64.c.ifdefed" startline="818" endline="827">
{
    unsigned maxlvt = lapic_get_maxlvt ();
    apic_write (APIC_LVTERR, ERROR_APIC_VECTOR);
    if (maxlvt > 3)
        apic_write (APIC_ESR, 0);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/apic_64.c.ifdefed" startline="830" endline="834">
{
    lapic_setup_esr ();
    setup_apic_nmi_watchdog (NULL);
    apic_pm_activate ();
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/apic_64.c.ifdefed" startline="843" endline="852">
{
    if (!cpu_has_apic) {
        printk (KERN_INFO "No local APIC present\n");
        return -1;
    }
    mp_lapic_addr = APIC_DEFAULT_PHYS_BASE;
    boot_cpu_physical_apicid = 0;
    return 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/apic_64.c.ifdefed" startline="844" endline="847">
{
    printk (KERN_INFO "No local APIC present\n");
    return -1;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/apic_64.c.ifdefed" startline="855" endline="876">
{
    unsigned long phys_addr;
    if (!smp_found_config)
        return;
    phys_addr = mp_lapic_addr;
    set_fixmap_nocache (FIX_APIC_BASE, phys_addr);
    apic_printk (APIC_VERBOSE, "mapped APIC to %16lx (%16lx)\n", APIC_BASE, phys_addr);
    boot_cpu_physical_apicid = GET_APIC_ID (read_apic_id ());
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/apic_64.c.ifdefed" startline="882" endline="903">
{
    if (!smp_found_config && detect_init_APIC ()) {
        apic_phys = (unsigned long) alloc_bootmem_pages (PAGE_SIZE);
        apic_phys = __pa (apic_phys);
    }
    else
        apic_phys = mp_lapic_addr;
    set_fixmap_nocache (FIX_APIC_BASE, apic_phys);
    apic_printk (APIC_VERBOSE, "mapped APIC to %16lx (%16lx)\n", APIC_BASE, apic_phys);
    boot_cpu_physical_apicid = GET_APIC_ID (read_apic_id ());
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/apic_64.c.ifdefed" startline="888" endline="891">
{
    apic_phys = (unsigned long) alloc_bootmem_pages (PAGE_SIZE);
    apic_phys = __pa (apic_phys);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/apic_64.c.ifdefed" startline="910" endline="948">
{
    if (disable_apic) {
        printk (KERN_INFO "Apic disabled\n");
        return -1;
    }
    if (!cpu_has_apic) {
        disable_apic = 1;
        printk (KERN_INFO "Apic disabled by BIOS\n");
        return -1;
    }
    verify_local_APIC ();
    connect_bsp_APIC ();
    physid_set_mask_of_physid (boot_cpu_physical_apicid, & phys_cpu_present_map);
    apic_write (APIC_ID, SET_APIC_ID (boot_cpu_physical_apicid));
    setup_local_APIC ();
    if (!skip_ioapic_setup && nr_ioapics)
        enable_IO_APIC ();
    if (!smp_found_config || skip_ioapic_setup || !nr_ioapics)
        localise_nmi_watchdog ();
    end_local_APIC_setup ();
    if (smp_found_config && !skip_ioapic_setup && nr_ioapics)
        setup_IO_APIC ();
    else
        nr_ioapics = 0;
    setup_boot_APIC_clock ();
    check_nmi_watchdog ();
    return 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/apic_64.c.ifdefed" startline="911" endline="914">
{
    printk (KERN_INFO "Apic disabled\n");
    return -1;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/apic_64.c.ifdefed" startline="915" endline="919">
{
    disable_apic = 1;
    printk (KERN_INFO "Apic disabled by BIOS\n");
    return -1;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/apic_64.c.ifdefed" startline="958" endline="973">
{
    unsigned int v;
    exit_idle ();
    irq_enter ();
    v = apic_read (APIC_ISR +((SPURIOUS_APIC_VECTOR & ~0x1f) >> 1));
    if (v & (1 << (SPURIOUS_APIC_VECTOR & 0x1f)))
        ack_APIC_irq ();
    add_pda (irq_spurious_count, 1);
    irq_exit ();
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/apic_64.c.ifdefed" startline="979" endline="1004">
{
    unsigned int v, v1;
    exit_idle ();
    irq_enter ();
    v = apic_read (APIC_ESR);
    apic_write (APIC_ESR, 0);
    v1 = apic_read (APIC_ESR);
    ack_APIC_irq ();
    atomic_inc (& irq_err_count);
    printk (KERN_DEBUG "APIC error on CPU%d: %02x(%02x)\n", smp_processor_id (), v, v1);
    irq_exit ();
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/apic_64.c.ifdefed" startline="1010" endline="1012">
{
    enable_apic_mode ();
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/apic_64.c.ifdefed" startline="1015" endline="1051">
{
    unsigned long value;
    value = apic_read (APIC_SPIV);
    value &= ~APIC_VECTOR_MASK;
    value |= APIC_SPIV_APIC_ENABLED;
    value |= 0xf;
    apic_write (APIC_SPIV, value);
    if (!virt_wire_setup) {
        value = apic_read (APIC_LVT0);
        value &= ~(APIC_MODE_MASK | APIC_SEND_PENDING | APIC_INPUT_POLARITY | APIC_LVT_REMOTE_IRR | APIC_LVT_LEVEL_TRIGGER | APIC_LVT_MASKED);
        value |= APIC_LVT_REMOTE_IRR | APIC_SEND_PENDING;
        value = SET_APIC_DELIVERY_MODE (value, APIC_MODE_EXTINT);
        apic_write (APIC_LVT0, value);
    }
    else {
        apic_write (APIC_LVT0, APIC_LVT_MASKED);
    }
    value = apic_read (APIC_LVT1);
    value &= ~(APIC_MODE_MASK | APIC_SEND_PENDING | APIC_INPUT_POLARITY | APIC_LVT_REMOTE_IRR | APIC_LVT_LEVEL_TRIGGER | APIC_LVT_MASKED);
    value |= APIC_LVT_REMOTE_IRR | APIC_SEND_PENDING;
    value = SET_APIC_DELIVERY_MODE (value, APIC_MODE_NMI);
    apic_write (APIC_LVT1, value);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/apic_64.c.ifdefed" startline="1026" endline="1038">
{
    value = apic_read (APIC_LVT0);
    value &= ~(APIC_MODE_MASK | APIC_SEND_PENDING | APIC_INPUT_POLARITY | APIC_LVT_REMOTE_IRR | APIC_LVT_LEVEL_TRIGGER | APIC_LVT_MASKED);
    value |= APIC_LVT_REMOTE_IRR | APIC_SEND_PENDING;
    value = SET_APIC_DELIVERY_MODE (value, APIC_MODE_EXTINT);
    apic_write (APIC_LVT0, value);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/apic_64.c.ifdefed" startline="1038" endline="1041">
{
    apic_write (APIC_LVT0, APIC_LVT_MASKED);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/apic_64.c.ifdefed" startline="1054" endline="1094">
{
    int cpu;
    cpumask_t tmp_map;
    if (num_processors >= NR_CPUS) {
        printk (KERN_WARNING "WARNING: NR_CPUS limit of %i reached." " Processor ignored.\n", NR_CPUS);
        return;
    }
    num_processors++;
    cpus_complement (tmp_map, cpu_present_map);
    cpu = first_cpu (tmp_map);
    physid_set (apicid, phys_cpu_present_map);
    if (apicid == boot_cpu_physical_apicid) {
        cpu = 0;
    }
    if (apicid > max_physical_apicid)
        max_physical_apicid = apicid;
    if (early_per_cpu_ptr (x86_cpu_to_apicid)) {
        u16 *cpu_to_apicid = early_per_cpu_ptr (x86_cpu_to_apicid);
        u16 *bios_cpu_apicid = early_per_cpu_ptr (x86_bios_cpu_apicid);
        cpu_to_apicid[cpu] = apicid;
        bios_cpu_apicid[cpu] = apicid;
    }
    else {
        per_cpu (x86_cpu_to_apicid, cpu) = apicid;
        per_cpu (x86_bios_cpu_apicid, cpu) = apicid;
    }
    cpu_set (cpu, cpu_possible_map);
    cpu_set (cpu, cpu_present_map);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/apic_64.c.ifdefed" startline="1058" endline="1062">
{
    printk (KERN_WARNING "WARNING: NR_CPUS limit of %i reached." " Processor ignored.\n", NR_CPUS);
    return;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/apic_64.c.ifdefed" startline="1069" endline="1076">
{
    cpu = 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/apic_64.c.ifdefed" startline="1081" endline="1087">
{
    u16 *cpu_to_apicid = early_per_cpu_ptr (x86_cpu_to_apicid);
    u16 *bios_cpu_apicid = early_per_cpu_ptr (x86_bios_cpu_apicid);
    cpu_to_apicid[cpu] = apicid;
    bios_cpu_apicid[cpu] = apicid;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/apic_64.c.ifdefed" startline="1087" endline="1090">
{
    per_cpu (x86_cpu_to_apicid, cpu) = apicid;
    per_cpu (x86_bios_cpu_apicid, cpu) = apicid;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/apic_64.c.ifdefed" startline="1230" endline="1230">
{
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/apic_64.c.ifdefed" startline="1244" endline="1308">
{
    int i, clusters, zeros;
    unsigned id;
    u16 *bios_cpu_apicid;
    DECLARE_BITMAP (clustermap, NUM_APIC_CLUSTERS);
    if ((boot_cpu_data.x86_vendor == X86_VENDOR_AMD) && !is_vsmp_box ())
        return 0;
    bios_cpu_apicid = early_per_cpu_ptr (x86_bios_cpu_apicid);
    bitmap_zero (clustermap, NUM_APIC_CLUSTERS);
    for (i = 0; i < NR_CPUS; i++) {
        if (bios_cpu_apicid) {
            id = bios_cpu_apicid[i];
        }
        else if (i < nr_cpu_ids) {
            if (cpu_present (i))
                id = per_cpu (x86_bios_cpu_apicid, i);
            else
                continue;
        }
        else
            break;
        if (id != BAD_APICID)
            __set_bit (APIC_CLUSTERID (id), clustermap);
    }
    clusters = 0;
    zeros = 0;
    for (i = 0; i < NUM_APIC_CLUSTERS; i++) {
        if (test_bit (i, clustermap)) {
            clusters += 1 + zeros;
            zeros = 0;
        }
        else
            ++zeros;
    }
    if (is_vsmp_box () && clusters > 1)
        return 1;
    return (clusters > 2);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/apic_64.c.ifdefed" startline="1262" endline="1278">
{
    if (bios_cpu_apicid) {
        id = bios_cpu_apicid[i];
    }
    else if (i < nr_cpu_ids) {
        if (cpu_present (i))
            id = per_cpu (x86_bios_cpu_apicid, i);
        else
            continue;
    }
    else
        break;
    if (id != BAD_APICID)
        __set_bit (APIC_CLUSTERID (id), clustermap);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/apic_64.c.ifdefed" startline="1264" endline="1266">
{
    id = bios_cpu_apicid[i];
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/apic_64.c.ifdefed" startline="1267" endline="1272">
{
    if (cpu_present (i))
        id = per_cpu (x86_bios_cpu_apicid, i);
    else
        continue;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/apic_64.c.ifdefed" startline="1288" endline="1294">
{
    if (test_bit (i, clustermap)) {
        clusters += 1 + zeros;
        zeros = 0;
    }
    else
        ++zeros;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/apic_64.c.ifdefed" startline="1289" endline="1292">
{
    clusters += 1 + zeros;
    zeros = 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/apic_64.c.ifdefed" startline="1314" endline="1331">
{
    if (str == NULL) {
        skip_ioapic_setup = 0;
        ioapic_force = 1;
        return 0;
    }
    if (strcmp ("debug", str) == 0)
        apic_verbosity = APIC_DEBUG;
    else if (strcmp ("verbose", str) == 0)
        apic_verbosity = APIC_VERBOSE;
    else {
        printk (KERN_WARNING "APIC Verbosity level %s not recognised" " use apic=verbose or apic=debug\n", str);
        return -EINVAL;
    }
    return 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/apic_64.c.ifdefed" startline="1315" endline="1319">
{
    skip_ioapic_setup = 0;
    ioapic_force = 1;
    return 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/apic_64.c.ifdefed" startline="1324" endline="1328">
{
    printk (KERN_WARNING "APIC Verbosity level %s not recognised" " use apic=verbose or apic=debug\n", str);
    return -EINVAL;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/apic_64.c.ifdefed" startline="1335" endline="1339">
{
    disable_apic = 1;
    setup_clear_cpu_cap (X86_FEATURE_APIC);
    return 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/apic_64.c.ifdefed" startline="1344" endline="1346">
{
    return setup_disableapic (str);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/apic_64.c.ifdefed" startline="1350" endline="1353">
{
    local_apic_timer_c2_ok = 1;
    return 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/apic_64.c.ifdefed" startline="1357" endline="1362">
{
    if (str[0] != ' ' && str[0] != 0)
        return 0;
    disable_apic_timer = 1;
    return 1;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/apic_64.c.ifdefed" startline="1366" endline="1370">
{
    apic_calibrate_pmtmr = 1;
    notsc_setup (NULL);
    return 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/apic_64.c.ifdefed" startline="1374" endline="1384">
{
    if (!apic_phys)
        return -1;
    lapic_resource.start = apic_phys;
    lapic_resource.end = lapic_resource.start + PAGE_SIZE - 1;
    insert_resource (& iomem_resource, & lapic_resource);
    return 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/module_64.c.ifdefed" startline="37" endline="41">
{
    vfree (module_region);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/module_64.c.ifdefed" startline="44" endline="58">
{
    struct vm_struct *area;
    if (!size)
        return NULL;
    size = PAGE_ALIGN (size);
    if (size > MODULES_LEN)
        return NULL;
    area = __get_vm_area (size, VM_ALLOC, MODULES_VADDR, MODULES_END);
    if (!area)
        return NULL;
    return __vmalloc_area (area, GFP_KERNEL, PAGE_KERNEL_EXEC);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/module_64.c.ifdefed" startline="66" endline="68">
{
    return 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/module_64.c.ifdefed" startline="75" endline="138">
{
    unsigned int i;
    Elf64_Rela *rel = (void *) sechdrs[relsec].sh_addr;
    Elf64_Sym *sym;
    void *loc;
    u64 val;
    DEBUGP ("Applying relocate section %u to %u\n", relsec, sechdrs [relsec].sh_info);
    for (i = 0; i < sechdrs[relsec].sh_size / sizeof (*rel); i++) {
        loc = (void *) sechdrs[sechdrs[relsec].sh_info].sh_addr + rel[i].r_offset;
        sym = (Elf64_Sym *) sechdrs[symindex].sh_addr + ELF64_R_SYM (rel[i].r_info);
        DEBUGP ("type %d st_value %Lx r_addend %Lx loc %Lx\n", (int) ELF64_R_TYPE (rel [i].r_info), sym -> st_value, rel [i].r_addend, (u64) loc);
        val = sym->st_value + rel[i].r_addend;
        switch (ELF64_R_TYPE (rel[i].r_info)) {
        case R_X86_64_NONE :
            break;
        case R_X86_64_64 :
            *(u64*) loc = val;
            break;
        case R_X86_64_32 :
            *(u32*) loc = val;
            if (val != *(u32*) loc)
                goto overflow;
            break;
        case R_X86_64_32S :
            *(s32*) loc = val;
            if ((s64) val != *(s32*) loc)
                goto overflow;
            break;
        case R_X86_64_PC32 :
            val -= (u64) loc;
            *(u32*) loc = val;
            break;
        default :
            printk (KERN_ERR "module %s: Unknown rela relocation: %Lu\n", me->name, ELF64_R_TYPE (rel[i].r_info));
            return -ENOEXEC;
        }
    }
    return 0;
overflow :
    printk (KERN_ERR "overflow in relocation type %d val %Lx\n", (int) ELF64_R_TYPE (rel[i].r_info), val);
    printk (KERN_ERR "`%s' likely not compiled with -mcmodel=kernel\n", me -> name);
    return -ENOEXEC;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/module_64.c.ifdefed" startline="84" endline="129">
{
    loc = (void *) sechdrs[sechdrs[relsec].sh_info].sh_addr + rel[i].r_offset;
    sym = (Elf64_Sym *) sechdrs[symindex].sh_addr + ELF64_R_SYM (rel[i].r_info);
    DEBUGP ("type %d st_value %Lx r_addend %Lx loc %Lx\n", (int) ELF64_R_TYPE (rel [i].r_info), sym -> st_value, rel [i].r_addend, (u64) loc);
    val = sym->st_value + rel[i].r_addend;
    switch (ELF64_R_TYPE (rel[i].r_info)) {
    case R_X86_64_NONE :
        break;
    case R_X86_64_64 :
        *(u64*) loc = val;
        break;
    case R_X86_64_32 :
        *(u32*) loc = val;
        if (val != *(u32*) loc)
            goto overflow;
        break;
    case R_X86_64_32S :
        *(s32*) loc = val;
        if ((s64) val != *(s32*) loc)
            goto overflow;
        break;
    case R_X86_64_PC32 :
        val -= (u64) loc;
        *(u32*) loc = val;
        break;
    default :
        printk (KERN_ERR "module %s: Unknown rela relocation: %Lu\n", me->name, ELF64_R_TYPE (rel[i].r_info));
        return -ENOEXEC;
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/module_64.c.ifdefed" startline="100" endline="128">
{
case R_X86_64_NONE :
    break;
case R_X86_64_64 :
    *(u64*) loc = val;
    break;
case R_X86_64_32 :
    *(u32*) loc = val;
    if (val != *(u32*) loc)
        goto overflow;
    break;
case R_X86_64_32S :
    *(s32*) loc = val;
    if ((s64) val != *(s32*) loc)
        goto overflow;
    break;
case R_X86_64_PC32 :
    val -= (u64) loc;
    *(u32*) loc = val;
    break;
default :
    printk (KERN_ERR "module %s: Unknown rela relocation: %Lu\n", me->name, ELF64_R_TYPE (rel[i].r_info));
    return -ENOEXEC;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/module_64.c.ifdefed" startline="145" endline="148">
{
    printk ("non add relocation not supported\n");
    return -ENOSYS;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/module_64.c.ifdefed" startline="153" endline="188">
{
    const Elf_Shdr *s, *text = NULL, *alt = NULL, *locks = NULL, *para = NULL;
    char *secstrings = (void *) hdr + sechdrs[hdr->e_shstrndx].sh_offset;
    for (s = sechdrs; s < sechdrs + hdr->e_shnum; s++) {
        if (!strcmp (".text", secstrings +s->sh_name))
            text = s;
        if (!strcmp (".altinstructions", secstrings +s->sh_name))
            alt = s;
        if (!strcmp (".smp_locks", secstrings +s->sh_name))
            locks = s;
        if (!strcmp (".parainstructions", secstrings +s->sh_name))
            para = s;
    }
    if (alt) {
        void *aseg = (void *) alt->sh_addr;
        apply_alternatives (aseg, aseg + alt -> sh_size);
    }
    if (locks && text) {
        void *lseg = (void *) locks->sh_addr;
        void *tseg = (void *) text->sh_addr;
        alternatives_smp_module_add (me, me -> name, lseg, lseg + locks -> sh_size, tseg, tseg + text -> sh_size);
    }
    if (para) {
        void *pseg = (void *) para->sh_addr;
        apply_paravirt (pseg, pseg + para -> sh_size);
    }
    return module_bug_finalize (hdr, sechdrs, me);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/module_64.c.ifdefed" startline="158" endline="167">
{
    if (!strcmp (".text", secstrings +s->sh_name))
        text = s;
    if (!strcmp (".altinstructions", secstrings +s->sh_name))
        alt = s;
    if (!strcmp (".smp_locks", secstrings +s->sh_name))
        locks = s;
    if (!strcmp (".parainstructions", secstrings +s->sh_name))
        para = s;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/module_64.c.ifdefed" startline="169" endline="173">
{
    void *aseg = (void *) alt->sh_addr;
    apply_alternatives (aseg, aseg + alt -> sh_size);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/module_64.c.ifdefed" startline="174" endline="180">
{
    void *lseg = (void *) locks->sh_addr;
    void *tseg = (void *) text->sh_addr;
    alternatives_smp_module_add (me, me -> name, lseg, lseg + locks -> sh_size, tseg, tseg + text -> sh_size);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/module_64.c.ifdefed" startline="182" endline="185">
{
    void *pseg = (void *) para->sh_addr;
    apply_paravirt (pseg, pseg + para -> sh_size);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/module_64.c.ifdefed" startline="191" endline="194">
{
    alternatives_smp_module_del (mod);
    module_bug_cleanup (mod);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/pci-calgary_64.c.ifdefed" startline="214" endline="216">
{
    return ~0UL;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/pci-calgary_64.c.ifdefed" startline="221" endline="228">
{
    unsigned int npages;
    npages = PAGE_ALIGN (dma +dmalen) - (dma & PAGE_MASK);
    npages >>= PAGE_SHIFT;
    return npages;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/pci-calgary_64.c.ifdefed" startline="231" endline="234">
{
    return (tbl != NULL);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/pci-calgary_64.c.ifdefed" startline="238" endline="267">
{
    unsigned long index;
    unsigned long end;
    unsigned long badbit;
    unsigned long flags;
    index = start_addr >> PAGE_SHIFT;
    if (index >= tbl->it_size)
        return;
    end = index + npages;
    if (end > tbl->it_size)
        end = tbl->it_size;
    spin_lock_irqsave (& tbl -> it_lock, flags);
    badbit = verify_bit_range (tbl->it_map, 0, index, end);
    if (badbit != ~0UL) {
        if (printk_ratelimit ())
            printk (KERN_ERR "Calgary: entry already allocated at " "0x%lx tbl %p dma 0x%lx npages %u\n", badbit, tbl, start_addr, npages);
    }
    set_bit_string (tbl -> it_map, index, npages);
    spin_unlock_irqrestore (& tbl -> it_lock, flags);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/pci-calgary_64.c.ifdefed" startline="257" endline="262">
{
    if (printk_ratelimit ())
        printk (KERN_ERR "Calgary: entry already allocated at " "0x%lx tbl %p dma 0x%lx npages %u\n", badbit, tbl, start_addr, npages);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/pci-calgary_64.c.ifdefed" startline="272" endline="307">
{
    unsigned long flags;
    unsigned long offset;
    unsigned long boundary_size;
    boundary_size = ALIGN (dma_get_seg_boundary (dev) +1, PAGE_SIZE) >> PAGE_SHIFT;
    BUG_ON (npages == 0);
    spin_lock_irqsave (& tbl -> it_lock, flags);
    offset = iommu_area_alloc (tbl->it_map, tbl->it_size, tbl->it_hint, npages, 0, boundary_size, 0);
    if (offset == ~0UL) {
        tbl->chip_ops->tce_cache_blast (tbl);
        offset = iommu_area_alloc (tbl->it_map, tbl->it_size, 0, npages, 0, boundary_size, 0);
        if (offset == ~0UL) {
            printk (KERN_WARNING "Calgary: IOMMU full.\n");
            spin_unlock_irqrestore (& tbl -> it_lock, flags);
            if (panic_on_overflow)
                panic ("Calgary: fix the allocator.\n");
            else
                return bad_dma_address;
        }
    }
    tbl->it_hint = offset + npages;
    BUG_ON (tbl -> it_hint > tbl -> it_size);
    spin_unlock_irqrestore (& tbl -> it_lock, flags);
    return offset;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/pci-calgary_64.c.ifdefed" startline="286" endline="299">
{
    tbl->chip_ops->tce_cache_blast (tbl);
    offset = iommu_area_alloc (tbl->it_map, tbl->it_size, 0, npages, 0, boundary_size, 0);
    if (offset == ~0UL) {
        printk (KERN_WARNING "Calgary: IOMMU full.\n");
        spin_unlock_irqrestore (& tbl -> it_lock, flags);
        if (panic_on_overflow)
            panic ("Calgary: fix the allocator.\n");
        else
            return bad_dma_address;
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/pci-calgary_64.c.ifdefed" startline="291" endline="298">
{
    printk (KERN_WARNING "Calgary: IOMMU full.\n");
    spin_unlock_irqrestore (& tbl -> it_lock, flags);
    if (panic_on_overflow)
        panic ("Calgary: fix the allocator.\n");
    else
        return bad_dma_address;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/pci-calgary_64.c.ifdefed" startline="311" endline="333">
{
    unsigned long entry;
    dma_addr_t ret = bad_dma_address;
    entry = iommu_range_alloc (dev, tbl, npages);
    if (unlikely (entry == bad_dma_address))
        goto error;
    ret = (entry << PAGE_SHIFT) | ((unsigned long) vaddr & ~PAGE_MASK);
    tce_build (tbl, entry, npages, (unsigned long) vaddr & PAGE_MASK, direction);
    return ret;
error :
    printk (KERN_WARNING "Calgary: failed to allocate %u pages in " "iommu %p\n", npages, tbl);
    return bad_dma_address;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/pci-calgary_64.c.ifdefed" startline="337" endline="370">
{
    unsigned long entry;
    unsigned long badbit;
    unsigned long badend;
    unsigned long flags;
    badend = bad_dma_address + (EMERGENCY_PAGES * PAGE_SIZE);
    if (unlikely ((dma_addr >= bad_dma_address) && (dma_addr < badend))) {
        WARN (1, KERN_ERR "Calgary: driver tried unmapping bad DMA " "address 0x%Lx\n", dma_addr);
        return;
    }
    entry = dma_addr >> PAGE_SHIFT;
    BUG_ON (entry + npages > tbl -> it_size);
    tce_free (tbl, entry, npages);
    spin_lock_irqsave (& tbl -> it_lock, flags);
    badbit = verify_bit_range (tbl->it_map, 1, entry, entry +npages);
    if (badbit != ~0UL) {
        if (printk_ratelimit ())
            printk (KERN_ERR "Calgary: bit is off at 0x%lx " "tbl %p dma 0x%Lx entry 0x%lx npages %u\n", badbit, tbl, dma_addr, entry, npages);
    }
    iommu_area_free (tbl -> it_map, entry, npages);
    spin_unlock_irqrestore (& tbl -> it_lock, flags);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/pci-calgary_64.c.ifdefed" startline="345" endline="349">
{
    WARN (1, KERN_ERR "Calgary: driver tried unmapping bad DMA " "address 0x%Lx\n", dma_addr);
    return;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/pci-calgary_64.c.ifdefed" startline="360" endline="365">
{
    if (printk_ratelimit ())
        printk (KERN_ERR "Calgary: bit is off at 0x%lx " "tbl %p dma 0x%Lx entry 0x%lx npages %u\n", badbit, tbl, dma_addr, entry, npages);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/pci-calgary_64.c.ifdefed" startline="373" endline="391">
{
    struct pci_dev *pdev;
    struct pci_bus *pbus;
    struct iommu_table *tbl;
    pdev = to_pci_dev (dev);
    pbus = pdev->bus;
    while (pbus->parent)
        pbus = pbus->parent;
    tbl = pci_iommu (pbus);
    BUG_ON (tbl && (tbl -> it_busno != pbus -> number));
    return tbl;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/pci-calgary_64.c.ifdefed" startline="395" endline="414">
{
    struct iommu_table *tbl = find_iommu_table (dev);
    struct scatterlist *s;
    int i;
    if (!translation_enabled (tbl))
        return;

    for_each_sg (sglist, s, nelems, i) {
        unsigned int npages;
        dma_addr_t dma = s->dma_address;
        unsigned int dmalen = s->dma_length;
        if (dmalen == 0)
            break;
        npages = num_dma_pages (dma, dmalen);
        iommu_free (tbl, dma, npages);
    }

}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/pci-calgary_64.c.ifdefed" startline="403" endline="413">
{
    unsigned int npages;
    dma_addr_t dma = s->dma_address;
    unsigned int dmalen = s->dma_length;
    if (dmalen == 0)
        break;
    npages = num_dma_pages (dma, dmalen);
    iommu_free (tbl, dma, npages);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/pci-calgary_64.c.ifdefed" startline="418" endline="456">
{
    struct iommu_table *tbl = find_iommu_table (dev);
    struct scatterlist *s;
    unsigned long vaddr;
    unsigned int npages;
    unsigned long entry;
    int i;

    for_each_sg (sg, s, nelems, i) {
        BUG_ON (! sg_page (s));
        vaddr = (unsigned long) sg_virt (s);
        npages = num_dma_pages (vaddr, s->length);
        entry = iommu_range_alloc (dev, tbl, npages);
        if (entry == bad_dma_address) {
            s->dma_length = 0;
            goto error;
        }
        s->dma_address = (entry << PAGE_SHIFT) | s->offset;
        tce_build (tbl, entry, npages, vaddr & PAGE_MASK, direction);
        s->dma_length = s->length;
    }

    return nelems;
error :
    calgary_unmap_sg (dev, sg, nelems, direction);

    for_each_sg (sg, s, nelems, i) {
        sg->dma_address = bad_dma_address;
        sg->dma_length = 0;
    }

    return 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/pci-calgary_64.c.ifdefed" startline="426" endline="446">
{
    BUG_ON (! sg_page (s));
    vaddr = (unsigned long) sg_virt (s);
    npages = num_dma_pages (vaddr, s->length);
    entry = iommu_range_alloc (dev, tbl, npages);
    if (entry == bad_dma_address) {
        s->dma_length = 0;
        goto error;
    }
    s->dma_address = (entry << PAGE_SHIFT) | s->offset;
    tce_build (tbl, entry, npages, vaddr & PAGE_MASK, direction);
    s->dma_length = s->length;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/pci-calgary_64.c.ifdefed" startline="433" endline="437">
{
    s->dma_length = 0;
    goto error;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/pci-calgary_64.c.ifdefed" startline="451" endline="454">
{
    sg->dma_address = bad_dma_address;
    sg->dma_length = 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/pci-calgary_64.c.ifdefed" startline="460" endline="470">
{
    void *vaddr = phys_to_virt (paddr);
    unsigned long uaddr;
    unsigned int npages;
    struct iommu_table *tbl = find_iommu_table (dev);
    uaddr = (unsigned long) vaddr;
    npages = num_dma_pages (uaddr, size);
    return iommu_alloc (dev, tbl, vaddr, npages, direction);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/pci-calgary_64.c.ifdefed" startline="474" endline="480">
{
    struct iommu_table *tbl = find_iommu_table (dev);
    unsigned int npages;
    npages = num_dma_pages (dma_handle, size);
    iommu_free (tbl, dma_handle, npages);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/pci-calgary_64.c.ifdefed" startline="484" endline="511">
{
    void *ret = NULL;
    dma_addr_t mapping;
    unsigned int npages, order;
    struct iommu_table *tbl = find_iommu_table (dev);
    size = PAGE_ALIGN (size);
    npages = size >> PAGE_SHIFT;
    order = get_order (size);
    ret = (void *) __get_free_pages (flag, order);
    if (!ret)
        goto error;
    memset (ret, 0, size);
    mapping = iommu_alloc (dev, tbl, ret, npages, DMA_BIDIRECTIONAL);
    if (mapping == bad_dma_address)
        goto free;
    *dma_handle = mapping;
    return ret;
free :
    free_pages ((unsigned long) ret, get_order (size));
    ret = NULL;
error :
    return ret;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/pci-calgary_64.c.ifdefed" startline="522" endline="524">
{
    return bus_info[num].bbar;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/pci-calgary_64.c.ifdefed" startline="527" endline="529">
{
    return bus_info[num].phbid;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/pci-calgary_64.c.ifdefed" startline="532" endline="536">
{
    size_t idx = busno_to_phbid (num);
    return split_queue_offsets[idx];
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/pci-calgary_64.c.ifdefed" startline="539" endline="543">
{
    size_t idx = busno_to_phbid (num);
    return tar_offsets[idx];
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/pci-calgary_64.c.ifdefed" startline="546" endline="550">
{
    size_t idx = busno_to_phbid (num);
    return phb_offsets[idx];
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/pci-calgary_64.c.ifdefed" startline="553" endline="556">
{
    unsigned long target = ((unsigned long) bar) | offset;
    return (void __iomem *) target;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/pci-calgary_64.c.ifdefed" startline="559" endline="561">
{
    return (device == PCI_DEVICE_ID_IBM_CALIOC2);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/pci-calgary_64.c.ifdefed" startline="564" endline="566">
{
    return (device == PCI_DEVICE_ID_IBM_CALGARY);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/pci-calgary_64.c.ifdefed" startline="569" endline="571">
{
    return (is_calgary (device) || is_calioc2 (device));
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/pci-calgary_64.c.ifdefed" startline="574" endline="608">
{
    u64 val;
    u32 aer;
    int i = 0;
    void __iomem *bbar = tbl->bbar;
    void __iomem *target;
    target = calgary_reg (bbar, phb_offset (tbl->it_busno) | PHB_AER_OFFSET);
    aer = readl (target);
    writel (0, target);
    target = calgary_reg (bbar, phb_offset (tbl->it_busno) | PHB_PLSSR_OFFSET);
    val = readl (target);
    target = calgary_reg (bbar, split_queue_offset (tbl->it_busno));
    do {
        val = readq (target);
        i++;
    }
    while ((val & 0xff) != 0xff && i < 100);
    if (i == 100)
        printk (KERN_WARNING "Calgary: PCI bus not quiesced, " "continuing anyway\n");
    target = calgary_reg (bbar, tar_offset (tbl->it_busno));
    writeq (tbl -> tar_val, target);
    target = calgary_reg (bbar, phb_offset (tbl->it_busno) | PHB_AER_OFFSET);
    writel (aer, target);
    (void) readl (target);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/pci-calgary_64.c.ifdefed" startline="592" endline="595">
{
    val = readq (target);
    i++;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/pci-calgary_64.c.ifdefed" startline="611" endline="687">
{
    void __iomem *bbar = tbl->bbar;
    void __iomem *target;
    u64 val64;
    u32 val;
    int i = 0;
    int count = 1;
    unsigned char bus = tbl->it_busno;
begin :
    printk (KERN_DEBUG "Calgary: CalIOC2 bus 0x%x entering tce cache blast " "sequence - count %d\n", bus, count);
    target = calgary_reg (bbar, phb_offset (bus) | PHB_PAGE_MIG_CTRL);
    val = be32_to_cpu (readl (target));
    printk (KERN_DEBUG "1a. read 0x%x [LE] from %p\n", val, target);
    val |= PMR_SOFTSTOP;
    printk (KERN_DEBUG "1b. writing 0x%x [LE] to %p\n", val, target);
    writel (cpu_to_be32 (val), target);
    printk (KERN_DEBUG "2a. starting to poll split queues\n");
    target = calgary_reg (bbar, split_queue_offset (bus));
    do {
        val64 = readq (target);
        i++;
    }
    while ((val64 & 0xff) != 0xff && i < 100);
    if (i == 100)
        printk (KERN_WARNING "CalIOC2: PCI bus not quiesced, " "continuing anyway\n");
    target = calgary_reg (bbar, phb_offset (bus) | PHB_PAGE_MIG_DEBUG);
    val = be32_to_cpu (readl (target));
    printk (KERN_DEBUG "3. read 0x%x [LE] from %p\n", val, target);
    if (val & PMR_SOFTSTOPFAULT) {
        if (++count < 100)
            goto begin;
        else {
            printk (KERN_WARNING "CalIOC2: too many SoftStopFaults, " "aborting TCE cache flush sequence!\n");
            return;
        }
    }
    target = calgary_reg (bbar, phb_offset (bus) | PHB_PAGE_MIG_CTRL);
    printk (KERN_DEBUG "5a. slamming into HardStop by reading %p\n", target);
    val = be32_to_cpu (readl (target));
    printk (KERN_DEBUG "5b. read 0x%x [LE] from %p\n", val, target);
    target = calgary_reg (bbar, phb_offset (bus) | PHB_PAGE_MIG_DEBUG);
    val = be32_to_cpu (readl (target));
    printk (KERN_DEBUG "5c. read 0x%x [LE] from %p (debug)\n", val, target);
    printk (KERN_DEBUG "6. invalidating TCE cache\n");
    target = calgary_reg (bbar, tar_offset (bus));
    writeq (tbl -> tar_val, target);
    printk (KERN_DEBUG "7a. Re-reading PMCR\n");
    target = calgary_reg (bbar, phb_offset (bus) | PHB_PAGE_MIG_CTRL);
    val = be32_to_cpu (readl (target));
    printk (KERN_DEBUG "7b. read 0x%x [LE] from %p\n", val, target);
    printk (KERN_DEBUG "8a. removing HardStop from PMCR\n");
    target = calgary_reg (bbar, phb_offset (bus) | PHB_PAGE_MIG_CTRL);
    val = 0;
    printk (KERN_DEBUG "8b. writing 0x%x [LE] to %p\n", val, target);
    writel (cpu_to_be32 (val), target);
    val = be32_to_cpu (readl (target));
    printk (KERN_DEBUG "8c. read 0x%x [LE] from %p\n", val, target);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/pci-calgary_64.c.ifdefed" startline="635" endline="638">
{
    val64 = readq (target);
    i++;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/pci-calgary_64.c.ifdefed" startline="649" endline="657">
{
    if (++count < 100)
        goto begin;
    else {
        printk (KERN_WARNING "CalIOC2: too many SoftStopFaults, " "aborting TCE cache flush sequence!\n");
        return;
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/pci-calgary_64.c.ifdefed" startline="652" endline="656">
{
    printk (KERN_WARNING "CalIOC2: too many SoftStopFaults, " "aborting TCE cache flush sequence!\n");
    return;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/pci-calgary_64.c.ifdefed" startline="691" endline="699">
{
    unsigned int numpages;
    limit = limit | 0xfffff;
    limit++;
    numpages = ((limit - start) >> PAGE_SHIFT);
    iommu_range_reserve (pci_iommu (dev -> bus), start, numpages);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/pci-calgary_64.c.ifdefed" startline="702" endline="722">
{
    void __iomem *target;
    u64 low, high, sizelow;
    u64 start, limit;
    struct iommu_table *tbl = pci_iommu (dev->bus);
    unsigned char busnum = dev->bus->number;
    void __iomem *bbar = tbl->bbar;
    target = calgary_reg (bbar, phb_offset (busnum) | PHB_MEM_1_LOW);
    low = be32_to_cpu (readl (target));
    target = calgary_reg (bbar, phb_offset (busnum) | PHB_MEM_1_HIGH);
    high = be32_to_cpu (readl (target));
    target = calgary_reg (bbar, phb_offset (busnum) | PHB_MEM_1_SIZE);
    sizelow = be32_to_cpu (readl (target));
    start = (high << 32) | low;
    limit = sizelow;
    calgary_reserve_mem_region (dev, start, limit);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/pci-calgary_64.c.ifdefed" startline="725" endline="753">
{
    void __iomem *target;
    u32 val32;
    u64 low, high, sizelow, sizehigh;
    u64 start, limit;
    struct iommu_table *tbl = pci_iommu (dev->bus);
    unsigned char busnum = dev->bus->number;
    void __iomem *bbar = tbl->bbar;
    target = calgary_reg (bbar, phb_offset (busnum) | PHB_CONFIG_RW_OFFSET);
    val32 = be32_to_cpu (readl (target));
    if (!(val32 & PHB_MEM2_ENABLE))
        return;
    target = calgary_reg (bbar, phb_offset (busnum) | PHB_MEM_2_LOW);
    low = be32_to_cpu (readl (target));
    target = calgary_reg (bbar, phb_offset (busnum) | PHB_MEM_2_HIGH);
    high = be32_to_cpu (readl (target));
    target = calgary_reg (bbar, phb_offset (busnum) | PHB_MEM_2_SIZE_LOW);
    sizelow = be32_to_cpu (readl (target));
    target = calgary_reg (bbar, phb_offset (busnum) | PHB_MEM_2_SIZE_HIGH);
    sizehigh = be32_to_cpu (readl (target));
    start = (high << 32) | low;
    limit = (sizehigh << 32) | sizelow;
    calgary_reserve_mem_region (dev, start, limit);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/pci-calgary_64.c.ifdefed" startline="763" endline="785">
{
    unsigned int npages;
    u64 start;
    struct iommu_table *tbl = pci_iommu (dev->bus);
    iommu_range_reserve (tbl, bad_dma_address, EMERGENCY_PAGES);
    if (is_calgary (dev->device)) {
        start = (640 * 1024);
        npages = ((1024 - 640) * 1024) >> PAGE_SHIFT;
    }
    else {
        start = 0;
        npages = (1 * 1024 * 1024) >> PAGE_SHIFT;
    }
    iommu_range_reserve (tbl, start, npages);
    calgary_reserve_peripheral_mem_1 (dev);
    calgary_reserve_peripheral_mem_2 (dev);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/pci-calgary_64.c.ifdefed" startline="773" endline="776">
{
    start = (640 * 1024);
    npages = ((1024 - 640) * 1024) >> PAGE_SHIFT;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/pci-calgary_64.c.ifdefed" startline="776" endline="779">
{
    start = 0;
    npages = (1 * 1024 * 1024) >> PAGE_SHIFT;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/pci-calgary_64.c.ifdefed" startline="788" endline="836">
{
    u64 val64;
    u64 table_phys;
    void __iomem *target;
    int ret;
    struct iommu_table *tbl;
    ret = build_tce_table (dev, bbar);
    if (ret)
        return ret;
    tbl = pci_iommu (dev->bus);
    tbl->it_base = (unsigned long) bus_info[dev->bus->number].tce_space;
    if (is_kdump_kernel ())
        calgary_init_bitmap_from_tce_table (tbl);
    else
        tce_free (tbl, 0, tbl->it_size);
    if (is_calgary (dev->device))
        tbl->chip_ops = &calgary_chip_ops;
    else if (is_calioc2 (dev->device))
        tbl->chip_ops = &calioc2_chip_ops;
    else
        BUG ();
    calgary_reserve_regions (dev);
    target = calgary_reg (bbar, tar_offset (dev->bus->number));
    val64 = be64_to_cpu (readq (target));
    val64 &= ~TAR_SW_BITS;
    table_phys = (u64) __pa (tbl->it_base);
    val64 |= table_phys;
    BUG_ON (specified_table_size > TCE_TABLE_SIZE_8M);
    val64 |= (u64) specified_table_size;
    tbl->tar_val = cpu_to_be64 (val64);
    writeq (tbl -> tar_val, target);
    readq (target);
    return 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/pci-calgary_64.c.ifdefed" startline="839" endline="861">
{
    u64 val64;
    struct iommu_table *tbl = pci_iommu (dev->bus);
    void __iomem *target;
    unsigned int bitmapsz;
    target = calgary_reg (tbl->bbar, tar_offset (dev->bus->number));
    val64 = be64_to_cpu (readq (target));
    val64 &= ~TAR_SW_BITS;
    writeq (cpu_to_be64 (val64), target);
    readq (target);
    bitmapsz = tbl->it_size / BITS_PER_BYTE;
    free_pages ((unsigned long) tbl -> it_map, get_order (bitmapsz));
    tbl->it_map = NULL;
    kfree (tbl);
    set_pci_iommu (dev -> bus, NULL);
    bus_info[dev->bus->number].tce_space = NULL;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/pci-calgary_64.c.ifdefed" startline="864" endline="878">
{
    void __iomem *bbar = tbl->bbar;
    void __iomem *target;
    u32 csr, plssr;
    target = calgary_reg (bbar, phb_offset (tbl->it_busno) | PHB_CSR_OFFSET);
    csr = be32_to_cpu (readl (target));
    target = calgary_reg (bbar, phb_offset (tbl->it_busno) | PHB_PLSSR_OFFSET);
    plssr = be32_to_cpu (readl (target));
    printk (KERN_EMERG "Calgary: DMA error on Calgary PHB 0x%x, " "0x%08x@CSR 0x%08x@PLSSR\n", tbl -> it_busno, csr, plssr);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/pci-calgary_64.c.ifdefed" startline="881" endline="925">
{
    void __iomem *bbar = tbl->bbar;
    u32 csr, csmr, plssr, mck, rcstat;
    void __iomem *target;
    unsigned long phboff = phb_offset (tbl->it_busno);
    unsigned long erroff;
    u32 errregs [7];
    int i;
    target = calgary_reg (bbar, phboff | PHB_CSR_OFFSET);
    csr = be32_to_cpu (readl (target));
    target = calgary_reg (bbar, phboff | PHB_PLSSR_OFFSET);
    plssr = be32_to_cpu (readl (target));
    target = calgary_reg (bbar, phboff | 0x290);
    csmr = be32_to_cpu (readl (target));
    target = calgary_reg (bbar, phboff | 0x800);
    mck = be32_to_cpu (readl (target));
    printk (KERN_EMERG "Calgary: DMA error on CalIOC2 PHB 0x%x\n", tbl -> it_busno);
    printk (KERN_EMERG "Calgary: 0x%08x@CSR 0x%08x@PLSSR 0x%08x@CSMR 0x%08x@MCK\n", csr, plssr, csmr, mck);
    printk (KERN_EMERG "Calgary: ");
    for (i = 0; i < ARRAY_SIZE (errregs); i++) {
        erroff = (0x810 + (i * 0x10));
        target = calgary_reg (bbar, phboff | erroff);
        errregs[i] = be32_to_cpu (readl (target));
        printk ("0x%08x@0x%lx ", errregs [i], erroff);
    }
    printk ("\n");
    target = calgary_reg (bbar, phboff | PHB_ROOT_COMPLEX_STATUS);
    rcstat = be32_to_cpu (readl (target));
    printk (KERN_EMERG "Calgary: 0x%08x@0x%x\n", rcstat, PHB_ROOT_COMPLEX_STATUS);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/pci-calgary_64.c.ifdefed" startline="911" endline="917">
{
    erroff = (0x810 + (i * 0x10));
    target = calgary_reg (bbar, phboff | erroff);
    errregs[i] = be32_to_cpu (readl (target));
    printk ("0x%08x@0x%lx ", errregs [i], erroff);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/pci-calgary_64.c.ifdefed" startline="928" endline="956">
{
    struct pci_dev *dev = (struct pci_dev *) data;
    struct iommu_table *tbl = pci_iommu (dev->bus);
    void __iomem *bbar = tbl->bbar;
    u32 val32;
    void __iomem *target;
    target = calgary_reg (bbar, phb_offset (tbl->it_busno) | PHB_CSR_OFFSET);
    val32 = be32_to_cpu (readl (target));
    if (val32 & CSR_AGENT_MASK) {
        tbl->chip_ops->dump_error_regs (tbl);
        writel (0, target);
        target = calgary_reg (bbar, phb_offset (tbl->it_busno) | PHB_CONFIG_RW_OFFSET);
        val32 = be32_to_cpu (readl (target));
        val32 |= PHB_SLOT_DISABLE;
        writel (cpu_to_be32 (val32), target);
        readl (target);
    }
    else {
        mod_timer (& tbl -> watchdog_timer, jiffies + 2 * HZ);
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/pci-calgary_64.c.ifdefed" startline="939" endline="952">
{
    tbl->chip_ops->dump_error_regs (tbl);
    writel (0, target);
    target = calgary_reg (bbar, phb_offset (tbl->it_busno) | PHB_CONFIG_RW_OFFSET);
    val32 = be32_to_cpu (readl (target));
    val32 |= PHB_SLOT_DISABLE;
    writel (cpu_to_be32 (val32), target);
    readl (target);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/pci-calgary_64.c.ifdefed" startline="952" endline="955">
{
    mod_timer (& tbl -> watchdog_timer, jiffies + 2 * HZ);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/pci-calgary_64.c.ifdefed" startline="960" endline="988">
{
    u64 val64;
    void __iomem *target;
    unsigned int phb_shift = ~0;
    u64 mask;
    switch (busno_to_phbid (busnum)) {
    case 0 :
        phb_shift = (63 - 19);
        break;
    case 1 :
        phb_shift = (63 - 23);
        break;
    case 2 :
        phb_shift = (63 - 27);
        break;
    case 3 :
        phb_shift = (63 - 35);
        break;
    default :
        BUG_ON (busno_to_phbid (busnum));
    }
    target = calgary_reg (bbar, CALGARY_CONFIG_REG);
    val64 = be64_to_cpu (readq (target));
    mask = ~(0xFUL << phb_shift);
    val64 &= mask;
    val64 |= (timeout << phb_shift);
    writeq (cpu_to_be64 (val64), target);
    readq (target);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/pci-calgary_64.c.ifdefed" startline="966" endline="977">
{
case 0 :
    phb_shift = (63 - 19);
    break;
case 1 :
    phb_shift = (63 - 23);
    break;
case 2 :
    phb_shift = (63 - 27);
    break;
case 3 :
    phb_shift = (63 - 35);
    break;
default :
    BUG_ON (busno_to_phbid (busnum));
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/pci-calgary_64.c.ifdefed" startline="991" endline="1004">
{
    unsigned char busnum = dev->bus->number;
    void __iomem *bbar = tbl->bbar;
    void __iomem *target;
    u32 val;
    target = calgary_reg (bbar, phb_offset (busnum) | PHB_SAVIOR_L2);
    val = cpu_to_be32 (readl (target));
    val |= 0x00800000;
    writel (cpu_to_be32 (val), target);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/pci-calgary_64.c.ifdefed" startline="1007" endline="1017">
{
    unsigned char busnum = dev->bus->number;
    if (is_calgary (dev->device) && (busnum == 1))
        calgary_set_split_completion_timeout (tbl->bbar, busnum, CCR_2SEC_TIMEOUT);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/pci-calgary_64.c.ifdefed" startline="1020" endline="1049">
{
    u32 val32;
    unsigned char busnum;
    void __iomem *target;
    void __iomem *bbar;
    struct iommu_table *tbl;
    busnum = dev->bus->number;
    tbl = pci_iommu (dev->bus);
    bbar = tbl->bbar;
    target = calgary_reg (bbar, phb_offset (busnum) | PHB_CONFIG_RW_OFFSET);
    val32 = be32_to_cpu (readl (target));
    val32 |= PHB_TCE_ENABLE | PHB_DAC_DISABLE | PHB_MCSR_ENABLE;
    printk (KERN_INFO "Calgary: enabling translation on %s PHB %#x\n", (dev -> device == PCI_DEVICE_ID_IBM_CALGARY) ? "Calgary" : "CalIOC2", busnum);
    printk (KERN_INFO "Calgary: errant DMAs will now be prevented on this " "bus.\n");
    writel (cpu_to_be32 (val32), target);
    readl (target);
    init_timer (& tbl -> watchdog_timer);
    tbl->watchdog_timer.function = &calgary_watchdog;
    tbl->watchdog_timer.data = (unsigned long) dev;
    mod_timer (& tbl -> watchdog_timer, jiffies);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/pci-calgary_64.c.ifdefed" startline="1052" endline="1073">
{
    u32 val32;
    unsigned char busnum;
    void __iomem *target;
    void __iomem *bbar;
    struct iommu_table *tbl;
    busnum = dev->bus->number;
    tbl = pci_iommu (dev->bus);
    bbar = tbl->bbar;
    target = calgary_reg (bbar, phb_offset (busnum) | PHB_CONFIG_RW_OFFSET);
    val32 = be32_to_cpu (readl (target));
    val32 &= ~(PHB_TCE_ENABLE | PHB_DAC_DISABLE | PHB_MCSR_ENABLE);
    printk (KERN_INFO "Calgary: disabling translation on PHB %#x!\n", busnum);
    writel (cpu_to_be32 (val32), target);
    readl (target);
    del_timer_sync (& tbl -> watchdog_timer);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/pci-calgary_64.c.ifdefed" startline="1076" endline="1085">
{
    pci_dev_get (dev);
    set_pci_iommu (dev -> bus, NULL);
    if (dev->bus->parent)
        dev->bus->parent->self = dev;
    else
        dev->bus->self = dev;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/pci-calgary_64.c.ifdefed" startline="1088" endline="1119">
{
    void __iomem *bbar;
    struct iommu_table *tbl;
    int ret;
    BUG_ON (dev -> bus -> number >= MAX_PHB_BUS_NUM);
    bbar = busno_to_bbar (dev->bus->number);
    ret = calgary_setup_tar (dev, bbar);
    if (ret)
        goto done;
    pci_dev_get (dev);
    if (dev->bus->parent) {
        if (dev->bus->parent->self)
            printk (KERN_WARNING "Calgary: IEEEE, dev %p has " "bus->parent->self!\n", dev);
        dev->bus->parent->self = dev;
    }
    else
        dev->bus->self = dev;
    tbl = pci_iommu (dev->bus);
    tbl->chip_ops->handle_quirks (tbl, dev);
    calgary_enable_translation (dev);
    return 0;
done :
    return ret;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/pci-calgary_64.c.ifdefed" startline="1102" endline="1107">
{
    if (dev->bus->parent->self)
        printk (KERN_WARNING "Calgary: IEEEE, dev %p has " "bus->parent->self!\n", dev);
    dev->bus->parent->self = dev;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/pci-calgary_64.c.ifdefed" startline="1122" endline="1173">
{
    int ret;
    int rioidx, phb, bus;
    void __iomem *bbar;
    void __iomem *target;
    unsigned long offset;
    u8 start_bus, end_bus;
    u32 val;
    ret = -ENODATA;
    for (rioidx = 0; rioidx < rio_table_hdr->num_rio_dev; rioidx++) {
        struct rio_detail *rio = rio_devs[rioidx];
        if ((rio->type != COMPAT_CALGARY) && (rio->type != ALT_CALGARY))
            continue;
        bbar = ioremap_nocache (rio->BBAR, 1024 * 1024);
        if (!bbar)
            goto error;
        for (phb = 0; phb < PHBS_PER_CALGARY; phb++) {
            offset = phb_debug_offsets[phb] | PHB_DEBUG_STUFF_OFFSET;
            target = calgary_reg (bbar, offset);
            val = be32_to_cpu (readl (target));
            start_bus = (u8) ((val & 0x00FF0000) >> 16);
            end_bus = (u8) ((val & 0x0000FF00) >> 8);
            if (end_bus) {
                for (bus = start_bus; bus <= end_bus; bus++) {
                    bus_info[bus].bbar = bbar;
                    bus_info[bus].phbid = phb;
                }
            }
            else {
                bus_info[start_bus].bbar = bbar;
                bus_info[start_bus].phbid = phb;
            }
        }
    }
    return 0;
error :
    for (bus = 0; bus < ARRAY_SIZE (bus_info); bus++)
        if (bus_info[bus].bbar)
            iounmap (bus_info[bus].bbar);
    return ret;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/pci-calgary_64.c.ifdefed" startline="1132" endline="1162">
{
    struct rio_detail *rio = rio_devs[rioidx];
    if ((rio->type != COMPAT_CALGARY) && (rio->type != ALT_CALGARY))
        continue;
    bbar = ioremap_nocache (rio->BBAR, 1024 * 1024);
    if (!bbar)
        goto error;
    for (phb = 0; phb < PHBS_PER_CALGARY; phb++) {
        offset = phb_debug_offsets[phb] | PHB_DEBUG_STUFF_OFFSET;
        target = calgary_reg (bbar, offset);
        val = be32_to_cpu (readl (target));
        start_bus = (u8) ((val & 0x00FF0000) >> 16);
        end_bus = (u8) ((val & 0x0000FF00) >> 8);
        if (end_bus) {
            for (bus = start_bus; bus <= end_bus; bus++) {
                bus_info[bus].bbar = bbar;
                bus_info[bus].phbid = phb;
            }
        }
        else {
            bus_info[start_bus].bbar = bbar;
            bus_info[start_bus].phbid = phb;
        }
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/pci-calgary_64.c.ifdefed" startline="1143" endline="1161">
{
    offset = phb_debug_offsets[phb] | PHB_DEBUG_STUFF_OFFSET;
    target = calgary_reg (bbar, offset);
    val = be32_to_cpu (readl (target));
    start_bus = (u8) ((val & 0x00FF0000) >> 16);
    end_bus = (u8) ((val & 0x0000FF00) >> 8);
    if (end_bus) {
        for (bus = start_bus; bus <= end_bus; bus++) {
            bus_info[bus].bbar = bbar;
            bus_info[bus].phbid = phb;
        }
    }
    else {
        bus_info[start_bus].bbar = bbar;
        bus_info[start_bus].phbid = phb;
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/pci-calgary_64.c.ifdefed" startline="1152" endline="1157">
{
    for (bus = start_bus; bus <= end_bus; bus++) {
        bus_info[bus].bbar = bbar;
        bus_info[bus].phbid = phb;
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/pci-calgary_64.c.ifdefed" startline="1153" endline="1156">
{
    bus_info[bus].bbar = bbar;
    bus_info[bus].phbid = phb;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/pci-calgary_64.c.ifdefed" startline="1157" endline="1160">
{
    bus_info[start_bus].bbar = bbar;
    bus_info[start_bus].phbid = phb;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/pci-calgary_64.c.ifdefed" startline="1176" endline="1245">
{
    int ret;
    struct pci_dev *dev = NULL;
    struct calgary_bus_info *info;
    ret = calgary_locate_bbars ();
    if (ret)
        return ret;
    if (is_kdump_kernel ())
        get_tce_space_from_tar ();
    do {
        dev = pci_get_device (PCI_VENDOR_ID_IBM, PCI_ANY_ID, dev);
        if (!dev)
            break;
        if (!is_cal_pci_dev (dev->device))
            continue;
        info = &bus_info[dev->bus->number];
        if (info->translation_disabled) {
            calgary_init_one_nontraslated (dev);
            continue;
        }
        if (!info->tce_space && !translate_empty_slots)
            continue;
        ret = calgary_init_one (dev);
        if (ret)
            goto error;
    }
    while (1);
    dev = NULL;

    for_each_pci_dev (dev) {
        struct iommu_table *tbl;
        tbl = find_iommu_table (&dev->dev);
        if (translation_enabled (tbl))
            dev->dev.archdata.dma_ops = &calgary_dma_ops;
    }

    return ret;
error :
    do {
        dev = pci_get_device (PCI_VENDOR_ID_IBM, PCI_ANY_ID, dev);
        if (!dev)
            break;
        if (!is_cal_pci_dev (dev->device))
            continue;
        info = &bus_info[dev->bus->number];
        if (info->translation_disabled) {
            pci_dev_put (dev);
            continue;
        }
        if (!info->tce_space && !translate_empty_slots)
            continue;
        calgary_disable_translation (dev);
        calgary_free_bus (dev);
        pci_dev_put (dev);
        dev->dev.archdata.dma_ops = NULL;
    }
    while (1);
    return ret;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/pci-calgary_64.c.ifdefed" startline="1189" endline="1208">
{
    dev = pci_get_device (PCI_VENDOR_ID_IBM, PCI_ANY_ID, dev);
    if (!dev)
        break;
    if (!is_cal_pci_dev (dev->device))
        continue;
    info = &bus_info[dev->bus->number];
    if (info->translation_disabled) {
        calgary_init_one_nontraslated (dev);
        continue;
    }
    if (!info->tce_space && !translate_empty_slots)
        continue;
    ret = calgary_init_one (dev);
    if (ret)
        goto error;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/pci-calgary_64.c.ifdefed" startline="1197" endline="1200">
{
    calgary_init_one_nontraslated (dev);
    continue;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/pci-calgary_64.c.ifdefed" startline="1211" endline="1218">
{
    struct iommu_table *tbl;
    tbl = find_iommu_table (&dev->dev);
    if (translation_enabled (tbl))
        dev->dev.archdata.dma_ops = &calgary_dma_ops;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/pci-calgary_64.c.ifdefed" startline="1223" endline="1242">
{
    dev = pci_get_device (PCI_VENDOR_ID_IBM, PCI_ANY_ID, dev);
    if (!dev)
        break;
    if (!is_cal_pci_dev (dev->device))
        continue;
    info = &bus_info[dev->bus->number];
    if (info->translation_disabled) {
        pci_dev_put (dev);
        continue;
    }
    if (!info->tce_space && !translate_empty_slots)
        continue;
    calgary_disable_translation (dev);
    calgary_free_bus (dev);
    pci_dev_put (dev);
    dev->dev.archdata.dma_ops = NULL;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/pci-calgary_64.c.ifdefed" startline="1231" endline="1234">
{
    pci_dev_put (dev);
    continue;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/pci-calgary_64.c.ifdefed" startline="1248" endline="1266">
{
    int ret;
    if (specified_table_size != TCE_TABLE_SIZE_UNSPECIFIED)
        return specified_table_size;
    ret = get_order (ram >> 13);
    if (ret > TCE_TABLE_SIZE_8M)
        ret = TCE_TABLE_SIZE_8M;
    return ret;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/pci-calgary_64.c.ifdefed" startline="1269" endline="1308">
{
    unsigned long ptr;
    unsigned numnodes, i;
    int scal_detail_size, rio_detail_size;
    numnodes = rio_table_hdr->num_scal_dev;
    if (numnodes > MAX_NUMNODES) {
        printk (KERN_WARNING "Calgary: MAX_NUMNODES too low! Defined as %d, " "but system has %d nodes.\n", MAX_NUMNODES, numnodes);
        return -ENODEV;
    }
    switch (rio_table_hdr->version) {
    case 2 :
        scal_detail_size = 11;
        rio_detail_size = 13;
        break;
    case 3 :
        scal_detail_size = 12;
        rio_detail_size = 15;
        break;
    default :
        printk (KERN_WARNING "Calgary: Invalid Rio Grande Table Version: %d\n", rio_table_hdr->version);
        return -EPROTO;
    }
    ptr = ((unsigned long) rio_table_hdr) + 3;
    for (i = 0; i < numnodes; i++, ptr += scal_detail_size)
        scal_devs[i] = (struct scal_detail *) ptr;
    for (i = 0; i < rio_table_hdr->num_rio_dev; i++, ptr += rio_detail_size)
        rio_devs[i] = (struct rio_detail *) ptr;
    return 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/pci-calgary_64.c.ifdefed" startline="1275" endline="1281">
{
    printk (KERN_WARNING "Calgary: MAX_NUMNODES too low! Defined as %d, " "but system has %d nodes.\n", MAX_NUMNODES, numnodes);
    return -ENODEV;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/pci-calgary_64.c.ifdefed" startline="1283" endline="1297">
{
case 2 :
    scal_detail_size = 11;
    rio_detail_size = 13;
    break;
case 3 :
    scal_detail_size = 12;
    rio_detail_size = 15;
    break;
default :
    printk (KERN_WARNING "Calgary: Invalid Rio Grande Table Version: %d\n", rio_table_hdr->version);
    return -EPROTO;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/pci-calgary_64.c.ifdefed" startline="1311" endline="1329">
{
    int dev;
    u32 val;
    if (pci_dev == PCI_DEVICE_ID_IBM_CALIOC2) {
        return 1;
    }
    for (dev = 1; dev < 8; dev++) {
        val = read_pci_config (bus, dev, 0, 0);
        if (val != 0xffffffff)
            break;
    }
    return (val != 0xffffffff);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/pci-calgary_64.c.ifdefed" startline="1315" endline="1321">
{
    return 1;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/pci-calgary_64.c.ifdefed" startline="1323" endline="1327">
{
    val = read_pci_config (bus, dev, 0, 0);
    if (val != 0xffffffff)
        break;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/pci-calgary_64.c.ifdefed" startline="1337" endline="1346">
{
    u64 *tp;
    unsigned int index;
    tp = ((u64 *) tbl->it_base);
    for (index = 0; index < tbl->it_size; index++) {
        if (*tp != 0x0)
            set_bit (index, tbl->it_map);
        tp++;
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/pci-calgary_64.c.ifdefed" startline="1341" endline="1345">
{
    if (*tp != 0x0)
        set_bit (index, tbl->it_map);
    tp++;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/pci-calgary_64.c.ifdefed" startline="1354" endline="1384">
{
    int bus;
    void __iomem *target;
    unsigned long tce_space;
    for (bus = 0; bus < MAX_PHB_BUS_NUM; bus++) {
        struct calgary_bus_info *info = &bus_info[bus];
        unsigned short pci_device;
        u32 val;
        val = read_pci_config (bus, 0, 0, 0);
        pci_device = (val & 0xFFFF0000) >> 16;
        if (!is_cal_pci_dev (pci_device))
            continue;
        if (info->translation_disabled)
            continue;
        if (calgary_bus_has_devices (bus, pci_device) || translate_empty_slots) {
            target = calgary_reg (bus_info[bus].bbar, tar_offset (bus));
            tce_space = be64_to_cpu (readq (target));
            tce_space = tce_space & TAR_SW_BITS;
            tce_space = tce_space & (~specified_table_size);
            info->tce_space = (u64 *) __va (tce_space);
        }
    }
    return;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/pci-calgary_64.c.ifdefed" startline="1359" endline="1382">
{
    struct calgary_bus_info *info = &bus_info[bus];
    unsigned short pci_device;
    u32 val;
    val = read_pci_config (bus, 0, 0, 0);
    pci_device = (val & 0xFFFF0000) >> 16;
    if (!is_cal_pci_dev (pci_device))
        continue;
    if (info->translation_disabled)
        continue;
    if (calgary_bus_has_devices (bus, pci_device) || translate_empty_slots) {
        target = calgary_reg (bus_info[bus].bbar, tar_offset (bus));
        tce_space = be64_to_cpu (readq (target));
        tce_space = tce_space & TAR_SW_BITS;
        tce_space = tce_space & (~specified_table_size);
        info->tce_space = (u64 *) __va (tce_space);
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/pci-calgary_64.c.ifdefed" startline="1373" endline="1381">
{
    target = calgary_reg (bus_info[bus].bbar, tar_offset (bus));
    tce_space = be64_to_cpu (readq (target));
    tce_space = tce_space & TAR_SW_BITS;
    tce_space = tce_space & (~specified_table_size);
    info->tce_space = (u64 *) __va (tce_space);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/pci-calgary_64.c.ifdefed" startline="1387" endline="1498">
{
    int bus;
    void *tbl;
    int calgary_found = 0;
    unsigned long ptr;
    unsigned int offset, prev_offset;
    int ret;
    if (swiotlb || no_iommu || iommu_detected)
        return;
    if (!use_calgary)
        return;
    if (!early_pci_allowed ())
        return;
    printk (KERN_DEBUG "Calgary: detecting Calgary via BIOS EBDA area\n");
    ptr = (unsigned long) phys_to_virt (get_bios_ebda ());
    rio_table_hdr = NULL;
    prev_offset = 0;
    offset = 0x180;
    while (offset > prev_offset) {
        if (*((unsigned short *) (ptr + offset + 2)) == 0x4752) {
            rio_table_hdr = (struct rio_table_hdr *) (ptr + offset + 4);
            break;
        }
        prev_offset = offset;
        offset = *((unsigned short *) (ptr + offset));
    }
    if (!rio_table_hdr) {
        printk (KERN_DEBUG "Calgary: Unable to locate Rio Grande table " "in EBDA - bailing!\n");
        return;
    }
    ret = build_detail_arrays ();
    if (ret) {
        printk (KERN_DEBUG "Calgary: build_detail_arrays ret %d\n", ret);
        return;
    }
    specified_table_size = determine_tce_table_size ((is_kdump_kernel () ? saved_max_pfn : max_pfn) * PAGE_SIZE);
    for (bus = 0; bus < MAX_PHB_BUS_NUM; bus++) {
        struct calgary_bus_info *info = &bus_info[bus];
        unsigned short pci_device;
        u32 val;
        val = read_pci_config (bus, 0, 0, 0);
        pci_device = (val & 0xFFFF0000) >> 16;
        if (!is_cal_pci_dev (pci_device))
            continue;
        if (info->translation_disabled)
            continue;
        if (calgary_bus_has_devices (bus, pci_device) || translate_empty_slots) {
            if (!is_kdump_kernel ()) {
                tbl = alloc_tce_table ();
                if (!tbl)
                    goto cleanup;
                info->tce_space = tbl;
            }
            calgary_found = 1;
        }
    }
    printk (KERN_DEBUG "Calgary: finished detection, Calgary %s\n", calgary_found ? "found" : "not found");
    if (calgary_found) {
        iommu_detected = 1;
        calgary_detected = 1;
        printk (KERN_INFO "PCI-DMA: Calgary IOMMU detected.\n");
        printk (KERN_INFO "PCI-DMA: Calgary TCE table spec is %d, " "CONFIG_IOMMU_DEBUG is %s.\n", specified_table_size, debugging ? "enabled" : "disabled");
        if (max_pfn > MAX_DMA32_PFN)
            swiotlb = 1;
    }
    return;
cleanup :
    for (--bus; bus >= 0; --bus) {
        struct calgary_bus_info *info = &bus_info[bus];
        if (info->tce_space)
            free_tce_table (info->tce_space);
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/pci-calgary_64.c.ifdefed" startline="1419" endline="1428">
{
    if (*((unsigned short *) (ptr + offset + 2)) == 0x4752) {
        rio_table_hdr = (struct rio_table_hdr *) (ptr + offset + 4);
        break;
    }
    prev_offset = offset;
    offset = *((unsigned short *) (ptr + offset));
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/pci-calgary_64.c.ifdefed" startline="1421" endline="1425">
{
    rio_table_hdr = (struct rio_table_hdr *) (ptr + offset + 4);
    break;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/pci-calgary_64.c.ifdefed" startline="1429" endline="1433">
{
    printk (KERN_DEBUG "Calgary: Unable to locate Rio Grande table " "in EBDA - bailing!\n");
    return;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/pci-calgary_64.c.ifdefed" startline="1436" endline="1439">
{
    printk (KERN_DEBUG "Calgary: build_detail_arrays ret %d\n", ret);
    return;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/pci-calgary_64.c.ifdefed" startline="1444" endline="1472">
{
    struct calgary_bus_info *info = &bus_info[bus];
    unsigned short pci_device;
    u32 val;
    val = read_pci_config (bus, 0, 0, 0);
    pci_device = (val & 0xFFFF0000) >> 16;
    if (!is_cal_pci_dev (pci_device))
        continue;
    if (info->translation_disabled)
        continue;
    if (calgary_bus_has_devices (bus, pci_device) || translate_empty_slots) {
        if (!is_kdump_kernel ()) {
            tbl = alloc_tce_table ();
            if (!tbl)
                goto cleanup;
            info->tce_space = tbl;
        }
        calgary_found = 1;
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/pci-calgary_64.c.ifdefed" startline="1459" endline="1471">
{
    if (!is_kdump_kernel ()) {
        tbl = alloc_tce_table ();
        if (!tbl)
            goto cleanup;
        info->tce_space = tbl;
    }
    calgary_found = 1;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/pci-calgary_64.c.ifdefed" startline="1464" endline="1469">
{
    tbl = alloc_tce_table ();
    if (!tbl)
        goto cleanup;
    info->tce_space = tbl;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/pci-calgary_64.c.ifdefed" startline="1477" endline="1488">
{
    iommu_detected = 1;
    calgary_detected = 1;
    printk (KERN_INFO "PCI-DMA: Calgary IOMMU detected.\n");
    printk (KERN_INFO "PCI-DMA: Calgary TCE table spec is %d, " "CONFIG_IOMMU_DEBUG is %s.\n", specified_table_size, debugging ? "enabled" : "disabled");
    if (max_pfn > MAX_DMA32_PFN)
        swiotlb = 1;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/pci-calgary_64.c.ifdefed" startline="1492" endline="1497">
{
    struct calgary_bus_info *info = &bus_info[bus];
    if (info->tce_space)
        free_tce_table (info->tce_space);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/pci-calgary_64.c.ifdefed" startline="1501" endline="1527">
{
    int ret;
    if (no_iommu || (swiotlb && !calgary_detected))
        return -ENODEV;
    if (!calgary_detected)
        return -ENODEV;
    printk (KERN_INFO "PCI-DMA: Using Calgary IOMMU\n");
    ret = calgary_init ();
    if (ret) {
        printk (KERN_ERR "PCI-DMA: Calgary init failed %d, " "falling back to no_iommu\n", ret);
        return ret;
    }
    force_iommu = 1;
    bad_dma_address = 0x0;
    if (!dma_ops)
        dma_ops = &nommu_dma_ops;
    return 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/pci-calgary_64.c.ifdefed" startline="1514" endline="1518">
{
    printk (KERN_ERR "PCI-DMA: Calgary init failed %d, " "falling back to no_iommu\n", ret);
    return ret;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/pci-calgary_64.c.ifdefed" startline="1530" endline="1582">
{
    unsigned int bridge;
    size_t len;
    char *endp;
    while (*p) {
        if (!strncmp (p, "64k", 3))
            specified_table_size = TCE_TABLE_SIZE_64K;
        else if (!strncmp (p, "128k", 4))
            specified_table_size = TCE_TABLE_SIZE_128K;
        else if (!strncmp (p, "256k", 4))
            specified_table_size = TCE_TABLE_SIZE_256K;
        else if (!strncmp (p, "512k", 4))
            specified_table_size = TCE_TABLE_SIZE_512K;
        else if (!strncmp (p, "1M", 2))
            specified_table_size = TCE_TABLE_SIZE_1M;
        else if (!strncmp (p, "2M", 2))
            specified_table_size = TCE_TABLE_SIZE_2M;
        else if (!strncmp (p, "4M", 2))
            specified_table_size = TCE_TABLE_SIZE_4M;
        else if (!strncmp (p, "8M", 2))
            specified_table_size = TCE_TABLE_SIZE_8M;
        len = strlen ("translate_empty_slots");
        if (!strncmp (p, "translate_empty_slots", len))
            translate_empty_slots = 1;
        len = strlen ("disable");
        if (!strncmp (p, "disable", len)) {
            p += len;
            if (*p == '=')
                ++p;
            if (*p == '\0')
                break;
            bridge = simple_strtol (p, &endp, 0);
            if (p == endp)
                break;
            if (bridge < MAX_PHB_BUS_NUM) {
                printk (KERN_INFO "Calgary: disabling " "translation for PHB %#x\n", bridge);
                bus_info[bridge].translation_disabled = 1;
            }
        }
        p = strpbrk (p, ",");
        if (!p)
            break;
        p++;
    }
    return 1;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/pci-calgary_64.c.ifdefed" startline="1535" endline="1580">
{
    if (!strncmp (p, "64k", 3))
        specified_table_size = TCE_TABLE_SIZE_64K;
    else if (!strncmp (p, "128k", 4))
        specified_table_size = TCE_TABLE_SIZE_128K;
    else if (!strncmp (p, "256k", 4))
        specified_table_size = TCE_TABLE_SIZE_256K;
    else if (!strncmp (p, "512k", 4))
        specified_table_size = TCE_TABLE_SIZE_512K;
    else if (!strncmp (p, "1M", 2))
        specified_table_size = TCE_TABLE_SIZE_1M;
    else if (!strncmp (p, "2M", 2))
        specified_table_size = TCE_TABLE_SIZE_2M;
    else if (!strncmp (p, "4M", 2))
        specified_table_size = TCE_TABLE_SIZE_4M;
    else if (!strncmp (p, "8M", 2))
        specified_table_size = TCE_TABLE_SIZE_8M;
    len = strlen ("translate_empty_slots");
    if (!strncmp (p, "translate_empty_slots", len))
        translate_empty_slots = 1;
    len = strlen ("disable");
    if (!strncmp (p, "disable", len)) {
        p += len;
        if (*p == '=')
            ++p;
        if (*p == '\0')
            break;
        bridge = simple_strtol (p, &endp, 0);
        if (p == endp)
            break;
        if (bridge < MAX_PHB_BUS_NUM) {
            printk (KERN_INFO "Calgary: disabling " "translation for PHB %#x\n", bridge);
            bus_info[bridge].translation_disabled = 1;
        }
    }
    p = strpbrk (p, ",");
    if (!p)
        break;
    p++;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/pci-calgary_64.c.ifdefed" startline="1558" endline="1573">
{
    p += len;
    if (*p == '=')
        ++p;
    if (*p == '\0')
        break;
    bridge = simple_strtol (p, &endp, 0);
    if (p == endp)
        break;
    if (bridge < MAX_PHB_BUS_NUM) {
        printk (KERN_INFO "Calgary: disabling " "translation for PHB %#x\n", bridge);
        bus_info[bridge].translation_disabled = 1;
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/pci-calgary_64.c.ifdefed" startline="1568" endline="1572">
{
    printk (KERN_INFO "Calgary: disabling " "translation for PHB %#x\n", bridge);
    bus_info[bridge].translation_disabled = 1;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/pci-calgary_64.c.ifdefed" startline="1586" endline="1610">
{
    struct iommu_table *tbl;
    unsigned int npages;
    int i;
    tbl = pci_iommu (dev->bus);
    for (i = 0; i < 4; i++) {
        struct resource *r = &dev->resource[PCI_BRIDGE_RESOURCES + i];
        if (!(r->flags & IORESOURCE_MEM))
            continue;
        if (!r->start)
            continue;
        npages = (r->end - r->start) >> PAGE_SHIFT;
        npages++;
        iommu_range_reserve (tbl, r -> start, npages);
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/pci-calgary_64.c.ifdefed" startline="1593" endline="1609">
{
    struct resource *r = &dev->resource[PCI_BRIDGE_RESOURCES + i];
    if (!(r->flags & IORESOURCE_MEM))
        continue;
    if (!r->start)
        continue;
    npages = (r->end - r->start) >> PAGE_SHIFT;
    npages++;
    iommu_range_reserve (tbl, r -> start, npages);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/pci-calgary_64.c.ifdefed" startline="1613" endline="1641">
{
    struct pci_dev *dev = NULL;
    struct calgary_bus_info *info;
    if (no_iommu || swiotlb || !calgary_detected)
        return -ENODEV;
    printk (KERN_DEBUG "Calgary: fixing up tce spaces\n");
    do {
        dev = pci_get_device (PCI_VENDOR_ID_IBM, PCI_ANY_ID, dev);
        if (!dev)
            break;
        if (!is_cal_pci_dev (dev->device))
            continue;
        info = &bus_info[dev->bus->number];
        if (info->translation_disabled)
            continue;
        if (!info->tce_space)
            continue;
        calgary_fixup_one_tce_space (dev);
    }
    while (1);
    return 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/pci-calgary_64.c.ifdefed" startline="1622" endline="1638">
{
    dev = pci_get_device (PCI_VENDOR_ID_IBM, PCI_ANY_ID, dev);
    if (!dev)
        break;
    if (!is_cal_pci_dev (dev->device))
        continue;
    info = &bus_info[dev->bus->number];
    if (info->translation_disabled)
        continue;
    if (!info->tce_space)
        continue;
    calgary_fixup_one_tce_space (dev);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/head64.c.ifdefed" startline="43" endline="47">
{
    _cpu_pda = __cpu_pda;
    cpu_pda (0) = &_boot_cpu_pda;
    pda_init (0);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/head64.c.ifdefed" startline="50" endline="54">
{
    pgd_t *pgd = pgd_offset_k (0UL);
    pgd_clear (pgd);
    __flush_tlb_all ();
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/head64.c.ifdefed" startline="59" endline="62">
{
    memset (__bss_start, 0, (unsigned long) __bss_stop - (unsigned long) __bss_start);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/head64.c.ifdefed" startline="65" endline="73">
{
    char *command_line;
    memcpy (& boot_params, real_mode_data, sizeof boot_params);
    if (boot_params.hdr.cmd_line_ptr) {
        command_line = __va (boot_params.hdr.cmd_line_ptr);
        memcpy (boot_command_line, command_line, COMMAND_LINE_SIZE);
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/head64.c.ifdefed" startline="69" endline="72">
{
    command_line = __va (boot_params.hdr.cmd_line_ptr);
    memcpy (boot_command_line, command_line, COMMAND_LINE_SIZE);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/head64.c.ifdefed" startline="76" endline="118">
{
    int i;
    BUILD_BUG_ON (MODULES_VADDR < KERNEL_IMAGE_START);
    BUILD_BUG_ON (MODULES_VADDR - KERNEL_IMAGE_START < KERNEL_IMAGE_SIZE);
    BUILD_BUG_ON (MODULES_LEN + KERNEL_IMAGE_SIZE > 2 * PUD_SIZE);
    BUILD_BUG_ON ((KERNEL_IMAGE_START & ~ PMD_MASK) != 0);
    BUILD_BUG_ON ((MODULES_VADDR & ~ PMD_MASK) != 0);
    BUILD_BUG_ON (! (MODULES_VADDR > __START_KERNEL));
    BUILD_BUG_ON (! (((MODULES_END - 1) & PGDIR_MASK) == (__START_KERNEL & PGDIR_MASK)));
    BUILD_BUG_ON (__fix_to_virt (__end_of_fixed_addresses) <= MODULES_END);
    clear_bss ();
    zap_identity_mappings ();
    cleanup_highmap ();
    for (i = 0; i < NUM_EXCEPTION_VECTORS; i++) {
        set_intr_gate (i, early_idt_handler);
    }
    load_idt ((const struct desc_ptr *) & idt_descr);
    early_printk ("Kernel alive\n");
    x86_64_init_pda ();
    early_printk ("Kernel really alive\n");
    x86_64_start_reservations (real_mode_data);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/head64.c.ifdefed" startline="102" endline="108">
{
    set_intr_gate (i, early_idt_handler);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/head64.c.ifdefed" startline="121" endline="145">
{
    copy_bootdata (__va (real_mode_data));
    reserve_early (__pa_symbol (& _text), __pa_symbol (& _end), "TEXT DATA BSS");
    reserve_ebda_region ();
    start_kernel ();
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/genapic_64.c.ifdefed" startline="38" endline="60">
{
    if (uv_system_type == UV_NON_UNIQUE_APIC)
        genapic = &apic_x2apic_uv_x;
    else if (max_physical_apicid < 8)
        genapic = &apic_flat;
    else
        genapic = &apic_physflat;
    printk (KERN_INFO "Setting APIC routing to %s\n", genapic -> name);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/genapic_64.c.ifdefed" startline="65" endline="67">
{
    __send_IPI_shortcut (APIC_DEST_SELF, vector, APIC_DEST_PHYSICAL);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/genapic_64.c.ifdefed" startline="70" endline="80">
{
    if (!strcmp (oem_id, "SGI")) {
        if (!strcmp (oem_table_id, "UVL"))
            uv_system_type = UV_LEGACY_APIC;
        else if (!strcmp (oem_table_id, "UVX"))
            uv_system_type = UV_X2APIC;
        else if (!strcmp (oem_table_id, "UVH"))
            uv_system_type = UV_NON_UNIQUE_APIC;
    }
    return 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/genapic_64.c.ifdefed" startline="71" endline="78">
{
    if (!strcmp (oem_table_id, "UVL"))
        uv_system_type = UV_LEGACY_APIC;
    else if (!strcmp (oem_table_id, "UVX"))
        uv_system_type = UV_X2APIC;
    else if (!strcmp (oem_table_id, "UVH"))
        uv_system_type = UV_NON_UNIQUE_APIC;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/genapic_64.c.ifdefed" startline="83" endline="91">
{
    unsigned int id;
    WARN_ON (preemptible () && num_online_cpus () > 1);
    id = apic_read (APIC_ID);
    if (uv_system_type >= UV_X2APIC)
        id |= __get_cpu_var (x2apic_extra_bits);
    return id;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/genapic_64.c.ifdefed" startline="94" endline="96">
{
    return uv_system_type;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/genapic_64.c.ifdefed" startline="99" endline="101">
{
    return uv_system_type != UV_NONE;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/machine_kexec_64.c.ifdefed" startline="31" endline="40">
{
    unsigned long end_addr;
    addr &= PAGE_MASK;
    end_addr = addr + PUD_SIZE;
    while (addr < end_addr) {
        set_pmd (level2p ++, __pmd (addr | __PAGE_KERNEL_LARGE_EXEC));
        addr += PMD_SIZE;
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/machine_kexec_64.c.ifdefed" startline="36" endline="39">
{
    set_pmd (level2p ++, __pmd (addr | __PAGE_KERNEL_LARGE_EXEC));
    addr += PMD_SIZE;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/machine_kexec_64.c.ifdefed" startline="44" endline="72">
{
    unsigned long end_addr;
    int result;
    result = 0;
    addr &= PAGE_MASK;
    end_addr = addr + PGDIR_SIZE;
    while ((addr < last_addr) && (addr < end_addr)) {
        struct page *page;
        pmd_t *level2p;
        page = kimage_alloc_control_pages (image, 0);
        if (!page) {
            result = -ENOMEM;
            goto out;
        }
        level2p = (pmd_t *) page_address (page);
        init_level2_page (level2p, addr);
        set_pud (level3p ++, __pud (__pa (level2p) | _KERNPG_TABLE));
        addr += PUD_SIZE;
    }
    while (addr < end_addr) {
        pud_clear (level3p ++);
        addr += PUD_SIZE;
    }
out :
    return result;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/machine_kexec_64.c.ifdefed" startline="51" endline="64">
{
    struct page *page;
    pmd_t *level2p;
    page = kimage_alloc_control_pages (image, 0);
    if (!page) {
        result = -ENOMEM;
        goto out;
    }
    level2p = (pmd_t *) page_address (page);
    init_level2_page (level2p, addr);
    set_pud (level3p ++, __pud (__pa (level2p) | _KERNPG_TABLE));
    addr += PUD_SIZE;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/machine_kexec_64.c.ifdefed" startline="56" endline="59">
{
    result = -ENOMEM;
    goto out;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/machine_kexec_64.c.ifdefed" startline="66" endline="69">
{
    pud_clear (level3p ++);
    addr += PUD_SIZE;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/machine_kexec_64.c.ifdefed" startline="77" endline="108">
{
    unsigned long end_addr;
    int result;
    result = 0;
    addr &= PAGE_MASK;
    end_addr = addr + (PTRS_PER_PGD * PGDIR_SIZE);
    while ((addr < last_addr) && (addr < end_addr)) {
        struct page *page;
        pud_t *level3p;
        page = kimage_alloc_control_pages (image, 0);
        if (!page) {
            result = -ENOMEM;
            goto out;
        }
        level3p = (pud_t *) page_address (page);
        result = init_level3_page (image, level3p, addr, last_addr);
        if (result) {
            goto out;
        }
        set_pgd (level4p ++, __pgd (__pa (level3p) | _KERNPG_TABLE));
        addr += PGDIR_SIZE;
    }
    while (addr < end_addr) {
        pgd_clear (level4p ++);
        addr += PGDIR_SIZE;
    }
out :
    return result;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/machine_kexec_64.c.ifdefed" startline="84" endline="100">
{
    struct page *page;
    pud_t *level3p;
    page = kimage_alloc_control_pages (image, 0);
    if (!page) {
        result = -ENOMEM;
        goto out;
    }
    level3p = (pud_t *) page_address (page);
    result = init_level3_page (image, level3p, addr, last_addr);
    if (result) {
        goto out;
    }
    set_pgd (level4p ++, __pgd (__pa (level3p) | _KERNPG_TABLE));
    addr += PGDIR_SIZE;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/machine_kexec_64.c.ifdefed" startline="89" endline="92">
{
    result = -ENOMEM;
    goto out;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/machine_kexec_64.c.ifdefed" startline="95" endline="97">
{
    goto out;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/machine_kexec_64.c.ifdefed" startline="102" endline="105">
{
    pgd_clear (level4p ++);
    addr += PGDIR_SIZE;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/machine_kexec_64.c.ifdefed" startline="112" endline="116">
{
    pgd_t *level4p;
    level4p = (pgd_t *) __va (start_pgtable);
    return init_level4_page (image, level4p, 0, max_pfn << PAGE_SHIFT);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/machine_kexec_64.c.ifdefed" startline="119" endline="130">
{
    struct desc_ptr curidt;
    curidt.size = limit;
    curidt.address = (unsigned long) newidt;
    __asm__ __volatile__ ("lidtq %0\n" : : "m" (curidt));
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/machine_kexec_64.c.ifdefed" startline="134" endline="145">
{
    struct desc_ptr curgdt;
    curgdt.size = limit;
    curgdt.address = (unsigned long) newgdt;
    __asm__ __volatile__ ("lgdtq %0\n" : : "m" (curgdt));
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/machine_kexec_64.c.ifdefed" startline="148" endline="157">
{
    __asm__ __volatile__ ("\tmovl %0,%%ds\n" "\tmovl %0,%%es\n" "\tmovl %0,%%ss\n" "\tmovl %0,%%fs\n" "\tmovl %0,%%gs\n" : : "a" (__KERNEL_DS) : "memory");
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/machine_kexec_64.c.ifdefed" startline="160" endline="173">
{
    unsigned long start_pgtable;
    int result;
    start_pgtable = page_to_pfn (image->control_code_page) << PAGE_SHIFT;
    result = init_pgtable (image, start_pgtable);
    if (result)
        return result;
    return 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/machine_kexec_64.c.ifdefed" startline="176" endline="178">
{
    return;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/machine_kexec_64.c.ifdefed" startline="185" endline="236">
{
    unsigned long page_list [PAGES_NR];
    void *control_page;
    tracer_disable ();
    local_irq_disable ();
    control_page = page_address (image->control_code_page) + PAGE_SIZE;
    memcpy (control_page, relocate_kernel, PAGE_SIZE);
    page_list[PA_CONTROL_PAGE] = virt_to_phys (control_page);
    page_list[VA_CONTROL_PAGE] = (unsigned long) relocate_kernel;
    page_list[PA_PGD] = virt_to_phys (&kexec_pgd);
    page_list[VA_PGD] = (unsigned long) kexec_pgd;
    page_list[PA_PUD_0] = virt_to_phys (&kexec_pud0);
    page_list[VA_PUD_0] = (unsigned long) kexec_pud0;
    page_list[PA_PMD_0] = virt_to_phys (&kexec_pmd0);
    page_list[VA_PMD_0] = (unsigned long) kexec_pmd0;
    page_list[PA_PTE_0] = virt_to_phys (&kexec_pte0);
    page_list[VA_PTE_0] = (unsigned long) kexec_pte0;
    page_list[PA_PUD_1] = virt_to_phys (&kexec_pud1);
    page_list[VA_PUD_1] = (unsigned long) kexec_pud1;
    page_list[PA_PMD_1] = virt_to_phys (&kexec_pmd1);
    page_list[VA_PMD_1] = (unsigned long) kexec_pmd1;
    page_list[PA_PTE_1] = virt_to_phys (&kexec_pte1);
    page_list[VA_PTE_1] = (unsigned long) kexec_pte1;
    page_list[PA_TABLE_PAGE] = (unsigned long) __pa (page_address (image->control_code_page));
    load_segments ();
    set_gdt (phys_to_virt (0), 0);
    set_idt (phys_to_virt (0), 0);
    relocate_kernel ((unsigned long) image -> head, (unsigned long) page_list, image -> start);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/machine_kexec_64.c.ifdefed" startline="239" endline="247">
{
    VMCOREINFO_SYMBOL (phys_base);
    VMCOREINFO_SYMBOL (init_level4_pgt);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/irq_64.c.ifdefed" startline="28" endline="41">
{
    printk (KERN_WARNING "unexpected IRQ trap at vector %02x\n", irq);
    if (!disable_apic)
        ack_APIC_irq ();
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/irq_64.c.ifdefed" startline="72" endline="155">
{
    int i = *(loff_t*) v, j;
    struct irqaction *action;
    unsigned long flags;
    if (i == 0) {
        seq_printf (p, "           ");
        for_each_online_cpu (j)
        seq_printf (p, "CPU%-8d", j);
        seq_putc (p, '\n');
    }
    if (i < NR_IRQS) {
        unsigned any_count = 0;
        spin_lock_irqsave (& irq_desc [i].lock, flags);
        any_count = kstat_irqs (i);
        action = irq_desc[i].action;
        if (!action && !any_count)
            goto skip;
        seq_printf (p, "%3d: ", i);
        seq_printf (p, "%10u ", kstat_irqs (i));
        seq_printf (p, " %8s", irq_desc [i].chip -> name);
        seq_printf (p, "-%-8s", irq_desc [i].name);
        if (action) {
            seq_printf (p, "  %s", action -> name);
            while ((action = action->next) != NULL)
                seq_printf (p, ", %s", action->name);
        }
        seq_putc (p, '\n');
    skip :
        spin_unlock_irqrestore (&irq_desc[i].lock, flags);
    }
    else if (i == NR_IRQS) {
        seq_printf (p, "NMI: ");
        for_each_online_cpu (j)
        seq_printf (p, "%10u ", cpu_pda (j) -> __nmi_count);
        seq_printf (p, "  Non-maskable interrupts\n");
        seq_printf (p, "LOC: ");
        for_each_online_cpu (j)
        seq_printf (p, "%10u ", cpu_pda (j) -> apic_timer_irqs);
        seq_printf (p, "  Local timer interrupts\n");
        seq_printf (p, "SPU: ");
        for_each_online_cpu (j)
        seq_printf (p, "%10u ", cpu_pda (j) -> irq_spurious_count);
        seq_printf (p, "  Spurious interrupts\n");
        seq_printf (p, "ERR: %10u\n", atomic_read (& irq_err_count));
    }
    return 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/irq_64.c.ifdefed" startline="77" endline="82">
{
    seq_printf (p, "           ");
    for_each_online_cpu (j)
    seq_printf (p, "CPU%-8d", j);
    seq_putc (p, '\n');
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/irq_64.c.ifdefed" startline="84" endline="115">
{
    unsigned any_count = 0;
    spin_lock_irqsave (& irq_desc [i].lock, flags);
    any_count = kstat_irqs (i);
    action = irq_desc[i].action;
    if (!action && !any_count)
        goto skip;
    seq_printf (p, "%3d: ", i);
    seq_printf (p, "%10u ", kstat_irqs (i));
    seq_printf (p, " %8s", irq_desc [i].chip -> name);
    seq_printf (p, "-%-8s", irq_desc [i].name);
    if (action) {
        seq_printf (p, "  %s", action -> name);
        while ((action = action->next) != NULL)
            seq_printf (p, ", %s", action->name);
    }
    seq_putc (p, '\n');
skip :
    spin_unlock_irqrestore (&irq_desc[i].lock, flags);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/irq_64.c.ifdefed" startline="107" endline="111">
{
    seq_printf (p, "  %s", action -> name);
    while ((action = action->next) != NULL)
        seq_printf (p, ", %s", action->name);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/irq_64.c.ifdefed" startline="115" endline="153">
{
    seq_printf (p, "NMI: ");
    for_each_online_cpu (j)
    seq_printf (p, "%10u ", cpu_pda (j) -> __nmi_count);
    seq_printf (p, "  Non-maskable interrupts\n");
    seq_printf (p, "LOC: ");
    for_each_online_cpu (j)
    seq_printf (p, "%10u ", cpu_pda (j) -> apic_timer_irqs);
    seq_printf (p, "  Local timer interrupts\n");
    seq_printf (p, "SPU: ");
    for_each_online_cpu (j)
    seq_printf (p, "%10u ", cpu_pda (j) -> irq_spurious_count);
    seq_printf (p, "  Spurious interrupts\n");
    seq_printf (p, "ERR: %10u\n", atomic_read (& irq_err_count));
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/irq_64.c.ifdefed" startline="161" endline="176">
{
    u64 sum = cpu_pda (cpu)->__nmi_count;
    sum += cpu_pda (cpu)->apic_timer_irqs;
    sum += cpu_pda (cpu)->irq_spurious_count;
    return sum;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/irq_64.c.ifdefed" startline="179" endline="181">
{
    return atomic_read (&irq_err_count);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/irq_64.c.ifdefed" startline="189" endline="219">
{
    struct pt_regs *old_regs = set_irq_regs (regs);
    unsigned vector = ~regs->orig_ax;
    unsigned irq;
    exit_idle ();
    irq_enter ();
    irq = __get_cpu_var (vector_irq)[vector];
    if (likely (irq < NR_IRQS))
        generic_handle_irq (irq);
    else {
        if (!disable_apic)
            ack_APIC_irq ();
        if (printk_ratelimit ())
            printk (KERN_EMERG "%s: %d.%d No irq handler for vector\n", __func__, smp_processor_id (), vector);
    }
    irq_exit ();
    set_irq_regs (old_regs);
    return 1;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/irq_64.c.ifdefed" startline="206" endline="213">
{
    if (!disable_apic)
        ack_APIC_irq ();
    if (printk_ratelimit ())
        printk (KERN_EMERG "%s: %d.%d No irq handler for vector\n", __func__, smp_processor_id (), vector);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/irq_64.c.ifdefed" startline="279" endline="294">
{
    __u32 pending;
    unsigned long flags;
    if (in_interrupt ())
        return;
    local_irq_save (flags);
    pending = local_softirq_pending ();
    if (pending) {
        call_softirq ();
        WARN_ON_ONCE (softirq_count ());
    }
    local_irq_restore (flags);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/irq_64.c.ifdefed" startline="289" endline="292">
{
    call_softirq ();
    WARN_ON_ONCE (softirq_count ());
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/reboot.c.ifdefed" startline="51" endline="97">
{
    for (;;) {
        switch (*str) {
        case 'w' :
            reboot_mode = 0x1234;
            break;
        case 'c' :
            reboot_mode = 0;
            break;
        case 'a' :
        case 'k' :
        case 't' :
        case 'e' :
            reboot_type = *str;
            break;
        case 'f' :
            reboot_force = 1;
            break;
        }
        str = strchr (str, ',');
        if (str)
            str++;
        else
            break;
    }
    return 1;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/reboot.c.ifdefed" startline="52" endline="95">
{
    switch (*str) {
    case 'w' :
        reboot_mode = 0x1234;
        break;
    case 'c' :
        reboot_mode = 0;
        break;
    case 'a' :
    case 'k' :
    case 't' :
    case 'e' :
        reboot_type = *str;
        break;
    case 'f' :
        reboot_force = 1;
        break;
    }
    str = strchr (str, ',');
    if (str)
        str++;
    else
        break;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/reboot.c.ifdefed" startline="53" endline="88">
{
case 'w' :
    reboot_mode = 0x1234;
    break;
case 'c' :
    reboot_mode = 0;
    break;
case 'a' :
case 'k' :
case 't' :
case 'e' :
    reboot_type = *str;
    break;
case 'f' :
    reboot_force = 1;
    break;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/reboot.c.ifdefed" startline="344" endline="352">
{
    int i;
    for (i = 0; i < 0x10000; i++) {
        if ((inb (0x64) & 0x02) == 0)
            break;
        udelay (2);
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/reboot.c.ifdefed" startline="347" endline="351">
{
    if ((inb (0x64) & 0x02) == 0)
        break;
    udelay (2);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/reboot.c.ifdefed" startline="355" endline="356">
{
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/reboot.c.ifdefed" startline="359" endline="408">
{
    int i;
    *((unsigned short *) __va (0x472)) = reboot_mode;
    for (;;) {
        switch (reboot_type) {
        case BOOT_KBD :
            mach_reboot_fixups ();
            for (i = 0; i < 10; i++) {
                kb_wait ();
                udelay (50);
                outb (0xfe, 0x64);
                udelay (50);
            }
        case BOOT_TRIPLE :
            load_idt (&no_idt);
            __asm__ __volatile__ ("int3");
            reboot_type = BOOT_KBD;
            break;
        case BOOT_ACPI :
            acpi_reboot ();
            reboot_type = BOOT_KBD;
            break;
        case BOOT_EFI :
            if (efi_enabled)
                efi.reset_system (reboot_mode ? EFI_RESET_WARM : EFI_RESET_COLD, EFI_SUCCESS, 0, NULL);
            reboot_type = BOOT_KBD;
            break;
        }
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/reboot.c.ifdefed" startline="365" endline="407">
{
    switch (reboot_type) {
    case BOOT_KBD :
        mach_reboot_fixups ();
        for (i = 0; i < 10; i++) {
            kb_wait ();
            udelay (50);
            outb (0xfe, 0x64);
            udelay (50);
        }
    case BOOT_TRIPLE :
        load_idt (&no_idt);
        __asm__ __volatile__ ("int3");
        reboot_type = BOOT_KBD;
        break;
    case BOOT_ACPI :
        acpi_reboot ();
        reboot_type = BOOT_KBD;
        break;
    case BOOT_EFI :
        if (efi_enabled)
            efi.reset_system (reboot_mode ? EFI_RESET_WARM : EFI_RESET_COLD, EFI_SUCCESS, 0, NULL);
        reboot_type = BOOT_KBD;
        break;
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/reboot.c.ifdefed" startline="367" endline="406">
{
case BOOT_KBD :
    mach_reboot_fixups ();
    for (i = 0; i < 10; i++) {
        kb_wait ();
        udelay (50);
        outb (0xfe, 0x64);
        udelay (50);
    }
case BOOT_TRIPLE :
    load_idt (&no_idt);
    __asm__ __volatile__ ("int3");
    reboot_type = BOOT_KBD;
    break;
case BOOT_ACPI :
    acpi_reboot ();
    reboot_type = BOOT_KBD;
    break;
case BOOT_EFI :
    if (efi_enabled)
        efi.reset_system (reboot_mode ? EFI_RESET_WARM : EFI_RESET_COLD, EFI_SUCCESS, 0, NULL);
    reboot_type = BOOT_KBD;
    break;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/reboot.c.ifdefed" startline="371" endline="376">
{
    kb_wait ();
    udelay (50);
    outb (0xfe, 0x64);
    udelay (50);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/reboot.c.ifdefed" startline="411" endline="451">
{
    lapic_shutdown ();
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/reboot.c.ifdefed" startline="454" endline="460">
{
    printk ("machine restart\n");
    if (!reboot_force)
        machine_shutdown ();
    machine_emergency_restart ();
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/reboot.c.ifdefed" startline="463" endline="464">
{
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/reboot.c.ifdefed" startline="467" endline="473">
{
    if (pm_power_off) {
        if (!reboot_force)
            machine_shutdown ();
        pm_power_off ();
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/reboot.c.ifdefed" startline="468" endline="472">
{
    if (!reboot_force)
        machine_shutdown ();
    pm_power_off ();
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/reboot.c.ifdefed" startline="487" endline="489">
{
    machine_ops.power_off ();
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/reboot.c.ifdefed" startline="492" endline="494">
{
    machine_ops.shutdown ();
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/reboot.c.ifdefed" startline="497" endline="499">
{
    machine_ops.emergency_restart ();
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/reboot.c.ifdefed" startline="502" endline="504">
{
    machine_ops.restart (cmd);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/reboot.c.ifdefed" startline="507" endline="509">
{
    machine_ops.halt ();
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/io_delay.c.ifdefed" startline="23" endline="44">
{
    switch (io_delay_type) {
    default :
    case CONFIG_IO_DELAY_TYPE_0X80 :
        asm volatile ("outb %al, $0x80"
        );
        break;
    case CONFIG_IO_DELAY_TYPE_0XED :
        asm volatile ("outb %al, $0xed"
        );
        break;
    case CONFIG_IO_DELAY_TYPE_UDELAY :
        udelay (2);
    case CONFIG_IO_DELAY_TYPE_NONE :
        break;
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/io_delay.c.ifdefed" startline="24" endline="43">
{
default :
case CONFIG_IO_DELAY_TYPE_0X80 :
    asm volatile ("outb %al, $0x80"
    );
    break;
case CONFIG_IO_DELAY_TYPE_0XED :
    asm volatile ("outb %al, $0xed"
    );
    break;
case CONFIG_IO_DELAY_TYPE_UDELAY :
    udelay (2);
case CONFIG_IO_DELAY_TYPE_NONE :
    break;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/io_delay.c.ifdefed" startline="48" endline="56">
{
    if (io_delay_type == CONFIG_IO_DELAY_TYPE_0X80) {
        printk (KERN_NOTICE "%s: using 0xed I/O delay port\n", id -> ident);
        io_delay_type = CONFIG_IO_DELAY_TYPE_0XED;
    }
    return 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/io_delay.c.ifdefed" startline="49" endline="53">
{
    printk (KERN_NOTICE "%s: using 0xed I/O delay port\n", id -> ident);
    io_delay_type = CONFIG_IO_DELAY_TYPE_0XED;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/io_delay.c.ifdefed" startline="107" endline="110">
{
    if (!io_delay_override)
        dmi_check_system (io_delay_0xed_port_dmi_table);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/io_delay.c.ifdefed" startline="113" endline="130">
{
    if (!s)
        return -EINVAL;
    if (!strcmp (s, "0x80"))
        io_delay_type = CONFIG_IO_DELAY_TYPE_0X80;
    else if (!strcmp (s, "0xed"))
        io_delay_type = CONFIG_IO_DELAY_TYPE_0XED;
    else if (!strcmp (s, "udelay"))
        io_delay_type = CONFIG_IO_DELAY_TYPE_UDELAY;
    else if (!strcmp (s, "none"))
        io_delay_type = CONFIG_IO_DELAY_TYPE_NONE;
    else
        return -EINVAL;
    io_delay_override = 1;
    return 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/smp.c.ifdefed" startline="116" endline="122">
{
    if (unlikely (cpu_is_offline (cpu))) {
        WARN_ON (1);
        return;
    }
    send_IPI_mask (cpumask_of_cpu (cpu), RESCHEDULE_VECTOR);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/smp.c.ifdefed" startline="117" endline="120">
{
    WARN_ON (1);
    return;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/smp.c.ifdefed" startline="125" endline="127">
{
    send_IPI_mask (cpumask_of_cpu (cpu), CALL_FUNCTION_SINGLE_VECTOR);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/smp.c.ifdefed" startline="130" endline="141">
{
    cpumask_t allbutself;
    allbutself = cpu_online_map;
    cpu_clear (smp_processor_id (), allbutself);
    if (cpus_equal (mask, allbutself) && cpus_equal (cpu_online_map, cpu_callout_map))
        send_IPI_allbutself (CALL_FUNCTION_VECTOR);
    else
        send_IPI_mask (mask, CALL_FUNCTION_VECTOR);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/smp.c.ifdefed" startline="144" endline="154">
{
    local_irq_disable ();
    cpu_clear (smp_processor_id (), cpu_online_map);
    disable_local_APIC ();
    if (hlt_works (smp_processor_id ()))
        for (;;)
            halt ();
    for (;;)
        ;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/smp.c.ifdefed" startline="161" endline="171">
{
    unsigned long flags;
    if (reboot_force)
        return;
    smp_call_function (stop_this_cpu, NULL, 0);
    local_irq_save (flags);
    disable_local_APIC ();
    local_irq_restore (flags);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/smp.c.ifdefed" startline="179" endline="186">
{
    ack_APIC_irq ();
    add_pda (irq_resched_count, 1);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/smp.c.ifdefed" startline="189" endline="199">
{
    ack_APIC_irq ();
    irq_enter ();
    generic_smp_call_function_interrupt ();
    add_pda (irq_call_count, 1);
    irq_exit ();
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/smp.c.ifdefed" startline="202" endline="212">
{
    ack_APIC_irq ();
    irq_enter ();
    generic_smp_call_function_single_interrupt ();
    add_pda (irq_call_count, 1);
    irq_exit ();
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/hpet.c.ifdefed" startline="29" endline="31">
{
    return readl (hpet_virt_address +a);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/hpet.c.ifdefed" startline="34" endline="36">
{
    writel (d, hpet_virt_address + a);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/hpet.c.ifdefed" startline="43" endline="48">
{
    hpet_virt_address = ioremap_nocache (hpet_address, HPET_MMAP_SIZE);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/hpet.c.ifdefed" startline="51" endline="54">
{
    iounmap (hpet_virt_address);
    hpet_virt_address = NULL;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/hpet.c.ifdefed" startline="63" endline="71">
{
    if (str) {
        if (!strncmp ("disable", str, 7))
            boot_hpet_disable = 1;
        if (!strncmp ("force", str, 5))
            hpet_force_user = 1;
    }
    return 1;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/hpet.c.ifdefed" startline="64" endline="69">
{
    if (!strncmp ("disable", str, 7))
        boot_hpet_disable = 1;
    if (!strncmp ("force", str, 5))
        hpet_force_user = 1;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/hpet.c.ifdefed" startline="75" endline="78">
{
    boot_hpet_disable = 1;
    return 1;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/hpet.c.ifdefed" startline="82" endline="84">
{
    return (!boot_hpet_disable && hpet_address);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/hpet.c.ifdefed" startline="95" endline="97">
{
    return is_hpet_capable () && hpet_legacy_int_enabled;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/hpet.c.ifdefed" startline="137" endline="137">
{
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/hpet.c.ifdefed" startline="164" endline="173">
{
    unsigned long cfg = hpet_readl (HPET_CFG);
    cfg &= ~HPET_CFG_ENABLE;
    hpet_writel (cfg, HPET_CFG);
    hpet_writel (0, HPET_COUNTER);
    hpet_writel (0, HPET_COUNTER + 4);
    cfg |= HPET_CFG_ENABLE;
    hpet_writel (cfg, HPET_CFG);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/hpet.c.ifdefed" startline="176" endline="178">
{
    force_hpet_resume ();
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/hpet.c.ifdefed" startline="181" endline="184">
{
    hpet_resume_device ();
    hpet_start_counter ();
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/hpet.c.ifdefed" startline="187" endline="193">
{
    unsigned long cfg = hpet_readl (HPET_CFG);
    cfg |= HPET_CFG_LEGACY;
    hpet_writel (cfg, HPET_CFG);
    hpet_legacy_int_enabled = 1;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/hpet.c.ifdefed" startline="196" endline="224">
{
    hpet_enable_legacy_int ();
    hpet_clockevent.mult = div_sc ((unsigned long) FSEC_PER_NSEC, hpet_period, hpet_clockevent.shift);
    hpet_clockevent.max_delta_ns = clockevent_delta2ns (0x7FFFFFFF, &hpet_clockevent);
    hpet_clockevent.min_delta_ns = 5000;
    hpet_clockevent.cpumask = cpumask_of_cpu (smp_processor_id ());
    clockevents_register_device (& hpet_clockevent);
    global_clock_event = &hpet_clockevent;
    printk (KERN_DEBUG "hpet clockevent registered\n");
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/hpet.c.ifdefed" startline="228" endline="270">
{
    unsigned long cfg, cmp, now;
    uint64_t delta;
    switch (mode) {
    case CLOCK_EVT_MODE_PERIODIC :
        delta = ((uint64_t) (NSEC_PER_SEC / HZ)) * hpet_clockevent.mult;
        delta >>= hpet_clockevent.shift;
        now = hpet_readl (HPET_COUNTER);
        cmp = now + (unsigned long) delta;
        cfg = hpet_readl (HPET_T0_CFG);
        cfg |= HPET_TN_ENABLE | HPET_TN_PERIODIC | HPET_TN_SETVAL | HPET_TN_32BIT;
        hpet_writel (cfg, HPET_T0_CFG);
        hpet_writel (cmp, HPET_T0_CMP);
        udelay (1);
        hpet_writel ((unsigned long) delta, HPET_T0_CMP);
        break;
    case CLOCK_EVT_MODE_ONESHOT :
        cfg = hpet_readl (HPET_T0_CFG);
        cfg &= ~HPET_TN_PERIODIC;
        cfg |= HPET_TN_ENABLE | HPET_TN_32BIT;
        hpet_writel (cfg, HPET_T0_CFG);
        break;
    case CLOCK_EVT_MODE_UNUSED :
    case CLOCK_EVT_MODE_SHUTDOWN :
        cfg = hpet_readl (HPET_T0_CFG);
        cfg &= ~HPET_TN_ENABLE;
        hpet_writel (cfg, HPET_T0_CFG);
        break;
    case CLOCK_EVT_MODE_RESUME :
        hpet_enable_legacy_int ();
        break;
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/hpet.c.ifdefed" startline="232" endline="269">
{
case CLOCK_EVT_MODE_PERIODIC :
    delta = ((uint64_t) (NSEC_PER_SEC / HZ)) * hpet_clockevent.mult;
    delta >>= hpet_clockevent.shift;
    now = hpet_readl (HPET_COUNTER);
    cmp = now + (unsigned long) delta;
    cfg = hpet_readl (HPET_T0_CFG);
    cfg |= HPET_TN_ENABLE | HPET_TN_PERIODIC | HPET_TN_SETVAL | HPET_TN_32BIT;
    hpet_writel (cfg, HPET_T0_CFG);
    hpet_writel (cmp, HPET_T0_CMP);
    udelay (1);
    hpet_writel ((unsigned long) delta, HPET_T0_CMP);
    break;
case CLOCK_EVT_MODE_ONESHOT :
    cfg = hpet_readl (HPET_T0_CFG);
    cfg &= ~HPET_TN_PERIODIC;
    cfg |= HPET_TN_ENABLE | HPET_TN_32BIT;
    hpet_writel (cfg, HPET_T0_CFG);
    break;
case CLOCK_EVT_MODE_UNUSED :
case CLOCK_EVT_MODE_SHUTDOWN :
    cfg = hpet_readl (HPET_T0_CFG);
    cfg &= ~HPET_TN_ENABLE;
    hpet_writel (cfg, HPET_T0_CFG);
    break;
case CLOCK_EVT_MODE_RESUME :
    hpet_enable_legacy_int ();
    break;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/hpet.c.ifdefed" startline="274" endline="289">
{
    u32 cnt;
    cnt = hpet_readl (HPET_COUNTER);
    cnt += (u32) delta;
    hpet_writel (cnt, HPET_T0_CMP);
    WARN_ON ((u32) hpet_readl (HPET_T0_CMP) != cnt);
    return (s32) ((u32) hpet_readl (HPET_COUNTER) - cnt) >= 0 ? -ETIME : 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/hpet.c.ifdefed" startline="295" endline="297">
{
    return (cycle_t) hpet_readl (HPET_COUNTER);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/hpet.c.ifdefed" startline="320" endline="361">
{
    u64 start, now;
    cycle_t t1;
    hpet_start_counter ();
    t1 = read_hpet ();
    rdtscll (start);
    do {
        rep_nop ();
        rdtscll (now);
    }
    while ((now - start) < 200000UL);
    if (t1 == read_hpet ()) {
        printk (KERN_WARNING "HPET counter not counting. HPET disabled\n");
        return -ENODEV;
    }
    clocksource_hpet.mult = div_sc (hpet_period, FSEC_PER_NSEC, HPET_SHIFT);
    clocksource_register (& clocksource_hpet);
    return 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/hpet.c.ifdefed" startline="337" endline="340">
{
    rep_nop ();
    rdtscll (now);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/hpet.c.ifdefed" startline="342" endline="346">
{
    printk (KERN_WARNING "HPET counter not counting. HPET disabled\n");
    return -ENODEV;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/hpet.c.ifdefed" startline="367" endline="434">
{
    unsigned long id;
    int i;
    if (!is_hpet_capable ())
        return 0;
    hpet_set_mapping ();
    hpet_period = hpet_readl (HPET_PERIOD);
    for (i = 0; hpet_readl (HPET_CFG) == 0xFFFFFFFF; i++) {
        if (i == 1000) {
            printk (KERN_WARNING "HPET config register value = 0xFFFFFFFF. " "Disabling HPET\n");
            goto out_nohpet;
        }
    }
    if (hpet_period < HPET_MIN_PERIOD || hpet_period > HPET_MAX_PERIOD)
        goto out_nohpet;
    id = hpet_readl (HPET_ID);
    if (hpet_clocksource_register ())
        goto out_nohpet;
    if (id & HPET_ID_LEGSUP) {
        hpet_legacy_clockevent_register ();
        return 1;
    }
    return 0;
out_nohpet :
    hpet_clear_mapping ();
    boot_hpet_disable = 1;
    return 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/hpet.c.ifdefed" startline="394" endline="401">
{
    if (i == 1000) {
        printk (KERN_WARNING "HPET config register value = 0xFFFFFFFF. " "Disabling HPET\n");
        goto out_nohpet;
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/hpet.c.ifdefed" startline="395" endline="400">
{
    printk (KERN_WARNING "HPET config register value = 0xFFFFFFFF. " "Disabling HPET\n");
    goto out_nohpet;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/hpet.c.ifdefed" startline="424" endline="427">
{
    hpet_legacy_clockevent_register ();
    return 1;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/hpet.c.ifdefed" startline="443" endline="460">
{
    if (boot_hpet_disable)
        return -ENODEV;
    if (!hpet_address) {
        if (!force_hpet_address)
            return -ENODEV;
        hpet_address = force_hpet_address;
        hpet_enable ();
        if (!hpet_virt_address)
            return -ENODEV;
    }
    hpet_reserve_platform_timers (hpet_readl (HPET_ID));
    return 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/hpet.c.ifdefed" startline="447" endline="455">
{
    if (!force_hpet_address)
        return -ENODEV;
    hpet_address = force_hpet_address;
    hpet_enable ();
    if (!hpet_virt_address)
        return -ENODEV;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/hpet.c.ifdefed" startline="464" endline="475">
{
    if (is_hpet_capable ()) {
        unsigned long cfg = hpet_readl (HPET_CFG);
        if (hpet_legacy_int_enabled) {
            cfg &= ~HPET_CFG_LEGACY;
            hpet_legacy_int_enabled = 0;
        }
        cfg &= ~HPET_CFG_ENABLE;
        hpet_writel (cfg, HPET_CFG);
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/hpet.c.ifdefed" startline="465" endline="474">
{
    unsigned long cfg = hpet_readl (HPET_CFG);
    if (hpet_legacy_int_enabled) {
        cfg &= ~HPET_CFG_LEGACY;
        hpet_legacy_int_enabled = 0;
    }
    cfg &= ~HPET_CFG_ENABLE;
    hpet_writel (cfg, HPET_CFG);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/hpet.c.ifdefed" startline="468" endline="471">
{
    cfg &= ~HPET_CFG_LEGACY;
    hpet_legacy_int_enabled = 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/setup.c.ifdefed" startline="247" endline="248">
{
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/setup.c.ifdefed" startline="366" endline="367">
{
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/setup.c.ifdefed" startline="371" endline="390">
{
    struct setup_data *data;
    u64 pa_data;
    if (boot_params.hdr.version < 0x0209)
        return;
    pa_data = boot_params.hdr.setup_data;
    while (pa_data) {
        data = early_ioremap (pa_data, PAGE_SIZE);
        switch (data->type) {
        case SETUP_E820_EXT :
            parse_e820_ext (data, pa_data);
            break;
        default :
            break;
        }
        pa_data = data->next;
        early_iounmap (data, PAGE_SIZE);
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/setup.c.ifdefed" startline="378" endline="389">
{
    data = early_ioremap (pa_data, PAGE_SIZE);
    switch (data->type) {
    case SETUP_E820_EXT :
        parse_e820_ext (data, pa_data);
        break;
    default :
        break;
    }
    pa_data = data->next;
    early_iounmap (data, PAGE_SIZE);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/setup.c.ifdefed" startline="380" endline="386">
{
case SETUP_E820_EXT :
    parse_e820_ext (data, pa_data);
    break;
default :
    break;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/setup.c.ifdefed" startline="393" endline="416">
{
    struct setup_data *data;
    u64 pa_data;
    int found = 0;
    if (boot_params.hdr.version < 0x0209)
        return;
    pa_data = boot_params.hdr.setup_data;
    while (pa_data) {
        data = early_ioremap (pa_data, sizeof (*data));
        e820_update_range (pa_data, sizeof (* data) + data -> len, E820_RAM, E820_RESERVED_KERN);
        found = 1;
        pa_data = data->next;
        early_iounmap (data, sizeof (* data));
    }
    if (!found)
        return;
    sanitize_e820_map (e820.map, ARRAY_SIZE (e820.map), & e820.nr_map);
    memcpy (& e820_saved, & e820, sizeof (struct e820map));
    printk (KERN_INFO "extended physical RAM map:\n");
    e820_print_map ("reserve setup_data");
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/setup.c.ifdefed" startline="401" endline="408">
{
    data = early_ioremap (pa_data, sizeof (*data));
    e820_update_range (pa_data, sizeof (* data) + data -> len, E820_RAM, E820_RESERVED_KERN);
    found = 1;
    pa_data = data->next;
    early_iounmap (data, sizeof (* data));
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/setup.c.ifdefed" startline="419" endline="434">
{
    struct setup_data *data;
    u64 pa_data;
    char buf [32];
    if (boot_params.hdr.version < 0x0209)
        return;
    pa_data = boot_params.hdr.setup_data;
    while (pa_data) {
        data = early_ioremap (pa_data, sizeof (*data));
        sprintf (buf, "setup data %x", data -> type);
        reserve_early (pa_data, pa_data + sizeof (* data) + data -> len, buf);
        pa_data = data->next;
        early_iounmap (data, sizeof (* data));
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/setup.c.ifdefed" startline="427" endline="433">
{
    data = early_ioremap (pa_data, sizeof (*data));
    sprintf (buf, "setup data %x", data -> type);
    reserve_early (pa_data, pa_data + sizeof (* data) + data -> len, buf);
    pa_data = data->next;
    early_iounmap (data, sizeof (* data));
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/setup.c.ifdefed" startline="524" endline="525">
{
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/setup.c.ifdefed" startline="552" endline="559">
{
    int i;
    for (i = 0; i < ARRAY_SIZE (standard_io_resources); i++)
        request_resource (&ioport_resource, &standard_io_resources[i]);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/setup.c.ifdefed" startline="595" endline="887">
{
    printk (KERN_INFO "Command line: %s\n", boot_command_line);
    early_cpu_init ();
    early_ioremap_init ();
    ROOT_DEV = old_decode_dev (boot_params.hdr.root_dev);
    screen_info = boot_params.screen_info;
    edid_info = boot_params.edid_info;
    saved_video_mode = boot_params.hdr.vid_mode;
    bootloader_type = boot_params.hdr.type_of_loader;
    ARCH_SETUP setup_memory_map ();
    parse_setup_data ();
    e820_reserve_setup_data ();
    copy_edd ();
    if (!boot_params.hdr.root_flags)
        root_mountflags &= ~MS_RDONLY;
    init_mm.start_code = (unsigned long) _text;
    init_mm.end_code = (unsigned long) _etext;
    init_mm.end_data = (unsigned long) _edata;
    init_mm.brk = (unsigned long) &_end;
    code_resource.start = virt_to_phys (_text);
    code_resource.end = virt_to_phys (_etext) - 1;
    data_resource.start = virt_to_phys (_etext);
    data_resource.end = virt_to_phys (_edata) - 1;
    bss_resource.start = virt_to_phys (&__bss_start);
    bss_resource.end = virt_to_phys (&__bss_stop) - 1;
    strlcpy (command_line, boot_command_line, COMMAND_LINE_SIZE);
    *cmdline_p = command_line;
    parse_early_param ();
    reserve_early_setup_data ();
    if (acpi_mps_check ()) {
        setup_clear_cpu_cap (X86_FEATURE_APIC);
    }
    finish_e820_parsing ();
    insert_resource (& iomem_resource, & code_resource);
    insert_resource (& iomem_resource, & data_resource);
    insert_resource (& iomem_resource, & bss_resource);
    if (efi_enabled)
        efi_init ();
    early_gart_iommu_check ();
    max_pfn = e820_end_of_ram_pfn ();
    early_reserve_e820_mpc_new ();
    mtrr_bp_init ();
    if (mtrr_trim_uncached_memory (max_pfn))
        max_pfn = e820_end_of_ram_pfn ();
    num_physpages = max_pfn;
    if (max_pfn > (1UL << (32 - PAGE_SHIFT)))
        max_low_pfn = e820_end_of_low_ram_pfn ();
    else
        max_low_pfn = max_pfn;
    high_memory = (void *) __va (max_pfn *PAGE_SIZE - 1) + 1;
    max_low_pfn_mapped = init_memory_mapping (0, max_low_pfn << PAGE_SHIFT);
    max_pfn_mapped = max_low_pfn_mapped;
    reserve_initrd ();
    dmi_scan_machine ();
    io_delay_init ();
    acpi_boot_table_init ();
    initmem_init (0, max_pfn);
    reserve_crashkernel ();
    reserve_ibft_region ();
    paravirt_pagetable_setup_start (swapper_pg_dir);
    paging_init ();
    paravirt_pagetable_setup_done (swapper_pg_dir);
    paravirt_post_allocator_init ();
    early_quirks ();
    acpi_boot_init ();
    prefill_possible_map ();
    init_apic_mappings ();
    ioapic_init_mappings ();
    kvm_guest_init ();
    e820_reserve_resources ();
    e820_mark_nosave_regions (max_low_pfn);
    reserve_standard_io_resources ();
    e820_setup_gap ();
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/setup.c.ifdefed" startline="688" endline="693">
{
    setup_clear_cpu_cap (X86_FEATURE_APIC);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/smpboot.c.ifdefed" startline="198" endline="280">
{
    int cpuid, phys_id;
    unsigned long timeout;
    wait_for_init_deassert (& init_deasserted);
    phys_id = GET_APIC_ID (read_apic_id ());
    cpuid = smp_processor_id ();
    if (cpu_isset (cpuid, cpu_callin_map)) {
        panic ("%s: phys CPU#%d, CPU#%d already present??\n", __func__, phys_id, cpuid);
    }
    pr_debug ("CPU#%d (phys ID: %d) waiting for CALLOUT\n", cpuid, phys_id);
    timeout = jiffies + 2 * HZ;
    while (time_before (jiffies, timeout)) {
        if (cpu_isset (cpuid, cpu_callout_map))
            break;
        cpu_relax ();
    }
    if (!time_before (jiffies, timeout)) {
        panic ("%s: CPU%d started up but did not get a callout!\n", __func__, cpuid);
    }
    pr_debug ("CALLIN, before setup_local_APIC().\n");
    smp_callin_clear_local_apic ();
    setup_local_APIC ();
    end_local_APIC_setup ();
    map_cpu_to_logical_apicid ();
    local_irq_enable ();
    calibrate_delay ();
    local_irq_disable ();
    pr_debug ("Stack at about %p\n", & cpuid);
    smp_store_cpu_info (cpuid);
    cpu_set (cpuid, cpu_callin_map);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/smpboot.c.ifdefed" startline="215" endline="218">
{
    panic ("%s: phys CPU#%d, CPU#%d already present??\n", __func__, phys_id, cpuid);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/smpboot.c.ifdefed" startline="233" endline="240">
{
    if (cpu_isset (cpuid, cpu_callout_map))
        break;
    cpu_relax ();
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/smpboot.c.ifdefed" startline="242" endline="245">
{
    panic ("%s: CPU%d started up but did not get a callout!\n", __func__, cpuid);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/smpboot.c.ifdefed" startline="286" endline="346">
{
    cpu_init ();
    preempt_disable ();
    smp_callin ();
    barrier ();
    check_tsc_sync_target ();
    if (nmi_watchdog == NMI_IO_APIC) {
        disable_8259A_irq (0);
        enable_NMI_through_LVT0 ();
        enable_8259A_irq (0);
    }
    set_cpu_sibling_map (raw_smp_processor_id ());
    wmb ();
    ipi_call_lock_irq ();
    lock_vector_lock ();
    __setup_vector_irq (smp_processor_id ());
    cpu_set (smp_processor_id (), cpu_online_map);
    unlock_vector_lock ();
    ipi_call_unlock_irq ();
    per_cpu (cpu_state, smp_processor_id ()) = CPU_ONLINE;
    setup_secondary_clock ();
    wmb ();
    cpu_idle ();
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/smpboot.c.ifdefed" startline="306" endline="310">
{
    disable_8259A_irq (0);
    enable_NMI_through_LVT0 ();
    enable_8259A_irq (0);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/smpboot.c.ifdefed" startline="349" endline="399">
{
    if (c->x86_vendor == X86_VENDOR_INTEL && c->x86 == 5 && c->x86_mask >= 1 && c->x86_mask <= 4 && c->x86_model <= 3)
        smp_b_stepping = 1;
    if ((c->x86_vendor == X86_VENDOR_AMD) && (c->x86 == 6)) {
        if (num_possible_cpus () == 1)
            goto valid_k7;
        if ((c->x86_model == 6) && ((c->x86_mask == 0) || (c->x86_mask == 1)))
            goto valid_k7;
        if ((c->x86_model == 7) && (c->x86_mask == 0))
            goto valid_k7;
        if (((c->x86_model == 6) && (c->x86_mask >= 2)) || ((c->x86_model == 7) && (c->x86_mask >= 1)) || (c->x86_model > 7))
            if (cpu_has_mp)
                goto valid_k7;
        add_taint (TAINT_UNSAFE_SMP);
    }
valid_k7 :
    ;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/smpboot.c.ifdefed" startline="366" endline="395">
{
    if (num_possible_cpus () == 1)
        goto valid_k7;
    if ((c->x86_model == 6) && ((c->x86_mask == 0) || (c->x86_mask == 1)))
        goto valid_k7;
    if ((c->x86_model == 7) && (c->x86_mask == 0))
        goto valid_k7;
    if (((c->x86_model == 6) && (c->x86_mask >= 2)) || ((c->x86_model == 7) && (c->x86_mask >= 1)) || (c->x86_model > 7))
        if (cpu_has_mp)
            goto valid_k7;
    add_taint (TAINT_UNSAFE_SMP);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/smpboot.c.ifdefed" startline="402" endline="418">
{
    if (smp_b_stepping)
        printk (KERN_WARNING "WARNING: SMP operation may be unreliable" "with B stepping processors.\n");
    if (tainted & TAINT_UNSAFE_SMP) {
        if (num_online_cpus ())
            printk (KERN_INFO "WARNING: This combination of AMD" "processors is not suitable for SMP.\n");
        else
            tainted &= ~TAINT_UNSAFE_SMP;
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/smpboot.c.ifdefed" startline="411" endline="417">
{
    if (num_online_cpus ())
        printk (KERN_INFO "WARNING: This combination of AMD" "processors is not suitable for SMP.\n");
    else
        tainted &= ~TAINT_UNSAFE_SMP;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/smpboot.c.ifdefed" startline="426" endline="434">
{
    struct cpuinfo_x86 *c = &cpu_data (id);
    *c = boot_cpu_data;
    c->cpu_index = id;
    if (id != 0)
        identify_secondary_cpu (c);
    smp_apply_quirks (c);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/smpboot.c.ifdefed" startline="438" endline="497">
{
    int i;
    struct cpuinfo_x86 *c = &cpu_data (cpu);
    cpu_set (cpu, cpu_sibling_setup_map);
    if (smp_num_siblings > 1) {

        for_each_cpu_mask_nr (i, cpu_sibling_setup_map) {
            if (c->phys_proc_id == cpu_data (i).phys_proc_id && c->cpu_core_id == cpu_data (i).cpu_core_id) {
                cpu_set (i, per_cpu (cpu_sibling_map, cpu));
                cpu_set (cpu, per_cpu (cpu_sibling_map, i));
                cpu_set (i, per_cpu (cpu_core_map, cpu));
                cpu_set (cpu, per_cpu (cpu_core_map, i));
                cpu_set (i, c -> llc_shared_map);
                cpu_set (cpu, cpu_data (i).llc_shared_map);
            }
        }

    }
    else {
        cpu_set (cpu, per_cpu (cpu_sibling_map, cpu));
    }
    cpu_set (cpu, c -> llc_shared_map);
    if (current_cpu_data.x86_max_cores == 1) {
        per_cpu (cpu_core_map, cpu) = per_cpu (cpu_sibling_map, cpu);
        c->booted_cores = 1;
        return;
    }

    for_each_cpu_mask_nr (i, cpu_sibling_setup_map) {
        if (per_cpu (cpu_llc_id, cpu) != BAD_APICID && per_cpu (cpu_llc_id, cpu) == per_cpu (cpu_llc_id, i)) {
            cpu_set (i, c -> llc_shared_map);
            cpu_set (cpu, cpu_data (i).llc_shared_map);
        }
        if (c->phys_proc_id == cpu_data (i).phys_proc_id) {
            cpu_set (i, per_cpu (cpu_core_map, cpu));
            cpu_set (cpu, per_cpu (cpu_core_map, i));
            if (cpus_weight (per_cpu (cpu_sibling_map, cpu)) == 1) {
                if (first_cpu (per_cpu (cpu_sibling_map, i)) == i)
                    c->booted_cores++;
                if (i != cpu)
                    cpu_data (i).booted_cores++;
            }
            else if (i != cpu && !c->booted_cores)
                c->booted_cores = cpu_data (i).booted_cores;
        }
    }

}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/smpboot.c.ifdefed" startline="444" endline="456">
{

    for_each_cpu_mask_nr (i, cpu_sibling_setup_map) {
        if (c->phys_proc_id == cpu_data (i).phys_proc_id && c->cpu_core_id == cpu_data (i).cpu_core_id) {
            cpu_set (i, per_cpu (cpu_sibling_map, cpu));
            cpu_set (cpu, per_cpu (cpu_sibling_map, i));
            cpu_set (i, per_cpu (cpu_core_map, cpu));
            cpu_set (cpu, per_cpu (cpu_core_map, i));
            cpu_set (i, c -> llc_shared_map);
            cpu_set (cpu, cpu_data (i).llc_shared_map);
        }
    }

}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/smpboot.c.ifdefed" startline="445" endline="455">
{
    if (c->phys_proc_id == cpu_data (i).phys_proc_id && c->cpu_core_id == cpu_data (i).cpu_core_id) {
        cpu_set (i, per_cpu (cpu_sibling_map, cpu));
        cpu_set (cpu, per_cpu (cpu_sibling_map, i));
        cpu_set (i, per_cpu (cpu_core_map, cpu));
        cpu_set (cpu, per_cpu (cpu_core_map, i));
        cpu_set (i, c -> llc_shared_map);
        cpu_set (cpu, cpu_data (i).llc_shared_map);
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/smpboot.c.ifdefed" startline="447" endline="454">
{
    cpu_set (i, per_cpu (cpu_sibling_map, cpu));
    cpu_set (cpu, per_cpu (cpu_sibling_map, i));
    cpu_set (i, per_cpu (cpu_core_map, cpu));
    cpu_set (cpu, per_cpu (cpu_core_map, i));
    cpu_set (i, c -> llc_shared_map);
    cpu_set (cpu, cpu_data (i).llc_shared_map);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/smpboot.c.ifdefed" startline="456" endline="458">
{
    cpu_set (cpu, per_cpu (cpu_sibling_map, cpu));
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/smpboot.c.ifdefed" startline="462" endline="466">
{
    per_cpu (cpu_core_map, cpu) = per_cpu (cpu_sibling_map, cpu);
    c->booted_cores = 1;
    return;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/smpboot.c.ifdefed" startline="468" endline="496">
{
    if (per_cpu (cpu_llc_id, cpu) != BAD_APICID && per_cpu (cpu_llc_id, cpu) == per_cpu (cpu_llc_id, i)) {
        cpu_set (i, c -> llc_shared_map);
        cpu_set (cpu, cpu_data (i).llc_shared_map);
    }
    if (c->phys_proc_id == cpu_data (i).phys_proc_id) {
        cpu_set (i, per_cpu (cpu_core_map, cpu));
        cpu_set (cpu, per_cpu (cpu_core_map, i));
        if (cpus_weight (per_cpu (cpu_sibling_map, cpu)) == 1) {
            if (first_cpu (per_cpu (cpu_sibling_map, i)) == i)
                c->booted_cores++;
            if (i != cpu)
                cpu_data (i).booted_cores++;
        }
        else if (i != cpu && !c->booted_cores)
            c->booted_cores = cpu_data (i).booted_cores;
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/smpboot.c.ifdefed" startline="470" endline="473">
{
    cpu_set (i, c -> llc_shared_map);
    cpu_set (cpu, cpu_data (i).llc_shared_map);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/smpboot.c.ifdefed" startline="474" endline="495">
{
    cpu_set (i, per_cpu (cpu_core_map, cpu));
    cpu_set (cpu, per_cpu (cpu_core_map, i));
    if (cpus_weight (per_cpu (cpu_sibling_map, cpu)) == 1) {
        if (first_cpu (per_cpu (cpu_sibling_map, i)) == i)
            c->booted_cores++;
        if (i != cpu)
            cpu_data (i).booted_cores++;
    }
    else if (i != cpu && !c->booted_cores)
        c->booted_cores = cpu_data (i).booted_cores;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/smpboot.c.ifdefed" startline="480" endline="493">
{
    if (first_cpu (per_cpu (cpu_sibling_map, i)) == i)
        c->booted_cores++;
    if (i != cpu)
        cpu_data (i).booted_cores++;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/smpboot.c.ifdefed" startline="501" endline="511">
{
    struct cpuinfo_x86 *c = &cpu_data (cpu);
    if (sched_mc_power_savings || sched_smt_power_savings)
        return per_cpu (cpu_core_map, cpu);
    else
        return c->llc_shared_map;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/smpboot.c.ifdefed" startline="514" endline="531">
{
    int cpu;
    unsigned long bogosum = 0;
    pr_debug ("Before bogomips.\n");
    for_each_possible_cpu (cpu)
    if (cpu_isset (cpu, cpu_callout_map))
        bogosum += cpu_data (cpu).loops_per_jiffy;
    printk (KERN_INFO "Total of %d processors activated (%lu.%02lu BogoMIPS).\n", num_online_cpus (), bogosum / (500000 / HZ), (bogosum / (5000 / HZ)) % 100);
    pr_debug ("Before bogocount - setting activated=1.\n");
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/smpboot.c.ifdefed" startline="534" endline="571">
{
    unsigned i, regs [] = {APIC_ID >> 4, APIC_LVR >> 4, APIC_SPIV >> 4};
    char *names [] = {"ID", "VERSION", "SPIV"};
    int timeout;
    u32 status;
    printk (KERN_INFO "Inquiring remote APIC #%d...\n", apicid);
    for (i = 0; i < ARRAY_SIZE (regs); i++) {
        printk (KERN_INFO "... APIC #%d %s: ", apicid, names [i]);
        status = safe_apic_wait_icr_idle ();
        if (status)
            printk (KERN_CONT "a previous APIC delivery may have failed\n");
        apic_write (APIC_ICR2, SET_APIC_DEST_FIELD (apicid));
        apic_write (APIC_ICR, APIC_DM_REMRD | regs [i]);
        timeout = 0;
        do {
            udelay (100);
            status = apic_read (APIC_ICR) & APIC_ICR_RR_MASK;
        }
        while (status == APIC_ICR_RR_INPROG && timeout++ < 1000);
        switch (status) {
        case APIC_ICR_RR_VALID :
            status = apic_read (APIC_RRR);
            printk (KERN_CONT "%08x\n", status);
            break;
        default :
            printk (KERN_CONT "failed\n");
        }
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/smpboot.c.ifdefed" startline="542" endline="570">
{
    printk (KERN_INFO "... APIC #%d %s: ", apicid, names [i]);
    status = safe_apic_wait_icr_idle ();
    if (status)
        printk (KERN_CONT "a previous APIC delivery may have failed\n");
    apic_write (APIC_ICR2, SET_APIC_DEST_FIELD (apicid));
    apic_write (APIC_ICR, APIC_DM_REMRD | regs [i]);
    timeout = 0;
    do {
        udelay (100);
        status = apic_read (APIC_ICR) & APIC_ICR_RR_MASK;
    }
    while (status == APIC_ICR_RR_INPROG && timeout++ < 1000);
    switch (status) {
    case APIC_ICR_RR_VALID :
        status = apic_read (APIC_RRR);
        printk (KERN_CONT "%08x\n", status);
        break;
    default :
        printk (KERN_CONT "failed\n");
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/smpboot.c.ifdefed" startline="557" endline="560">
{
    udelay (100);
    status = apic_read (APIC_ICR) & APIC_ICR_RR_MASK;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/smpboot.c.ifdefed" startline="562" endline="569">
{
case APIC_ICR_RR_VALID :
    status = apic_read (APIC_RRR);
    printk (KERN_CONT "%08x\n", status);
    break;
default :
    printk (KERN_CONT "failed\n");
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/smpboot.c.ifdefed" startline="750" endline="756">
{
    struct create_idle *c_idle = container_of (work, struct create_idle, work);
    c_idle->idle = fork_idle (c_idle->cpu);
    complete (& c_idle -> done);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/smpboot.c.ifdefed" startline="810" endline="963">
{
    unsigned long boot_error = 0;
    int timeout;
    unsigned long start_ip;
    unsigned short nmi_high = 0, nmi_low = 0;
    struct create_idle c_idle = {
        .cpu = cpu,
        .done = COMPLETION_INITIALIZER_ONSTACK (c_idle.done),
    };
    INIT_WORK (& c_idle.work, do_fork_idle);
    alternatives_smp_switch (1);
    c_idle.idle = get_idle_for_cpu (cpu);
    if (c_idle.idle) {
        c_idle.idle->thread.sp = (unsigned long) (((struct pt_regs *) (THREAD_SIZE + task_stack_page (c_idle.idle))) - 1);
        init_idle (c_idle.idle, cpu);
        goto do_rest;
    }
    if (!keventd_up () || current_is_keventd ())
        c_idle.work.func (&c_idle.work);
    else {
        schedule_work (& c_idle.work);
        wait_for_completion (& c_idle.done);
    }
    if (IS_ERR (c_idle.idle)) {
        printk ("failed fork for CPU %d\n", cpu);
        return PTR_ERR (c_idle.idle);
    }
    set_idle_for_cpu (cpu, c_idle.idle);
do_rest :
    cpu_pda (cpu)->pcurrent = c_idle.idle;
    clear_tsk_thread_flag (c_idle.idle, TIF_FORK);
    early_gdt_descr.address = (unsigned long) get_cpu_gdt_table (cpu);
    initial_code = (unsigned long) start_secondary;
    stack_start.sp = (void *) c_idle.idle->thread.sp;
    start_ip = setup_trampoline ();
    printk (KERN_INFO "Booting processor %d/%d ip %lx\n", cpu, apicid, start_ip);
    atomic_set (& init_deasserted, 0);
    if (get_uv_system_type () != UV_NON_UNIQUE_APIC) {
        pr_debug ("Setting warm reset code and vector.\n");
        store_NMI_vector (& nmi_high, & nmi_low);
        smpboot_setup_warm_reset_vector (start_ip);
        apic_write (APIC_ESR, 0);
        apic_read (APIC_ESR);
    }
    boot_error = wakeup_secondary_cpu (apicid, start_ip);
    if (!boot_error) {
        pr_debug ("Before Callout %d.\n", cpu);
        cpu_set (cpu, cpu_callout_map);
        pr_debug ("After Callout %d.\n", cpu);
        for (timeout = 0; timeout < 50000; timeout++) {
            if (cpu_isset (cpu, cpu_callin_map))
                break;
            udelay (100);
        }
        if (cpu_isset (cpu, cpu_callin_map)) {
            pr_debug ("OK.\n");
            printk (KERN_INFO "CPU%d: ", cpu);
            print_cpu_info (& cpu_data (cpu));
            pr_debug ("CPU has booted.\n");
        }
        else {
            boot_error = 1;
            if (*((volatile unsigned char *) trampoline_base) == 0xA5)
                printk (KERN_ERR "Stuck ??\n");
            else
                printk (KERN_ERR "Not responding.\n");
            if (get_uv_system_type () != UV_NON_UNIQUE_APIC)
                inquire_remote_apic (apicid);
        }
    }
    if (boot_error) {
        numa_remove_cpu (cpu);
        cpu_clear (cpu, cpu_callout_map);
        cpu_clear (cpu, cpu_initialized);
        cpu_clear (cpu, cpu_present_map);
        per_cpu (x86_cpu_to_apicid, cpu) = BAD_APICID;
    }
    *((volatile unsigned long *) trampoline_base) = 0;
    smpboot_restore_warm_reset_vector ();
    return boot_error;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/smpboot.c.ifdefed" startline="839" endline="844">
{
    c_idle.idle->thread.sp = (unsigned long) (((struct pt_regs *) (THREAD_SIZE + task_stack_page (c_idle.idle))) - 1);
    init_idle (c_idle.idle, cpu);
    goto do_rest;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/smpboot.c.ifdefed" startline="848" endline="851">
{
    schedule_work (& c_idle.work);
    wait_for_completion (& c_idle.done);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/smpboot.c.ifdefed" startline="853" endline="856">
{
    printk ("failed fork for CPU %d\n", cpu);
    return PTR_ERR (c_idle.idle);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/smpboot.c.ifdefed" startline="887" endline="899">
{
    pr_debug ("Setting warm reset code and vector.\n");
    store_NMI_vector (& nmi_high, & nmi_low);
    smpboot_setup_warm_reset_vector (start_ip);
    apic_write (APIC_ESR, 0);
    apic_read (APIC_ESR);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/smpboot.c.ifdefed" startline="906" endline="941">
{
    pr_debug ("Before Callout %d.\n", cpu);
    cpu_set (cpu, cpu_callout_map);
    pr_debug ("After Callout %d.\n", cpu);
    for (timeout = 0; timeout < 50000; timeout++) {
        if (cpu_isset (cpu, cpu_callin_map))
            break;
        udelay (100);
    }
    if (cpu_isset (cpu, cpu_callin_map)) {
        pr_debug ("OK.\n");
        printk (KERN_INFO "CPU%d: ", cpu);
        print_cpu_info (& cpu_data (cpu));
        pr_debug ("CPU has booted.\n");
    }
    else {
        boot_error = 1;
        if (*((volatile unsigned char *) trampoline_base) == 0xA5)
            printk (KERN_ERR "Stuck ??\n");
        else
            printk (KERN_ERR "Not responding.\n");
        if (get_uv_system_type () != UV_NON_UNIQUE_APIC)
            inquire_remote_apic (apicid);
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/smpboot.c.ifdefed" startline="917" endline="921">
{
    if (cpu_isset (cpu, cpu_callin_map))
        break;
    udelay (100);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/smpboot.c.ifdefed" startline="923" endline="929">
{
    pr_debug ("OK.\n");
    printk (KERN_INFO "CPU%d: ", cpu);
    print_cpu_info (& cpu_data (cpu));
    pr_debug ("CPU has booted.\n");
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/smpboot.c.ifdefed" startline="929" endline="940">
{
    boot_error = 1;
    if (*((volatile unsigned char *) trampoline_base) == 0xA5)
        printk (KERN_ERR "Stuck ??\n");
    else
        printk (KERN_ERR "Not responding.\n");
    if (get_uv_system_type () != UV_NON_UNIQUE_APIC)
        inquire_remote_apic (apicid);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/smpboot.c.ifdefed" startline="945" endline="952">
{
    numa_remove_cpu (cpu);
    cpu_clear (cpu, cpu_callout_map);
    cpu_clear (cpu, cpu_initialized);
    cpu_clear (cpu, cpu_present_map);
    per_cpu (x86_cpu_to_apicid, cpu) = BAD_APICID;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/smpboot.c.ifdefed" startline="966" endline="1030">
{
    int apicid = cpu_present_to_apicid (cpu);
    unsigned long flags;
    int err;
    WARN_ON (irqs_disabled ());
    pr_debug ("++++++++++++++++++++=_---CPU UP  %u\n", cpu);
    if (apicid == BAD_APICID || apicid == boot_cpu_physical_apicid || !physid_isset (apicid, phys_cpu_present_map)) {
        printk (KERN_ERR "%s: bad cpu %d\n", __func__, cpu);
        return -EINVAL;
    }
    if (cpu_isset (cpu, cpu_callin_map)) {
        pr_debug ("do_boot_cpu %d Already started\n", cpu);
        return -ENOSYS;
    }
    mtrr_save_state ();
    per_cpu (cpu_state, cpu) = CPU_UP_PREPARE;
    err = do_boot_cpu (apicid, cpu);
    if (err) {
        pr_debug ("do_boot_cpu failed %d\n", err);
        return -EIO;
    }
    local_irq_save (flags);
    check_tsc_sync_source (cpu);
    local_irq_restore (flags);
    while (!cpu_online (cpu)) {
        cpu_relax ();
        touch_nmi_watchdog ();
    }
    return 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/smpboot.c.ifdefed" startline="976" endline="979">
{
    printk (KERN_ERR "%s: bad cpu %d\n", __func__, cpu);
    return -EINVAL;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/smpboot.c.ifdefed" startline="984" endline="987">
{
    pr_debug ("do_boot_cpu %d Already started\n", cpu);
    return -ENOSYS;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/smpboot.c.ifdefed" startline="1011" endline="1014">
{
    pr_debug ("do_boot_cpu failed %d\n", err);
    return -EIO;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/smpboot.c.ifdefed" startline="1024" endline="1027">
{
    cpu_relax ();
    touch_nmi_watchdog ();
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/smpboot.c.ifdefed" startline="1038" endline="1050">
{
    cpu_present_map = cpumask_of_cpu (0);
    cpu_possible_map = cpumask_of_cpu (0);
    smpboot_clear_io_apic_irqs ();
    if (smp_found_config)
        physid_set_mask_of_physid (boot_cpu_physical_apicid, &phys_cpu_present_map);
    else
        physid_set_mask_of_physid (0, &phys_cpu_present_map);
    map_cpu_to_logical_apicid ();
    cpu_set (0, per_cpu (cpu_sibling_map, 0));
    cpu_set (0, per_cpu (cpu_core_map, 0));
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/smpboot.c.ifdefed" startline="1056" endline="1149">
{
    preempt_disable ();
    if (!physid_isset (hard_smp_processor_id (), phys_cpu_present_map)) {
        printk (KERN_WARNING "weird, boot CPU (#%d) not listed" "by the BIOS.\n", hard_smp_processor_id ());
        physid_set (hard_smp_processor_id (), phys_cpu_present_map);
    }
    if (!smp_found_config && !acpi_lapic) {
        preempt_enable ();
        printk (KERN_NOTICE "SMP motherboard not detected.\n");
        disable_smp ();
        if (APIC_init_uniprocessor ())
            printk (KERN_NOTICE "Local APIC not detected." " Using dummy APIC emulation.\n");
        return -1;
    }
    if (!check_phys_apicid_present (boot_cpu_physical_apicid)) {
        printk (KERN_NOTICE "weird, boot CPU (#%d) not listed by the BIOS.\n", boot_cpu_physical_apicid);
        physid_set (hard_smp_processor_id (), phys_cpu_present_map);
    }
    preempt_enable ();
    if (APIC_INTEGRATED (apic_version[boot_cpu_physical_apicid]) && !cpu_has_apic) {
        printk (KERN_ERR "BIOS bug, local APIC #%d not detected!...\n", boot_cpu_physical_apicid);
        printk (KERN_ERR "... forcing use of dummy APIC emulation." "(tell your hw vendor)\n");
        smpboot_clear_io_apic ();
        return -1;
    }
    verify_local_APIC ();
    if (!max_cpus) {
        printk (KERN_INFO "SMP mode deactivated.\n");
        smpboot_clear_io_apic ();
        localise_nmi_watchdog ();
        connect_bsp_APIC ();
        setup_local_APIC ();
        end_local_APIC_setup ();
        return -1;
    }
    return 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/smpboot.c.ifdefed" startline="1086" endline="1090">
{
    printk (KERN_WARNING "weird, boot CPU (#%d) not listed" "by the BIOS.\n", hard_smp_processor_id ());
    physid_set (hard_smp_processor_id (), phys_cpu_present_map);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/smpboot.c.ifdefed" startline="1096" endline="1104">
{
    preempt_enable ();
    printk (KERN_NOTICE "SMP motherboard not detected.\n");
    disable_smp ();
    if (APIC_init_uniprocessor ())
        printk (KERN_NOTICE "Local APIC not detected." " Using dummy APIC emulation.\n");
    return -1;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/smpboot.c.ifdefed" startline="1110" endline="1115">
{
    printk (KERN_NOTICE "weird, boot CPU (#%d) not listed by the BIOS.\n", boot_cpu_physical_apicid);
    physid_set (hard_smp_processor_id (), phys_cpu_present_map);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/smpboot.c.ifdefed" startline="1122" endline="1129">
{
    printk (KERN_ERR "BIOS bug, local APIC #%d not detected!...\n", boot_cpu_physical_apicid);
    printk (KERN_ERR "... forcing use of dummy APIC emulation." "(tell your hw vendor)\n");
    smpboot_clear_io_apic ();
    return -1;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/smpboot.c.ifdefed" startline="1136" endline="1146">
{
    printk (KERN_INFO "SMP mode deactivated.\n");
    smpboot_clear_io_apic ();
    localise_nmi_watchdog ();
    connect_bsp_APIC ();
    setup_local_APIC ();
    end_local_APIC_setup ();
    return -1;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/smpboot.c.ifdefed" startline="1152" endline="1161">
{
    int i;
    struct cpuinfo_x86 *c;

    for_each_possible_cpu (i) {
        c = &cpu_data (i);
        c->cpu_index = NR_CPUS;
    }

}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/smpboot.c.ifdefed" startline="1156" endline="1160">
{
    c = &cpu_data (i);
    c->cpu_index = NR_CPUS;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/smpboot.c.ifdefed" startline="1168" endline="1229">
{
    preempt_disable ();
    smp_cpu_index_default ();
    current_cpu_data = boot_cpu_data;
    cpu_callin_map = cpumask_of_cpu (0);
    mb ();
    smp_store_cpu_info (0);
    boot_cpu_logical_apicid = logical_smp_processor_id ();
    current_thread_info ()->cpu = 0;
    set_cpu_sibling_map (0);
    if (smp_sanity_check (max_cpus) < 0) {
        printk (KERN_INFO "SMP disabled\n");
        disable_smp ();
        goto out;
    }
    preempt_disable ();
    if (GET_APIC_ID (read_apic_id ()) != boot_cpu_physical_apicid) {
        panic ("Boot APIC ID in local APIC unexpected (%d vs %d)", GET_APIC_ID (read_apic_id ()), boot_cpu_physical_apicid);
    }
    preempt_enable ();
    connect_bsp_APIC ();
    setup_local_APIC ();
    end_local_APIC_setup ();
    map_cpu_to_logical_apicid ();
    setup_portio_remap ();
    smpboot_setup_io_apic ();
    printk (KERN_INFO "CPU%d: ", 0);
    print_cpu_info (& cpu_data (0));
    setup_boot_clock ();
    if (is_uv_system ())
        uv_system_init ();
out :
    preempt_enable ();
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/smpboot.c.ifdefed" startline="1182" endline="1186">
{
    printk (KERN_INFO "SMP disabled\n");
    disable_smp ();
    goto out;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/smpboot.c.ifdefed" startline="1189" endline="1193">
{
    panic ("Boot APIC ID in local APIC unexpected (%d vs %d)", GET_APIC_ID (read_apic_id ()), boot_cpu_physical_apicid);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/smpboot.c.ifdefed" startline="1234" endline="1243">
{
    int me = smp_processor_id ();
    switch_to_new_gdt ();
    cpu_set (me, cpu_callout_map);
    per_cpu (cpu_state, me) = CPU_ONLINE;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/smpboot.c.ifdefed" startline="1246" endline="1255">
{
    pr_debug ("Boot done.\n");
    impress_friends ();
    smp_checks ();
    check_nmi_watchdog ();
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/smpboot.c.ifdefed" startline="1407" endline="1409">
{
    return -ENOSYS;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/smpboot.c.ifdefed" startline="1412" endline="1415">
{
    BUG ();
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/test_nx.c.ifdefed" startline="46" endline="63">
{
    struct module *mod = THIS_MODULE;
    struct exception_table_entry *extable;
    if (mod->num_exentries > 1) {
        printk (KERN_ERR "test_nx: too many exception table entries!\n");
        printk (KERN_ERR "test_nx: test results are not reliable.\n");
        return;
    }
    extable = (struct exception_table_entry *) mod->extable;
    extable[0].insn = (unsigned long) new;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/test_nx.c.ifdefed" startline="56" endline="60">
{
    printk (KERN_ERR "test_nx: too many exception table entries!\n");
    printk (KERN_ERR "test_nx: test results are not reliable.\n");
    return;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/test_nx.c.ifdefed" startline="81" endline="105">
{
    unsigned long result;
    fudze_exception_table (& foo_label, address);
    result = 1;
    asm volatile ("foo_label:\n"
        "0:	call *%[fake_code]\n"
        "1:\n"
        ".section .fixup,\"ax\"\n"
        "2:	mov %[zero], %[rslt]\n"
        "	ret\n"
        ".previous\n"
        _ASM_EXTABLE (0b, 2b)
        : [rslt] "=r" (result)
        : [fake_code] "r" (address), [zero] "r" (0UL), "0" (result)
    ) fudze_exception_table (address, & foo_label);
    if (result)
        return -ENODEV;
    return 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/test_nx.c.ifdefed" startline="110" endline="165">
{
    int ret = 0;
    char stackcode [] = {0xC3, 0x90, 0};
    char *heap;
    test_data = 0xC3;
    printk (KERN_INFO "Testing NX protection\n");
    if (test_address (&stackcode)) {
        printk (KERN_ERR "test_nx: stack was executable\n");
        ret = -ENODEV;
    }
    heap = kmalloc (64, GFP_KERNEL);
    if (!heap)
        return -ENOMEM;
    heap[0] = 0xC3;
    if (test_address (heap)) {
        printk (KERN_ERR "test_nx: heap was executable\n");
        ret = -ENODEV;
    }
    kfree (heap);
    return 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/test_nx.c.ifdefed" startline="121" endline="124">
{
    printk (KERN_ERR "test_nx: stack was executable\n");
    ret = -ENODEV;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/test_nx.c.ifdefed" startline="133" endline="136">
{
    printk (KERN_ERR "test_nx: heap was executable\n");
    ret = -ENODEV;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/test_nx.c.ifdefed" startline="168" endline="169">
{
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/early_printk.c.ifdefed" startline="19" endline="49">
{
    char c;
    int i, k, j;
    while ((c = *str++) != '\0' && n-- > 0) {
        if (current_ypos >= max_ypos) {
            for (k = 1, j = 0; k < max_ypos; k++, j++) {
                for (i = 0; i < max_xpos; i++) {
                    writew (readw (VGABASE + 2 * (max_xpos * k + i)), VGABASE + 2 * (max_xpos * j + i));
                }
            }
            for (i = 0; i < max_xpos; i++)
                writew (0x720, VGABASE +2 * (max_xpos * j + i));
            current_ypos = max_ypos - 1;
        }
        if (c == '\n') {
            current_xpos = 0;
            current_ypos++;
        }
        else if (c != '\r') {
            writew (((0x7 << 8) | (unsigned short) c), VGABASE + 2 * (max_xpos * current_ypos + current_xpos ++));
            if (current_xpos >= max_xpos) {
                current_xpos = 0;
                current_ypos++;
            }
        }
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/early_printk.c.ifdefed" startline="23" endline="48">
{
    if (current_ypos >= max_ypos) {
        for (k = 1, j = 0; k < max_ypos; k++, j++) {
            for (i = 0; i < max_xpos; i++) {
                writew (readw (VGABASE + 2 * (max_xpos * k + i)), VGABASE + 2 * (max_xpos * j + i));
            }
        }
        for (i = 0; i < max_xpos; i++)
            writew (0x720, VGABASE +2 * (max_xpos * j + i));
        current_ypos = max_ypos - 1;
    }
    if (c == '\n') {
        current_xpos = 0;
        current_ypos++;
    }
    else if (c != '\r') {
        writew (((0x7 << 8) | (unsigned short) c), VGABASE + 2 * (max_xpos * current_ypos + current_xpos ++));
        if (current_xpos >= max_xpos) {
            current_xpos = 0;
            current_ypos++;
        }
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/early_printk.c.ifdefed" startline="24" endline="35">
{
    for (k = 1, j = 0; k < max_ypos; k++, j++) {
        for (i = 0; i < max_xpos; i++) {
            writew (readw (VGABASE + 2 * (max_xpos * k + i)), VGABASE + 2 * (max_xpos * j + i));
        }
    }
    for (i = 0; i < max_xpos; i++)
        writew (0x720, VGABASE +2 * (max_xpos * j + i));
    current_ypos = max_ypos - 1;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/early_printk.c.ifdefed" startline="26" endline="31">
{
    for (i = 0; i < max_xpos; i++) {
        writew (readw (VGABASE + 2 * (max_xpos * k + i)), VGABASE + 2 * (max_xpos * j + i));
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/early_printk.c.ifdefed" startline="27" endline="30">
{
    writew (readw (VGABASE + 2 * (max_xpos * k + i)), VGABASE + 2 * (max_xpos * j + i));
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/early_printk.c.ifdefed" startline="36" endline="39">
{
    current_xpos = 0;
    current_ypos++;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/early_printk.c.ifdefed" startline="39" endline="47">
{
    writew (((0x7 << 8) | (unsigned short) c), VGABASE + 2 * (max_xpos * current_ypos + current_xpos ++));
    if (current_xpos >= max_xpos) {
        current_xpos = 0;
        current_ypos++;
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/early_printk.c.ifdefed" startline="43" endline="46">
{
    current_xpos = 0;
    current_ypos++;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/early_printk.c.ifdefed" startline="79" endline="85">
{
    unsigned timeout = 0xffff;
    while ((inb (early_serial_base +LSR) & XMTRDY) == 0 && --timeout)
        cpu_relax ();
    outb (ch, early_serial_base + TXR);
    return timeout ? 0 : -1;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/early_printk.c.ifdefed" startline="88" endline="95">
{
    while (*s && n-- > 0) {
        if (*s == '\n')
            early_serial_putc ('\r');
        early_serial_putc (*s);
        s++;
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/early_printk.c.ifdefed" startline="89" endline="94">
{
    if (*s == '\n')
        early_serial_putc ('\r');
    early_serial_putc (*s);
    s++;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/early_printk.c.ifdefed" startline="100" endline="145">
{
    unsigned char c;
    unsigned divisor;
    unsigned baud = DEFAULT_BAUD;
    char *e;
    if (*s == ',')
        ++s;
    if (*s) {
        unsigned port;
        if (!strncmp (s, "0x", 2)) {
            early_serial_base = simple_strtoul (s, &e, 16);
        }
        else {
            static int bases [] = {0x3f8, 0x2f8};
            if (!strncmp (s, "ttyS", 4))
                s += 4;
            port = simple_strtoul (s, &e, 10);
            if (port > 1 || s == e)
                port = 0;
            early_serial_base = bases[port];
        }
        s += strcspn (s, ",");
        if (*s == ',')
            s++;
    }
    outb (0x3, early_serial_base + LCR);
    outb (0, early_serial_base + IER);
    outb (0, early_serial_base + FCR);
    outb (0x3, early_serial_base + MCR);
    if (*s) {
        baud = simple_strtoul (s, &e, 0);
        if (baud == 0 || s == e)
            baud = DEFAULT_BAUD;
    }
    divisor = 115200 / baud;
    c = inb (early_serial_base +LCR);
    outb (c | DLAB, early_serial_base + LCR);
    outb (divisor & 0xff, early_serial_base + DLL);
    outb ((divisor >> 8) & 0xff, early_serial_base + DLH);
    outb (c & ~ DLAB, early_serial_base + LCR);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/early_printk.c.ifdefed" startline="109" endline="126">
{
    unsigned port;
    if (!strncmp (s, "0x", 2)) {
        early_serial_base = simple_strtoul (s, &e, 16);
    }
    else {
        static int bases [] = {0x3f8, 0x2f8};
        if (!strncmp (s, "ttyS", 4))
            s += 4;
        port = simple_strtoul (s, &e, 10);
        if (port > 1 || s == e)
            port = 0;
        early_serial_base = bases[port];
    }
    s += strcspn (s, ",");
    if (*s == ',')
        s++;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/early_printk.c.ifdefed" startline="111" endline="113">
{
    early_serial_base = simple_strtoul (s, &e, 16);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/early_printk.c.ifdefed" startline="113" endline="122">
{
    static int bases [] = {0x3f8, 0x2f8};
    if (!strncmp (s, "ttyS", 4))
        s += 4;
    port = simple_strtoul (s, &e, 10);
    if (port > 1 || s == e)
        port = 0;
    early_serial_base = bases[port];
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/early_printk.c.ifdefed" startline="133" endline="137">
{
    baud = simple_strtoul (s, &e, 0);
    if (baud == 0 || s == e)
        baud = DEFAULT_BAUD;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/early_printk.c.ifdefed" startline="166" endline="172">
{
    long ret;
    asm volatile ("cpuid"
        : "=a" (ret)
        : "b" (a), "c" (b), "d" (c), "0" (MAGIC1), "D" (cmd + MAGIC2)
    ) return ret;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/early_printk.c.ifdefed" startline="175" endline="181">
{
    char *fn = "klog";
    if (*str == '=')
        fn = ++str;
    simnow_fd = simnow (XOPEN, (unsigned long) fn, O_WRONLY | O_APPEND | O_CREAT, 0644);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/early_printk.c.ifdefed" startline="184" endline="186">
{
    simnow (XWRITE, simnow_fd, (unsigned long) s, n);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/early_printk.c.ifdefed" startline="200" endline="209">
{
    char buf [512];
    int n;
    va_list ap;
    va_start (ap, fmt);
    n = vscnprintf (buf, 512, fmt, ap);
    early_console->write (early_console, buf, n);
    va_end (ap);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/early_printk.c.ifdefed" startline="214" endline="253">
{
    if (!buf)
        return 0;
    if (early_console_initialized)
        return 0;
    early_console_initialized = 1;
    if (strstr (buf, "keep"))
        keep_early = 1;
    if (!strncmp (buf, "serial", 6)) {
        early_serial_init (buf + 6);
        early_console = &early_serial_console;
    }
    else if (!strncmp (buf, "ttyS", 4)) {
        early_serial_init (buf);
        early_console = &early_serial_console;
    }
    else if (!strncmp (buf, "vga", 3) && boot_params.screen_info.orig_video_isVGA == 1) {
        max_xpos = boot_params.screen_info.orig_video_cols;
        max_ypos = boot_params.screen_info.orig_video_lines;
        current_ypos = boot_params.screen_info.orig_y;
        early_console = &early_vga_console;
    }
    else if (!strncmp (buf, "simnow", 6)) {
        simnow_init (buf + 6);
        early_console = &simnow_console;
        keep_early = 1;
    }
    if (keep_early)
        early_console->flags &= ~CON_BOOT;
    else
        early_console->flags |= CON_BOOT;
    register_console (early_console);
    return 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/early_printk.c.ifdefed" startline="225" endline="228">
{
    early_serial_init (buf + 6);
    early_console = &early_serial_console;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/early_printk.c.ifdefed" startline="228" endline="231">
{
    early_serial_init (buf);
    early_console = &early_serial_console;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/early_printk.c.ifdefed" startline="232" endline="237">
{
    max_xpos = boot_params.screen_info.orig_video_cols;
    max_ypos = boot_params.screen_info.orig_video_lines;
    current_ypos = boot_params.screen_info.orig_y;
    early_console = &early_vga_console;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/early_printk.c.ifdefed" startline="237" endline="245">
{
    simnow_init (buf + 6);
    early_console = &simnow_console;
    keep_early = 1;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/step.c.ifdefed" startline="9" endline="49">
{
    unsigned long addr, seg;
    addr = regs->ip;
    seg = regs->cs & 0xffff;
    if (v8086_mode (regs)) {
        addr = (addr & 0xffff) + (seg << 4);
        return addr;
    }
    if ((seg & SEGMENT_TI_MASK) == SEGMENT_LDT) {
        u32 *desc;
        unsigned long base;
        seg &= ~7UL;
        mutex_lock (& child -> mm -> context.lock);
        if (unlikely ((seg >> 3) >= child->mm->context.size))
            addr = -1L;
        else {
            desc = child->mm->context.ldt + seg;
            base = ((desc[0] >> 16) | ((desc[1] & 0xff) << 16) | (desc[1] & 0xff000000));
            if (!((desc[1] >> 22) & 1))
                addr &= 0xffff;
            addr += base;
        }
        mutex_unlock (& child -> mm -> context.lock);
    }
    return addr;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/step.c.ifdefed" startline="14" endline="17">
{
    addr = (addr & 0xffff) + (seg << 4);
    return addr;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/step.c.ifdefed" startline="25" endline="46">
{
    u32 *desc;
    unsigned long base;
    seg &= ~7UL;
    mutex_lock (& child -> mm -> context.lock);
    if (unlikely ((seg >> 3) >= child->mm->context.size))
        addr = -1L;
    else {
        desc = child->mm->context.ldt + seg;
        base = ((desc[0] >> 16) | ((desc[1] & 0xff) << 16) | (desc[1] & 0xff000000));
        if (!((desc[1] >> 22) & 1))
            addr &= 0xffff;
        addr += base;
    }
    mutex_unlock (& child -> mm -> context.lock);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/step.c.ifdefed" startline="34" endline="44">
{
    desc = child->mm->context.ldt + seg;
    base = ((desc[0] >> 16) | ((desc[1] & 0xff) << 16) | (desc[1] & 0xff000000));
    if (!((desc[1] >> 22) & 1))
        addr &= 0xffff;
    addr += base;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/step.c.ifdefed" startline="52" endline="100">
{
    int i, copied;
    unsigned char opcode [15];
    unsigned long addr = convert_ip_to_linear (child, regs);
    copied = access_process_vm (child, addr, opcode, sizeof (opcode), 0);
    for (i = 0; i < copied; i++) {
        switch (opcode[i]) {
        case 0x9d :
        case 0xcf :
            return 1;
        case 0x66 :
        case 0x67 :
            continue;
        case 0x26 :
        case 0x2e :
        case 0x36 :
        case 0x3e :
        case 0x64 :
        case 0x65 :
        case 0xf0 :
        case 0xf2 :
        case 0xf3 :
            continue;
        case 0x9c :
        default :
            return 0;
        }
    }
    return 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/step.c.ifdefed" startline="58" endline="98">
{
    switch (opcode[i]) {
    case 0x9d :
    case 0xcf :
        return 1;
    case 0x66 :
    case 0x67 :
        continue;
    case 0x26 :
    case 0x2e :
    case 0x36 :
    case 0x3e :
    case 0x64 :
    case 0x65 :
    case 0xf0 :
    case 0xf2 :
    case 0xf3 :
        continue;
    case 0x9c :
    default :
        return 0;
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/step.c.ifdefed" startline="59" endline="97">
{
case 0x9d :
case 0xcf :
    return 1;
case 0x66 :
case 0x67 :
    continue;
case 0x26 :
case 0x2e :
case 0x36 :
case 0x3e :
case 0x64 :
case 0x65 :
case 0xf0 :
case 0xf2 :
case 0xf3 :
    continue;
case 0x9c :
default :
    return 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/step.c.ifdefed" startline="106" endline="159">
{
    struct pt_regs *regs = task_pt_regs (child);
    unsigned long oflags;
    if (unlikely (test_tsk_thread_flag (child, TIF_SINGLESTEP)))
        regs->flags |= X86_EFLAGS_TF;
    set_tsk_thread_flag (child, TIF_SINGLESTEP);
    oflags = regs->flags;
    regs->flags |= X86_EFLAGS_TF;
    if (is_setting_trap_flag (child, regs)) {
        clear_tsk_thread_flag (child, TIF_FORCED_TF);
        return 0;
    }
    if (oflags & X86_EFLAGS_TF)
        return test_tsk_thread_flag (child, TIF_FORCED_TF);
    set_tsk_thread_flag (child, TIF_FORCED_TF);
    return 1;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/step.c.ifdefed" startline="144" endline="147">
{
    clear_tsk_thread_flag (child, TIF_FORCED_TF);
    return 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/step.c.ifdefed" startline="165" endline="175">
{
    if (child->thread.debugctlmsr == val)
        return;
    child->thread.debugctlmsr = val;
    if (child != current)
        return;
    update_debugctlmsr (val);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/step.c.ifdefed" startline="181" endline="200">
{
    if (enable_single_step (child) && block) {
        set_tsk_thread_flag (child, TIF_DEBUGCTLMSR);
        write_debugctlmsr (child, child -> thread.debugctlmsr | DEBUGCTLMSR_BTF);
    }
    else {
        write_debugctlmsr (child, child -> thread.debugctlmsr & ~ DEBUGCTLMSR_BTF);
        if (!child->thread.debugctlmsr)
            clear_tsk_thread_flag (child, TIF_DEBUGCTLMSR);
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/step.c.ifdefed" startline="189" endline="193">
{
    set_tsk_thread_flag (child, TIF_DEBUGCTLMSR);
    write_debugctlmsr (child, child -> thread.debugctlmsr | DEBUGCTLMSR_BTF);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/step.c.ifdefed" startline="193" endline="199">
{
    write_debugctlmsr (child, child -> thread.debugctlmsr & ~ DEBUGCTLMSR_BTF);
    if (!child->thread.debugctlmsr)
        clear_tsk_thread_flag (child, TIF_DEBUGCTLMSR);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/step.c.ifdefed" startline="203" endline="205">
{
    enable_step (child, 0);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/step.c.ifdefed" startline="208" endline="210">
{
    enable_step (child, 1);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/step.c.ifdefed" startline="213" endline="229">
{
    write_debugctlmsr (child, child -> thread.debugctlmsr & ~ DEBUGCTLMSR_BTF);
    if (!child->thread.debugctlmsr)
        clear_tsk_thread_flag (child, TIF_DEBUGCTLMSR);
    clear_tsk_thread_flag (child, TIF_SINGLESTEP);
    if (test_and_clear_tsk_thread_flag (child, TIF_FORCED_TF))
        task_pt_regs (child)->flags &= ~X86_EFLAGS_TF;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/io_apic_64.c.ifdefed" startline="148" endline="151">
{
    return (void __iomem *) __fix_to_virt (FIX_IO_APIC_BASE_0 +idx) + (mp_ioapics[idx].mp_apicaddr & ~PAGE_MASK);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/io_apic_64.c.ifdefed" startline="154" endline="158">
{
    struct io_apic __iomem *io_apic = io_apic_base (apic);
    writel (reg, & io_apic -> index);
    return readl (&io_apic->data);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/io_apic_64.c.ifdefed" startline="161" endline="165">
{
    struct io_apic __iomem *io_apic = io_apic_base (apic);
    writel (reg, & io_apic -> index);
    writel (value, & io_apic -> data);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/io_apic_64.c.ifdefed" startline="172" endline="175">
{
    struct io_apic __iomem *io_apic = io_apic_base (apic);
    writel (value, & io_apic -> data);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/io_apic_64.c.ifdefed" startline="178" endline="204">
{
    struct irq_pin_list *entry;
    unsigned long flags;
    spin_lock_irqsave (& ioapic_lock, flags);
    entry = irq_2_pin + irq;
    for (;;) {
        unsigned int reg;
        int pin;
        pin = entry->pin;
        if (pin == -1)
            break;
        reg = io_apic_read (entry->apic, 0x10 + pin * 2);
        if (reg & IO_APIC_REDIR_REMOTE_IRR) {
            spin_unlock_irqrestore (& ioapic_lock, flags);
            return true;
        }
        if (!entry->next)
            break;
        entry = irq_2_pin + entry->next;
    }
    spin_unlock_irqrestore (& ioapic_lock, flags);
    return false;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/io_apic_64.c.ifdefed" startline="184" endline="200">
{
    unsigned int reg;
    int pin;
    pin = entry->pin;
    if (pin == -1)
        break;
    reg = io_apic_read (entry->apic, 0x10 + pin * 2);
    if (reg & IO_APIC_REDIR_REMOTE_IRR) {
        spin_unlock_irqrestore (& ioapic_lock, flags);
        return true;
    }
    if (!entry->next)
        break;
    entry = irq_2_pin + entry->next;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/io_apic_64.c.ifdefed" startline="193" endline="196">
{
    spin_unlock_irqrestore (& ioapic_lock, flags);
    return true;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/io_apic_64.c.ifdefed" startline="211" endline="214">
{
    struct io_apic __iomem *io_apic = io_apic_base (apic);
    readl (& io_apic -> data);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/io_apic_64.c.ifdefed" startline="244" endline="252">
{
    union entry_union eu;
    unsigned long flags;
    spin_lock_irqsave (& ioapic_lock, flags);
    eu.w1 = io_apic_read (apic, 0x10 + 2 * pin);
    eu.w2 = io_apic_read (apic, 0x11 + 2 * pin);
    spin_unlock_irqrestore (& ioapic_lock, flags);
    return eu.entry;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/io_apic_64.c.ifdefed" startline="262" endline="267">
{
    union entry_union eu;
    eu.entry = e;
    io_apic_write (apic, 0x11 + 2 * pin, eu.w2);
    io_apic_write (apic, 0x10 + 2 * pin, eu.w1);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/io_apic_64.c.ifdefed" startline="270" endline="275">
{
    unsigned long flags;
    spin_lock_irqsave (& ioapic_lock, flags);
    __ioapic_write_entry (apic, pin, e);
    spin_unlock_irqrestore (& ioapic_lock, flags);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/io_apic_64.c.ifdefed" startline="283" endline="291">
{
    unsigned long flags;
    union entry_union eu = {
        .entry.mask = 1
    };
    spin_lock_irqsave (& ioapic_lock, flags);
    io_apic_write (apic, 0x10 + 2 * pin, eu.w1);
    io_apic_write (apic, 0x11 + 2 * pin, eu.w2);
    spin_unlock_irqrestore (& ioapic_lock, flags);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/io_apic_64.c.ifdefed" startline="352" endline="368">
{
    static int first_free_entry = NR_IRQS;
    struct irq_pin_list *entry = irq_2_pin + irq;
    BUG_ON (irq >= NR_IRQS);
    while (entry->next)
        entry = irq_2_pin + entry->next;
    if (entry->pin != -1) {
        entry->next = first_free_entry;
        entry = irq_2_pin + entry->next;
        if (++first_free_entry >= PIN_MAP_SIZE)
            panic ("io_apic.c: ran out of irq_2_pin entries!");
    }
    entry->apic = apic;
    entry->pin = pin;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/io_apic_64.c.ifdefed" startline="360" endline="365">
{
    entry->next = first_free_entry;
    entry = irq_2_pin + entry->next;
    if (++first_free_entry >= PIN_MAP_SIZE)
        panic ("io_apic.c: ran out of irq_2_pin entries!");
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/io_apic_64.c.ifdefed" startline="376" endline="388">
{
    struct irq_pin_list *entry = irq_2_pin + irq;
    while (1) {
        if (entry->apic == oldapic && entry->pin == oldpin) {
            entry->apic = newapic;
            entry->pin = newpin;
        }
        if (!entry->next)
            break;
        entry = irq_2_pin + entry->next;
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/io_apic_64.c.ifdefed" startline="379" endline="387">
{
    if (entry->apic == oldapic && entry->pin == oldpin) {
        entry->apic = newapic;
        entry->pin = newpin;
    }
    if (!entry->next)
        break;
    entry = irq_2_pin + entry->next;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/io_apic_64.c.ifdefed" startline="380" endline="383">
{
    entry->apic = newapic;
    entry->pin = newpin;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/io_apic_64.c.ifdefed" startline="403" endline="409">
{
    unsigned long flags;
    spin_lock_irqsave (& ioapic_lock, flags);
    __mask_IO_APIC_irq (irq);
    spin_unlock_irqrestore (& ioapic_lock, flags);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/io_apic_64.c.ifdefed" startline="412" endline="418">
{
    unsigned long flags;
    spin_lock_irqsave (& ioapic_lock, flags);
    __unmask_IO_APIC_irq (irq);
    spin_unlock_irqrestore (& ioapic_lock, flags);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/io_apic_64.c.ifdefed" startline="421" endline="432">
{
    struct IO_APIC_route_entry entry;
    entry = ioapic_read_entry (apic, pin);
    if (entry.delivery_mode == dest_SMI)
        return;
    ioapic_mask_entry (apic, pin);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/io_apic_64.c.ifdefed" startline="435" endline="441">
{
    int apic, pin;
    for (apic = 0; apic < nr_ioapics; apic++)
        for (pin = 0; pin < nr_ioapic_registers[apic]; pin++)
            clear_IO_APIC_pin (apic, pin);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/io_apic_64.c.ifdefed" startline="447" endline="450">
{
    disable_ioapic_setup ();
    return 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/io_apic_64.c.ifdefed" startline="455" endline="458">
{
    disable_timer_pin_1 = 1;
    return 1;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/io_apic_64.c.ifdefed" startline="466" endline="477">
{
    int i;
    for (i = 0; i < mp_irq_entries; i++)
        if (mp_irqs[i].mp_irqtype == type && (mp_irqs[i].mp_dstapic == mp_ioapics[apic].mp_apicid || mp_irqs[i].mp_dstapic == MP_APIC_ALL) && mp_irqs[i].mp_dstirq == pin)
            return i;
    return -1;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/io_apic_64.c.ifdefed" startline="483" endline="496">
{
    int i;
    for (i = 0; i < mp_irq_entries; i++) {
        int lbus = mp_irqs[i].mp_srcbus;
        if (test_bit (lbus, mp_bus_not_pci) && (mp_irqs[i].mp_irqtype == type) && (mp_irqs[i].mp_srcbusirq == irq))
            return mp_irqs[i].mp_dstirq;
    }
    return -1;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/io_apic_64.c.ifdefed" startline="486" endline="494">
{
    int lbus = mp_irqs[i].mp_srcbus;
    if (test_bit (lbus, mp_bus_not_pci) && (mp_irqs[i].mp_irqtype == type) && (mp_irqs[i].mp_srcbusirq == irq))
        return mp_irqs[i].mp_dstirq;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/io_apic_64.c.ifdefed" startline="499" endline="519">
{
    int i;
    for (i = 0; i < mp_irq_entries; i++) {
        int lbus = mp_irqs[i].mp_srcbus;
        if (test_bit (lbus, mp_bus_not_pci) && (mp_irqs[i].mp_irqtype == type) && (mp_irqs[i].mp_srcbusirq == irq))
            break;
    }
    if (i < mp_irq_entries) {
        int apic;
        for (apic = 0; apic < nr_ioapics; apic++) {
            if (mp_ioapics[apic].mp_apicid == mp_irqs[i].mp_dstapic)
                return apic;
        }
    }
    return -1;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/io_apic_64.c.ifdefed" startline="502" endline="509">
{
    int lbus = mp_irqs[i].mp_srcbus;
    if (test_bit (lbus, mp_bus_not_pci) && (mp_irqs[i].mp_irqtype == type) && (mp_irqs[i].mp_srcbusirq == irq))
        break;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/io_apic_64.c.ifdefed" startline="510" endline="516">
{
    int apic;
    for (apic = 0; apic < nr_ioapics; apic++) {
        if (mp_ioapics[apic].mp_apicid == mp_irqs[i].mp_dstapic)
            return apic;
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/io_apic_64.c.ifdefed" startline="512" endline="515">
{
    if (mp_ioapics[apic].mp_apicid == mp_irqs[i].mp_dstapic)
        return apic;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/io_apic_64.c.ifdefed" startline="528" endline="566">
{
    int apic, i, best_guess = -1;
    apic_printk (APIC_DEBUG, "querying PCI -> IRQ mapping bus:%d, slot:%d, pin:%d.\n", bus, slot, pin);
    if (test_bit (bus, mp_bus_not_pci)) {
        apic_printk (APIC_VERBOSE, "PCI BIOS passed nonexistent PCI bus %d!\n", bus);
        return -1;
    }
    for (i = 0; i < mp_irq_entries; i++) {
        int lbus = mp_irqs[i].mp_srcbus;
        for (apic = 0; apic < nr_ioapics; apic++)
            if (mp_ioapics[apic].mp_apicid == mp_irqs[i].mp_dstapic || mp_irqs[i].mp_dstapic == MP_APIC_ALL)
                break;
        if (!test_bit (lbus, mp_bus_not_pci) && !mp_irqs[i].mp_irqtype && (bus == lbus) && (slot == ((mp_irqs[i].mp_srcbusirq >> 2) & 0x1f))) {
            int irq = pin_2_irq (i, apic, mp_irqs[i].mp_dstirq);
            if (!(apic || IO_APIC_IRQ (irq)))
                continue;
            if (pin == (mp_irqs[i].mp_srcbusirq & 3))
                return irq;
            if (best_guess < 0)
                best_guess = irq;
        }
    }
    BUG_ON (best_guess >= NR_IRQS);
    return best_guess;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/io_apic_64.c.ifdefed" startline="533" endline="536">
{
    apic_printk (APIC_VERBOSE, "PCI BIOS passed nonexistent PCI bus %d!\n", bus);
    return -1;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/io_apic_64.c.ifdefed" startline="537" endline="563">
{
    int lbus = mp_irqs[i].mp_srcbus;
    for (apic = 0; apic < nr_ioapics; apic++)
        if (mp_ioapics[apic].mp_apicid == mp_irqs[i].mp_dstapic || mp_irqs[i].mp_dstapic == MP_APIC_ALL)
            break;
    if (!test_bit (lbus, mp_bus_not_pci) && !mp_irqs[i].mp_irqtype && (bus == lbus) && (slot == ((mp_irqs[i].mp_srcbusirq >> 2) & 0x1f))) {
        int irq = pin_2_irq (i, apic, mp_irqs[i].mp_dstirq);
        if (!(apic || IO_APIC_IRQ (irq)))
            continue;
        if (pin == (mp_irqs[i].mp_srcbusirq & 3))
            return irq;
        if (best_guess < 0)
            best_guess = irq;
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/io_apic_64.c.ifdefed" startline="548" endline="562">
{
    int irq = pin_2_irq (i, apic, mp_irqs[i].mp_dstirq);
    if (!(apic || IO_APIC_IRQ (irq)))
        continue;
    if (pin == (mp_irqs[i].mp_srcbusirq & 3))
        return irq;
    if (best_guess < 0)
        best_guess = irq;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/io_apic_64.c.ifdefed" startline="581" endline="620">
{
    int bus = mp_irqs[idx].mp_srcbus;
    int polarity;
    switch (mp_irqs[idx].mp_irqflag & 3) {
    case 0 :
        if (test_bit (bus, mp_bus_not_pci))
            polarity = default_ISA_polarity (idx);
        else
            polarity = default_PCI_polarity (idx);
        break;
    case 1 :
        {
            polarity = 0;
            break;
        }
    case 2 :
        {
            printk (KERN_WARNING "broken BIOS!!\n");
            polarity = 1;
            break;
        }
    case 3 :
        {
            polarity = 1;
            break;
        }
    default :
        {
            printk (KERN_WARNING "broken BIOS!!\n");
            polarity = 1;
            break;
        }
    }
    return polarity;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/io_apic_64.c.ifdefed" startline="589" endline="618">
{
case 0 :
    if (test_bit (bus, mp_bus_not_pci))
        polarity = default_ISA_polarity (idx);
    else
        polarity = default_PCI_polarity (idx);
    break;
case 1 :
    {
        polarity = 0;
        break;
    }
case 2 :
    {
        printk (KERN_WARNING "broken BIOS!!\n");
        polarity = 1;
        break;
    }
case 3 :
    {
        polarity = 1;
        break;
    }
default :
    {
        printk (KERN_WARNING "broken BIOS!!\n");
        polarity = 1;
        break;
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/io_apic_64.c.ifdefed" startline="597" endline="600">
{
    polarity = 0;
    break;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/io_apic_64.c.ifdefed" startline="602" endline="606">
{
    printk (KERN_WARNING "broken BIOS!!\n");
    polarity = 1;
    break;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/io_apic_64.c.ifdefed" startline="608" endline="611">
{
    polarity = 1;
    break;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/io_apic_64.c.ifdefed" startline="613" endline="617">
{
    printk (KERN_WARNING "broken BIOS!!\n");
    polarity = 1;
    break;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/io_apic_64.c.ifdefed" startline="623" endline="662">
{
    int bus = mp_irqs[idx].mp_srcbus;
    int trigger;
    switch ((mp_irqs[idx].mp_irqflag >> 2) & 3) {
    case 0 :
        if (test_bit (bus, mp_bus_not_pci))
            trigger = default_ISA_trigger (idx);
        else
            trigger = default_PCI_trigger (idx);
        break;
    case 1 :
        {
            trigger = 0;
            break;
        }
    case 2 :
        {
            printk (KERN_WARNING "broken BIOS!!\n");
            trigger = 1;
            break;
        }
    case 3 :
        {
            trigger = 1;
            break;
        }
    default :
        {
            printk (KERN_WARNING "broken BIOS!!\n");
            trigger = 0;
            break;
        }
    }
    return trigger;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/io_apic_64.c.ifdefed" startline="631" endline="660">
{
case 0 :
    if (test_bit (bus, mp_bus_not_pci))
        trigger = default_ISA_trigger (idx);
    else
        trigger = default_PCI_trigger (idx);
    break;
case 1 :
    {
        trigger = 0;
        break;
    }
case 2 :
    {
        printk (KERN_WARNING "broken BIOS!!\n");
        trigger = 1;
        break;
    }
case 3 :
    {
        trigger = 1;
        break;
    }
default :
    {
        printk (KERN_WARNING "broken BIOS!!\n");
        trigger = 0;
        break;
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/io_apic_64.c.ifdefed" startline="639" endline="642">
{
    trigger = 0;
    break;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/io_apic_64.c.ifdefed" startline="644" endline="648">
{
    printk (KERN_WARNING "broken BIOS!!\n");
    trigger = 1;
    break;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/io_apic_64.c.ifdefed" startline="650" endline="653">
{
    trigger = 1;
    break;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/io_apic_64.c.ifdefed" startline="655" endline="659">
{
    printk (KERN_WARNING "broken BIOS!!\n");
    trigger = 0;
    break;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/io_apic_64.c.ifdefed" startline="665" endline="667">
{
    return MPBIOS_polarity (idx);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/io_apic_64.c.ifdefed" startline="670" endline="672">
{
    return MPBIOS_trigger (idx);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/io_apic_64.c.ifdefed" startline="675" endline="698">
{
    int irq, i;
    int bus = mp_irqs[idx].mp_srcbus;
    if (mp_irqs[idx].mp_dstirq != pin)
        printk (KERN_ERR "broken BIOS or MPTABLE parser, ayiee!!\n");
    if (test_bit (bus, mp_bus_not_pci)) {
        irq = mp_irqs[idx].mp_srcbusirq;
    }
    else {
        i = irq = 0;
        while (i < apic)
            irq += nr_ioapic_registers[i++];
        irq += pin;
    }
    BUG_ON (irq >= NR_IRQS);
    return irq;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/io_apic_64.c.ifdefed" startline="685" endline="687">
{
    irq = mp_irqs[idx].mp_srcbusirq;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/io_apic_64.c.ifdefed" startline="687" endline="695">
{
    i = irq = 0;
    while (i < apic)
        irq += nr_ioapic_registers[i++];
    irq += pin;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/io_apic_64.c.ifdefed" startline="701" endline="706">
{
    spin_lock (& vector_lock);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/io_apic_64.c.ifdefed" startline="709" endline="711">
{
    spin_unlock (& vector_lock);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/io_apic_64.c.ifdefed" startline="714" endline="786">
{
    static int current_vector = FIRST_DEVICE_VECTOR, current_offset = 0;
    unsigned int old_vector;
    int cpu;
    struct irq_cfg *cfg;
    BUG_ON ((unsigned) irq >= NR_IRQS);
    cfg = &irq_cfg[irq];
    cpus_and (mask, mask, cpu_online_map);
    if ((cfg->move_in_progress) || cfg->move_cleanup_count)
        return -EBUSY;
    old_vector = cfg->vector;
    if (old_vector) {
        cpumask_t tmp;
        cpus_and (tmp, cfg -> domain, mask);
        if (!cpus_empty (tmp))
            return 0;
    }

    for_each_cpu_mask_nr (cpu, mask) {
        cpumask_t domain, new_mask;
        int new_cpu;
        int vector, offset;
        domain = vector_allocation_domain (cpu);
        cpus_and (new_mask, domain, cpu_online_map);
        vector = current_vector;
        offset = current_offset;
    next :
        vector += 8;
        if (vector >= first_system_vector) {
            offset = (offset + 1) % 8;
            vector = FIRST_DEVICE_VECTOR + offset;
        }
        if (unlikely (current_vector == vector))
            continue;
        if (vector == IA32_SYSCALL_VECTOR)
            goto next;
        for_each_cpu_mask_nr (new_cpu, new_mask)
        if (per_cpu (vector_irq, new_cpu)[vector] != -1)
            goto next;
        current_vector = vector;
        current_offset = offset;
        if (old_vector) {
            cfg->move_in_progress = 1;
            cfg->old_domain = cfg->domain;
        }
        for_each_cpu_mask_nr (new_cpu, new_mask)
        per_cpu (vector_irq, new_cpu) [vector] = irq;
        cfg->vector = vector;
        cfg->domain = domain;
        return 0;
    }

    return -ENOSPC;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/io_apic_64.c.ifdefed" startline="741" endline="746">
{
    cpumask_t tmp;
    cpus_and (tmp, cfg -> domain, mask);
    if (!cpus_empty (tmp))
        return 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/io_apic_64.c.ifdefed" startline="748" endline="784">
{
    cpumask_t domain, new_mask;
    int new_cpu;
    int vector, offset;
    domain = vector_allocation_domain (cpu);
    cpus_and (new_mask, domain, cpu_online_map);
    vector = current_vector;
    offset = current_offset;
next :
    vector += 8;
    if (vector >= first_system_vector) {
        offset = (offset + 1) % 8;
        vector = FIRST_DEVICE_VECTOR + offset;
    }
    if (unlikely (current_vector == vector))
        continue;
    if (vector == IA32_SYSCALL_VECTOR)
        goto next;
    for_each_cpu_mask_nr (new_cpu, new_mask)
    if (per_cpu (vector_irq, new_cpu)[vector] != -1)
        goto next;
    current_vector = vector;
    current_offset = offset;
    if (old_vector) {
        cfg->move_in_progress = 1;
        cfg->old_domain = cfg->domain;
    }
    for_each_cpu_mask_nr (new_cpu, new_mask)
    per_cpu (vector_irq, new_cpu) [vector] = irq;
    cfg->vector = vector;
    cfg->domain = domain;
    return 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/io_apic_64.c.ifdefed" startline="760" endline="764">
{
    offset = (offset + 1) % 8;
    vector = FIRST_DEVICE_VECTOR + offset;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/io_apic_64.c.ifdefed" startline="775" endline="778">
{
    cfg->move_in_progress = 1;
    cfg->old_domain = cfg->domain;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/io_apic_64.c.ifdefed" startline="789" endline="797">
{
    int err;
    unsigned long flags;
    spin_lock_irqsave (& vector_lock, flags);
    err = __assign_irq_vector (irq, mask);
    spin_unlock_irqrestore (& vector_lock, flags);
    return err;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/io_apic_64.c.ifdefed" startline="800" endline="816">
{
    struct irq_cfg *cfg;
    cpumask_t mask;
    int cpu, vector;
    BUG_ON ((unsigned) irq >= NR_IRQS);
    cfg = &irq_cfg[irq];
    BUG_ON (! cfg -> vector);
    vector = cfg->vector;
    cpus_and (mask, cfg -> domain, cpu_online_map);
    for_each_cpu_mask_nr (cpu, mask)
    per_cpu (vector_irq, cpu) [vector] = -1;
    cfg->vector = 0;
    cpus_clear (cfg -> domain);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/io_apic_64.c.ifdefed" startline="819" endline="839">
{
    int irq, vector;
    for (irq = 0; irq < NR_IRQS; ++irq) {
        if (!cpu_isset (cpu, irq_cfg[irq].domain))
            continue;
        vector = irq_cfg[irq].vector;
        per_cpu (vector_irq, cpu)[vector] = irq;
    }
    for (vector = 0; vector < NR_VECTORS; ++vector) {
        irq = per_cpu (vector_irq, cpu)[vector];
        if (irq < 0)
            continue;
        if (!cpu_isset (cpu, irq_cfg[irq].domain))
            per_cpu (vector_irq, cpu)[vector] = -1;
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/io_apic_64.c.ifdefed" startline="825" endline="830">
{
    if (!cpu_isset (cpu, irq_cfg[irq].domain))
        continue;
    vector = irq_cfg[irq].vector;
    per_cpu (vector_irq, cpu)[vector] = irq;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/io_apic_64.c.ifdefed" startline="832" endline="838">
{
    irq = per_cpu (vector_irq, cpu)[vector];
    if (irq < 0)
        continue;
    if (!cpu_isset (cpu, irq_cfg[irq].domain))
        per_cpu (vector_irq, cpu)[vector] = -1;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/io_apic_64.c.ifdefed" startline="844" endline="854">
{
    if (trigger) {
        irq_desc[irq].status |= IRQ_LEVEL;
        set_irq_chip_and_handler_name (irq, & ioapic_chip, handle_fasteoi_irq, "fasteoi");
    }
    else {
        irq_desc[irq].status &= ~IRQ_LEVEL;
        set_irq_chip_and_handler_name (irq, & ioapic_chip, handle_edge_irq, "edge");
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/io_apic_64.c.ifdefed" startline="845" endline="849">
{
    irq_desc[irq].status |= IRQ_LEVEL;
    set_irq_chip_and_handler_name (irq, & ioapic_chip, handle_fasteoi_irq, "fasteoi");
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/io_apic_64.c.ifdefed" startline="849" endline="853">
{
    irq_desc[irq].status &= ~IRQ_LEVEL;
    set_irq_chip_and_handler_name (irq, & ioapic_chip, handle_edge_irq, "edge");
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/io_apic_64.c.ifdefed" startline="858" endline="902">
{
    struct irq_cfg *cfg = irq_cfg + irq;
    struct IO_APIC_route_entry entry;
    cpumask_t mask;
    if (!IO_APIC_IRQ (irq))
        return;
    mask = TARGET_CPUS;
    if (assign_irq_vector (irq, mask))
        return;
    cpus_and (mask, cfg -> domain, mask);
    apic_printk (APIC_VERBOSE, KERN_DEBUG "IOAPIC[%d]: Set routing entry (%d-%d -> 0x%x -> " "IRQ %d Mode:%i Active:%i)\n", apic, mp_ioapics [apic].mp_apicid, pin, cfg -> vector, irq, trigger, polarity);
    memset (& entry, 0, sizeof (entry));
    entry.delivery_mode = INT_DELIVERY_MODE;
    entry.dest_mode = INT_DEST_MODE;
    entry.dest = cpu_mask_to_apicid (mask);
    entry.mask = 0;
    entry.trigger = trigger;
    entry.polarity = polarity;
    entry.vector = cfg->vector;
    if (trigger)
        entry.mask = 1;
    ioapic_register_intr (irq, trigger);
    if (irq < 16)
        disable_8259A_irq (irq);
    ioapic_write_entry (apic, pin, entry);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/io_apic_64.c.ifdefed" startline="905" endline="937">
{
    int apic, pin, idx, irq, first_notcon = 1;
    apic_printk (APIC_VERBOSE, KERN_DEBUG "init IO_APIC IRQs\n");
    for (apic = 0; apic < nr_ioapics; apic++) {
        for (pin = 0; pin < nr_ioapic_registers[apic]; pin++) {
            idx = find_irq_entry (apic, pin, mp_INT);
            if (idx == -1) {
                if (first_notcon) {
                    apic_printk (APIC_VERBOSE, KERN_DEBUG " IO-APIC (apicid-pin) %d-%d", mp_ioapics [apic].mp_apicid, pin);
                    first_notcon = 0;
                }
                else
                    apic_printk (APIC_VERBOSE, ", %d-%d", mp_ioapics[apic].mp_apicid, pin);
                continue;
            }
            if (!first_notcon) {
                apic_printk (APIC_VERBOSE, " not connected.\n");
                first_notcon = 1;
            }
            irq = pin_2_irq (idx, apic, pin);
            add_pin_to_irq (irq, apic, pin);
            setup_IO_APIC_irq (apic, pin, irq, irq_trigger (idx), irq_polarity (idx));
        }
    }
    if (!first_notcon)
        apic_printk (APIC_VERBOSE, " not connected.\n");
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/io_apic_64.c.ifdefed" startline="910" endline="933">
{
    for (pin = 0; pin < nr_ioapic_registers[apic]; pin++) {
        idx = find_irq_entry (apic, pin, mp_INT);
        if (idx == -1) {
            if (first_notcon) {
                apic_printk (APIC_VERBOSE, KERN_DEBUG " IO-APIC (apicid-pin) %d-%d", mp_ioapics [apic].mp_apicid, pin);
                first_notcon = 0;
            }
            else
                apic_printk (APIC_VERBOSE, ", %d-%d", mp_ioapics[apic].mp_apicid, pin);
            continue;
        }
        if (!first_notcon) {
            apic_printk (APIC_VERBOSE, " not connected.\n");
            first_notcon = 1;
        }
        irq = pin_2_irq (idx, apic, pin);
        add_pin_to_irq (irq, apic, pin);
        setup_IO_APIC_irq (apic, pin, irq, irq_trigger (idx), irq_polarity (idx));
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/io_apic_64.c.ifdefed" startline="911" endline="932">
{
    idx = find_irq_entry (apic, pin, mp_INT);
    if (idx == -1) {
        if (first_notcon) {
            apic_printk (APIC_VERBOSE, KERN_DEBUG " IO-APIC (apicid-pin) %d-%d", mp_ioapics [apic].mp_apicid, pin);
            first_notcon = 0;
        }
        else
            apic_printk (APIC_VERBOSE, ", %d-%d", mp_ioapics[apic].mp_apicid, pin);
        continue;
    }
    if (!first_notcon) {
        apic_printk (APIC_VERBOSE, " not connected.\n");
        first_notcon = 1;
    }
    irq = pin_2_irq (idx, apic, pin);
    add_pin_to_irq (irq, apic, pin);
    setup_IO_APIC_irq (apic, pin, irq, irq_trigger (idx), irq_polarity (idx));
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/io_apic_64.c.ifdefed" startline="914" endline="921">
{
    if (first_notcon) {
        apic_printk (APIC_VERBOSE, KERN_DEBUG " IO-APIC (apicid-pin) %d-%d", mp_ioapics [apic].mp_apicid, pin);
        first_notcon = 0;
    }
    else
        apic_printk (APIC_VERBOSE, ", %d-%d", mp_ioapics[apic].mp_apicid, pin);
    continue;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/io_apic_64.c.ifdefed" startline="915" endline="918">
{
    apic_printk (APIC_VERBOSE, KERN_DEBUG " IO-APIC (apicid-pin) %d-%d", mp_ioapics [apic].mp_apicid, pin);
    first_notcon = 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/io_apic_64.c.ifdefed" startline="922" endline="925">
{
    apic_printk (APIC_VERBOSE, " not connected.\n");
    first_notcon = 1;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/io_apic_64.c.ifdefed" startline="944" endline="971">
{
    struct IO_APIC_route_entry entry;
    memset (& entry, 0, sizeof (entry));
    entry.dest_mode = INT_DEST_MODE;
    entry.mask = 1;
    entry.dest = cpu_mask_to_apicid (TARGET_CPUS);
    entry.delivery_mode = INT_DELIVERY_MODE;
    entry.polarity = 0;
    entry.trigger = 0;
    entry.vector = vector;
    set_irq_chip_and_handler_name (0, & ioapic_chip, handle_edge_irq, "edge");
    ioapic_write_entry (apic, pin, entry);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/io_apic_64.c.ifdefed" startline="974" endline="1065">
{
    int apic, i;
    union IO_APIC_reg_00 reg_00;
    union IO_APIC_reg_01 reg_01;
    union IO_APIC_reg_02 reg_02;
    unsigned long flags;
    if (apic_verbosity == APIC_QUIET)
        return;
    printk (KERN_DEBUG "number of MP IRQ sources: %d.\n", mp_irq_entries);
    for (i = 0; i < nr_ioapics; i++)
        printk (KERN_DEBUG "number of IO-APIC #%d registers: %d.\n", mp_ioapics[i].mp_apicid, nr_ioapic_registers[i]);
    printk (KERN_INFO "testing the IO APIC.......................\n");
    for (apic = 0; apic < nr_ioapics; apic++) {
        spin_lock_irqsave (& ioapic_lock, flags);
        reg_00.raw = io_apic_read (apic, 0);
        reg_01.raw = io_apic_read (apic, 1);
        if (reg_01.bits.version >= 0x10)
            reg_02.raw = io_apic_read (apic, 2);
        spin_unlock_irqrestore (& ioapic_lock, flags);
        printk ("\n");
        printk (KERN_DEBUG "IO APIC #%d......\n", mp_ioapics [apic].mp_apicid);
        printk (KERN_DEBUG ".... register #00: %08X\n", reg_00.raw);
        printk (KERN_DEBUG ".......    : physical APIC id: %02X\n", reg_00.bits.ID);
        printk (KERN_DEBUG ".... register #01: %08X\n", * (int *) & reg_01);
        printk (KERN_DEBUG ".......     : max redirection entries: %04X\n", reg_01.bits.entries);
        printk (KERN_DEBUG ".......     : PRQ implemented: %X\n", reg_01.bits.PRQ);
        printk (KERN_DEBUG ".......     : IO APIC version: %04X\n", reg_01.bits.version);
        if (reg_01.bits.version >= 0x10) {
            printk (KERN_DEBUG ".... register #02: %08X\n", reg_02.raw);
            printk (KERN_DEBUG ".......     : arbitration: %02X\n", reg_02.bits.arbitration);
        }
        printk (KERN_DEBUG ".... IRQ redirection table:\n");
        printk (KERN_DEBUG " NR Dst Mask Trig IRR Pol" " Stat Dmod Deli Vect:   \n");
        for (i = 0; i <= reg_01.bits.entries; i++) {
            struct IO_APIC_route_entry entry;
            entry = ioapic_read_entry (apic, i);
            printk (KERN_DEBUG " %02x %03X ", i, entry.dest);
            printk ("%1d    %1d    %1d   %1d   %1d    %1d    %1d    %02X\n", entry.mask, entry.trigger, entry.irr, entry.polarity, entry.delivery_status, entry.dest_mode, entry.delivery_mode, entry.vector);
        }
    }
    printk (KERN_DEBUG "IRQ to pin mappings:\n");
    for (i = 0; i < NR_IRQS; i++) {
        struct irq_pin_list *entry = irq_2_pin + i;
        if (entry->pin < 0)
            continue;
        printk (KERN_DEBUG "IRQ%d ", i);
        for (;;) {
            printk ("-> %d:%d", entry -> apic, entry -> pin);
            if (!entry->next)
                break;
            entry = irq_2_pin + entry->next;
        }
        printk ("\n");
    }
    printk (KERN_INFO ".................................... done.\n");
    return;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/io_apic_64.c.ifdefed" startline="995" endline="1046">
{
    spin_lock_irqsave (& ioapic_lock, flags);
    reg_00.raw = io_apic_read (apic, 0);
    reg_01.raw = io_apic_read (apic, 1);
    if (reg_01.bits.version >= 0x10)
        reg_02.raw = io_apic_read (apic, 2);
    spin_unlock_irqrestore (& ioapic_lock, flags);
    printk ("\n");
    printk (KERN_DEBUG "IO APIC #%d......\n", mp_ioapics [apic].mp_apicid);
    printk (KERN_DEBUG ".... register #00: %08X\n", reg_00.raw);
    printk (KERN_DEBUG ".......    : physical APIC id: %02X\n", reg_00.bits.ID);
    printk (KERN_DEBUG ".... register #01: %08X\n", * (int *) & reg_01);
    printk (KERN_DEBUG ".......     : max redirection entries: %04X\n", reg_01.bits.entries);
    printk (KERN_DEBUG ".......     : PRQ implemented: %X\n", reg_01.bits.PRQ);
    printk (KERN_DEBUG ".......     : IO APIC version: %04X\n", reg_01.bits.version);
    if (reg_01.bits.version >= 0x10) {
        printk (KERN_DEBUG ".... register #02: %08X\n", reg_02.raw);
        printk (KERN_DEBUG ".......     : arbitration: %02X\n", reg_02.bits.arbitration);
    }
    printk (KERN_DEBUG ".... IRQ redirection table:\n");
    printk (KERN_DEBUG " NR Dst Mask Trig IRR Pol" " Stat Dmod Deli Vect:   \n");
    for (i = 0; i <= reg_01.bits.entries; i++) {
        struct IO_APIC_route_entry entry;
        entry = ioapic_read_entry (apic, i);
        printk (KERN_DEBUG " %02x %03X ", i, entry.dest);
        printk ("%1d    %1d    %1d   %1d   %1d    %1d    %1d    %02X\n", entry.mask, entry.trigger, entry.irr, entry.polarity, entry.delivery_status, entry.dest_mode, entry.delivery_mode, entry.vector);
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/io_apic_64.c.ifdefed" startline="1015" endline="1018">
{
    printk (KERN_DEBUG ".... register #02: %08X\n", reg_02.raw);
    printk (KERN_DEBUG ".......     : arbitration: %02X\n", reg_02.bits.arbitration);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/io_apic_64.c.ifdefed" startline="1025" endline="1045">
{
    struct IO_APIC_route_entry entry;
    entry = ioapic_read_entry (apic, i);
    printk (KERN_DEBUG " %02x %03X ", i, entry.dest);
    printk ("%1d    %1d    %1d   %1d   %1d    %1d    %1d    %02X\n", entry.mask, entry.trigger, entry.irr, entry.polarity, entry.delivery_status, entry.dest_mode, entry.delivery_mode, entry.vector);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/io_apic_64.c.ifdefed" startline="1048" endline="1060">
{
    struct irq_pin_list *entry = irq_2_pin + i;
    if (entry->pin < 0)
        continue;
    printk (KERN_DEBUG "IRQ%d ", i);
    for (;;) {
        printk ("-> %d:%d", entry -> apic, entry -> pin);
        if (!entry->next)
            break;
        entry = irq_2_pin + entry->next;
    }
    printk ("\n");
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/io_apic_64.c.ifdefed" startline="1053" endline="1058">
{
    printk ("-> %d:%d", entry -> apic, entry -> pin);
    if (!entry->next)
        break;
    entry = irq_2_pin + entry->next;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/io_apic_64.c.ifdefed" startline="1207" endline="1265">
{
    union IO_APIC_reg_01 reg_01;
    int i8259_apic, i8259_pin;
    int i, apic;
    unsigned long flags;
    for (i = 0; i < PIN_MAP_SIZE; i++) {
        irq_2_pin[i].pin = -1;
        irq_2_pin[i].next = 0;
    }
    for (apic = 0; apic < nr_ioapics; apic++) {
        spin_lock_irqsave (& ioapic_lock, flags);
        reg_01.raw = io_apic_read (apic, 1);
        spin_unlock_irqrestore (& ioapic_lock, flags);
        nr_ioapic_registers[apic] = reg_01.bits.entries + 1;
    }
    for (apic = 0; apic < nr_ioapics; apic++) {
        int pin;
        for (pin = 0; pin < nr_ioapic_registers[apic]; pin++) {
            struct IO_APIC_route_entry entry;
            entry = ioapic_read_entry (apic, pin);
            if ((entry.mask == 0) && (entry.delivery_mode == dest_ExtINT)) {
                ioapic_i8259.apic = apic;
                ioapic_i8259.pin = pin;
                goto found_i8259;
            }
        }
    }
found_i8259 :
    i8259_pin = find_isa_irq_pin (0, mp_ExtINT);
    i8259_apic = find_isa_irq_apic (0, mp_ExtINT);
    if ((ioapic_i8259.pin == -1) && (i8259_pin >= 0)) {
        printk (KERN_WARNING "ExtINT not setup in hardware but reported by MP table\n");
        ioapic_i8259.pin = i8259_pin;
        ioapic_i8259.apic = i8259_apic;
    }
    if (((ioapic_i8259.apic != i8259_apic) || (ioapic_i8259.pin != i8259_pin)) && (i8259_pin >= 0) && (ioapic_i8259.pin >= 0)) {
        printk (KERN_WARNING "ExtINT in hardware and MP table differ\n");
    }
    clear_IO_APIC ();
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/io_apic_64.c.ifdefed" startline="1213" endline="1216">
{
    irq_2_pin[i].pin = -1;
    irq_2_pin[i].next = 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/io_apic_64.c.ifdefed" startline="1221" endline="1226">
{
    spin_lock_irqsave (& ioapic_lock, flags);
    reg_01.raw = io_apic_read (apic, 1);
    spin_unlock_irqrestore (& ioapic_lock, flags);
    nr_ioapic_registers[apic] = reg_01.bits.entries + 1;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/io_apic_64.c.ifdefed" startline="1227" endline="1243">
{
    int pin;
    for (pin = 0; pin < nr_ioapic_registers[apic]; pin++) {
        struct IO_APIC_route_entry entry;
        entry = ioapic_read_entry (apic, pin);
        if ((entry.mask == 0) && (entry.delivery_mode == dest_ExtINT)) {
            ioapic_i8259.apic = apic;
            ioapic_i8259.pin = pin;
            goto found_i8259;
        }
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/io_apic_64.c.ifdefed" startline="1230" endline="1242">
{
    struct IO_APIC_route_entry entry;
    entry = ioapic_read_entry (apic, pin);
    if ((entry.mask == 0) && (entry.delivery_mode == dest_ExtINT)) {
        ioapic_i8259.apic = apic;
        ioapic_i8259.pin = pin;
        goto found_i8259;
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/io_apic_64.c.ifdefed" startline="1237" endline="1241">
{
    ioapic_i8259.apic = apic;
    ioapic_i8259.pin = pin;
    goto found_i8259;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/io_apic_64.c.ifdefed" startline="1249" endline="1253">
{
    printk (KERN_WARNING "ExtINT not setup in hardware but reported by MP table\n");
    ioapic_i8259.pin = i8259_pin;
    ioapic_i8259.apic = i8259_apic;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/io_apic_64.c.ifdefed" startline="1257" endline="1259">
{
    printk (KERN_WARNING "ExtINT in hardware and MP table differ\n");
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/io_apic_64.c.ifdefed" startline="1271" endline="1303">
{
    clear_IO_APIC ();
    if (ioapic_i8259.pin != -1) {
        struct IO_APIC_route_entry entry;
        memset (& entry, 0, sizeof (entry));
        entry.mask = 0;
        entry.trigger = 0;
        entry.irr = 0;
        entry.polarity = 0;
        entry.delivery_status = 0;
        entry.dest_mode = 0;
        entry.delivery_mode = dest_ExtINT;
        entry.vector = 0;
        entry.dest = GET_APIC_ID (read_apic_id ());
        ioapic_write_entry (ioapic_i8259.apic, ioapic_i8259.pin, entry);
    }
    disconnect_bsp_APIC (ioapic_i8259.pin != - 1);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/io_apic_64.c.ifdefed" startline="1282" endline="1300">
{
    struct IO_APIC_route_entry entry;
    memset (& entry, 0, sizeof (entry));
    entry.mask = 0;
    entry.trigger = 0;
    entry.irr = 0;
    entry.polarity = 0;
    entry.delivery_status = 0;
    entry.dest_mode = 0;
    entry.delivery_mode = dest_ExtINT;
    entry.vector = 0;
    entry.dest = GET_APIC_ID (read_apic_id ());
    ioapic_write_entry (ioapic_i8259.apic, ioapic_i8259.pin, entry);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/io_apic_64.c.ifdefed" startline="1314" endline="1336">
{
    unsigned long t1 = jiffies;
    unsigned long flags;
    local_save_flags (flags);
    local_irq_enable ();
    mdelay ((10 * 1000) / HZ);
    local_irq_restore (flags);
    if (time_after (jiffies, t1 +4))
        return 1;
    return 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/io_apic_64.c.ifdefed" startline="1362" endline="1376">
{
    int was_pending = 0;
    unsigned long flags;
    spin_lock_irqsave (& ioapic_lock, flags);
    if (irq < 16) {
        disable_8259A_irq (irq);
        if (i8259A_irq_pending (irq))
            was_pending = 1;
    }
    __unmask_IO_APIC_irq (irq);
    spin_unlock_irqrestore (& ioapic_lock, flags);
    return was_pending;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/io_apic_64.c.ifdefed" startline="1367" endline="1371">
{
    disable_8259A_irq (irq);
    if (i8259A_irq_pending (irq))
        was_pending = 1;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/io_apic_64.c.ifdefed" startline="1379" endline="1388">
{
    struct irq_cfg *cfg = &irq_cfg[irq];
    unsigned long flags;
    spin_lock_irqsave (& vector_lock, flags);
    send_IPI_mask (cpumask_of_cpu (first_cpu (cfg -> domain)), cfg -> vector);
    spin_unlock_irqrestore (& vector_lock, flags);
    return 1;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/io_apic_64.c.ifdefed" startline="1454" endline="1454">
{
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/io_apic_64.c.ifdefed" startline="1458" endline="1462">
{
    irq_complete_move (irq);
    move_native_irq (irq);
    ack_APIC_irq ();
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/io_apic_64.c.ifdefed" startline="1465" endline="1515">
{
    int do_unmask_irq = 0;
    irq_complete_move (irq);
    ack_APIC_irq ();
    if (unlikely (do_unmask_irq)) {
        if (!io_apic_level_ack_pending (irq))
            move_masked_irq (irq);
        unmask_IO_APIC_irq (irq);
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/io_apic_64.c.ifdefed" startline="1484" endline="1514">
{
    if (!io_apic_level_ack_pending (irq))
        move_masked_irq (irq);
    unmask_IO_APIC_irq (irq);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/io_apic_64.c.ifdefed" startline="1531" endline="1559">
{
    int irq;
    for (irq = 0; irq < NR_IRQS; irq++) {
        if (IO_APIC_IRQ (irq) && !irq_cfg[irq].vector) {
            if (irq < 16)
                make_8259A_irq (irq);
            else
                irq_desc[irq].chip = &no_irq_chip;
        }
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/io_apic_64.c.ifdefed" startline="1545" endline="1558">
{
    if (IO_APIC_IRQ (irq) && !irq_cfg[irq].vector) {
        if (irq < 16)
            make_8259A_irq (irq);
        else
            irq_desc[irq].chip = &no_irq_chip;
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/io_apic_64.c.ifdefed" startline="1546" endline="1557">
{
    if (irq < 16)
        make_8259A_irq (irq);
    else
        irq_desc[irq].chip = &no_irq_chip;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/io_apic_64.c.ifdefed" startline="1562" endline="1567">
{
    unsigned long v;
    v = apic_read (APIC_LVT0);
    apic_write (APIC_LVT0, v & ~ APIC_LVT_MASKED);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/io_apic_64.c.ifdefed" startline="1570" endline="1575">
{
    unsigned long v;
    v = apic_read (APIC_LVT0);
    apic_write (APIC_LVT0, v | APIC_LVT_MASKED);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/io_apic_64.c.ifdefed" startline="1578" endline="1580">
{
    ack_APIC_irq ();
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/io_apic_64.c.ifdefed" startline="1590" endline="1594">
{
    irq_desc[irq].status &= ~IRQ_LEVEL;
    set_irq_chip_and_handler_name (irq, & lapic_chip, handle_edge_irq, "edge");
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/io_apic_64.c.ifdefed" startline="1597" endline="1612">
{
    printk (KERN_INFO "activating NMI Watchdog ...");
    enable_NMI_through_LVT0 ();
    printk (" done.\n");
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/io_apic_64.c.ifdefed" startline="1622" endline="1666">
{
    int apic, pin, i;
    struct IO_APIC_route_entry entry0, entry1;
    unsigned char save_control, save_freq_select;
    pin = find_isa_irq_pin (8, mp_INT);
    apic = find_isa_irq_apic (8, mp_INT);
    if (pin == -1)
        return;
    entry0 = ioapic_read_entry (apic, pin);
    clear_IO_APIC_pin (apic, pin);
    memset (& entry1, 0, sizeof (entry1));
    entry1.dest_mode = 0;
    entry1.mask = 0;
    entry1.dest = hard_smp_processor_id ();
    entry1.delivery_mode = dest_ExtINT;
    entry1.polarity = entry0.polarity;
    entry1.trigger = 0;
    entry1.vector = 0;
    ioapic_write_entry (apic, pin, entry1);
    save_control = CMOS_READ (RTC_CONTROL);
    save_freq_select = CMOS_READ (RTC_FREQ_SELECT);
    CMOS_WRITE ((save_freq_select & ~ RTC_RATE_SELECT) | 0x6, RTC_FREQ_SELECT);
    CMOS_WRITE (save_control | RTC_PIE, RTC_CONTROL);
    i = 100;
    while (i-- > 0) {
        mdelay (10);
        if ((CMOS_READ (RTC_INTR_FLAGS) & RTC_PF) == RTC_PF)
            i -= 10;
    }
    CMOS_WRITE (save_control, RTC_CONTROL);
    CMOS_WRITE (save_freq_select, RTC_FREQ_SELECT);
    clear_IO_APIC_pin (apic, pin);
    ioapic_write_entry (apic, pin, entry0);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/io_apic_64.c.ifdefed" startline="1655" endline="1659">
{
    mdelay (10);
    if ((CMOS_READ (RTC_INTR_FLAGS) & RTC_PF) == RTC_PF)
        i -= 10;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/io_apic_64.c.ifdefed" startline="1677" endline="1814">
{
    struct irq_cfg *cfg = irq_cfg + 0;
    int apic1, pin1, apic2, pin2;
    unsigned long flags;
    int no_pin1 = 0;
    local_irq_save (flags);
    disable_8259A_irq (0);
    assign_irq_vector (0, TARGET_CPUS);
    apic_write (APIC_LVT0, APIC_LVT_MASKED | APIC_DM_EXTINT);
    init_8259A (1);
    pin1 = find_isa_irq_pin (0, mp_INT);
    apic1 = find_isa_irq_apic (0, mp_INT);
    pin2 = ioapic_i8259.pin;
    apic2 = ioapic_i8259.apic;
    apic_printk (APIC_QUIET, KERN_INFO "..TIMER: vector=0x%02X " "apic1=%d pin1=%d apic2=%d pin2=%d\n", cfg -> vector, apic1, pin1, apic2, pin2);
    if (pin1 == -1) {
        pin1 = pin2;
        apic1 = apic2;
        no_pin1 = 1;
    }
    else if (pin2 == -1) {
        pin2 = pin1;
        apic2 = apic1;
    }
    if (pin1 != -1) {
        if (no_pin1) {
            add_pin_to_irq (0, apic1, pin1);
            setup_timer_IRQ0_pin (apic1, pin1, cfg -> vector);
        }
        unmask_IO_APIC_irq (0);
        if (!no_timer_check && timer_irq_works ()) {
            if (nmi_watchdog == NMI_IO_APIC) {
                setup_nmi ();
                enable_8259A_irq (0);
            }
            if (disable_timer_pin_1 > 0)
                clear_IO_APIC_pin (0, pin1);
            goto out;
        }
        clear_IO_APIC_pin (apic1, pin1);
        if (!no_pin1)
            apic_printk (APIC_QUIET, KERN_ERR "..MP-BIOS bug: " "8254 timer not connected to IO-APIC\n");
        apic_printk (APIC_QUIET, KERN_INFO "...trying to set up timer " "(IRQ0) through the 8259A ...\n");
        apic_printk (APIC_QUIET, KERN_INFO "..... (found apic %d pin %d) ...\n", apic2, pin2);
        replace_pin_at_irq (0, apic1, pin1, apic2, pin2);
        setup_timer_IRQ0_pin (apic2, pin2, cfg -> vector);
        unmask_IO_APIC_irq (0);
        enable_8259A_irq (0);
        if (timer_irq_works ()) {
            apic_printk (APIC_QUIET, KERN_INFO "....... works.\n");
            timer_through_8259 = 1;
            if (nmi_watchdog == NMI_IO_APIC) {
                disable_8259A_irq (0);
                setup_nmi ();
                enable_8259A_irq (0);
            }
            goto out;
        }
        disable_8259A_irq (0);
        clear_IO_APIC_pin (apic2, pin2);
        apic_printk (APIC_QUIET, KERN_INFO "....... failed.\n");
    }
    if (nmi_watchdog == NMI_IO_APIC) {
        apic_printk (APIC_QUIET, KERN_WARNING "timer doesn't work " "through the IO-APIC - disabling NMI Watchdog!\n");
        nmi_watchdog = NMI_NONE;
    }
    apic_printk (APIC_QUIET, KERN_INFO "...trying to set up timer as Virtual Wire IRQ...\n");
    lapic_register_intr (0);
    apic_write (APIC_LVT0, APIC_DM_FIXED | cfg -> vector);
    enable_8259A_irq (0);
    if (timer_irq_works ()) {
        apic_printk (APIC_QUIET, KERN_INFO "..... works.\n");
        goto out;
    }
    disable_8259A_irq (0);
    apic_write (APIC_LVT0, APIC_LVT_MASKED | APIC_DM_FIXED | cfg -> vector);
    apic_printk (APIC_QUIET, KERN_INFO "..... failed.\n");
    apic_printk (APIC_QUIET, KERN_INFO "...trying to set up timer as ExtINT IRQ...\n");
    init_8259A (0);
    make_8259A_irq (0);
    apic_write (APIC_LVT0, APIC_DM_EXTINT);
    unlock_ExtINT_logic ();
    if (timer_irq_works ()) {
        apic_printk (APIC_QUIET, KERN_INFO "..... works.\n");
        goto out;
    }
    apic_printk (APIC_QUIET, KERN_INFO "..... failed :(.\n");
    panic ("IO-APIC + timer doesn't work!  Boot with apic=debug and send a " "report.  Then try booting with the 'noapic' option.\n");
out :
    local_irq_restore (flags);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/io_apic_64.c.ifdefed" startline="1714" endline="1718">
{
    pin1 = pin2;
    apic1 = apic2;
    no_pin1 = 1;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/io_apic_64.c.ifdefed" startline="1718" endline="1721">
{
    pin2 = pin1;
    apic2 = apic1;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/io_apic_64.c.ifdefed" startline="1723" endline="1773">
{
    if (no_pin1) {
        add_pin_to_irq (0, apic1, pin1);
        setup_timer_IRQ0_pin (apic1, pin1, cfg -> vector);
    }
    unmask_IO_APIC_irq (0);
    if (!no_timer_check && timer_irq_works ()) {
        if (nmi_watchdog == NMI_IO_APIC) {
            setup_nmi ();
            enable_8259A_irq (0);
        }
        if (disable_timer_pin_1 > 0)
            clear_IO_APIC_pin (0, pin1);
        goto out;
    }
    clear_IO_APIC_pin (apic1, pin1);
    if (!no_pin1)
        apic_printk (APIC_QUIET, KERN_ERR "..MP-BIOS bug: " "8254 timer not connected to IO-APIC\n");
    apic_printk (APIC_QUIET, KERN_INFO "...trying to set up timer " "(IRQ0) through the 8259A ...\n");
    apic_printk (APIC_QUIET, KERN_INFO "..... (found apic %d pin %d) ...\n", apic2, pin2);
    replace_pin_at_irq (0, apic1, pin1, apic2, pin2);
    setup_timer_IRQ0_pin (apic2, pin2, cfg -> vector);
    unmask_IO_APIC_irq (0);
    enable_8259A_irq (0);
    if (timer_irq_works ()) {
        apic_printk (APIC_QUIET, KERN_INFO "....... works.\n");
        timer_through_8259 = 1;
        if (nmi_watchdog == NMI_IO_APIC) {
            disable_8259A_irq (0);
            setup_nmi ();
            enable_8259A_irq (0);
        }
        goto out;
    }
    disable_8259A_irq (0);
    clear_IO_APIC_pin (apic2, pin2);
    apic_printk (APIC_QUIET, KERN_INFO "....... failed.\n");
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/io_apic_64.c.ifdefed" startline="1727" endline="1730">
{
    add_pin_to_irq (0, apic1, pin1);
    setup_timer_IRQ0_pin (apic1, pin1, cfg -> vector);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/io_apic_64.c.ifdefed" startline="1732" endline="1740">
{
    if (nmi_watchdog == NMI_IO_APIC) {
        setup_nmi ();
        enable_8259A_irq (0);
    }
    if (disable_timer_pin_1 > 0)
        clear_IO_APIC_pin (0, pin1);
    goto out;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/io_apic_64.c.ifdefed" startline="1733" endline="1736">
{
    setup_nmi ();
    enable_8259A_irq (0);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/io_apic_64.c.ifdefed" startline="1757" endline="1766">
{
    apic_printk (APIC_QUIET, KERN_INFO "....... works.\n");
    timer_through_8259 = 1;
    if (nmi_watchdog == NMI_IO_APIC) {
        disable_8259A_irq (0);
        setup_nmi ();
        enable_8259A_irq (0);
    }
    goto out;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/io_apic_64.c.ifdefed" startline="1760" endline="1764">
{
    disable_8259A_irq (0);
    setup_nmi ();
    enable_8259A_irq (0);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/io_apic_64.c.ifdefed" startline="1775" endline="1779">
{
    apic_printk (APIC_QUIET, KERN_WARNING "timer doesn't work " "through the IO-APIC - disabling NMI Watchdog!\n");
    nmi_watchdog = NMI_NONE;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/io_apic_64.c.ifdefed" startline="1788" endline="1791">
{
    apic_printk (APIC_QUIET, KERN_INFO "..... works.\n");
    goto out;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/io_apic_64.c.ifdefed" startline="1805" endline="1808">
{
    apic_printk (APIC_QUIET, KERN_INFO "..... works.\n");
    goto out;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/io_apic_64.c.ifdefed" startline="1817" endline="1820">
{
    no_timer_check = 1;
    return 1;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/io_apic_64.c.ifdefed" startline="1843" endline="1859">
{
    io_apic_irqs = ~PIC_IRQS;
    apic_printk (APIC_VERBOSE, "ENABLING IO-APIC IRQs\n");
    sync_Arb_IDs ();
    setup_IO_APIC_irqs ();
    init_IO_APIC_traps ();
    check_timer ();
    if (!acpi_ioapic)
        print_IO_APIC ();
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/io_apic_64.c.ifdefed" startline="1868" endline="1879">
{
    struct IO_APIC_route_entry *entry;
    struct sysfs_ioapic_data *data;
    int i;
    data = container_of (dev, struct sysfs_ioapic_data, dev);
    entry = data->entry;
    for (i = 0; i < nr_ioapic_registers[dev->id]; i++, entry++)
        *entry = ioapic_read_entry (dev->id, i);
    return 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/io_apic_64.c.ifdefed" startline="1882" endline="1903">
{
    struct IO_APIC_route_entry *entry;
    struct sysfs_ioapic_data *data;
    unsigned long flags;
    union IO_APIC_reg_00 reg_00;
    int i;
    data = container_of (dev, struct sysfs_ioapic_data, dev);
    entry = data->entry;
    spin_lock_irqsave (& ioapic_lock, flags);
    reg_00.raw = io_apic_read (dev->id, 0);
    if (reg_00.bits.ID != mp_ioapics[dev->id].mp_apicid) {
        reg_00.bits.ID = mp_ioapics[dev->id].mp_apicid;
        io_apic_write (dev -> id, 0, reg_00.raw);
    }
    spin_unlock_irqrestore (& ioapic_lock, flags);
    for (i = 0; i < nr_ioapic_registers[dev->id]; i++)
        ioapic_write_entry (dev->id, i, entry[i]);
    return 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/io_apic_64.c.ifdefed" startline="1894" endline="1897">
{
    reg_00.bits.ID = mp_ioapics[dev->id].mp_apicid;
    io_apic_write (dev -> id, 0, reg_00.raw);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/io_apic_64.c.ifdefed" startline="1912" endline="1941">
{
    struct sys_device *dev;
    int i, size, error;
    error = sysdev_class_register (&ioapic_sysdev_class);
    if (error)
        return error;
    for (i = 0; i < nr_ioapics; i++) {
        size = sizeof (struct sys_device) + nr_ioapic_registers[i] * sizeof (struct IO_APIC_route_entry);
        mp_ioapic_data[i] = kzalloc (size, GFP_KERNEL);
        if (!mp_ioapic_data[i]) {
            printk (KERN_ERR "Can't suspend/resume IOAPIC %d\n", i);
            continue;
        }
        dev = &mp_ioapic_data[i]->dev;
        dev->id = i;
        dev->cls = &ioapic_sysdev_class;
        error = sysdev_register (dev);
        if (error) {
            kfree (mp_ioapic_data [i]);
            mp_ioapic_data[i] = NULL;
            printk (KERN_ERR "Can't suspend/resume IOAPIC %d\n", i);
            continue;
        }
    }
    return 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/io_apic_64.c.ifdefed" startline="1920" endline="1938">
{
    size = sizeof (struct sys_device) + nr_ioapic_registers[i] * sizeof (struct IO_APIC_route_entry);
    mp_ioapic_data[i] = kzalloc (size, GFP_KERNEL);
    if (!mp_ioapic_data[i]) {
        printk (KERN_ERR "Can't suspend/resume IOAPIC %d\n", i);
        continue;
    }
    dev = &mp_ioapic_data[i]->dev;
    dev->id = i;
    dev->cls = &ioapic_sysdev_class;
    error = sysdev_register (dev);
    if (error) {
        kfree (mp_ioapic_data [i]);
        mp_ioapic_data[i] = NULL;
        printk (KERN_ERR "Can't suspend/resume IOAPIC %d\n", i);
        continue;
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/io_apic_64.c.ifdefed" startline="1924" endline="1927">
{
    printk (KERN_ERR "Can't suspend/resume IOAPIC %d\n", i);
    continue;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/io_apic_64.c.ifdefed" startline="1932" endline="1937">
{
    kfree (mp_ioapic_data [i]);
    mp_ioapic_data[i] = NULL;
    printk (KERN_ERR "Can't suspend/resume IOAPIC %d\n", i);
    continue;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/io_apic_64.c.ifdefed" startline="1949" endline="1972">
{
    int irq;
    int new;
    unsigned long flags;
    irq = -ENOSPC;
    spin_lock_irqsave (& vector_lock, flags);
    for (new = (NR_IRQS - 1); new >= 0; new--) {
        if (platform_legacy_irq (new))
            continue;
        if (irq_cfg[new].vector != 0)
            continue;
        if (__assign_irq_vector (new, TARGET_CPUS) == 0)
            irq = new;
        break;
    }
    spin_unlock_irqrestore (& vector_lock, flags);
    if (irq >= 0) {
        dynamic_irq_init (irq);
    }
    return irq;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/io_apic_64.c.ifdefed" startline="1957" endline="1965">
{
    if (platform_legacy_irq (new))
        continue;
    if (irq_cfg[new].vector != 0)
        continue;
    if (__assign_irq_vector (new, TARGET_CPUS) == 0)
        irq = new;
    break;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/io_apic_64.c.ifdefed" startline="1968" endline="1970">
{
    dynamic_irq_init (irq);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/io_apic_64.c.ifdefed" startline="1975" endline="1983">
{
    unsigned long flags;
    dynamic_irq_cleanup (irq);
    spin_lock_irqsave (& vector_lock, flags);
    __clear_irq_vector (irq);
    spin_unlock_irqrestore (& vector_lock, flags);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/io_apic_64.c.ifdefed" startline="2349" endline="2378">
{
    unsigned long n;
    struct resource *res;
    char *mem;
    int i;
    if (nr_ioapics <= 0)
        return NULL;
    n = IOAPIC_RESOURCE_NAME_SIZE + sizeof (struct resource);
    n *= nr_ioapics;
    mem = alloc_bootmem (n);
    res = (void *) mem;
    if (mem != NULL) {
        mem += sizeof (struct resource) * nr_ioapics;
        for (i = 0; i < nr_ioapics; i++) {
            res[i].name = mem;
            res[i].flags = IORESOURCE_MEM | IORESOURCE_BUSY;
            sprintf (mem, "IOAPIC %u", i);
            mem += IOAPIC_RESOURCE_NAME_SIZE;
        }
    }
    ioapic_resources = res;
    return res;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/io_apic_64.c.ifdefed" startline="2364" endline="2373">
{
    mem += sizeof (struct resource) * nr_ioapics;
    for (i = 0; i < nr_ioapics; i++) {
        res[i].name = mem;
        res[i].flags = IORESOURCE_MEM | IORESOURCE_BUSY;
        sprintf (mem, "IOAPIC %u", i);
        mem += IOAPIC_RESOURCE_NAME_SIZE;
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/io_apic_64.c.ifdefed" startline="2367" endline="2372">
{
    res[i].name = mem;
    res[i].flags = IORESOURCE_MEM | IORESOURCE_BUSY;
    sprintf (mem, "IOAPIC %u", i);
    mem += IOAPIC_RESOURCE_NAME_SIZE;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/io_apic_64.c.ifdefed" startline="2381" endline="2407">
{
    unsigned long ioapic_phys, idx = FIX_IO_APIC_BASE_0;
    struct resource *ioapic_res;
    int i;
    ioapic_res = ioapic_setup_resources ();
    for (i = 0; i < nr_ioapics; i++) {
        if (smp_found_config) {
            ioapic_phys = mp_ioapics[i].mp_apicaddr;
        }
        else {
            ioapic_phys = (unsigned long) alloc_bootmem_pages (PAGE_SIZE);
            ioapic_phys = __pa (ioapic_phys);
        }
        set_fixmap_nocache (idx, ioapic_phys);
        apic_printk (APIC_VERBOSE, "mapped IOAPIC to %016lx (%016lx)\n", __fix_to_virt (idx), ioapic_phys);
        idx++;
        if (ioapic_res != NULL) {
            ioapic_res->start = ioapic_phys;
            ioapic_res->end = ioapic_phys + (4 * 1024) - 1;
            ioapic_res++;
        }
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/io_apic_64.c.ifdefed" startline="2387" endline="2406">
{
    if (smp_found_config) {
        ioapic_phys = mp_ioapics[i].mp_apicaddr;
    }
    else {
        ioapic_phys = (unsigned long) alloc_bootmem_pages (PAGE_SIZE);
        ioapic_phys = __pa (ioapic_phys);
    }
    set_fixmap_nocache (idx, ioapic_phys);
    apic_printk (APIC_VERBOSE, "mapped IOAPIC to %016lx (%016lx)\n", __fix_to_virt (idx), ioapic_phys);
    idx++;
    if (ioapic_res != NULL) {
        ioapic_res->start = ioapic_phys;
        ioapic_res->end = ioapic_phys + (4 * 1024) - 1;
        ioapic_res++;
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/io_apic_64.c.ifdefed" startline="2388" endline="2390">
{
    ioapic_phys = mp_ioapics[i].mp_apicaddr;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/io_apic_64.c.ifdefed" startline="2390" endline="2394">
{
    ioapic_phys = (unsigned long) alloc_bootmem_pages (PAGE_SIZE);
    ioapic_phys = __pa (ioapic_phys);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/io_apic_64.c.ifdefed" startline="2401" endline="2405">
{
    ioapic_res->start = ioapic_phys;
    ioapic_res->end = ioapic_phys + (4 * 1024) - 1;
    ioapic_res++;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/io_apic_64.c.ifdefed" startline="2410" endline="2426">
{
    int i;
    struct resource *r = ioapic_resources;
    if (!r) {
        printk (KERN_ERR "IO APIC resources could be not be allocated.\n");
        return -1;
    }
    for (i = 0; i < nr_ioapics; i++) {
        insert_resource (& iomem_resource, r);
        r++;
    }
    return 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/io_apic_64.c.ifdefed" startline="2414" endline="2418">
{
    printk (KERN_ERR "IO APIC resources could be not be allocated.\n");
    return -1;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/io_apic_64.c.ifdefed" startline="2420" endline="2423">
{
    insert_resource (& iomem_resource, r);
    r++;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/process_64.c.ifdefed" startline="62" endline="64">
{
    atomic_notifier_chain_register (& idle_notifier, n);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/process_64.c.ifdefed" startline="67" endline="70">
{
    write_pda (isidle, 1);
    atomic_notifier_call_chain (& idle_notifier, IDLE_START, NULL);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/process_64.c.ifdefed" startline="73" endline="77">
{
    if (test_and_clear_bit_pda (0, isidle) == 0)
        return;
    atomic_notifier_call_chain (& idle_notifier, IDLE_END, NULL);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/process_64.c.ifdefed" startline="81" endline="86">
{
    if (current->pid)
        return;
    __exit_idle ();
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/process_64.c.ifdefed" startline="108" endline="110">
{
    BUG ();
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/process_64.c.ifdefed" startline="120" endline="153">
{
    current_thread_info ()->status |= TS_POLLING;
    while (1) {
        tick_nohz_stop_sched_tick (1);
        while (!need_resched ()) {
            rmb ();
            if (cpu_is_offline (smp_processor_id ()))
                play_dead ();
            local_irq_disable ();
            enter_idle ();
            stop_critical_timings ();
            pm_idle ();
            start_critical_timings ();
            __exit_idle ();
        }
        tick_nohz_restart_sched_tick ();
        preempt_enable_no_resched ();
        schedule ();
        preempt_disable ();
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/process_64.c.ifdefed" startline="123" endline="152">
{
    tick_nohz_stop_sched_tick (1);
    while (!need_resched ()) {
        rmb ();
        if (cpu_is_offline (smp_processor_id ()))
            play_dead ();
        local_irq_disable ();
        enter_idle ();
        stop_critical_timings ();
        pm_idle ();
        start_critical_timings ();
        __exit_idle ();
    }
    tick_nohz_restart_sched_tick ();
    preempt_enable_no_resched ();
    schedule ();
    preempt_disable ();
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/process_64.c.ifdefed" startline="125" endline="146">
{
    rmb ();
    if (cpu_is_offline (smp_processor_id ()))
        play_dead ();
    local_irq_disable ();
    enter_idle ();
    stop_critical_timings ();
    pm_idle ();
    start_critical_timings ();
    __exit_idle ();
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/process_64.c.ifdefed" startline="157" endline="213">
{
    unsigned long cr0 = 0L, cr2 = 0L, cr3 = 0L, cr4 = 0L, fs, gs, shadowgs;
    unsigned long d0, d1, d2, d3, d6, d7;
    unsigned int fsindex, gsindex;
    unsigned int ds, cs, es;
    printk ("\n");
    print_modules ();
    printk ("Pid: %d, comm: %.20s %s %s %.*s\n", current -> pid, current -> comm, print_tainted (), init_utsname () -> release, (int) strcspn (init_utsname () -> version, " "), init_utsname () -> version);
    printk ("RIP: %04lx:[<%016lx>] ", regs -> cs & 0xffff, regs -> ip);
    printk_address (regs -> ip, 1);
    printk ("RSP: %04lx:%016lx  EFLAGS: %08lx\n", regs -> ss, regs -> sp, regs -> flags);
    printk ("RAX: %016lx RBX: %016lx RCX: %016lx\n", regs -> ax, regs -> bx, regs -> cx);
    printk ("RDX: %016lx RSI: %016lx RDI: %016lx\n", regs -> dx, regs -> si, regs -> di);
    printk ("RBP: %016lx R08: %016lx R09: %016lx\n", regs -> bp, regs -> r8, regs -> r9);
    printk ("R10: %016lx R11: %016lx R12: %016lx\n", regs -> r10, regs -> r11, regs -> r12);
    printk ("R13: %016lx R14: %016lx R15: %016lx\n", regs -> r13, regs -> r14, regs -> r15);
    asm ("movl %%ds,%0"
        : "=r" (ds)
    ) asm ("movl %%cs,%0"
        : "=r" (cs)
    ) asm ("movl %%es,%0"
        : "=r" (es)
    ) asm ("movl %%fs,%0"
        : "=r" (fsindex)
    ) asm ("movl %%gs,%0"
        : "=r" (gsindex)
    ) rdmsrl (MSR_FS_BASE, fs);
    rdmsrl (MSR_GS_BASE, gs);
    rdmsrl (MSR_KERNEL_GS_BASE, shadowgs);
    cr0 = read_cr0 ();
    cr2 = read_cr2 ();
    cr3 = read_cr3 ();
    cr4 = read_cr4 ();
    printk ("FS:  %016lx(%04x) GS:%016lx(%04x) knlGS:%016lx\n", fs, fsindex, gs, gsindex, shadowgs);
    printk ("CS:  %04x DS: %04x ES: %04x CR0: %016lx\n", cs, ds, es, cr0);
    printk ("CR2: %016lx CR3: %016lx CR4: %016lx\n", cr2, cr3, cr4);
    get_debugreg (d0, 0);
    get_debugreg (d1, 1);
    get_debugreg (d2, 2);
    printk ("DR0: %016lx DR1: %016lx DR2: %016lx\n", d0, d1, d2);
    get_debugreg (d3, 3);
    get_debugreg (d6, 6);
    get_debugreg (d7, 7);
    printk ("DR3: %016lx DR6: %016lx DR7: %016lx\n", d3, d6, d7);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/process_64.c.ifdefed" startline="216" endline="220">
{
    printk ("CPU %d:", smp_processor_id ());
    __show_regs (regs);
    show_trace (NULL, regs, (void *) (regs + 1), regs -> bp);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/process_64.c.ifdefed" startline="226" endline="243">
{
    struct task_struct *me = current;
    struct thread_struct *t = &me->thread;
    if (me->thread.io_bitmap_ptr) {
        struct tss_struct *tss = &per_cpu (init_tss, get_cpu ());
        kfree (t -> io_bitmap_ptr);
        t->io_bitmap_ptr = NULL;
        clear_thread_flag (TIF_IO_BITMAP);
        memset (tss -> io_bitmap, 0xff, t -> io_bitmap_max);
        t->io_bitmap_max = 0;
        put_cpu ();
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/process_64.c.ifdefed" startline="230" endline="242">
{
    struct tss_struct *tss = &per_cpu (init_tss, get_cpu ());
    kfree (t -> io_bitmap_ptr);
    t->io_bitmap_ptr = NULL;
    clear_thread_flag (TIF_IO_BITMAP);
    memset (tss -> io_bitmap, 0xff, t -> io_bitmap_max);
    t->io_bitmap_max = 0;
    put_cpu ();
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/process_64.c.ifdefed" startline="246" endline="273">
{
    struct task_struct *tsk = current;
    if (test_tsk_thread_flag (tsk, TIF_ABI_PENDING)) {
        clear_tsk_thread_flag (tsk, TIF_ABI_PENDING);
        if (test_tsk_thread_flag (tsk, TIF_IA32)) {
            clear_tsk_thread_flag (tsk, TIF_IA32);
        }
        else {
            set_tsk_thread_flag (tsk, TIF_IA32);
            current_thread_info ()->status |= TS_COMPAT;
        }
    }
    clear_tsk_thread_flag (tsk, TIF_DEBUG);
    tsk->thread.debugreg0 = 0;
    tsk->thread.debugreg1 = 0;
    tsk->thread.debugreg2 = 0;
    tsk->thread.debugreg3 = 0;
    tsk->thread.debugreg6 = 0;
    tsk->thread.debugreg7 = 0;
    memset (tsk -> thread.tls_array, 0, sizeof (tsk -> thread.tls_array));
    tsk->fpu_counter = 0;
    clear_fpu (tsk);
    clear_used_math ();
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/process_64.c.ifdefed" startline="249" endline="257">
{
    clear_tsk_thread_flag (tsk, TIF_ABI_PENDING);
    if (test_tsk_thread_flag (tsk, TIF_IA32)) {
        clear_tsk_thread_flag (tsk, TIF_IA32);
    }
    else {
        set_tsk_thread_flag (tsk, TIF_IA32);
        current_thread_info ()->status |= TS_COMPAT;
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/process_64.c.ifdefed" startline="251" endline="253">
{
    clear_tsk_thread_flag (tsk, TIF_IA32);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/process_64.c.ifdefed" startline="253" endline="256">
{
    set_tsk_thread_flag (tsk, TIF_IA32);
    current_thread_info ()->status |= TS_COMPAT;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/process_64.c.ifdefed" startline="276" endline="286">
{
    if (dead_task->mm) {
        if (dead_task->mm->context.size) {
            printk ("WARNING: dead process %8s still has LDT? <%p/%d>\n", dead_task -> comm, dead_task -> mm -> context.ldt, dead_task -> mm -> context.size);
            BUG ();
        }
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/process_64.c.ifdefed" startline="277" endline="285">
{
    if (dead_task->mm->context.size) {
        printk ("WARNING: dead process %8s still has LDT? <%p/%d>\n", dead_task -> comm, dead_task -> mm -> context.ldt, dead_task -> mm -> context.size);
        BUG ();
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/process_64.c.ifdefed" startline="278" endline="284">
{
    printk ("WARNING: dead process %8s still has LDT? <%p/%d>\n", dead_task -> comm, dead_task -> mm -> context.ldt, dead_task -> mm -> context.size);
    BUG ();
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/process_64.c.ifdefed" startline="289" endline="300">
{
    struct user_desc ud = {
        .base_addr = addr,
        .limit = 0xfffff,
        .seg_32bit = 1,
        .limit_in_pages = 1,
        .useable = 1,
    };
    struct desc_struct *desc = t->thread.tls_array;
    desc += tls;
    fill_ldt (desc, & ud);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/process_64.c.ifdefed" startline="303" endline="305">
{
    return get_desc_base (&t->thread.tls_array[tls]);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/process_64.c.ifdefed" startline="312" endline="314">
{
    unlazy_fpu (tsk);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/process_64.c.ifdefed" startline="319" endline="379">
{
    int err;
    struct pt_regs *childregs;
    struct task_struct *me = current;
    childregs = ((struct pt_regs *) (THREAD_SIZE + task_stack_page (p))) - 1;
    *childregs = *regs;
    childregs->ax = 0;
    childregs->sp = sp;
    if (sp == ~0UL)
        childregs->sp = (unsigned long) childregs;
    p->thread.sp = (unsigned long) childregs;
    p->thread.sp0 = (unsigned long) (childregs + 1);
    p->thread.usersp = me->thread.usersp;
    set_tsk_thread_flag (p, TIF_FORK);
    p->thread.fs = me->thread.fs;
    p->thread.gs = me->thread.gs;
    savesegment (gs, p -> thread.gsindex);
    savesegment (fs, p -> thread.fsindex);
    savesegment (es, p -> thread.es);
    savesegment (ds, p -> thread.ds);
    if (unlikely (test_tsk_thread_flag (me, TIF_IO_BITMAP))) {
        p->thread.io_bitmap_ptr = kmalloc (IO_BITMAP_BYTES, GFP_KERNEL);
        if (!p->thread.io_bitmap_ptr) {
            p->thread.io_bitmap_max = 0;
            return -ENOMEM;
        }
        memcpy (p -> thread.io_bitmap_ptr, me -> thread.io_bitmap_ptr, IO_BITMAP_BYTES);
        set_tsk_thread_flag (p, TIF_IO_BITMAP);
    }
    if (clone_flags & CLONE_SETTLS) {
        err = do_arch_prctl (p, ARCH_SET_FS, childregs->r8);
        if (err)
            goto out;
    }
    err = 0;
out :
    if (err && p->thread.io_bitmap_ptr) {
        kfree (p -> thread.io_bitmap_ptr);
        p->thread.io_bitmap_max = 0;
    }
    return err;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/process_64.c.ifdefed" startline="347" endline="356">
{
    p->thread.io_bitmap_ptr = kmalloc (IO_BITMAP_BYTES, GFP_KERNEL);
    if (!p->thread.io_bitmap_ptr) {
        p->thread.io_bitmap_max = 0;
        return -ENOMEM;
    }
    memcpy (p -> thread.io_bitmap_ptr, me -> thread.io_bitmap_ptr, IO_BITMAP_BYTES);
    set_tsk_thread_flag (p, TIF_IO_BITMAP);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/process_64.c.ifdefed" startline="349" endline="352">
{
    p->thread.io_bitmap_max = 0;
    return -ENOMEM;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/process_64.c.ifdefed" startline="361" endline="371">
{
    err = do_arch_prctl (p, ARCH_SET_FS, childregs->r8);
    if (err)
        goto out;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/process_64.c.ifdefed" startline="374" endline="377">
{
    kfree (p -> thread.io_bitmap_ptr);
    p->thread.io_bitmap_max = 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/process_64.c.ifdefed" startline="383" endline="399">
{
    loadsegment (fs, 0);
    loadsegment (es, 0);
    loadsegment (ds, 0);
    load_gs_index (0);
    regs->ip = new_ip;
    regs->sp = new_sp;
    write_pda (oldrsp, new_sp);
    regs->cs = __USER_CS;
    regs->ss = __USER_DS;
    regs->flags = 0x200;
    set_fs (USER_DS);
    free_thread_xstate (current);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/process_64.c.ifdefed" startline="403" endline="405">
{
    write_cr4 (read_cr4 () | X86_CR4_TSD);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/process_64.c.ifdefed" startline="408" endline="417">
{
    preempt_disable ();
    if (!test_and_set_thread_flag (TIF_NOTSC))
        hard_disable_TSC ();
    preempt_enable ();
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/process_64.c.ifdefed" startline="420" endline="422">
{
    write_cr4 (read_cr4 () & ~ X86_CR4_TSD);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/process_64.c.ifdefed" startline="425" endline="434">
{
    preempt_disable ();
    if (test_and_clear_thread_flag (TIF_NOTSC))
        hard_enable_TSC ();
    preempt_enable ();
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/process_64.c.ifdefed" startline="437" endline="446">
{
    unsigned int val;
    if (test_thread_flag (TIF_NOTSC))
        val = PR_TSC_SIGSEGV;
    else
        val = PR_TSC_ENABLE;
    return put_user (val, (unsigned int __user *) adr);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/process_64.c.ifdefed" startline="449" endline="458">
{
    if (val == PR_TSC_SIGSEGV)
        disable_TSC ();
    else if (val == PR_TSC_ENABLE)
        enable_TSC ();
    else
        return -EINVAL;
    return 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/process_64.c.ifdefed" startline="468" endline="527">
{
    struct thread_struct *prev, *next;
    unsigned long debugctl;
    prev = &prev_p->thread, next = &next_p->thread;
    debugctl = prev->debugctlmsr;
    if (next->ds_area_msr != prev->ds_area_msr) {
        debugctl = 0;
        update_debugctlmsr (0);
        wrmsrl (MSR_IA32_DS_AREA, next -> ds_area_msr);
    }
    if (next->debugctlmsr != debugctl)
        update_debugctlmsr (next->debugctlmsr);
    if (test_tsk_thread_flag (next_p, TIF_DEBUG)) {
        loaddebug (next, 0);
        loaddebug (next, 1);
        loaddebug (next, 2);
        loaddebug (next, 3);
        loaddebug (next, 6);
        loaddebug (next, 7);
    }
    if (test_tsk_thread_flag (prev_p, TIF_NOTSC) ^ test_tsk_thread_flag (next_p, TIF_NOTSC)) {
        if (test_tsk_thread_flag (next_p, TIF_NOTSC))
            hard_disable_TSC ();
        else
            hard_enable_TSC ();
    }
    if (test_tsk_thread_flag (next_p, TIF_IO_BITMAP)) {
        memcpy (tss -> io_bitmap, next -> io_bitmap_ptr, max (prev -> io_bitmap_max, next -> io_bitmap_max));
    }
    else if (test_tsk_thread_flag (prev_p, TIF_IO_BITMAP)) {
        memset (tss -> io_bitmap, 0xff, prev -> io_bitmap_max);
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/process_64.c.ifdefed" startline="476" endline="482">
{
    debugctl = 0;
    update_debugctlmsr (0);
    wrmsrl (MSR_IA32_DS_AREA, next -> ds_area_msr);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/process_64.c.ifdefed" startline="487" endline="495">
{
    loaddebug (next, 0);
    loaddebug (next, 1);
    loaddebug (next, 2);
    loaddebug (next, 3);
    loaddebug (next, 6);
    loaddebug (next, 7);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/process_64.c.ifdefed" startline="498" endline="504">
{
    if (test_tsk_thread_flag (next_p, TIF_NOTSC))
        hard_disable_TSC ();
    else
        hard_enable_TSC ();
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/process_64.c.ifdefed" startline="506" endline="513">
{
    memcpy (tss -> io_bitmap, next -> io_bitmap_ptr, max (prev -> io_bitmap_max, next -> io_bitmap_max));
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/process_64.c.ifdefed" startline="513" endline="518">
{
    memset (tss -> io_bitmap, 0xff, prev -> io_bitmap_max);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/process_64.c.ifdefed" startline="540" endline="658">
{
    struct thread_struct *prev = &prev_p->thread;
    struct thread_struct *next = &next_p->thread;
    int cpu = smp_processor_id ();
    struct tss_struct *tss = &per_cpu (init_tss, cpu);
    unsigned fsindex, gsindex;
    if (next_p->fpu_counter > 5)
        prefetch (next->xstate);
    load_sp0 (tss, next);
    savesegment (es, prev -> es);
    if (unlikely (next->es | prev->es))
        loadsegment (es, next->es);
    savesegment (ds, prev -> ds);
    if (unlikely (next->ds | prev->ds))
        loadsegment (ds, next->ds);
    savesegment (fs, fsindex);
    savesegment (gs, gsindex);
    load_TLS (next, cpu);
    arch_leave_lazy_cpu_mode ();
    if (unlikely (fsindex | next->fsindex | prev->fs)) {
        loadsegment (fs, next -> fsindex);
        if (fsindex)
            prev->fs = 0;
    }
    if (next->fs)
        wrmsrl (MSR_FS_BASE, next->fs);
    prev->fsindex = fsindex;
    if (unlikely (gsindex | next->gsindex | prev->gs)) {
        load_gs_index (next -> gsindex);
        if (gsindex)
            prev->gs = 0;
    }
    if (next->gs)
        wrmsrl (MSR_KERNEL_GS_BASE, next->gs);
    prev->gsindex = gsindex;
    unlazy_fpu (prev_p);
    prev->usersp = read_pda (oldrsp);
    write_pda (oldrsp, next -> usersp);
    write_pda (pcurrent, next_p);
    write_pda (kernelstack, (unsigned long) task_stack_page (next_p) + THREAD_SIZE - PDA_STACKOFFSET);
    if (unlikely (task_thread_info (next_p)->flags & _TIF_WORK_CTXSW_NEXT || task_thread_info (prev_p)->flags & _TIF_WORK_CTXSW_PREV))
        __switch_to_xtra (prev_p, next_p, tss);
    if (tsk_used_math (next_p) && next_p->fpu_counter > 5)
        math_state_restore ();
    return prev_p;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/process_64.c.ifdefed" startline="595" endline="604">
{
    loadsegment (fs, next -> fsindex);
    if (fsindex)
        prev->fs = 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/process_64.c.ifdefed" startline="610" endline="614">
{
    load_gs_index (next -> gsindex);
    if (gsindex)
        prev->gs = 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/process_64.c.ifdefed" startline="666" endline="677">
{
    long error;
    char *filename;
    filename = getname (name);
    error = PTR_ERR (filename);
    if (IS_ERR (filename))
        return error;
    error = do_execve (filename, argv, envp, regs);
    putname (filename);
    return error;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/process_64.c.ifdefed" startline="680" endline="691">
{
    clear_thread_flag (TIF_IA32);
    current->personality &= ~READ_IMPLIES_EXEC;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/process_64.c.ifdefed" startline="694" endline="696">
{
    return do_fork (SIGCHLD, regs->sp, regs, 0, NULL, NULL);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/process_64.c.ifdefed" startline="701" endline="705">
{
    if (!newsp)
        newsp = regs->sp;
    return do_fork (clone_flags, newsp, regs, 0, parent_tid, child_tid);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/process_64.c.ifdefed" startline="718" endline="721">
{
    return do_fork (CLONE_VFORK | CLONE_VM | SIGCHLD, regs->sp, regs, 0, NULL, NULL);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/process_64.c.ifdefed" startline="724" endline="745">
{
    unsigned long stack;
    u64 fp, ip;
    int count = 0;
    if (!p || p == current || p->state == TASK_RUNNING)
        return 0;
    stack = (unsigned long) task_stack_page (p);
    if (p->thread.sp < stack || p->thread.sp > stack + THREAD_SIZE)
        return 0;
    fp = *(u64*) (p->thread.sp);
    do {
        if (fp < (unsigned long) stack || fp > (unsigned long) stack + THREAD_SIZE)
            return 0;
        ip = *(u64*) (fp + 8);
        if (!in_sched_functions (ip))
            return ip;
        fp = *(u64*) fp;
    }
    while (count++ < 16);
    return 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/process_64.c.ifdefed" startline="735" endline="743">
{
    if (fp < (unsigned long) stack || fp > (unsigned long) stack + THREAD_SIZE)
        return 0;
    ip = *(u64*) (fp + 8);
    if (!in_sched_functions (ip))
        return ip;
    fp = *(u64*) fp;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/process_64.c.ifdefed" startline="748" endline="841">
{
    int ret = 0;
    int doit = task == current;
    int cpu;
    switch (code) {
    case ARCH_SET_GS :
        if (addr >= TASK_SIZE_OF (task))
            return -EPERM;
        cpu = get_cpu ();
        if (addr <= 0xffffffff) {
            set_32bit_tls (task, GS_TLS, addr);
            if (doit) {
                load_TLS (& task -> thread, cpu);
                load_gs_index (GS_TLS_SEL);
            }
            task->thread.gsindex = GS_TLS_SEL;
            task->thread.gs = 0;
        }
        else {
            task->thread.gsindex = 0;
            task->thread.gs = addr;
            if (doit) {
                load_gs_index (0);
                ret = checking_wrmsrl (MSR_KERNEL_GS_BASE, addr);
            }
        }
        put_cpu ();
        break;
    case ARCH_SET_FS :
        if (addr >= TASK_SIZE_OF (task))
            return -EPERM;
        cpu = get_cpu ();
        if (addr <= 0xffffffff) {
            set_32bit_tls (task, FS_TLS, addr);
            if (doit) {
                load_TLS (& task -> thread, cpu);
                loadsegment (fs, FS_TLS_SEL);
            }
            task->thread.fsindex = FS_TLS_SEL;
            task->thread.fs = 0;
        }
        else {
            task->thread.fsindex = 0;
            task->thread.fs = addr;
            if (doit) {
                loadsegment (fs, 0);
                ret = checking_wrmsrl (MSR_FS_BASE, addr);
            }
        }
        put_cpu ();
        break;
    case ARCH_GET_FS :
        {
            unsigned long base;
            if (task->thread.fsindex == FS_TLS_SEL)
                base = read_32bit_tls (task, FS_TLS);
            else if (doit)
                rdmsrl (MSR_FS_BASE, base);
            else
                base = task->thread.fs;
            ret = put_user (base, (unsigned long __user *) addr);
            break;
        }
    case ARCH_GET_GS :
        {
            unsigned long base;
            unsigned gsindex;
            if (task->thread.gsindex == GS_TLS_SEL)
                base = read_32bit_tls (task, GS_TLS);
            else if (doit) {
                savesegment (gs, gsindex);
                if (gsindex)
                    rdmsrl (MSR_KERNEL_GS_BASE, base);
                else
                    base = task->thread.gs;
            }
            else
                base = task->thread.gs;
            ret = put_user (base, (unsigned long __user *) addr);
            break;
        }
    default :
        ret = -EINVAL;
        break;
    }
    return ret;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/process_64.c.ifdefed" startline="753" endline="838">
{
case ARCH_SET_GS :
    if (addr >= TASK_SIZE_OF (task))
        return -EPERM;
    cpu = get_cpu ();
    if (addr <= 0xffffffff) {
        set_32bit_tls (task, GS_TLS, addr);
        if (doit) {
            load_TLS (& task -> thread, cpu);
            load_gs_index (GS_TLS_SEL);
        }
        task->thread.gsindex = GS_TLS_SEL;
        task->thread.gs = 0;
    }
    else {
        task->thread.gsindex = 0;
        task->thread.gs = addr;
        if (doit) {
            load_gs_index (0);
            ret = checking_wrmsrl (MSR_KERNEL_GS_BASE, addr);
        }
    }
    put_cpu ();
    break;
case ARCH_SET_FS :
    if (addr >= TASK_SIZE_OF (task))
        return -EPERM;
    cpu = get_cpu ();
    if (addr <= 0xffffffff) {
        set_32bit_tls (task, FS_TLS, addr);
        if (doit) {
            load_TLS (& task -> thread, cpu);
            loadsegment (fs, FS_TLS_SEL);
        }
        task->thread.fsindex = FS_TLS_SEL;
        task->thread.fs = 0;
    }
    else {
        task->thread.fsindex = 0;
        task->thread.fs = addr;
        if (doit) {
            loadsegment (fs, 0);
            ret = checking_wrmsrl (MSR_FS_BASE, addr);
        }
    }
    put_cpu ();
    break;
case ARCH_GET_FS :
    {
        unsigned long base;
        if (task->thread.fsindex == FS_TLS_SEL)
            base = read_32bit_tls (task, FS_TLS);
        else if (doit)
            rdmsrl (MSR_FS_BASE, base);
        else
            base = task->thread.fs;
        ret = put_user (base, (unsigned long __user *) addr);
        break;
    }
case ARCH_GET_GS :
    {
        unsigned long base;
        unsigned gsindex;
        if (task->thread.gsindex == GS_TLS_SEL)
            base = read_32bit_tls (task, GS_TLS);
        else if (doit) {
            savesegment (gs, gsindex);
            if (gsindex)
                rdmsrl (MSR_KERNEL_GS_BASE, base);
            else
                base = task->thread.gs;
        }
        else
            base = task->thread.gs;
        ret = put_user (base, (unsigned long __user *) addr);
        break;
    }
default :
    ret = -EINVAL;
    break;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/process_64.c.ifdefed" startline="760" endline="768">
{
    set_32bit_tls (task, GS_TLS, addr);
    if (doit) {
        load_TLS (& task -> thread, cpu);
        load_gs_index (GS_TLS_SEL);
    }
    task->thread.gsindex = GS_TLS_SEL;
    task->thread.gs = 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/process_64.c.ifdefed" startline="762" endline="765">
{
    load_TLS (& task -> thread, cpu);
    load_gs_index (GS_TLS_SEL);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/process_64.c.ifdefed" startline="768" endline="775">
{
    task->thread.gsindex = 0;
    task->thread.gs = addr;
    if (doit) {
        load_gs_index (0);
        ret = checking_wrmsrl (MSR_KERNEL_GS_BASE, addr);
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/process_64.c.ifdefed" startline="771" endline="774">
{
    load_gs_index (0);
    ret = checking_wrmsrl (MSR_KERNEL_GS_BASE, addr);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/process_64.c.ifdefed" startline="786" endline="794">
{
    set_32bit_tls (task, FS_TLS, addr);
    if (doit) {
        load_TLS (& task -> thread, cpu);
        loadsegment (fs, FS_TLS_SEL);
    }
    task->thread.fsindex = FS_TLS_SEL;
    task->thread.fs = 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/process_64.c.ifdefed" startline="788" endline="791">
{
    load_TLS (& task -> thread, cpu);
    loadsegment (fs, FS_TLS_SEL);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/process_64.c.ifdefed" startline="794" endline="803">
{
    task->thread.fsindex = 0;
    task->thread.fs = addr;
    if (doit) {
        loadsegment (fs, 0);
        ret = checking_wrmsrl (MSR_FS_BASE, addr);
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/process_64.c.ifdefed" startline="797" endline="802">
{
    loadsegment (fs, 0);
    ret = checking_wrmsrl (MSR_FS_BASE, addr);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/process_64.c.ifdefed" startline="806" endline="816">
{
    unsigned long base;
    if (task->thread.fsindex == FS_TLS_SEL)
        base = read_32bit_tls (task, FS_TLS);
    else if (doit)
        rdmsrl (MSR_FS_BASE, base);
    else
        base = task->thread.fs;
    ret = put_user (base, (unsigned long __user *) addr);
    break;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/process_64.c.ifdefed" startline="817" endline="833">
{
    unsigned long base;
    unsigned gsindex;
    if (task->thread.gsindex == GS_TLS_SEL)
        base = read_32bit_tls (task, GS_TLS);
    else if (doit) {
        savesegment (gs, gsindex);
        if (gsindex)
            rdmsrl (MSR_KERNEL_GS_BASE, base);
        else
            base = task->thread.gs;
    }
    else
        base = task->thread.gs;
    ret = put_user (base, (unsigned long __user *) addr);
    break;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/process_64.c.ifdefed" startline="822" endline="828">
{
    savesegment (gs, gsindex);
    if (gsindex)
        rdmsrl (MSR_KERNEL_GS_BASE, base);
    else
        base = task->thread.gs;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/process_64.c.ifdefed" startline="844" endline="846">
{
    return do_arch_prctl (current, code, addr);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/process_64.c.ifdefed" startline="849" endline="853">
{
    if (!(current->personality & ADDR_NO_RANDOMIZE) && randomize_va_space)
        sp -= get_random_int () % 8192;
    return sp & ~0xf;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/process_64.c.ifdefed" startline="856" endline="859">
{
    unsigned long range_end = mm->brk + 0x02000000;
    return randomize_range (mm->brk, range_end, 0) ? : mm->brk;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/tsc_sync.c.ifdefed" startline="45" endline="94">
{
    cycles_t start, now, prev, end;
    int i;
    start = get_cycles ();
    end = start + tsc_khz * 20ULL;
    now = start;
    for (i = 0;; i++) {
        __raw_spin_lock (& sync_lock);
        prev = last_tsc;
        now = get_cycles ();
        last_tsc = now;
        __raw_spin_unlock (& sync_lock);
        if (unlikely (!(i & 7))) {
            if (now > end || i > 10000000)
                break;
            cpu_relax ();
            touch_nmi_watchdog ();
        }
        if (unlikely (prev > now)) {
            __raw_spin_lock (& sync_lock);
            max_warp = max (max_warp, prev -now);
            nr_warps++;
            __raw_spin_unlock (& sync_lock);
        }
    }
    WARN (! (now - start), "Warning: zero tsc calibration delta: %Ld [max: %Ld]\n", now - start, end - start);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/tsc_sync.c.ifdefed" startline="56" endline="90">
{
    __raw_spin_lock (& sync_lock);
    prev = last_tsc;
    now = get_cycles ();
    last_tsc = now;
    __raw_spin_unlock (& sync_lock);
    if (unlikely (!(i & 7))) {
        if (now > end || i > 10000000)
            break;
        cpu_relax ();
        touch_nmi_watchdog ();
    }
    if (unlikely (prev > now)) {
        __raw_spin_lock (& sync_lock);
        max_warp = max (max_warp, prev -now);
        nr_warps++;
        __raw_spin_unlock (& sync_lock);
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/tsc_sync.c.ifdefed" startline="74" endline="79">
{
    if (now > end || i > 10000000)
        break;
    cpu_relax ();
    touch_nmi_watchdog ();
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/tsc_sync.c.ifdefed" startline="84" endline="89">
{
    __raw_spin_lock (& sync_lock);
    max_warp = max (max_warp, prev -now);
    nr_warps++;
    __raw_spin_unlock (& sync_lock);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/tsc_sync.c.ifdefed" startline="101" endline="155">
{
    int cpus = 2;
    if (unsynchronized_tsc ())
        return;
    printk (KERN_INFO "checking TSC synchronization [CPU#%d -> CPU#%d]:", smp_processor_id (), cpu);
    atomic_set (& stop_count, 0);
    while (atomic_read (&start_count) != cpus - 1)
        cpu_relax ();
    atomic_inc (& start_count);
    check_tsc_warp ();
    while (atomic_read (&stop_count) != cpus - 1)
        cpu_relax ();
    if (nr_warps) {
        printk ("\n");
        printk (KERN_WARNING "Measured %Ld cycles TSC warp between CPUs," " turning off TSC clock.\n", max_warp);
        mark_tsc_unstable ("check_tsc_sync_source failed");
    }
    else {
        printk (" passed.\n");
    }
    atomic_set (& start_count, 0);
    nr_warps = 0;
    max_warp = 0;
    last_tsc = 0;
    atomic_inc (& stop_count);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/tsc_sync.c.ifdefed" startline="134" endline="139">
{
    printk ("\n");
    printk (KERN_WARNING "Measured %Ld cycles TSC warp between CPUs," " turning off TSC clock.\n", max_warp);
    mark_tsc_unstable ("check_tsc_sync_source failed");
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/tsc_sync.c.ifdefed" startline="139" endline="141">
{
    printk (" passed.\n");
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/tsc_sync.c.ifdefed" startline="161" endline="187">
{
    int cpus = 2;
    if (unsynchronized_tsc ())
        return;
    atomic_inc (& start_count);
    while (atomic_read (&start_count) != cpus)
        cpu_relax ();
    check_tsc_warp ();
    atomic_inc (& stop_count);
    while (atomic_read (&stop_count) != cpus)
        cpu_relax ();
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/msr.c.ifdefed" startline="47" endline="66">
{
    loff_t ret;
    struct inode *inode = file->f_mapping->host;
    mutex_lock (& inode -> i_mutex);
    switch (orig) {
    case 0 :
        file->f_pos = offset;
        ret = file->f_pos;
        break;
    case 1 :
        file->f_pos += offset;
        ret = file->f_pos;
        break;
    default :
        ret = -EINVAL;
    }
    mutex_unlock (& inode -> i_mutex);
    return ret;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/msr.c.ifdefed" startline="52" endline="63">
{
case 0 :
    file->f_pos = offset;
    ret = file->f_pos;
    break;
case 1 :
    file->f_pos += offset;
    ret = file->f_pos;
    break;
default :
    ret = -EINVAL;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/msr.c.ifdefed" startline="70" endline="97">
{
    u32 __user *tmp = (u32 __user *) buf;
    u32 data [2];
    u32 reg = *ppos;
    int cpu = iminor (file->f_path.dentry->d_inode);
    int err = 0;
    ssize_t bytes = 0;
    if (count % 8)
        return -EINVAL;
    for (; count; count -= 8) {
        err = rdmsr_safe_on_cpu (cpu, reg, &data[0], &data[1]);
        if (err) {
            if (err == -EFAULT)
                err = -EIO;
            break;
        }
        if (copy_to_user (tmp, &data, 8)) {
            err = -EFAULT;
            break;
        }
        tmp += 2;
        bytes += 8;
    }
    return bytes ? bytes : err;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/msr.c.ifdefed" startline="81" endline="94">
{
    err = rdmsr_safe_on_cpu (cpu, reg, &data[0], &data[1]);
    if (err) {
        if (err == -EFAULT)
            err = -EIO;
        break;
    }
    if (copy_to_user (tmp, &data, 8)) {
        err = -EFAULT;
        break;
    }
    tmp += 2;
    bytes += 8;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/msr.c.ifdefed" startline="83" endline="87">
{
    if (err == -EFAULT)
        err = -EIO;
    break;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/msr.c.ifdefed" startline="88" endline="91">
{
    err = -EFAULT;
    break;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/msr.c.ifdefed" startline="101" endline="128">
{
    const u32 __user *tmp = (const u32 __user *) buf;
    u32 data [2];
    u32 reg = *ppos;
    int cpu = iminor (file->f_path.dentry->d_inode);
    int err = 0;
    ssize_t bytes = 0;
    if (count % 8)
        return -EINVAL;
    for (; count; count -= 8) {
        if (copy_from_user (&data, tmp, 8)) {
            err = -EFAULT;
            break;
        }
        err = wrmsr_safe_on_cpu (cpu, reg, data[0], data[1]);
        if (err) {
            if (err == -EFAULT)
                err = -EIO;
            break;
        }
        tmp += 2;
        bytes += 8;
    }
    return bytes ? bytes : err;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/msr.c.ifdefed" startline="112" endline="125">
{
    if (copy_from_user (&data, tmp, 8)) {
        err = -EFAULT;
        break;
    }
    err = wrmsr_safe_on_cpu (cpu, reg, data[0], data[1]);
    if (err) {
        if (err == -EFAULT)
            err = -EIO;
        break;
    }
    tmp += 2;
    bytes += 8;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/msr.c.ifdefed" startline="113" endline="116">
{
    err = -EFAULT;
    break;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/msr.c.ifdefed" startline="118" endline="122">
{
    if (err == -EFAULT)
        err = -EIO;
    break;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/msr.c.ifdefed" startline="131" endline="149">
{
    unsigned int cpu = iminor (file->f_path.dentry->d_inode);
    struct cpuinfo_x86 *c = &cpu_data (cpu);
    int ret = 0;
    lock_kernel ();
    cpu = iminor (file->f_path.dentry->d_inode);
    if (cpu >= NR_CPUS || !cpu_online (cpu)) {
        ret = -ENXIO;
        goto out;
    }
    c = &cpu_data (cpu);
    if (!cpu_has (c, X86_FEATURE_MSR))
        ret = -EIO;
out :
    unlock_kernel ();
    return ret;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/msr.c.ifdefed" startline="139" endline="142">
{
    ret = -ENXIO;
    goto out;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/msr.c.ifdefed" startline="163" endline="169">
{
    struct device *dev;
    dev = device_create_drvdata (msr_class, NULL, MKDEV (MSR_MAJOR, cpu), NULL, "msr%d", cpu);
    return IS_ERR (dev) ? PTR_ERR (dev) : 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/msr.c.ifdefed" startline="172" endline="174">
{
    device_destroy (msr_class, MKDEV (MSR_MAJOR, cpu));
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/msr.c.ifdefed" startline="178" endline="193">
{
    unsigned int cpu = (unsigned long) hcpu;
    int err = 0;
    switch (action) {
    case CPU_UP_PREPARE :
        err = msr_device_create (cpu);
        break;
    case CPU_UP_CANCELED :
    case CPU_UP_CANCELED_FROZEN :
    case CPU_DEAD :
        msr_device_destroy (cpu);
        break;
    }
    return err ? NOTIFY_BAD : NOTIFY_OK;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/msr.c.ifdefed" startline="182" endline="191">
{
case CPU_UP_PREPARE :
    err = msr_device_create (cpu);
    break;
case CPU_UP_CANCELED :
case CPU_UP_CANCELED_FROZEN :
case CPU_DEAD :
    msr_device_destroy (cpu);
    break;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/msr.c.ifdefed" startline="200" endline="234">
{
    int i, err = 0;
    i = 0;
    if (register_chrdev (MSR_MAJOR, "cpu/msr", &msr_fops)) {
        printk (KERN_ERR "msr: unable to get major %d for msr\n", MSR_MAJOR);
        err = -EBUSY;
        goto out;
    }
    msr_class = class_create (THIS_MODULE, "msr");
    if (IS_ERR (msr_class)) {
        err = PTR_ERR (msr_class);
        goto out_chrdev;
    }

    for_each_online_cpu (i) {
        err = msr_device_create (i);
        if (err != 0)
            goto out_class;
    }

    register_hotcpu_notifier (& msr_class_cpu_notifier);
    err = 0;
    goto out;
out_class :
    i = 0;
    for_each_online_cpu (i)
    msr_device_destroy (i);
    class_destroy (msr_class);
out_chrdev :
    unregister_chrdev (MSR_MAJOR, "cpu/msr");
out :
    return err;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/msr.c.ifdefed" startline="204" endline="209">
{
    printk (KERN_ERR "msr: unable to get major %d for msr\n", MSR_MAJOR);
    err = -EBUSY;
    goto out;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/msr.c.ifdefed" startline="211" endline="214">
{
    err = PTR_ERR (msr_class);
    goto out_chrdev;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/msr.c.ifdefed" startline="215" endline="219">
{
    err = msr_device_create (i);
    if (err != 0)
        goto out_class;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/msr.c.ifdefed" startline="237" endline="244">
{
    int cpu = 0;
    for_each_online_cpu (cpu)
    msr_device_destroy (cpu);
    class_destroy (msr_class);
    unregister_chrdev (MSR_MAJOR, "cpu/msr");
    unregister_hotcpu_notifier (& msr_class_cpu_notifier);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/nmi.c.ifdefed" startline="65" endline="71">
{
    return nmi_count (cpu);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/nmi.c.ifdefed" startline="74" endline="79">
{
    return 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/nmi.c.ifdefed" startline="86" endline="93">
{
    return per_cpu (irq_stat, cpu).apic_timer_irqs + per_cpu (irq_stat, cpu).irq0_irqs;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/nmi.c.ifdefed" startline="118" endline="132">
{
    printk (KERN_CONT "\n");
    printk (KERN_WARNING "WARNING: CPU#%d: NMI appears to be stuck (%d->%d)!\n", cpu, prev_nmi_count [cpu], get_nmi_count (cpu));
    printk (KERN_WARNING "Please report this to bugzilla.kernel.org,\n");
    printk (KERN_WARNING "and attach the output of the 'dmesg' command.\n");
    per_cpu (wd_enabled, cpu) = 0;
    atomic_dec (& nmi_active);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/nmi.c.ifdefed" startline="135" endline="188">
{
    unsigned int *prev_nmi_count;
    int cpu;
    if (!nmi_watchdog_active () || !atomic_read (&nmi_active))
        return 0;
    prev_nmi_count = kmalloc (nr_cpu_ids * sizeof (int), GFP_KERNEL);
    if (!prev_nmi_count)
        goto error;
    printk (KERN_INFO "Testing NMI watchdog ... ");
    for_each_possible_cpu (cpu)
    prev_nmi_count [cpu] = get_nmi_count (cpu);
    local_irq_enable ();
    mdelay ((20 * 1000) / nmi_hz);

    for_each_online_cpu (cpu) {
        if (!per_cpu (wd_enabled, cpu))
            continue;
        if (get_nmi_count (cpu) - prev_nmi_count[cpu] <= 5)
            report_broken_nmi (cpu, prev_nmi_count);
    }

    endflag = 1;
    if (!atomic_read (&nmi_active)) {
        kfree (prev_nmi_count);
        atomic_set (& nmi_active, - 1);
        goto error;
    }
    printk ("OK.\n");
    if (nmi_watchdog == NMI_LOCAL_APIC)
        nmi_hz = lapic_adjust_nmi_hz (1);
    kfree (prev_nmi_count);
    return 0;
error :
    if (nmi_watchdog == NMI_IO_APIC && !timer_through_8259)
        disable_8259A_irq (0);
    return -1;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/nmi.c.ifdefed" startline="158" endline="163">
{
    if (!per_cpu (wd_enabled, cpu))
        continue;
    if (get_nmi_count (cpu) - prev_nmi_count[cpu] <= 5)
        report_broken_nmi (cpu, prev_nmi_count);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/nmi.c.ifdefed" startline="165" endline="169">
{
    kfree (prev_nmi_count);
    atomic_set (& nmi_active, - 1);
    goto error;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/nmi.c.ifdefed" startline="191" endline="209">
{
    unsigned int nmi;
    if (!strncmp (str, "panic", 5)) {
        panic_on_timeout = 1;
        str = strchr (str, ',');
        if (!str)
            return 1;
        ++str;
    }
    get_option (& str, & nmi);
    if (nmi >= NMI_INVALID)
        return 0;
    nmi_watchdog = nmi;
    return 1;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/nmi.c.ifdefed" startline="194" endline="200">
{
    panic_on_timeout = 1;
    str = strchr (str, ',');
    if (!str)
        return 1;
    ++str;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/nmi.c.ifdefed" startline="275" endline="277">
{
    apic_write (APIC_LVT0, APIC_DM_NMI);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/nmi.c.ifdefed" startline="283" endline="286">
{
    if (atomic_read (&nmi_active) && nmi_watchdog == NMI_IO_APIC)
        on_each_cpu (__acpi_nmi_enable, NULL, 1);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/nmi.c.ifdefed" startline="289" endline="291">
{
    apic_write (APIC_LVT0, APIC_DM_NMI | APIC_LVT_MASKED);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/nmi.c.ifdefed" startline="297" endline="300">
{
    if (atomic_read (&nmi_active) && nmi_watchdog == NMI_IO_APIC)
        on_each_cpu (__acpi_nmi_disable, NULL, 1);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/nmi.c.ifdefed" startline="303" endline="325">
{
    if (__get_cpu_var (wd_enabled))
        return;
    if (smp_processor_id () != 0 && atomic_read (&nmi_active) <= 0)
        return;
    switch (nmi_watchdog) {
    case NMI_LOCAL_APIC :
        __get_cpu_var (wd_enabled) = 1;
        if (lapic_watchdog_init (nmi_hz) < 0) {
            __get_cpu_var (wd_enabled) = 0;
            return;
        }
    case NMI_IO_APIC :
        __get_cpu_var (wd_enabled) = 1;
        atomic_inc (& nmi_active);
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/nmi.c.ifdefed" startline="312" endline="324">
{
case NMI_LOCAL_APIC :
    __get_cpu_var (wd_enabled) = 1;
    if (lapic_watchdog_init (nmi_hz) < 0) {
        __get_cpu_var (wd_enabled) = 0;
        return;
    }
case NMI_IO_APIC :
    __get_cpu_var (wd_enabled) = 1;
    atomic_inc (& nmi_active);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/nmi.c.ifdefed" startline="316" endline="319">
{
    __get_cpu_var (wd_enabled) = 0;
    return;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/nmi.c.ifdefed" startline="328" endline="338">
{
    if (!nmi_watchdog_active ())
        return;
    if (__get_cpu_var (wd_enabled) == 0)
        return;
    if (nmi_watchdog == NMI_LOCAL_APIC)
        lapic_watchdog_stop ();
    __get_cpu_var (wd_enabled) = 0;
    atomic_dec (& nmi_active);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/nmi.c.ifdefed" startline="359" endline="378">
{
    if (nmi_watchdog_active ()) {
        unsigned cpu;

        for_each_present_cpu (cpu) {
            if (per_cpu (nmi_touch, cpu) != 1)
                per_cpu (nmi_touch, cpu) = 1;
        }

    }
    touch_softlockup_watchdog ();
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/nmi.c.ifdefed" startline="360" endline="372">
{
    unsigned cpu;

    for_each_present_cpu (cpu) {
        if (per_cpu (nmi_touch, cpu) != 1)
            per_cpu (nmi_touch, cpu) = 1;
    }

}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/nmi.c.ifdefed" startline="368" endline="371">
{
    if (per_cpu (nmi_touch, cpu) != 1)
        per_cpu (nmi_touch, cpu) = 1;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/nmi.c.ifdefed" startline="383" endline="457">
{
    unsigned int sum;
    int touched = 0;
    int cpu = smp_processor_id ();
    int rc = 0;
    if (notify_die (DIE_NMI, "nmi", regs, reason, 2, SIGINT) == NOTIFY_STOP) {
        rc = 1;
        touched = 1;
    }
    sum = get_timer_irqs (cpu);
    if (__get_cpu_var (nmi_touch)) {
        __get_cpu_var (nmi_touch) = 0;
        touched = 1;
    }
    if (cpu_isset (cpu, backtrace_mask)) {
        static DEFINE_SPINLOCK (lock);
        spin_lock (& lock);
        printk (KERN_WARNING "NMI backtrace for cpu %d\n", cpu);
        dump_stack ();
        spin_unlock (& lock);
        cpu_clear (cpu, backtrace_mask);
    }
    if (mce_in_progress ())
        touched = 1;
    if (!touched && __get_cpu_var (last_irq_sum) == sum) {
        local_inc (& __get_cpu_var (alert_counter));
        if (local_read (&__get_cpu_var (alert_counter)) == 5 * nmi_hz)
            die_nmi ("BUG: NMI Watchdog detected LOCKUP", regs, panic_on_timeout);
    }
    else {
        __get_cpu_var (last_irq_sum) = sum;
        local_set (& __get_cpu_var (alert_counter), 0);
    }
    if (!__get_cpu_var (wd_enabled))
        return rc;
    switch (nmi_watchdog) {
    case NMI_LOCAL_APIC :
        rc |= lapic_wd_event (nmi_hz);
        break;
    case NMI_IO_APIC :
        rc = 1;
        break;
    }
    return rc;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/nmi.c.ifdefed" startline="396" endline="399">
{
    rc = 1;
    touched = 1;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/nmi.c.ifdefed" startline="403" endline="406">
{
    __get_cpu_var (nmi_touch) = 0;
    touched = 1;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/nmi.c.ifdefed" startline="408" endline="416">
{
    static DEFINE_SPINLOCK (lock);
    spin_lock (& lock);
    printk (KERN_WARNING "NMI backtrace for cpu %d\n", cpu);
    dump_stack ();
    spin_unlock (& lock);
    cpu_clear (cpu, backtrace_mask);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/nmi.c.ifdefed" startline="423" endline="435">
{
    local_inc (& __get_cpu_var (alert_counter));
    if (local_read (&__get_cpu_var (alert_counter)) == 5 * nmi_hz)
        die_nmi ("BUG: NMI Watchdog detected LOCKUP", regs, panic_on_timeout);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/nmi.c.ifdefed" startline="435" endline="438">
{
    __get_cpu_var (last_irq_sum) = sum;
    local_set (& __get_cpu_var (alert_counter), 0);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/nmi.c.ifdefed" startline="443" endline="455">
{
case NMI_LOCAL_APIC :
    rc |= lapic_wd_event (nmi_hz);
    break;
case NMI_IO_APIC :
    rc = 1;
    break;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/nmi.c.ifdefed" startline="514" endline="520">
{
    return 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/nmi.c.ifdefed" startline="523" endline="533">
{
    int i;
    backtrace_mask = cpu_online_map;
    for (i = 0; i < 10 * 1000; i++) {
        if (cpus_empty (backtrace_mask))
            break;
        mdelay (1);
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/nmi.c.ifdefed" startline="528" endline="532">
{
    if (cpus_empty (backtrace_mask))
        break;
    mdelay (1);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/early-quirks.c.ifdefed" startline="22" endline="45">
{
    u32 htcfg;
    htcfg = read_pci_config (num, slot, func, 0x68);
    if (htcfg & (1 << 18)) {
        printk (KERN_INFO "Detected use of extended apic ids " "on hypertransport bus\n");
        if ((htcfg & (1 << 17)) == 0) {
            printk (KERN_INFO "Enabling hypertransport extended " "apic interrupt broadcast\n");
            printk (KERN_INFO "Note this is a bios bug, " "please contact your hw vendor\n");
            htcfg |= (1 << 17);
            write_pci_config (num, slot, func, 0x68, htcfg);
        }
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/early-quirks.c.ifdefed" startline="31" endline="42">
{
    printk (KERN_INFO "Detected use of extended apic ids " "on hypertransport bus\n");
    if ((htcfg & (1 << 17)) == 0) {
        printk (KERN_INFO "Enabling hypertransport extended " "apic interrupt broadcast\n");
        printk (KERN_INFO "Note this is a bios bug, " "please contact your hw vendor\n");
        htcfg |= (1 << 17);
        write_pci_config (num, slot, func, 0x68, htcfg);
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/early-quirks.c.ifdefed" startline="34" endline="41">
{
    printk (KERN_INFO "Enabling hypertransport extended " "apic interrupt broadcast\n");
    printk (KERN_INFO "Note this is a bios bug, " "please contact your hw vendor\n");
    htcfg |= (1 << 17);
    write_pci_config (num, slot, func, 0x68, htcfg);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/early-quirks.c.ifdefed" startline="48" endline="58">
{
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/early-quirks.c.ifdefed" startline="71" endline="96">
{
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/early-quirks.c.ifdefed" startline="132" endline="168">
{
    u16 class;
    u16 vendor;
    u16 device;
    u8 type;
    int i;
    class = read_pci_config_16 (num, slot, func, PCI_CLASS_DEVICE);
    if (class == 0xffff)
        return -1;
    vendor = read_pci_config_16 (num, slot, func, PCI_VENDOR_ID);
    device = read_pci_config_16 (num, slot, func, PCI_DEVICE_ID);
    for (i = 0; early_qrk[i].f != NULL; i++) {
        if (((early_qrk[i].vendor == PCI_ANY_ID) || (early_qrk[i].vendor == vendor)) && ((early_qrk[i].device == PCI_ANY_ID) || (early_qrk[i].device == device)) && (!((early_qrk[i].class ^ class) & early_qrk[i].class_mask))) {
            if ((early_qrk[i].flags & QFLAG_DONE) != QFLAG_DONE)
                early_qrk[i].f (num, slot, func);
            early_qrk[i].flags |= QFLAG_APPLIED;
        }
    }
    type = read_pci_config_byte (num, slot, func, PCI_HEADER_TYPE);
    if (!(type & 0x80))
        return -1;
    return 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/early-quirks.c.ifdefed" startline="148" endline="160">
{
    if (((early_qrk[i].vendor == PCI_ANY_ID) || (early_qrk[i].vendor == vendor)) && ((early_qrk[i].device == PCI_ANY_ID) || (early_qrk[i].device == device)) && (!((early_qrk[i].class ^ class) & early_qrk[i].class_mask))) {
        if ((early_qrk[i].flags & QFLAG_DONE) != QFLAG_DONE)
            early_qrk[i].f (num, slot, func);
        early_qrk[i].flags |= QFLAG_APPLIED;
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/early-quirks.c.ifdefed" startline="154" endline="159">
{
    if ((early_qrk[i].flags & QFLAG_DONE) != QFLAG_DONE)
        early_qrk[i].f (num, slot, func);
    early_qrk[i].flags |= QFLAG_APPLIED;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/early-quirks.c.ifdefed" startline="171" endline="185">
{
    int num, slot, func;
    if (!early_pci_allowed ())
        return;
    for (num = 0; num < 32; num++)
        for (slot = 0; slot < 32; slot++)
            for (func = 0; func < 8; func++) {
                if (check_dev_quirk (num, slot, func))
                    break;
            }
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/early-quirks.c.ifdefed" startline="180" endline="184">
{
    if (check_dev_quirk (num, slot, func))
        break;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/bootflag.c.ifdefed" startline="24" endline="34">
{
    int x = 0;
    int i;
    for (i = 0; i < 8; i++) {
        x ^= (v & 1);
        v >>= 1;
    }
    return x;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/bootflag.c.ifdefed" startline="28" endline="31">
{
    x ^= (v & 1);
    v >>= 1;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/bootflag.c.ifdefed" startline="37" endline="52">
{
    unsigned long flags;
    if (sbf_port != -1) {
        v &= ~SBF_PARITY;
        if (!parity (v))
            v |= SBF_PARITY;
        printk (KERN_INFO "Simple Boot Flag at 0x%x set to 0x%x\n", sbf_port, v);
        spin_lock_irqsave (& rtc_lock, flags);
        CMOS_WRITE (v, sbf_port);
        spin_unlock_irqrestore (& rtc_lock, flags);
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/bootflag.c.ifdefed" startline="40" endline="51">
{
    v &= ~SBF_PARITY;
    if (!parity (v))
        v |= SBF_PARITY;
    printk (KERN_INFO "Simple Boot Flag at 0x%x set to 0x%x\n", sbf_port, v);
    spin_lock_irqsave (& rtc_lock, flags);
    CMOS_WRITE (v, sbf_port);
    spin_unlock_irqrestore (& rtc_lock, flags);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/bootflag.c.ifdefed" startline="55" endline="67">
{
    unsigned long flags;
    u8 v;
    if (sbf_port == -1)
        return 0;
    spin_lock_irqsave (& rtc_lock, flags);
    v = CMOS_READ (sbf_port);
    spin_unlock_irqrestore (& rtc_lock, flags);
    return v;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/bootflag.c.ifdefed" startline="70" endline="77">
{
    if (v & SBF_RESERVED)
        return 0;
    if (!parity (v))
        return 0;
    return 1;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/bootflag.c.ifdefed" startline="80" endline="101">
{
    u8 v;
    if (sbf_port == -1)
        return 0;
    v = sbf_read ();
    if (!sbf_value_valid (v)) {
        printk (KERN_WARNING "Simple Boot Flag value 0x%x read from " "CMOS RAM was invalid\n", v);
    }
    v &= ~SBF_RESERVED;
    v &= ~SBF_BOOTING;
    v &= ~SBF_DIAG;
    sbf_write (v);
    return 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/bootflag.c.ifdefed" startline="87" endline="90">
{
    printk (KERN_WARNING "Simple Boot Flag value 0x%x read from " "CMOS RAM was invalid\n", v);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/bios_uv.c.ifdefed" startline="25" endline="35">
{
    const char *str;
    switch (status) {
    case 0 :
        str = "Call completed without error";
        break;
    case -1 :
        str = "Not implemented";
        break;
    case -2 :
        str = "Invalid argument";
        break;
    case -3 :
        str = "Call completed with error";
        break;
    default :
        str = "Unknown BIOS status code";
        break;
    }
    return str;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/bios_uv.c.ifdefed" startline="27" endline="33">
{
case 0 :
    str = "Call completed without error";
    break;
case -1 :
    str = "Not implemented";
    break;
case -2 :
    str = "Invalid argument";
    break;
case -3 :
    str = "Call completed with error";
    break;
default :
    str = "Unknown BIOS status code";
    break;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/bios_uv.c.ifdefed" startline="40" endline="47">
{
    struct uv_bios_retval isrv;
    BIOS_CALL (isrv, BIOS_FREQ_BASE, which, 0, 0, 0, 0, 0, 0);
    *ticks_per_second = isrv.v0;
    *drift_info = isrv.v1;
    return isrv.status;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/aperture_64.c.ifdefed" startline="57" endline="61">
{
    gart_resource.start = aper_base;
    gart_resource.end = aper_base + aper_size - 1;
    insert_resource (& iomem_resource, & gart_resource);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/aperture_64.c.ifdefed" startline="67" endline="111">
{
    u32 aper_size;
    void *p;
    if (fallback_aper_order > 5)
        fallback_aper_order = 5;
    aper_size = (32 * 1024 * 1024) << fallback_aper_order;
    p = __alloc_bootmem_nopanic (aper_size, aper_size, 512ULL << 20);
    if (!p || __pa (p) + aper_size > 0xffffffff) {
        printk (KERN_ERR "Cannot allocate aperture memory hole (%p,%uK)\n", p, aper_size >> 10);
        if (p)
            free_bootmem (__pa (p), aper_size);
        return 0;
    }
    printk (KERN_INFO "Mapping aperture over %d KB of RAM @ %lx\n", aper_size >> 10, __pa (p));
    insert_aperture_resource ((u32) __pa (p), aper_size);
    register_nosave_region ((u32) __pa (p) >> PAGE_SHIFT, (u32) __pa (p + aper_size) >> PAGE_SHIFT);
    return (u32) __pa (p);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/aperture_64.c.ifdefed" startline="96" endline="103">
{
    printk (KERN_ERR "Cannot allocate aperture memory hole (%p,%uK)\n", p, aper_size >> 10);
    if (p)
        free_bootmem (__pa (p), aper_size);
    return 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/aperture_64.c.ifdefed" startline="116" endline="138">
{
    int bytes;
    u8 pos;
    if (!(read_pci_config_16 (bus, slot, func, PCI_STATUS) & PCI_STATUS_CAP_LIST))
        return 0;
    pos = read_pci_config_byte (bus, slot, func, PCI_CAPABILITY_LIST);
    for (bytes = 0; bytes < 48 && pos >= 0x40; bytes++) {
        u8 id;
        pos &= ~3;
        id = read_pci_config_byte (bus, slot, func, pos +PCI_CAP_LIST_ID);
        if (id == 0xff)
            break;
        if (id == cap)
            return pos;
        pos = read_pci_config_byte (bus, slot, func, pos +PCI_CAP_LIST_NEXT);
    }
    return 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/aperture_64.c.ifdefed" startline="125" endline="136">
{
    u8 id;
    pos &= ~3;
    id = read_pci_config_byte (bus, slot, func, pos +PCI_CAP_LIST_ID);
    if (id == 0xff)
        break;
    if (id == cap)
        return pos;
    pos = read_pci_config_byte (bus, slot, func, pos +PCI_CAP_LIST_NEXT);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/aperture_64.c.ifdefed" startline="142" endline="191">
{
    u32 apsize;
    u32 apsizereg;
    int nbits;
    u32 aper_low, aper_hi;
    u64 aper;
    u32 old_order;
    printk (KERN_INFO "AGP bridge at %02x:%02x:%02x\n", bus, slot, func);
    apsizereg = read_pci_config_16 (bus, slot, func, cap +0x14);
    if (apsizereg == 0xffffffff) {
        printk (KERN_ERR "APSIZE in AGP bridge unreadable\n");
        return 0;
    }
    old_order = *order;
    apsize = apsizereg & 0xfff;
    if (apsize & 0xff)
        apsize |= 0xf00;
    nbits = hweight16 (apsize);
    *order = 7 - nbits;
    if ((int) *order < 0)
        *order = 0;
    aper_low = read_pci_config (bus, slot, func, 0x10);
    aper_hi = read_pci_config (bus, slot, func, 0x14);
    aper = (aper_low & ~((1 << 22) - 1)) | ((u64) aper_hi << 32);
    printk (KERN_INFO "Aperture from AGP @ %Lx old size %u MB\n", aper, 32 << old_order);
    if (aper + (32ULL << (20 + *order)) > 0x100000000ULL) {
        printk (KERN_INFO "Aperture size %u MB (APSIZE %x) is not right, using settings from NB\n", 32 << * order, apsizereg);
        *order = old_order;
    }
    printk (KERN_INFO "Aperture from AGP @ %Lx size %u MB (APSIZE %x)\n", aper, 32 << * order, apsizereg);
    if (!aperture_valid (aper, (32 * 1024 * 1024) << *order, 32 << 20))
        return 0;
    return (u32) aper;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/aperture_64.c.ifdefed" startline="152" endline="155">
{
    printk (KERN_ERR "APSIZE in AGP bridge unreadable\n");
    return 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/aperture_64.c.ifdefed" startline="179" endline="183">
{
    printk (KERN_INFO "Aperture size %u MB (APSIZE %x) is not right, using settings from NB\n", 32 << * order, apsizereg);
    *order = old_order;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/aperture_64.c.ifdefed" startline="207" endline="245">
{
    int bus, slot, func;
    for (bus = 0; bus < 256; bus++) {
        for (slot = 0; slot < 32; slot++) {
            for (func = 0; func < 8; func++) {
                u32 class, cap;
                u8 type;
                class = read_pci_config (bus, slot, func, PCI_CLASS_REVISION);
                if (class == 0xffffffff)
                    break;
                switch (class >> 16) {
                case PCI_CLASS_BRIDGE_HOST :
                case PCI_CLASS_BRIDGE_OTHER :
                    cap = find_cap (bus, slot, func, PCI_CAP_ID_AGP);
                    if (!cap)
                        break;
                    *valid_agp = 1;
                    return read_agp (bus, slot, func, cap, order);
                }
                type = read_pci_config_byte (bus, slot, func, PCI_HEADER_TYPE);
                if (!(type & 0x80))
                    break;
            }
        }
    }
    printk (KERN_INFO "No AGP bridge found\n");
    return 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/aperture_64.c.ifdefed" startline="211" endline="241">
{
    for (slot = 0; slot < 32; slot++) {
        for (func = 0; func < 8; func++) {
            u32 class, cap;
            u8 type;
            class = read_pci_config (bus, slot, func, PCI_CLASS_REVISION);
            if (class == 0xffffffff)
                break;
            switch (class >> 16) {
            case PCI_CLASS_BRIDGE_HOST :
            case PCI_CLASS_BRIDGE_OTHER :
                cap = find_cap (bus, slot, func, PCI_CAP_ID_AGP);
                if (!cap)
                    break;
                *valid_agp = 1;
                return read_agp (bus, slot, func, cap, order);
            }
            type = read_pci_config_byte (bus, slot, func, PCI_HEADER_TYPE);
            if (!(type & 0x80))
                break;
        }
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/aperture_64.c.ifdefed" startline="212" endline="240">
{
    for (func = 0; func < 8; func++) {
        u32 class, cap;
        u8 type;
        class = read_pci_config (bus, slot, func, PCI_CLASS_REVISION);
        if (class == 0xffffffff)
            break;
        switch (class >> 16) {
        case PCI_CLASS_BRIDGE_HOST :
        case PCI_CLASS_BRIDGE_OTHER :
            cap = find_cap (bus, slot, func, PCI_CAP_ID_AGP);
            if (!cap)
                break;
            *valid_agp = 1;
            return read_agp (bus, slot, func, cap, order);
        }
        type = read_pci_config_byte (bus, slot, func, PCI_HEADER_TYPE);
        if (!(type & 0x80))
            break;
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/aperture_64.c.ifdefed" startline="213" endline="239">
{
    u32 class, cap;
    u8 type;
    class = read_pci_config (bus, slot, func, PCI_CLASS_REVISION);
    if (class == 0xffffffff)
        break;
    switch (class >> 16) {
    case PCI_CLASS_BRIDGE_HOST :
    case PCI_CLASS_BRIDGE_OTHER :
        cap = find_cap (bus, slot, func, PCI_CAP_ID_AGP);
        if (!cap)
            break;
        *valid_agp = 1;
        return read_agp (bus, slot, func, cap, order);
    }
    type = read_pci_config_byte (bus, slot, func, PCI_HEADER_TYPE);
    if (!(type & 0x80))
        break;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/aperture_64.c.ifdefed" startline="221" endline="232">
{
case PCI_CLASS_BRIDGE_HOST :
case PCI_CLASS_BRIDGE_OTHER :
    cap = find_cap (bus, slot, func, PCI_CAP_ID_AGP);
    if (!cap)
        break;
    *valid_agp = 1;
    return read_agp (bus, slot, func, cap, order);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/aperture_64.c.ifdefed" startline="250" endline="260">
{
    if (!p)
        return -EINVAL;
    if (!strncmp (p, "off", 3))
        gart_fix_e820 = 0;
    else if (!strncmp (p, "on", 2))
        gart_fix_e820 = 1;
    return 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/aperture_64.c.ifdefed" startline="264" endline="359">
{
    int i, fix, slot;
    u32 ctl;
    u32 aper_size = 0, aper_order = 0, last_aper_order = 0;
    u64 aper_base = 0, last_aper_base = 0;
    int aper_enabled = 0, last_aper_enabled = 0, last_valid = 0;
    if (!early_pci_allowed ())
        return;
    fix = 0;
    for (i = 0; i < ARRAY_SIZE (bus_dev_ranges); i++) {
        int bus;
        int dev_base, dev_limit;
        bus = bus_dev_ranges[i].bus;
        dev_base = bus_dev_ranges[i].dev_base;
        dev_limit = bus_dev_ranges[i].dev_limit;
        for (slot = dev_base; slot < dev_limit; slot++) {
            if (!early_is_k8_nb (read_pci_config (bus, slot, 3, 0x00)))
                continue;
            ctl = read_pci_config (bus, slot, 3, AMD64_GARTAPERTURECTL);
            aper_enabled = ctl & AMD64_GARTEN;
            aper_order = (ctl >> 1) & 7;
            aper_size = (32 * 1024 * 1024) << aper_order;
            aper_base = read_pci_config (bus, slot, 3, AMD64_GARTAPERTUREBASE) & 0x7fff;
            aper_base <<= 25;
            if (last_valid) {
                if ((aper_order != last_aper_order) || (aper_base != last_aper_base) || (aper_enabled != last_aper_enabled)) {
                    fix = 1;
                    break;
                }
            }
            last_aper_order = aper_order;
            last_aper_base = aper_base;
            last_aper_enabled = aper_enabled;
            last_valid = 1;
        }
    }
    if (!fix && !aper_enabled)
        return;
    if (!aper_base || !aper_size || aper_base + aper_size > 0x100000000UL)
        fix = 1;
    if (gart_fix_e820 && !fix && aper_enabled) {
        if (e820_any_mapped (aper_base, aper_base +aper_size, E820_RAM)) {
            printk (KERN_INFO "update e820 for GART\n");
            e820_add_region (aper_base, aper_size, E820_RESERVED);
            update_e820 ();
        }
    }
    if (!fix)
        return;
    for (i = 0; i < ARRAY_SIZE (bus_dev_ranges); i++) {
        int bus;
        int dev_base, dev_limit;
        bus = bus_dev_ranges[i].bus;
        dev_base = bus_dev_ranges[i].dev_base;
        dev_limit = bus_dev_ranges[i].dev_limit;
        for (slot = dev_base; slot < dev_limit; slot++) {
            if (!early_is_k8_nb (read_pci_config (bus, slot, 3, 0x00)))
                continue;
            ctl = read_pci_config (bus, slot, 3, AMD64_GARTAPERTURECTL);
            ctl &= ~AMD64_GARTEN;
            write_pci_config (bus, slot, 3, AMD64_GARTAPERTURECTL, ctl);
        }
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/aperture_64.c.ifdefed" startline="286" endline="319">
{
    int bus;
    int dev_base, dev_limit;
    bus = bus_dev_ranges[i].bus;
    dev_base = bus_dev_ranges[i].dev_base;
    dev_limit = bus_dev_ranges[i].dev_limit;
    for (slot = dev_base; slot < dev_limit; slot++) {
        if (!early_is_k8_nb (read_pci_config (bus, slot, 3, 0x00)))
            continue;
        ctl = read_pci_config (bus, slot, 3, AMD64_GARTAPERTURECTL);
        aper_enabled = ctl & AMD64_GARTEN;
        aper_order = (ctl >> 1) & 7;
        aper_size = (32 * 1024 * 1024) << aper_order;
        aper_base = read_pci_config (bus, slot, 3, AMD64_GARTAPERTUREBASE) & 0x7fff;
        aper_base <<= 25;
        if (last_valid) {
            if ((aper_order != last_aper_order) || (aper_base != last_aper_base) || (aper_enabled != last_aper_enabled)) {
                fix = 1;
                break;
            }
        }
        last_aper_order = aper_order;
        last_aper_base = aper_base;
        last_aper_enabled = aper_enabled;
        last_valid = 1;
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/aperture_64.c.ifdefed" startline="294" endline="318">
{
    if (!early_is_k8_nb (read_pci_config (bus, slot, 3, 0x00)))
        continue;
    ctl = read_pci_config (bus, slot, 3, AMD64_GARTAPERTURECTL);
    aper_enabled = ctl & AMD64_GARTEN;
    aper_order = (ctl >> 1) & 7;
    aper_size = (32 * 1024 * 1024) << aper_order;
    aper_base = read_pci_config (bus, slot, 3, AMD64_GARTAPERTUREBASE) & 0x7fff;
    aper_base <<= 25;
    if (last_valid) {
        if ((aper_order != last_aper_order) || (aper_base != last_aper_base) || (aper_enabled != last_aper_enabled)) {
            fix = 1;
            break;
        }
    }
    last_aper_order = aper_order;
    last_aper_base = aper_base;
    last_aper_enabled = aper_enabled;
    last_valid = 1;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/aperture_64.c.ifdefed" startline="305" endline="312">
{
    if ((aper_order != last_aper_order) || (aper_base != last_aper_base) || (aper_enabled != last_aper_enabled)) {
        fix = 1;
        break;
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/aperture_64.c.ifdefed" startline="308" endline="311">
{
    fix = 1;
    break;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/aperture_64.c.ifdefed" startline="327" endline="335">
{
    if (e820_any_mapped (aper_base, aper_base +aper_size, E820_RAM)) {
        printk (KERN_INFO "update e820 for GART\n");
        e820_add_region (aper_base, aper_size, E820_RESERVED);
        update_e820 ();
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/aperture_64.c.ifdefed" startline="329" endline="334">
{
    printk (KERN_INFO "update e820 for GART\n");
    e820_add_region (aper_base, aper_size, E820_RESERVED);
    update_e820 ();
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/aperture_64.c.ifdefed" startline="341" endline="357">
{
    int bus;
    int dev_base, dev_limit;
    bus = bus_dev_ranges[i].bus;
    dev_base = bus_dev_ranges[i].dev_base;
    dev_limit = bus_dev_ranges[i].dev_limit;
    for (slot = dev_base; slot < dev_limit; slot++) {
        if (!early_is_k8_nb (read_pci_config (bus, slot, 3, 0x00)))
            continue;
        ctl = read_pci_config (bus, slot, 3, AMD64_GARTAPERTURECTL);
        ctl &= ~AMD64_GARTEN;
        write_pci_config (bus, slot, 3, AMD64_GARTAPERTURECTL, ctl);
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/aperture_64.c.ifdefed" startline="349" endline="356">
{
    if (!early_is_k8_nb (read_pci_config (bus, slot, 3, 0x00)))
        continue;
    ctl = read_pci_config (bus, slot, 3, AMD64_GARTAPERTURECTL);
    ctl &= ~AMD64_GARTEN;
    write_pci_config (bus, slot, 3, AMD64_GARTAPERTURECTL, ctl);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/aperture_64.c.ifdefed" startline="364" endline="504">
{
    u32 agp_aper_base = 0, agp_aper_order = 0;
    u32 aper_size, aper_alloc = 0, aper_order = 0, last_aper_order = 0;
    u64 aper_base, last_aper_base = 0;
    int fix, slot, valid_agp = 0;
    int i, node;
    if (gart_iommu_aperture_disabled || !fix_aperture || !early_pci_allowed ())
        return;
    printk (KERN_INFO "Checking aperture...\n");
    if (!fallback_aper_force)
        agp_aper_base = search_agp_bridge (&agp_aper_order, &valid_agp);
    fix = 0;
    node = 0;
    for (i = 0; i < ARRAY_SIZE (bus_dev_ranges); i++) {
        int bus;
        int dev_base, dev_limit;
        bus = bus_dev_ranges[i].bus;
        dev_base = bus_dev_ranges[i].dev_base;
        dev_limit = bus_dev_ranges[i].dev_limit;
        for (slot = dev_base; slot < dev_limit; slot++) {
            if (!early_is_k8_nb (read_pci_config (bus, slot, 3, 0x00)))
                continue;
            iommu_detected = 1;
            gart_iommu_aperture = 1;
            aper_order = (read_pci_config (bus, slot, 3, AMD64_GARTAPERTURECTL) >> 1) & 7;
            aper_size = (32 * 1024 * 1024) << aper_order;
            aper_base = read_pci_config (bus, slot, 3, AMD64_GARTAPERTUREBASE) & 0x7fff;
            aper_base <<= 25;
            printk (KERN_INFO "Node %d: aperture @ %Lx size %u MB\n", node, aper_base, aper_size >> 20);
            node++;
            if (!aperture_valid (aper_base, aper_size, 64 << 20)) {
                if (valid_agp && agp_aper_base && agp_aper_base == aper_base && agp_aper_order == aper_order) {
                    if (!no_iommu && max_pfn > MAX_DMA32_PFN && !printed_gart_size_msg) {
                        printk (KERN_ERR "you are using iommu with agp, but GART size is less than 64M\n");
                        printk (KERN_ERR "please increase GART size in your BIOS setup\n");
                        printk (KERN_ERR "if BIOS doesn't have that option, contact your HW vendor!\n");
                        printed_gart_size_msg = 1;
                    }
                }
                else {
                    fix = 1;
                    goto out;
                }
            }
            if ((last_aper_order && aper_order != last_aper_order) || (last_aper_base && aper_base != last_aper_base)) {
                fix = 1;
                goto out;
            }
            last_aper_order = aper_order;
            last_aper_base = aper_base;
        }
    }
out :
    if (!fix && !fallback_aper_force) {
        if (last_aper_base) {
            unsigned long n = (32 * 1024 * 1024) << last_aper_order;
            insert_aperture_resource ((u32) last_aper_base, n);
        }
        return;
    }
    if (!fallback_aper_force) {
        aper_alloc = agp_aper_base;
        aper_order = agp_aper_order;
    }
    if (aper_alloc) {
    }
    else if (swiotlb && !valid_agp) {
    }
    else if ((!no_iommu && max_pfn > MAX_DMA32_PFN) || force_iommu || valid_agp || fallback_aper_force) {
        printk (KERN_ERR "Your BIOS doesn't leave a aperture memory hole\n");
        printk (KERN_ERR "Please enable the IOMMU option in the BIOS setup\n");
        printk (KERN_ERR "This costs you %d MB of RAM\n", 32 << fallback_aper_order);
        aper_order = fallback_aper_order;
        aper_alloc = allocate_aperture ();
        if (!aper_alloc) {
            panic ("Not enough memory for aperture");
        }
    }
    else {
        return;
    }
    for (i = 0; i < ARRAY_SIZE (bus_dev_ranges); i++) {
        int bus;
        int dev_base, dev_limit;
        bus = bus_dev_ranges[i].bus;
        dev_base = bus_dev_ranges[i].dev_base;
        dev_limit = bus_dev_ranges[i].dev_limit;
        for (slot = dev_base; slot < dev_limit; slot++) {
            if (!early_is_k8_nb (read_pci_config (bus, slot, 3, 0x00)))
                continue;
            write_pci_config (bus, slot, 3, AMD64_GARTAPERTURECTL, aper_order << 1);
            write_pci_config (bus, slot, 3, AMD64_GARTAPERTUREBASE, aper_alloc >> 25);
        }
    }
    set_up_gart_resume (aper_order, aper_alloc);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/aperture_64.c.ifdefed" startline="382" endline="433">
{
    int bus;
    int dev_base, dev_limit;
    bus = bus_dev_ranges[i].bus;
    dev_base = bus_dev_ranges[i].dev_base;
    dev_limit = bus_dev_ranges[i].dev_limit;
    for (slot = dev_base; slot < dev_limit; slot++) {
        if (!early_is_k8_nb (read_pci_config (bus, slot, 3, 0x00)))
            continue;
        iommu_detected = 1;
        gart_iommu_aperture = 1;
        aper_order = (read_pci_config (bus, slot, 3, AMD64_GARTAPERTURECTL) >> 1) & 7;
        aper_size = (32 * 1024 * 1024) << aper_order;
        aper_base = read_pci_config (bus, slot, 3, AMD64_GARTAPERTUREBASE) & 0x7fff;
        aper_base <<= 25;
        printk (KERN_INFO "Node %d: aperture @ %Lx size %u MB\n", node, aper_base, aper_size >> 20);
        node++;
        if (!aperture_valid (aper_base, aper_size, 64 << 20)) {
            if (valid_agp && agp_aper_base && agp_aper_base == aper_base && agp_aper_order == aper_order) {
                if (!no_iommu && max_pfn > MAX_DMA32_PFN && !printed_gart_size_msg) {
                    printk (KERN_ERR "you are using iommu with agp, but GART size is less than 64M\n");
                    printk (KERN_ERR "please increase GART size in your BIOS setup\n");
                    printk (KERN_ERR "if BIOS doesn't have that option, contact your HW vendor!\n");
                    printed_gart_size_msg = 1;
                }
            }
            else {
                fix = 1;
                goto out;
            }
        }
        if ((last_aper_order && aper_order != last_aper_order) || (last_aper_base && aper_base != last_aper_base)) {
            fix = 1;
            goto out;
        }
        last_aper_order = aper_order;
        last_aper_base = aper_base;
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/aperture_64.c.ifdefed" startline="390" endline="432">
{
    if (!early_is_k8_nb (read_pci_config (bus, slot, 3, 0x00)))
        continue;
    iommu_detected = 1;
    gart_iommu_aperture = 1;
    aper_order = (read_pci_config (bus, slot, 3, AMD64_GARTAPERTURECTL) >> 1) & 7;
    aper_size = (32 * 1024 * 1024) << aper_order;
    aper_base = read_pci_config (bus, slot, 3, AMD64_GARTAPERTUREBASE) & 0x7fff;
    aper_base <<= 25;
    printk (KERN_INFO "Node %d: aperture @ %Lx size %u MB\n", node, aper_base, aper_size >> 20);
    node++;
    if (!aperture_valid (aper_base, aper_size, 64 << 20)) {
        if (valid_agp && agp_aper_base && agp_aper_base == aper_base && agp_aper_order == aper_order) {
            if (!no_iommu && max_pfn > MAX_DMA32_PFN && !printed_gart_size_msg) {
                printk (KERN_ERR "you are using iommu with agp, but GART size is less than 64M\n");
                printk (KERN_ERR "please increase GART size in your BIOS setup\n");
                printk (KERN_ERR "if BIOS doesn't have that option, contact your HW vendor!\n");
                printed_gart_size_msg = 1;
            }
        }
        else {
            fix = 1;
            goto out;
        }
    }
    if ((last_aper_order && aper_order != last_aper_order) || (last_aper_base && aper_base != last_aper_base)) {
        fix = 1;
        goto out;
    }
    last_aper_order = aper_order;
    last_aper_base = aper_base;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/aperture_64.c.ifdefed" startline="406" endline="423">
{
    if (valid_agp && agp_aper_base && agp_aper_base == aper_base && agp_aper_order == aper_order) {
        if (!no_iommu && max_pfn > MAX_DMA32_PFN && !printed_gart_size_msg) {
            printk (KERN_ERR "you are using iommu with agp, but GART size is less than 64M\n");
            printk (KERN_ERR "please increase GART size in your BIOS setup\n");
            printk (KERN_ERR "if BIOS doesn't have that option, contact your HW vendor!\n");
            printed_gart_size_msg = 1;
        }
    }
    else {
        fix = 1;
        goto out;
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/aperture_64.c.ifdefed" startline="409" endline="419">
{
    if (!no_iommu && max_pfn > MAX_DMA32_PFN && !printed_gart_size_msg) {
        printk (KERN_ERR "you are using iommu with agp, but GART size is less than 64M\n");
        printk (KERN_ERR "please increase GART size in your BIOS setup\n");
        printk (KERN_ERR "if BIOS doesn't have that option, contact your HW vendor!\n");
        printed_gart_size_msg = 1;
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/aperture_64.c.ifdefed" startline="413" endline="418">
{
    printk (KERN_ERR "you are using iommu with agp, but GART size is less than 64M\n");
    printk (KERN_ERR "please increase GART size in your BIOS setup\n");
    printk (KERN_ERR "if BIOS doesn't have that option, contact your HW vendor!\n");
    printed_gart_size_msg = 1;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/aperture_64.c.ifdefed" startline="419" endline="422">
{
    fix = 1;
    goto out;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/aperture_64.c.ifdefed" startline="426" endline="429">
{
    fix = 1;
    goto out;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/aperture_64.c.ifdefed" startline="436" endline="443">
{
    if (last_aper_base) {
        unsigned long n = (32 * 1024 * 1024) << last_aper_order;
        insert_aperture_resource ((u32) last_aper_base, n);
    }
    return;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/aperture_64.c.ifdefed" startline="437" endline="441">
{
    unsigned long n = (32 * 1024 * 1024) << last_aper_order;
    insert_aperture_resource ((u32) last_aper_base, n);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/aperture_64.c.ifdefed" startline="445" endline="448">
{
    aper_alloc = agp_aper_base;
    aper_order = agp_aper_order;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/aperture_64.c.ifdefed" startline="450" endline="452">
{
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/aperture_64.c.ifdefed" startline="452" endline="454">
{
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/aperture_64.c.ifdefed" startline="457" endline="479">
{
    printk (KERN_ERR "Your BIOS doesn't leave a aperture memory hole\n");
    printk (KERN_ERR "Please enable the IOMMU option in the BIOS setup\n");
    printk (KERN_ERR "This costs you %d MB of RAM\n", 32 << fallback_aper_order);
    aper_order = fallback_aper_order;
    aper_alloc = allocate_aperture ();
    if (!aper_alloc) {
        panic ("Not enough memory for aperture");
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/aperture_64.c.ifdefed" startline="468" endline="478">
{
    panic ("Not enough memory for aperture");
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/aperture_64.c.ifdefed" startline="479" endline="481">
{
    return;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/aperture_64.c.ifdefed" startline="484" endline="501">
{
    int bus;
    int dev_base, dev_limit;
    bus = bus_dev_ranges[i].bus;
    dev_base = bus_dev_ranges[i].dev_base;
    dev_limit = bus_dev_ranges[i].dev_limit;
    for (slot = dev_base; slot < dev_limit; slot++) {
        if (!early_is_k8_nb (read_pci_config (bus, slot, 3, 0x00)))
            continue;
        write_pci_config (bus, slot, 3, AMD64_GARTAPERTURECTL, aper_order << 1);
        write_pci_config (bus, slot, 3, AMD64_GARTAPERTUREBASE, aper_alloc >> 25);
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/aperture_64.c.ifdefed" startline="491" endline="500">
{
    if (!early_is_k8_nb (read_pci_config (bus, slot, 3, 0x00)))
        continue;
    write_pci_config (bus, slot, 3, AMD64_GARTAPERTURECTL, aper_order << 1);
    write_pci_config (bus, slot, 3, AMD64_GARTAPERTUREBASE, aper_alloc >> 25);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/tlb_64.c.ifdefed" startline="64" endline="69">
{
    if (read_pda (mmu_state) == TLBSTATE_OK)
        BUG ();
    cpu_clear (cpu, read_pda (active_mm) -> cpu_vm_mask);
    load_cr3 (swapper_pg_dir);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/tlb_64.c.ifdefed" startline="121" endline="158">
{
    int cpu;
    int sender;
    union smp_flush_state *f;
    cpu = smp_processor_id ();
    sender = ~regs->orig_ax - INVALIDATE_TLB_VECTOR_START;
    f = &per_cpu (flush_state, sender);
    if (!cpu_isset (cpu, f->flush_cpumask))
        goto out;
    if (f->flush_mm == read_pda (active_mm)) {
        if (read_pda (mmu_state) == TLBSTATE_OK) {
            if (f->flush_va == TLB_FLUSH_ALL)
                local_flush_tlb ();
            else
                __flush_tlb_one (f->flush_va);
        }
        else
            leave_mm (cpu);
    }
out :
    ack_APIC_irq ();
    cpu_clear (cpu, f -> flush_cpumask);
    add_pda (irq_tlb_count, 1);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/tlb_64.c.ifdefed" startline="145" endline="153">
{
    if (read_pda (mmu_state) == TLBSTATE_OK) {
        if (f->flush_va == TLB_FLUSH_ALL)
            local_flush_tlb ();
        else
            __flush_tlb_one (f->flush_va);
    }
    else
        leave_mm (cpu);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/tlb_64.c.ifdefed" startline="146" endline="151">
{
    if (f->flush_va == TLB_FLUSH_ALL)
        local_flush_tlb ();
    else
        __flush_tlb_one (f->flush_va);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/tlb_64.c.ifdefed" startline="162" endline="197">
{
    int sender;
    union smp_flush_state *f;
    cpumask_t cpumask = *cpumaskp;
    if (is_uv_system () && uv_flush_tlb_others (&cpumask, mm, va))
        return;
    sender = smp_processor_id () % NUM_INVALIDATE_TLB_VECTORS;
    f = &per_cpu (flush_state, sender);
    spin_lock (& f -> tlbstate_lock);
    f->flush_mm = mm;
    f->flush_va = va;
    cpus_or (f -> flush_cpumask, cpumask, f -> flush_cpumask);
    send_IPI_mask (cpumask, INVALIDATE_TLB_VECTOR_START + sender);
    while (!cpus_empty (f->flush_cpumask))
        cpu_relax ();
    f->flush_mm = NULL;
    f->flush_va = 0;
    spin_unlock (& f -> tlbstate_lock);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/tlb_64.c.ifdefed" startline="200" endline="207">
{
    int i;
    for_each_possible_cpu (i)
    spin_lock_init (& per_cpu (flush_state, i).tlbstate_lock);
    return 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/tlb_64.c.ifdefed" startline="211" endline="223">
{
    struct mm_struct *mm = current->mm;
    cpumask_t cpu_mask;
    preempt_disable ();
    cpu_mask = mm->cpu_vm_mask;
    cpu_clear (smp_processor_id (), cpu_mask);
    local_flush_tlb ();
    if (!cpus_empty (cpu_mask))
        flush_tlb_others (cpu_mask, mm, TLB_FLUSH_ALL);
    preempt_enable ();
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/tlb_64.c.ifdefed" startline="226" endline="243">
{
    cpumask_t cpu_mask;
    preempt_disable ();
    cpu_mask = mm->cpu_vm_mask;
    cpu_clear (smp_processor_id (), cpu_mask);
    if (current->active_mm == mm) {
        if (current->mm)
            local_flush_tlb ();
        else
            leave_mm (smp_processor_id ());
    }
    if (!cpus_empty (cpu_mask))
        flush_tlb_others (cpu_mask, mm, TLB_FLUSH_ALL);
    preempt_enable ();
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/tlb_64.c.ifdefed" startline="233" endline="238">
{
    if (current->mm)
        local_flush_tlb ();
    else
        leave_mm (smp_processor_id ());
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/tlb_64.c.ifdefed" startline="246" endline="265">
{
    struct mm_struct *mm = vma->vm_mm;
    cpumask_t cpu_mask;
    preempt_disable ();
    cpu_mask = mm->cpu_vm_mask;
    cpu_clear (smp_processor_id (), cpu_mask);
    if (current->active_mm == mm) {
        if (current->mm)
            __flush_tlb_one (va);
        else
            leave_mm (smp_processor_id ());
    }
    if (!cpus_empty (cpu_mask))
        flush_tlb_others (cpu_mask, mm, va);
    preempt_enable ();
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/tlb_64.c.ifdefed" startline="254" endline="259">
{
    if (current->mm)
        __flush_tlb_one (va);
    else
        leave_mm (smp_processor_id ());
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/tlb_64.c.ifdefed" startline="268" endline="274">
{
    unsigned long cpu = smp_processor_id ();
    __flush_tlb_all ();
    if (read_pda (mmu_state) == TLBSTATE_LAZY)
        leave_mm (cpu);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/tlb_64.c.ifdefed" startline="277" endline="279">
{
    on_each_cpu (do_flush_tlb_all, NULL, 1);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/crash_dump_64.c.ifdefed" startline="29" endline="47">
{
    void *vaddr;
    if (!csize)
        return 0;
    vaddr = ioremap (pfn << PAGE_SHIFT, PAGE_SIZE);
    if (userbuf) {
        if (copy_to_user (buf, (vaddr + offset), csize)) {
            iounmap (vaddr);
            return -EFAULT;
        }
    }
    else
        memcpy (buf, (vaddr + offset), csize);
    iounmap (vaddr);
    return csize;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/crash_dump_64.c.ifdefed" startline="37" endline="42">
{
    if (copy_to_user (buf, (vaddr + offset), csize)) {
        iounmap (vaddr);
        return -EFAULT;
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/crash_dump_64.c.ifdefed" startline="38" endline="41">
{
    iounmap (vaddr);
    return -EFAULT;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/vsyscall_64.c.ifdefed" startline="64" endline="71">
{
    unsigned long flags;
    write_seqlock_irqsave (& vsyscall_gtod_data.lock, flags);
    vsyscall_gtod_data.sys_tz = sys_tz;
    write_sequnlock_irqrestore (& vsyscall_gtod_data.lock, flags);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/vsyscall_64.c.ifdefed" startline="74" endline="88">
{
    unsigned long flags;
    write_seqlock_irqsave (& vsyscall_gtod_data.lock, flags);
    vsyscall_gtod_data.clock.vread = clock->vread;
    vsyscall_gtod_data.clock.cycle_last = clock->cycle_last;
    vsyscall_gtod_data.clock.mask = clock->mask;
    vsyscall_gtod_data.clock.mult = clock->mult;
    vsyscall_gtod_data.clock.shift = clock->shift;
    vsyscall_gtod_data.wall_time_sec = wall_time->tv_sec;
    vsyscall_gtod_data.wall_time_nsec = wall_time->tv_nsec;
    vsyscall_gtod_data.wall_to_monotonic = wall_to_monotonic;
    write_sequnlock_irqrestore (& vsyscall_gtod_data.lock, flags);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/vsyscall_64.c.ifdefed" startline="94" endline="96">
{
    *tz = __vsyscall_gtod_data.sys_tz;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/vsyscall_64.c.ifdefed" startline="99" endline="106">
{
    int ret;
    asm volatile ("syscall"
        : "=a" (ret)
        : "0" (__NR_gettimeofday), "D" (tv), "S" (tz)
        : __syscall_clobber
    ) return ret;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/vsyscall_64.c.ifdefed" startline="109" endline="115">
{
    long secs;
    asm volatile ("syscall"
        : "=a" (secs)
        : "0" (__NR_time), "D" (t)
        : __syscall_clobber
    ) return secs;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/vsyscall_64.c.ifdefed" startline="118" endline="151">
{
    cycle_t now, base, mask, cycle_delta;
    unsigned seq;
    unsigned long mult, shift, nsec;
    cycle_t (*vread) (void);
    do {
        seq = read_seqbegin (&__vsyscall_gtod_data.lock);
        vread = __vsyscall_gtod_data.clock.vread;
        if (unlikely (!__vsyscall_gtod_data.sysctl_enabled || !vread)) {
            gettimeofday (tv, NULL);
            return;
        }
        now = vread ();
        base = __vsyscall_gtod_data.clock.cycle_last;
        mask = __vsyscall_gtod_data.clock.mask;
        mult = __vsyscall_gtod_data.clock.mult;
        shift = __vsyscall_gtod_data.clock.shift;
        tv->tv_sec = __vsyscall_gtod_data.wall_time_sec;
        nsec = __vsyscall_gtod_data.wall_time_nsec;
    }
    while (read_seqretry (&__vsyscall_gtod_data.lock, seq));
    cycle_delta = (now - base) & mask;
    nsec += (cycle_delta * mult) >> shift;
    while (nsec >= NSEC_PER_SEC) {
        tv->tv_sec += 1;
        nsec -= NSEC_PER_SEC;
    }
    tv->tv_usec = nsec / NSEC_PER_USEC;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/vsyscall_64.c.ifdefed" startline="123" endline="139">
{
    seq = read_seqbegin (&__vsyscall_gtod_data.lock);
    vread = __vsyscall_gtod_data.clock.vread;
    if (unlikely (!__vsyscall_gtod_data.sysctl_enabled || !vread)) {
        gettimeofday (tv, NULL);
        return;
    }
    now = vread ();
    base = __vsyscall_gtod_data.clock.cycle_last;
    mask = __vsyscall_gtod_data.clock.mask;
    mult = __vsyscall_gtod_data.clock.mult;
    shift = __vsyscall_gtod_data.clock.shift;
    tv->tv_sec = __vsyscall_gtod_data.wall_time_sec;
    nsec = __vsyscall_gtod_data.wall_time_nsec;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/vsyscall_64.c.ifdefed" startline="127" endline="130">
{
    gettimeofday (tv, NULL);
    return;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/vsyscall_64.c.ifdefed" startline="146" endline="149">
{
    tv->tv_sec += 1;
    nsec -= NSEC_PER_SEC;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/vsyscall_64.c.ifdefed" startline="154" endline="160">
{
    if (tv)
        do_vgettimeofday (tv);
    if (tz)
        do_get_tz (tz);
    return 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/vsyscall_64.c.ifdefed" startline="165" endline="176">
{
    struct timeval tv;
    time_t result;
    if (unlikely (!__vsyscall_gtod_data.sysctl_enabled))
        return time_syscall (t);
    vgettimeofday (& tv, NULL);
    result = tv.tv_sec;
    if (t)
        *t = result;
    return result;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/vsyscall_64.c.ifdefed" startline="188" endline="218">
{
    unsigned int p;
    unsigned long j = 0;
    if (tcache && tcache->blob[0] == (j = __jiffies)) {
        p = tcache->blob[1];
    }
    else if (__vgetcpu_mode == VGETCPU_RDTSCP) {
        native_read_tscp (& p);
    }
    else {
        asm ("lsl %1,%0"
            : "=r" (p)
            : "r" (__PER_CPU_SEG)
        )}
    if (tcache) {
        tcache->blob[0] = j;
        tcache->blob[1] = p;
    }
    if (cpu)
        *cpu = p & 0xfff;
    if (node)
        *node = p >> 12;
    return 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/vsyscall_64.c.ifdefed" startline="200" endline="202">
{
    p = tcache->blob[1];
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/vsyscall_64.c.ifdefed" startline="202" endline="205">
{
    native_read_tscp (& p);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/vsyscall_64.c.ifdefed" startline="205" endline="208">
{
    asm ("lsl %1,%0"
        : "=r" (p)
        : "r" (__PER_CPU_SEG)
    )}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/vsyscall_64.c.ifdefed" startline="209" endline="212">
{
    tcache->blob[0] = j;
    tcache->blob[1] = p;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/vsyscall_64.c.ifdefed" startline="221" endline="223">
{
    return -ENOSYS;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/vsyscall_64.c.ifdefed" startline="252" endline="269">
{
    unsigned long d;
    unsigned long node = 0;
    if (cpu_has (&cpu_data (cpu), X86_FEATURE_RDTSCP))
        write_rdtscp_aux ((node << 12) | cpu);
    d = 0x0f40000000000ULL;
    d |= cpu;
    d |= (node & 0xf) << 12;
    d |= (node >> 4) << 48;
    write_gdt_entry (get_cpu_gdt_table (cpu), GDT_ENTRY_PER_CPU, & d, DESCTYPE_S);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/vsyscall_64.c.ifdefed" startline="272" endline="275">
{
    vsyscall_set_cpu (raw_smp_processor_id ());
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/vsyscall_64.c.ifdefed" startline="279" endline="284">
{
    long cpu = (long) arg;
    if (action == CPU_ONLINE || action == CPU_ONLINE_FROZEN)
        smp_call_function_single (cpu, cpu_vsyscall_init, NULL, 1);
    return NOTIFY_DONE;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/vsyscall_64.c.ifdefed" startline="287" endline="293">
{
    extern char __vsyscall_0;
    unsigned long physaddr_page0 = __pa_symbol (&__vsyscall_0);
    __set_fixmap (VSYSCALL_FIRST_PAGE, physaddr_page0, PAGE_KERNEL_VSYSCALL);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/vsyscall_64.c.ifdefed" startline="296" endline="308">
{
    BUG_ON (((unsigned long) & vgettimeofday != VSYSCALL_ADDR (__NR_vgettimeofday)));
    BUG_ON ((unsigned long) & vtime != VSYSCALL_ADDR (__NR_vtime));
    BUG_ON ((VSYSCALL_ADDR (0) != __fix_to_virt (VSYSCALL_FIRST_PAGE)));
    BUG_ON ((unsigned long) & vgetcpu != VSYSCALL_ADDR (__NR_vgetcpu));
    on_each_cpu (cpu_vsyscall_init, NULL, 1);
    hotcpu_notifier (cpu_vsyscall_notifier, 0);
    return 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/mpparse.c.ifdefed" startline="43" endline="50">
{
    int sum = 0;
    while (len--)
        sum += *mp++;
    return sum & 0xFF;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/mpparse.c.ifdefed" startline="53" endline="74">
{
    int apicid;
    char *bootup_cpu = "";
    if (!(m->mpc_cpuflag & CPU_ENABLED)) {
        disabled_cpus++;
        return;
    }
    if (x86_quirks->mpc_apic_id)
        apicid = x86_quirks->mpc_apic_id (m);
    else
        apicid = m->mpc_apicid;
    if (m->mpc_cpuflag & CPU_BOOTPROCESSOR) {
        bootup_cpu = " (Bootup-CPU)";
        boot_cpu_physical_apicid = m->mpc_apicid;
    }
    printk (KERN_INFO "Processor #%d%s\n", m -> mpc_apicid, bootup_cpu);
    generic_processor_info (apicid, m -> mpc_apicver);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/mpparse.c.ifdefed" startline="57" endline="60">
{
    disabled_cpus++;
    return;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/mpparse.c.ifdefed" startline="67" endline="70">
{
    bootup_cpu = " (Bootup-CPU)";
    boot_cpu_physical_apicid = m->mpc_apicid;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/mpparse.c.ifdefed" startline="237" endline="243">
{
    apic_printk (APIC_VERBOSE, "Lint: type %d, pol %d, trig %d, bus %02x," " IRQ %02x, APIC ID %x, APIC LINT %02x\n", m -> mpc_irqtype, m -> mpc_irqflag & 3, (m -> mpc_irqflag >> 2) & 3, m -> mpc_srcbusid, m -> mpc_srcbusirq, m -> mpc_destapic, m -> mpc_destapiclint);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/mpparse.c.ifdefed" startline="251" endline="284">
{
    if (memcmp (mpc->mpc_signature, MPC_SIGNATURE, 4)) {
        printk (KERN_ERR "MPTABLE: bad signature [%c%c%c%c]!\n", mpc -> mpc_signature [0], mpc -> mpc_signature [1], mpc -> mpc_signature [2], mpc -> mpc_signature [3]);
        return 0;
    }
    if (mpf_checksum ((unsigned char *) mpc, mpc->mpc_length)) {
        printk (KERN_ERR "MPTABLE: checksum error!\n");
        return 0;
    }
    if (mpc->mpc_spec != 0x01 && mpc->mpc_spec != 0x04) {
        printk (KERN_ERR "MPTABLE: bad table version (%d)!!\n", mpc -> mpc_spec);
        return 0;
    }
    if (!mpc->mpc_lapic) {
        printk (KERN_ERR "MPTABLE: null local APIC address!\n");
        return 0;
    }
    memcpy (oem, mpc -> mpc_oem, 8);
    oem[8] = 0;
    printk (KERN_INFO "MPTABLE: OEM ID: %s\n", oem);
    memcpy (str, mpc -> mpc_productid, 12);
    str[12] = 0;
    printk (KERN_INFO "MPTABLE: Product ID: %s\n", str);
    printk (KERN_INFO "MPTABLE: APIC at: 0x%X\n", mpc -> mpc_lapic);
    return 1;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/mpparse.c.ifdefed" startline="253" endline="258">
{
    printk (KERN_ERR "MPTABLE: bad signature [%c%c%c%c]!\n", mpc -> mpc_signature [0], mpc -> mpc_signature [1], mpc -> mpc_signature [2], mpc -> mpc_signature [3]);
    return 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/mpparse.c.ifdefed" startline="259" endline="262">
{
    printk (KERN_ERR "MPTABLE: checksum error!\n");
    return 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/mpparse.c.ifdefed" startline="263" endline="267">
{
    printk (KERN_ERR "MPTABLE: bad table version (%d)!!\n", mpc -> mpc_spec);
    return 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/mpparse.c.ifdefed" startline="268" endline="271">
{
    printk (KERN_ERR "MPTABLE: null local APIC address!\n");
    return 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/mpparse.c.ifdefed" startline="287" endline="404">
{
    char str [16];
    char oem [10];
    int count = sizeof (*mpc);
    unsigned char *mpt = ((unsigned char *) mpc) + count;
    if (!smp_check_mpc (mpc, oem, str))
        return 0;
    if (!acpi_lapic)
        mp_lapic_addr = mpc->mpc_lapic;
    if (early)
        return 1;
    if (mpc->mpc_oemptr && x86_quirks->smp_read_mpc_oem) {
        struct mp_config_oemtable *oem_table = (struct mp_config_oemtable *) (unsigned long) mpc->mpc_oemptr;
        x86_quirks->smp_read_mpc_oem (oem_table, mpc->mpc_oemsize);
    }
    if (x86_quirks->mpc_record)
        *x86_quirks->mpc_record = 0;
    while (count < mpc->mpc_length) {
        switch (*mpt) {
        case MP_PROCESSOR :
            {
                struct mpc_config_processor *m = (struct mpc_config_processor *) mpt;
                if (!acpi_lapic)
                    MP_processor_info (m);
                mpt += sizeof (*m);
                count += sizeof (*m);
                break;
            }
        case MP_BUS :
            {
                struct mpc_config_bus *m = (struct mpc_config_bus *) mpt;
                mpt += sizeof (*m);
                count += sizeof (*m);
                break;
            }
        case MP_IOAPIC :
            {
                mpt += sizeof (struct mpc_config_ioapic);
                count += sizeof (struct mpc_config_ioapic);
                break;
            }
        case MP_INTSRC :
            {
                mpt += sizeof (struct mpc_config_intsrc);
                count += sizeof (struct mpc_config_intsrc);
                break;
            }
        case MP_LINTSRC :
            {
                struct mpc_config_lintsrc *m = (struct mpc_config_lintsrc *) mpt;
                MP_lintsrc_info (m);
                mpt += sizeof (*m);
                count += sizeof (*m);
                break;
            }
        default :
            printk (KERN_ERR "Your mptable is wrong, contact your HW vendor!\n");
            printk (KERN_ERR "type %x\n", * mpt);
            print_hex_dump (KERN_ERR, "  ", DUMP_PREFIX_ADDRESS, 16, 1, mpc, mpc -> mpc_length, 1);
            count = mpc->mpc_length;
            break;
        }
        if (x86_quirks->mpc_record)
            (*x86_quirks->mpc_record)++;
    }
    setup_apic_routing ();
    if (!num_processors)
        printk (KERN_ERR "MPTABLE: no processors registered!\n");
    return num_processors;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/mpparse.c.ifdefed" startline="316" endline="319">
{
    struct mp_config_oemtable *oem_table = (struct mp_config_oemtable *) (unsigned long) mpc->mpc_oemptr;
    x86_quirks->smp_read_mpc_oem (oem_table, mpc->mpc_oemsize);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/mpparse.c.ifdefed" startline="327" endline="394">
{
    switch (*mpt) {
    case MP_PROCESSOR :
        {
            struct mpc_config_processor *m = (struct mpc_config_processor *) mpt;
            if (!acpi_lapic)
                MP_processor_info (m);
            mpt += sizeof (*m);
            count += sizeof (*m);
            break;
        }
    case MP_BUS :
        {
            struct mpc_config_bus *m = (struct mpc_config_bus *) mpt;
            mpt += sizeof (*m);
            count += sizeof (*m);
            break;
        }
    case MP_IOAPIC :
        {
            mpt += sizeof (struct mpc_config_ioapic);
            count += sizeof (struct mpc_config_ioapic);
            break;
        }
    case MP_INTSRC :
        {
            mpt += sizeof (struct mpc_config_intsrc);
            count += sizeof (struct mpc_config_intsrc);
            break;
        }
    case MP_LINTSRC :
        {
            struct mpc_config_lintsrc *m = (struct mpc_config_lintsrc *) mpt;
            MP_lintsrc_info (m);
            mpt += sizeof (*m);
            count += sizeof (*m);
            break;
        }
    default :
        printk (KERN_ERR "Your mptable is wrong, contact your HW vendor!\n");
        printk (KERN_ERR "type %x\n", * mpt);
        print_hex_dump (KERN_ERR, "  ", DUMP_PREFIX_ADDRESS, 16, 1, mpc, mpc -> mpc_length, 1);
        count = mpc->mpc_length;
        break;
    }
    if (x86_quirks->mpc_record)
        (*x86_quirks->mpc_record)++;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/mpparse.c.ifdefed" startline="328" endline="391">
{
case MP_PROCESSOR :
    {
        struct mpc_config_processor *m = (struct mpc_config_processor *) mpt;
        if (!acpi_lapic)
            MP_processor_info (m);
        mpt += sizeof (*m);
        count += sizeof (*m);
        break;
    }
case MP_BUS :
    {
        struct mpc_config_bus *m = (struct mpc_config_bus *) mpt;
        mpt += sizeof (*m);
        count += sizeof (*m);
        break;
    }
case MP_IOAPIC :
    {
        mpt += sizeof (struct mpc_config_ioapic);
        count += sizeof (struct mpc_config_ioapic);
        break;
    }
case MP_INTSRC :
    {
        mpt += sizeof (struct mpc_config_intsrc);
        count += sizeof (struct mpc_config_intsrc);
        break;
    }
case MP_LINTSRC :
    {
        struct mpc_config_lintsrc *m = (struct mpc_config_lintsrc *) mpt;
        MP_lintsrc_info (m);
        mpt += sizeof (*m);
        count += sizeof (*m);
        break;
    }
default :
    printk (KERN_ERR "Your mptable is wrong, contact your HW vendor!\n");
    printk (KERN_ERR "type %x\n", * mpt);
    print_hex_dump (KERN_ERR, "  ", DUMP_PREFIX_ADDRESS, 16, 1, mpc, mpc -> mpc_length, 1);
    count = mpc->mpc_length;
    break;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/mpparse.c.ifdefed" startline="330" endline="339">
{
    struct mpc_config_processor *m = (struct mpc_config_processor *) mpt;
    if (!acpi_lapic)
        MP_processor_info (m);
    mpt += sizeof (*m);
    count += sizeof (*m);
    break;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/mpparse.c.ifdefed" startline="341" endline="350">
{
    struct mpc_config_bus *m = (struct mpc_config_bus *) mpt;
    mpt += sizeof (*m);
    count += sizeof (*m);
    break;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/mpparse.c.ifdefed" startline="352" endline="361">
{
    mpt += sizeof (struct mpc_config_ioapic);
    count += sizeof (struct mpc_config_ioapic);
    break;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/mpparse.c.ifdefed" startline="363" endline="373">
{
    mpt += sizeof (struct mpc_config_intsrc);
    count += sizeof (struct mpc_config_intsrc);
    break;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/mpparse.c.ifdefed" startline="375" endline="382">
{
    struct mpc_config_lintsrc *m = (struct mpc_config_lintsrc *) mpt;
    MP_lintsrc_info (m);
    mpt += sizeof (*m);
    count += sizeof (*m);
    break;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/mpparse.c.ifdefed" startline="532" endline="532">
{
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/mpparse.c.ifdefed" startline="536" endline="576">
{
    struct mpc_config_processor processor;
    struct mpc_config_lintsrc lintsrc;
    int linttypes [2] = {mp_ExtINT, mp_NMI};
    int i;
    mp_lapic_addr = APIC_DEFAULT_PHYS_BASE;
    processor.mpc_type = MP_PROCESSOR;
    processor.mpc_apicver = mpc_default_type > 4 ? 0x10 : 0x01;
    processor.mpc_cpuflag = CPU_ENABLED;
    processor.mpc_cpufeature = (boot_cpu_data.x86 << 8) | (boot_cpu_data.x86_model << 4) | boot_cpu_data.x86_mask;
    processor.mpc_featureflag = boot_cpu_data.x86_capability[0];
    processor.mpc_reserved[0] = 0;
    processor.mpc_reserved[1] = 0;
    for (i = 0; i < 2; i++) {
        processor.mpc_apicid = i;
        MP_processor_info (& processor);
    }
    construct_ioapic_table (mpc_default_type);
    lintsrc.mpc_type = MP_LINTSRC;
    lintsrc.mpc_irqflag = 0;
    lintsrc.mpc_srcbusid = 0;
    lintsrc.mpc_srcbusirq = 0;
    lintsrc.mpc_destapic = MP_APIC_ALL;
    for (i = 0; i < 2; i++) {
        lintsrc.mpc_irqtype = linttypes[i];
        lintsrc.mpc_destapiclint = i;
        MP_lintsrc_info (& lintsrc);
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/mpparse.c.ifdefed" startline="559" endline="562">
{
    processor.mpc_apicid = i;
    MP_processor_info (& processor);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/mpparse.c.ifdefed" startline="571" endline="575">
{
    lintsrc.mpc_irqtype = linttypes[i];
    lintsrc.mpc_destapiclint = i;
    MP_lintsrc_info (& lintsrc);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/mpparse.c.ifdefed" startline="584" endline="680">
{
    struct intel_mp_floating *mpf = mpf_found;
    if (x86_quirks->mach_get_smp_config) {
        if (x86_quirks->mach_get_smp_config (early))
            return;
    }
    if (acpi_lapic && early)
        return;
    if (acpi_lapic && acpi_ioapic) {
        printk (KERN_INFO "Using ACPI (MADT) for SMP configuration " "information\n");
        return;
    }
    else if (acpi_lapic)
        printk (KERN_INFO "Using ACPI for processor (LAPIC) " "configuration information\n");
    printk (KERN_INFO "Intel MultiProcessor Specification v1.%d\n", mpf -> mpf_specification);
    if (mpf->mpf_feature1 != 0) {
        if (early) {
            mp_lapic_addr = APIC_DEFAULT_PHYS_BASE;
            return;
        }
        printk (KERN_INFO "Default MP configuration #%d\n", mpf -> mpf_feature1);
        construct_default_ISA_mptable (mpf -> mpf_feature1);
    }
    else if (mpf->mpf_physptr) {
        if (!smp_read_mpc (phys_to_virt (mpf->mpf_physptr), early)) {
            printk (KERN_ERR "BIOS bug, MP table errors detected!...\n");
            printk (KERN_ERR "... disabling SMP support. " "(tell your hw vendor)\n");
            return;
        }
        if (early)
            return;
    }
    else
        BUG ();
    if (!early)
        printk (KERN_INFO "Processors: %d\n", num_processors);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/mpparse.c.ifdefed" startline="587" endline="590">
{
    if (x86_quirks->mach_get_smp_config (early))
        return;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/mpparse.c.ifdefed" startline="597" endline="601">
{
    printk (KERN_INFO "Using ACPI (MADT) for SMP configuration " "information\n");
    return;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/mpparse.c.ifdefed" startline="619" endline="632">
{
    if (early) {
        mp_lapic_addr = APIC_DEFAULT_PHYS_BASE;
        return;
    }
    printk (KERN_INFO "Default MP configuration #%d\n", mpf -> mpf_feature1);
    construct_default_ISA_mptable (mpf -> mpf_feature1);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/mpparse.c.ifdefed" startline="620" endline="626">
{
    mp_lapic_addr = APIC_DEFAULT_PHYS_BASE;
    return;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/mpparse.c.ifdefed" startline="632" endline="672">
{
    if (!smp_read_mpc (phys_to_virt (mpf->mpf_physptr), early)) {
        printk (KERN_ERR "BIOS bug, MP table errors detected!...\n");
        printk (KERN_ERR "... disabling SMP support. " "(tell your hw vendor)\n");
        return;
    }
    if (early)
        return;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/mpparse.c.ifdefed" startline="638" endline="647">
{
    printk (KERN_ERR "BIOS bug, MP table errors detected!...\n");
    printk (KERN_ERR "... disabling SMP support. " "(tell your hw vendor)\n");
    return;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/mpparse.c.ifdefed" startline="683" endline="685">
{
    __get_smp_config (1);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/mpparse.c.ifdefed" startline="688" endline="690">
{
    __get_smp_config (0);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/mpparse.c.ifdefed" startline="694" endline="747">
{
    unsigned int *bp = phys_to_virt (base);
    struct intel_mp_floating *mpf;
    apic_printk (APIC_VERBOSE, "Scan SMP from %p for %ld bytes.\n", bp, length);
    BUILD_BUG_ON (sizeof (* mpf) != 16);
    while (length > 0) {
        mpf = (struct intel_mp_floating *) bp;
        if ((*bp == SMP_MAGIC_IDENT) && (mpf->mpf_length == 1) && !mpf_checksum ((unsigned char *) bp, 16) && ((mpf->mpf_specification == 1) || (mpf->mpf_specification == 4))) {
            mpf_found = mpf;
            printk (KERN_INFO "found SMP MP-table at [%p] %08lx\n", mpf, virt_to_phys (mpf));
            if (!reserve)
                return 1;
            reserve_bootmem_generic (virt_to_phys (mpf), PAGE_SIZE, BOOTMEM_DEFAULT);
            if (mpf->mpf_physptr) {
                unsigned long size = PAGE_SIZE;
                reserve_bootmem_generic (mpf -> mpf_physptr, size, BOOTMEM_DEFAULT);
            }
            return 1;
        }
        bp += 4;
        length -= 16;
    }
    return 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/mpparse.c.ifdefed" startline="702" endline="745">
{
    mpf = (struct intel_mp_floating *) bp;
    if ((*bp == SMP_MAGIC_IDENT) && (mpf->mpf_length == 1) && !mpf_checksum ((unsigned char *) bp, 16) && ((mpf->mpf_specification == 1) || (mpf->mpf_specification == 4))) {
        mpf_found = mpf;
        printk (KERN_INFO "found SMP MP-table at [%p] %08lx\n", mpf, virt_to_phys (mpf));
        if (!reserve)
            return 1;
        reserve_bootmem_generic (virt_to_phys (mpf), PAGE_SIZE, BOOTMEM_DEFAULT);
        if (mpf->mpf_physptr) {
            unsigned long size = PAGE_SIZE;
            reserve_bootmem_generic (mpf -> mpf_physptr, size, BOOTMEM_DEFAULT);
        }
        return 1;
    }
    bp += 4;
    length -= 16;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/mpparse.c.ifdefed" startline="708" endline="742">
{
    mpf_found = mpf;
    printk (KERN_INFO "found SMP MP-table at [%p] %08lx\n", mpf, virt_to_phys (mpf));
    if (!reserve)
        return 1;
    reserve_bootmem_generic (virt_to_phys (mpf), PAGE_SIZE, BOOTMEM_DEFAULT);
    if (mpf->mpf_physptr) {
        unsigned long size = PAGE_SIZE;
        reserve_bootmem_generic (mpf -> mpf_physptr, size, BOOTMEM_DEFAULT);
    }
    return 1;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/mpparse.c.ifdefed" startline="721" endline="739">
{
    unsigned long size = PAGE_SIZE;
    reserve_bootmem_generic (mpf -> mpf_physptr, size, BOOTMEM_DEFAULT);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/mpparse.c.ifdefed" startline="750" endline="789">
{
    unsigned int address;
    if (x86_quirks->mach_find_smp_config) {
        if (x86_quirks->mach_find_smp_config (reserve))
            return;
    }
    if (smp_scan_config (0x0, 0x400, reserve) || smp_scan_config (639 * 0x400, 0x400, reserve) || smp_scan_config (0xF0000, 0x10000, reserve))
        return;
    address = get_bios_ebda ();
    if (address)
        smp_scan_config (address, 0x400, reserve);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/mpparse.c.ifdefed" startline="753" endline="756">
{
    if (x86_quirks->mach_find_smp_config (reserve))
        return;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/mpparse.c.ifdefed" startline="792" endline="794">
{
    __find_smp_config (0);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/mpparse.c.ifdefed" startline="797" endline="799">
{
    __find_smp_config (1);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/mpparse.c.ifdefed" startline="847" endline="972">
{
    int count = sizeof (*mpc);
    unsigned char *mpt = ((unsigned char *) mpc) + count;
    printk (KERN_INFO "mpc_length %x\n", mpc -> mpc_length);
    while (count < mpc->mpc_length) {
        switch (*mpt) {
        case MP_PROCESSOR :
            {
                struct mpc_config_processor *m = (struct mpc_config_processor *) mpt;
                mpt += sizeof (*m);
                count += sizeof (*m);
                break;
            }
        case MP_BUS :
            {
                struct mpc_config_bus *m = (struct mpc_config_bus *) mpt;
                mpt += sizeof (*m);
                count += sizeof (*m);
                break;
            }
        case MP_IOAPIC :
            {
                mpt += sizeof (struct mpc_config_ioapic);
                count += sizeof (struct mpc_config_ioapic);
                break;
            }
        case MP_INTSRC :
            {
                mpt += sizeof (struct mpc_config_intsrc);
                count += sizeof (struct mpc_config_intsrc);
                break;
            }
        case MP_LINTSRC :
            {
                struct mpc_config_lintsrc *m = (struct mpc_config_lintsrc *) mpt;
                mpt += sizeof (*m);
                count += sizeof (*m);
                break;
            }
        default :
            printk (KERN_ERR "Your mptable is wrong, contact your HW vendor!\n");
            printk (KERN_ERR "type %x\n", * mpt);
            print_hex_dump (KERN_ERR, "  ", DUMP_PREFIX_ADDRESS, 16, 1, mpc, mpc -> mpc_length, 1);
            goto out;
        }
    }
out :
    mpc->mpc_checksum = 0;
    mpc->mpc_checksum -= mpf_checksum ((unsigned char *) mpc, mpc->mpc_length);
    return 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/mpparse.c.ifdefed" startline="857" endline="926">
{
    switch (*mpt) {
    case MP_PROCESSOR :
        {
            struct mpc_config_processor *m = (struct mpc_config_processor *) mpt;
            mpt += sizeof (*m);
            count += sizeof (*m);
            break;
        }
    case MP_BUS :
        {
            struct mpc_config_bus *m = (struct mpc_config_bus *) mpt;
            mpt += sizeof (*m);
            count += sizeof (*m);
            break;
        }
    case MP_IOAPIC :
        {
            mpt += sizeof (struct mpc_config_ioapic);
            count += sizeof (struct mpc_config_ioapic);
            break;
        }
    case MP_INTSRC :
        {
            mpt += sizeof (struct mpc_config_intsrc);
            count += sizeof (struct mpc_config_intsrc);
            break;
        }
    case MP_LINTSRC :
        {
            struct mpc_config_lintsrc *m = (struct mpc_config_lintsrc *) mpt;
            mpt += sizeof (*m);
            count += sizeof (*m);
            break;
        }
    default :
        printk (KERN_ERR "Your mptable is wrong, contact your HW vendor!\n");
        printk (KERN_ERR "type %x\n", * mpt);
        print_hex_dump (KERN_ERR, "  ", DUMP_PREFIX_ADDRESS, 16, 1, mpc, mpc -> mpc_length, 1);
        goto out;
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/mpparse.c.ifdefed" startline="858" endline="925">
{
case MP_PROCESSOR :
    {
        struct mpc_config_processor *m = (struct mpc_config_processor *) mpt;
        mpt += sizeof (*m);
        count += sizeof (*m);
        break;
    }
case MP_BUS :
    {
        struct mpc_config_bus *m = (struct mpc_config_bus *) mpt;
        mpt += sizeof (*m);
        count += sizeof (*m);
        break;
    }
case MP_IOAPIC :
    {
        mpt += sizeof (struct mpc_config_ioapic);
        count += sizeof (struct mpc_config_ioapic);
        break;
    }
case MP_INTSRC :
    {
        mpt += sizeof (struct mpc_config_intsrc);
        count += sizeof (struct mpc_config_intsrc);
        break;
    }
case MP_LINTSRC :
    {
        struct mpc_config_lintsrc *m = (struct mpc_config_lintsrc *) mpt;
        mpt += sizeof (*m);
        count += sizeof (*m);
        break;
    }
default :
    printk (KERN_ERR "Your mptable is wrong, contact your HW vendor!\n");
    printk (KERN_ERR "type %x\n", * mpt);
    print_hex_dump (KERN_ERR, "  ", DUMP_PREFIX_ADDRESS, 16, 1, mpc, mpc -> mpc_length, 1);
    goto out;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/mpparse.c.ifdefed" startline="860" endline="866">
{
    struct mpc_config_processor *m = (struct mpc_config_processor *) mpt;
    mpt += sizeof (*m);
    count += sizeof (*m);
    break;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/mpparse.c.ifdefed" startline="868" endline="874">
{
    struct mpc_config_bus *m = (struct mpc_config_bus *) mpt;
    mpt += sizeof (*m);
    count += sizeof (*m);
    break;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/mpparse.c.ifdefed" startline="876" endline="880">
{
    mpt += sizeof (struct mpc_config_ioapic);
    count += sizeof (struct mpc_config_ioapic);
    break;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/mpparse.c.ifdefed" startline="882" endline="909">
{
    mpt += sizeof (struct mpc_config_intsrc);
    count += sizeof (struct mpc_config_intsrc);
    break;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/mpparse.c.ifdefed" startline="911" endline="917">
{
    struct mpc_config_lintsrc *m = (struct mpc_config_lintsrc *) mpt;
    mpt += sizeof (*m);
    count += sizeof (*m);
    break;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/mpparse.c.ifdefed" startline="977" endline="980">
{
    enable_update_mptable = 1;
    return 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/mpparse.c.ifdefed" startline="989" endline="996">
{
    enable_update_mptable = 1;
    alloc_mptable = 1;
    if (!p)
        return 0;
    mpc_new_length = memparse (p, &p);
    return 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/mpparse.c.ifdefed" startline="1000" endline="1008">
{
    if (enable_update_mptable && alloc_mptable) {
        u64 startt = 0;
        mpc_new_phys = early_reserve_e820 (startt, mpc_new_length, 4);
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/mpparse.c.ifdefed" startline="1001" endline="1007">
{
    u64 startt = 0;
    mpc_new_phys = early_reserve_e820 (startt, mpc_new_length, 4);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/mpparse.c.ifdefed" startline="1011" endline="1089">
{
    char str [16];
    char oem [10];
    struct intel_mp_floating *mpf;
    struct mp_config_table *mpc;
    struct mp_config_table *mpc_new;
    if (!enable_update_mptable)
        return 0;
    mpf = mpf_found;
    if (!mpf)
        return 0;
    if (mpf->mpf_feature1 != 0)
        return 0;
    if (!mpf->mpf_physptr)
        return 0;
    mpc = phys_to_virt (mpf->mpf_physptr);
    if (!smp_check_mpc (mpc, oem, str))
        return 0;
    printk (KERN_INFO "mpf: %lx\n", virt_to_phys (mpf));
    printk (KERN_INFO "mpf_physptr: %x\n", mpf -> mpf_physptr);
    if (mpc_new_phys && mpc->mpc_length > mpc_new_length) {
        mpc_new_phys = 0;
        printk (KERN_INFO "mpc_new_length is %ld, please use alloc_mptable=8k\n", mpc_new_length);
    }
    if (!mpc_new_phys) {
        unsigned char old, new;
        mpc->mpc_checksum = 0;
        old = mpf_checksum ((unsigned char *) mpc, mpc->mpc_length);
        mpc->mpc_checksum = 0xff;
        new = mpf_checksum ((unsigned char *) mpc, mpc->mpc_length);
        if (old == new) {
            printk (KERN_INFO "mpc is readonly, please try alloc_mptable instead\n");
            return 0;
        }
        printk (KERN_INFO "use in-positon replacing\n");
    }
    else {
        mpf->mpf_physptr = mpc_new_phys;
        mpc_new = phys_to_virt (mpc_new_phys);
        memcpy (mpc_new, mpc, mpc -> mpc_length);
        mpc = mpc_new;
        if (mpc_new_phys - mpf->mpf_physptr) {
            struct intel_mp_floating *mpf_new;
            printk (KERN_INFO "mpf new: %x\n", 0x400 - 16);
            mpf_new = phys_to_virt (0x400 - 16);
            memcpy (mpf_new, mpf, 16);
            mpf = mpf_new;
            mpf->mpf_physptr = mpc_new_phys;
        }
        mpf->mpf_checksum = 0;
        mpf->mpf_checksum -= mpf_checksum ((unsigned char *) mpf, 16);
        printk (KERN_INFO "mpf_physptr new: %x\n", mpf -> mpf_physptr);
    }
    replace_intsrc_all (mpc, mpc_new_phys, mpc_new_length);
    return 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/mpparse.c.ifdefed" startline="1042" endline="1046">
{
    mpc_new_phys = 0;
    printk (KERN_INFO "mpc_new_length is %ld, please use alloc_mptable=8k\n", mpc_new_length);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/mpparse.c.ifdefed" startline="1048" endline="1060">
{
    unsigned char old, new;
    mpc->mpc_checksum = 0;
    old = mpf_checksum ((unsigned char *) mpc, mpc->mpc_length);
    mpc->mpc_checksum = 0xff;
    new = mpf_checksum ((unsigned char *) mpc, mpc->mpc_length);
    if (old == new) {
        printk (KERN_INFO "mpc is readonly, please try alloc_mptable instead\n");
        return 0;
    }
    printk (KERN_INFO "use in-positon replacing\n");
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/mpparse.c.ifdefed" startline="1055" endline="1058">
{
    printk (KERN_INFO "mpc is readonly, please try alloc_mptable instead\n");
    return 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/mpparse.c.ifdefed" startline="1060" endline="1078">
{
    mpf->mpf_physptr = mpc_new_phys;
    mpc_new = phys_to_virt (mpc_new_phys);
    memcpy (mpc_new, mpc, mpc -> mpc_length);
    mpc = mpc_new;
    if (mpc_new_phys - mpf->mpf_physptr) {
        struct intel_mp_floating *mpf_new;
        printk (KERN_INFO "mpf new: %x\n", 0x400 - 16);
        mpf_new = phys_to_virt (0x400 - 16);
        memcpy (mpf_new, mpf, 16);
        mpf = mpf_new;
        mpf->mpf_physptr = mpc_new_phys;
    }
    mpf->mpf_checksum = 0;
    mpf->mpf_checksum -= mpf_checksum ((unsigned char *) mpf, 16);
    printk (KERN_INFO "mpf_physptr new: %x\n", mpf -> mpf_physptr);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/mpparse.c.ifdefed" startline="1066" endline="1074">
{
    struct intel_mp_floating *mpf_new;
    printk (KERN_INFO "mpf new: %x\n", 0x400 - 16);
    mpf_new = phys_to_virt (0x400 - 16);
    memcpy (mpf_new, mpf, 16);
    mpf = mpf_new;
    mpf->mpf_physptr = mpc_new_phys;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/signal_64.c.ifdefed" startline="52" endline="54">
{
    return do_sigaltstack (uss, uoss, regs->sp);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/signal_64.c.ifdefed" startline="61" endline="87">
{
    struct task_struct *tsk = current;
    int err = 0;
    BUILD_BUG_ON (sizeof (struct user_i387_struct) != sizeof (tsk -> thread.xstate -> fxsave));
    if ((unsigned long) buf % 16)
        printk ("save_i387: bad fpstate %p\n", buf);
    if (!used_math ())
        return 0;
    clear_used_math ();
    if (task_thread_info (tsk)->status & TS_USEDFPU) {
        err = save_i387_checking ((struct i387_fxsave_struct __user *) buf);
        if (err)
            return err;
        task_thread_info (tsk)->status &= ~TS_USEDFPU;
        stts ();
    }
    else {
        if (__copy_to_user (buf, &tsk->thread.xstate->fxsave, sizeof (struct i387_fxsave_struct)))
            return -1;
    }
    return 1;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/signal_64.c.ifdefed" startline="74" endline="81">
{
    err = save_i387_checking ((struct i387_fxsave_struct __user *) buf);
    if (err)
        return err;
    task_thread_info (tsk)->status &= ~TS_USEDFPU;
    stts ();
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/signal_64.c.ifdefed" startline="81" endline="85">
{
    if (__copy_to_user (buf, &tsk->thread.xstate->fxsave, sizeof (struct i387_fxsave_struct)))
        return -1;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/signal_64.c.ifdefed" startline="93" endline="117">
{
    struct task_struct *tsk = current;
    int err;
    if (!used_math ()) {
        err = init_fpu (tsk);
        if (err)
            return err;
    }
    if (!(task_thread_info (current)->status & TS_USEDFPU)) {
        clts ();
        task_thread_info (current)->status |= TS_USEDFPU;
    }
    err = restore_fpu_checking ((__force struct i387_fxsave_struct *) buf);
    if (unlikely (err)) {
        clear_fpu (tsk);
        clear_used_math ();
    }
    return err;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/signal_64.c.ifdefed" startline="97" endline="101">
{
    err = init_fpu (tsk);
    if (err)
        return err;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/signal_64.c.ifdefed" startline="103" endline="106">
{
    clts ();
    task_thread_info (current)->status |= TS_USEDFPU;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/signal_64.c.ifdefed" startline="108" endline="115">
{
    clear_fpu (tsk);
    clear_used_math ();
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/signal_64.c.ifdefed" startline="125" endline="182">
{
    unsigned int err = 0;
    current_thread_info ()->restart_block.fn = do_no_restart_syscall;
    COPY (di);
    COPY (si);
    COPY (bp);
    COPY (sp);
    COPY (bx);
    COPY (dx);
    COPY (cx);
    COPY (ip);
    COPY (r8);
    COPY (r9);
    COPY (r10);
    COPY (r11);
    COPY (r12);
    COPY (r13);
    COPY (r14);
    COPY (r15);
    {
        unsigned cs;
        err |= __get_user (cs, &sc->cs);
        regs->cs = cs | 3;
    }
    {
        unsigned int tmpflags;
        err |= __get_user (tmpflags, &sc->flags);
        regs->flags = (regs->flags & ~FIX_EFLAGS) | (tmpflags & FIX_EFLAGS);
        regs->orig_ax = -1;
    }
    {
        struct _fpstate __user *buf;
        err |= __get_user (buf, &sc->fpstate);
        if (buf) {
            if (!access_ok (VERIFY_READ, buf, sizeof (*buf)))
                goto badframe;
            err |= restore_i387 (buf);
        }
        else {
            struct task_struct *me = current;
            if (used_math ()) {
                clear_fpu (me);
                clear_used_math ();
            }
        }
    }
    err |= __get_user (*pax, &sc->ax);
    return err;
badframe :
    return 1;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/signal_64.c.ifdefed" startline="147" endline="151">
{
    unsigned cs;
    err |= __get_user (cs, &sc->cs);
    regs->cs = cs | 3;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/signal_64.c.ifdefed" startline="153" endline="158">
{
    unsigned int tmpflags;
    err |= __get_user (tmpflags, &sc->flags);
    regs->flags = (regs->flags & ~FIX_EFLAGS) | (tmpflags & FIX_EFLAGS);
    regs->orig_ax = -1;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/signal_64.c.ifdefed" startline="160" endline="175">
{
    struct _fpstate __user *buf;
    err |= __get_user (buf, &sc->fpstate);
    if (buf) {
        if (!access_ok (VERIFY_READ, buf, sizeof (*buf)))
            goto badframe;
        err |= restore_i387 (buf);
    }
    else {
        struct task_struct *me = current;
        if (used_math ()) {
            clear_fpu (me);
            clear_used_math ();
        }
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/signal_64.c.ifdefed" startline="164" endline="168">
{
    if (!access_ok (VERIFY_READ, buf, sizeof (*buf)))
        goto badframe;
    err |= restore_i387 (buf);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/signal_64.c.ifdefed" startline="168" endline="174">
{
    struct task_struct *me = current;
    if (used_math ()) {
        clear_fpu (me);
        clear_used_math ();
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/signal_64.c.ifdefed" startline="170" endline="173">
{
    clear_fpu (me);
    clear_used_math ();
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/signal_64.c.ifdefed" startline="185" endline="213">
{
    struct rt_sigframe __user *frame;
    sigset_t set;
    unsigned long ax;
    frame = (struct rt_sigframe __user *) (regs->sp - sizeof (long));
    if (!access_ok (VERIFY_READ, frame, sizeof (*frame)))
        goto badframe;
    if (__copy_from_user (&set, &frame->uc.uc_sigmask, sizeof (set)))
        goto badframe;
    sigdelsetmask (& set, ~ _BLOCKABLE);
    spin_lock_irq (& current -> sighand -> siglock);
    current->blocked = set;
    recalc_sigpending ();
    spin_unlock_irq (& current -> sighand -> siglock);
    if (restore_sigcontext (regs, &frame->uc.uc_mcontext, &ax))
        goto badframe;
    if (do_sigaltstack (&frame->uc.uc_stack, NULL, regs->sp) == -EFAULT)
        goto badframe;
    return ax;
badframe :
    signal_fault (regs, frame, "sigreturn");
    return 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/signal_64.c.ifdefed" startline="221" endline="252">
{
    int err = 0;
    err |= __put_user (regs->cs, &sc->cs);
    err |= __put_user (0, &sc->gs);
    err |= __put_user (0, &sc->fs);
    err |= __put_user (regs->di, &sc->di);
    err |= __put_user (regs->si, &sc->si);
    err |= __put_user (regs->bp, &sc->bp);
    err |= __put_user (regs->sp, &sc->sp);
    err |= __put_user (regs->bx, &sc->bx);
    err |= __put_user (regs->dx, &sc->dx);
    err |= __put_user (regs->cx, &sc->cx);
    err |= __put_user (regs->ax, &sc->ax);
    err |= __put_user (regs->r8, &sc->r8);
    err |= __put_user (regs->r9, &sc->r9);
    err |= __put_user (regs->r10, &sc->r10);
    err |= __put_user (regs->r11, &sc->r11);
    err |= __put_user (regs->r12, &sc->r12);
    err |= __put_user (regs->r13, &sc->r13);
    err |= __put_user (regs->r14, &sc->r14);
    err |= __put_user (regs->r15, &sc->r15);
    err |= __put_user (me->thread.trap_no, &sc->trapno);
    err |= __put_user (me->thread.error_code, &sc->err);
    err |= __put_user (regs->ip, &sc->ip);
    err |= __put_user (regs->flags, &sc->flags);
    err |= __put_user (mask, &sc->oldmask);
    err |= __put_user (me->thread.cr2, &sc->cr2);
    return err;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/signal_64.c.ifdefed" startline="260" endline="273">
{
    unsigned long sp;
    sp = regs->sp - 128;
    if (ka->sa.sa_flags & SA_ONSTACK) {
        if (sas_ss_flags (sp) == 0)
            sp = current->sas_ss_sp + current->sas_ss_size;
    }
    return (void __user *) round_down (sp -size, 16);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/signal_64.c.ifdefed" startline="267" endline="270">
{
    if (sas_ss_flags (sp) == 0)
        sp = current->sas_ss_sp + current->sas_ss_size;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/signal_64.c.ifdefed" startline="277" endline="355">
{
    struct rt_sigframe __user *frame;
    struct _fpstate __user *fp = NULL;
    int err = 0;
    struct task_struct *me = current;
    if (used_math ()) {
        fp = get_stack (ka, regs, sizeof (struct _fpstate));
        frame = (void __user *) round_down ((unsigned long) fp - sizeof (struct rt_sigframe), 16) - 8;
        if (!access_ok (VERIFY_WRITE, fp, sizeof (struct _fpstate)))
            goto give_sigsegv;
        if (save_i387 (fp) < 0)
            err |= -1;
    }
    else
        frame = get_stack (ka, regs, sizeof (struct rt_sigframe)) - 8;
    if (!access_ok (VERIFY_WRITE, frame, sizeof (*frame)))
        goto give_sigsegv;
    if (ka->sa.sa_flags & SA_SIGINFO) {
        err |= copy_siginfo_to_user (&frame->info, info);
        if (err)
            goto give_sigsegv;
    }
    err |= __put_user (0, &frame->uc.uc_flags);
    err |= __put_user (0, &frame->uc.uc_link);
    err |= __put_user (me->sas_ss_sp, &frame->uc.uc_stack.ss_sp);
    err |= __put_user (sas_ss_flags (regs->sp), &frame->uc.uc_stack.ss_flags);
    err |= __put_user (me->sas_ss_size, &frame->uc.uc_stack.ss_size);
    err |= setup_sigcontext (&frame->uc.uc_mcontext, regs, set->sig[0], me);
    err |= __put_user (fp, &frame->uc.uc_mcontext.fpstate);
    if (sizeof (*set) == 16) {
        __put_user (set -> sig [0], & frame -> uc.uc_sigmask.sig [0]);
        __put_user (set -> sig [1], & frame -> uc.uc_sigmask.sig [1]);
    }
    else
        err |= __copy_to_user (&frame->uc.uc_sigmask, set, sizeof (*set));
    if (ka->sa.sa_flags & SA_RESTORER) {
        err |= __put_user (ka->sa.sa_restorer, &frame->pretcode);
    }
    else {
        goto give_sigsegv;
    }
    if (err)
        goto give_sigsegv;
    regs->di = sig;
    regs->ax = 0;
    regs->si = (unsigned long) &frame->info;
    regs->dx = (unsigned long) &frame->uc;
    regs->ip = (unsigned long) ka->sa.sa_handler;
    regs->sp = (unsigned long) frame;
    regs->cs = __USER_CS;
    return 0;
give_sigsegv :
    force_sigsegv (sig, current);
    return -EFAULT;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/signal_64.c.ifdefed" startline="283" endline="293">
{
    fp = get_stack (ka, regs, sizeof (struct _fpstate));
    frame = (void __user *) round_down ((unsigned long) fp - sizeof (struct rt_sigframe), 16) - 8;
    if (!access_ok (VERIFY_WRITE, fp, sizeof (struct _fpstate)))
        goto give_sigsegv;
    if (save_i387 (fp) < 0)
        err |= -1;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/signal_64.c.ifdefed" startline="299" endline="303">
{
    err |= copy_siginfo_to_user (&frame->info, info);
    if (err)
        goto give_sigsegv;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/signal_64.c.ifdefed" startline="314" endline="317">
{
    __put_user (set -> sig [0], & frame -> uc.uc_sigmask.sig [0]);
    __put_user (set -> sig [1], & frame -> uc.uc_sigmask.sig [1]);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/signal_64.c.ifdefed" startline="323" endline="325">
{
    err |= __put_user (ka->sa.sa_restorer, &frame->pretcode);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/signal_64.c.ifdefed" startline="325" endline="328">
{
    goto give_sigsegv;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/signal_64.c.ifdefed" startline="361" endline="367">
{
    return regs->orig_ax;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/signal_64.c.ifdefed" startline="374" endline="384">
{
    return regs->ax;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/signal_64.c.ifdefed" startline="393" endline="468">
{
    int ret;
    if (current_syscall (regs) >= 0) {
        switch (current_syscall_ret (regs)) {
        case -ERESTART_RESTARTBLOCK :
        case -ERESTARTNOHAND :
            regs->ax = -EINTR;
            break;
        case -ERESTARTSYS :
            if (!(ka->sa.sa_flags & SA_RESTART)) {
                regs->ax = -EINTR;
                break;
            }
        case -ERESTARTNOINTR :
            regs->ax = regs->orig_ax;
            regs->ip -= 2;
            break;
        }
    }
    if (unlikely (regs->flags & X86_EFLAGS_TF) && likely (test_and_clear_thread_flag (TIF_FORCED_TF)))
        regs->flags &= ~X86_EFLAGS_TF;
    ret = setup_rt_frame (sig, ka, info, oldset, regs);
    if (ret == 0) {
        set_fs (USER_DS);
        regs->flags &= ~X86_EFLAGS_DF;
        regs->flags &= ~X86_EFLAGS_TF;
        if (test_thread_flag (TIF_SINGLESTEP))
            ptrace_notify (SIGTRAP);
        spin_lock_irq (& current -> sighand -> siglock);
        sigorsets (& current -> blocked, & current -> blocked, & ka -> sa.sa_mask);
        if (!(ka->sa.sa_flags & SA_NODEFER))
            sigaddset (&current->blocked, sig);
        recalc_sigpending ();
        spin_unlock_irq (& current -> sighand -> siglock);
    }
    return ret;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/signal_64.c.ifdefed" startline="397" endline="416">
{
    switch (current_syscall_ret (regs)) {
    case -ERESTART_RESTARTBLOCK :
    case -ERESTARTNOHAND :
        regs->ax = -EINTR;
        break;
    case -ERESTARTSYS :
        if (!(ka->sa.sa_flags & SA_RESTART)) {
            regs->ax = -EINTR;
            break;
        }
    case -ERESTARTNOINTR :
        regs->ax = regs->orig_ax;
        regs->ip -= 2;
        break;
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/signal_64.c.ifdefed" startline="399" endline="415">
{
case -ERESTART_RESTARTBLOCK :
case -ERESTARTNOHAND :
    regs->ax = -EINTR;
    break;
case -ERESTARTSYS :
    if (!(ka->sa.sa_flags & SA_RESTART)) {
        regs->ax = -EINTR;
        break;
    }
case -ERESTARTNOINTR :
    regs->ax = regs->orig_ax;
    regs->ip -= 2;
    break;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/signal_64.c.ifdefed" startline="406" endline="409">
{
    regs->ax = -EINTR;
    break;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/signal_64.c.ifdefed" startline="436" endline="465">
{
    set_fs (USER_DS);
    regs->flags &= ~X86_EFLAGS_DF;
    regs->flags &= ~X86_EFLAGS_TF;
    if (test_thread_flag (TIF_SINGLESTEP))
        ptrace_notify (SIGTRAP);
    spin_lock_irq (& current -> sighand -> siglock);
    sigorsets (& current -> blocked, & current -> blocked, & ka -> sa.sa_mask);
    if (!(ka->sa.sa_flags & SA_NODEFER))
        sigaddset (&current->blocked, sig);
    recalc_sigpending ();
    spin_unlock_irq (& current -> sighand -> siglock);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/signal_64.c.ifdefed" startline="476" endline="547">
{
    struct k_sigaction ka;
    siginfo_t info;
    int signr;
    sigset_t *oldset;
    if (!user_mode (regs))
        return;
    if (current_thread_info ()->status & TS_RESTORE_SIGMASK)
        oldset = &current->saved_sigmask;
    else
        oldset = &current->blocked;
    signr = get_signal_to_deliver (&info, &ka, regs, NULL);
    if (signr > 0) {
        if (current->thread.debugreg7)
            set_debugreg (current->thread.debugreg7, 7);
        if (handle_signal (signr, &info, &ka, oldset, regs) == 0) {
            current_thread_info ()->status &= ~TS_RESTORE_SIGMASK;
        }
        return;
    }
    if (current_syscall (regs) >= 0) {
        switch (current_syscall_ret (regs)) {
        case -ERESTARTNOHAND :
        case -ERESTARTSYS :
        case -ERESTARTNOINTR :
            regs->ax = regs->orig_ax;
            regs->ip -= 2;
            break;
        case -ERESTART_RESTARTBLOCK :
            regs->ax = test_thread_flag (TIF_IA32) ? __NR_ia32_restart_syscall : __NR_restart_syscall;
            regs->ip -= 2;
            break;
        }
    }
    if (current_thread_info ()->status & TS_RESTORE_SIGMASK) {
        current_thread_info ()->status &= ~TS_RESTORE_SIGMASK;
        sigprocmask (SIG_SETMASK, & current -> saved_sigmask, NULL);
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/signal_64.c.ifdefed" startline="498" endline="518">
{
    if (current->thread.debugreg7)
        set_debugreg (current->thread.debugreg7, 7);
    if (handle_signal (signr, &info, &ka, oldset, regs) == 0) {
        current_thread_info ()->status &= ~TS_RESTORE_SIGMASK;
    }
    return;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/signal_64.c.ifdefed" startline="508" endline="516">
{
    current_thread_info ()->status &= ~TS_RESTORE_SIGMASK;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/signal_64.c.ifdefed" startline="521" endline="537">
{
    switch (current_syscall_ret (regs)) {
    case -ERESTARTNOHAND :
    case -ERESTARTSYS :
    case -ERESTARTNOINTR :
        regs->ax = regs->orig_ax;
        regs->ip -= 2;
        break;
    case -ERESTART_RESTARTBLOCK :
        regs->ax = test_thread_flag (TIF_IA32) ? __NR_ia32_restart_syscall : __NR_restart_syscall;
        regs->ip -= 2;
        break;
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/signal_64.c.ifdefed" startline="523" endline="536">
{
case -ERESTARTNOHAND :
case -ERESTARTSYS :
case -ERESTARTNOINTR :
    regs->ax = regs->orig_ax;
    regs->ip -= 2;
    break;
case -ERESTART_RESTARTBLOCK :
    regs->ax = test_thread_flag (TIF_IA32) ? __NR_ia32_restart_syscall : __NR_restart_syscall;
    regs->ip -= 2;
    break;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/signal_64.c.ifdefed" startline="543" endline="546">
{
    current_thread_info ()->status &= ~TS_RESTORE_SIGMASK;
    sigprocmask (SIG_SETMASK, & current -> saved_sigmask, NULL);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/signal_64.c.ifdefed" startline="551" endline="561">
{
    if (thread_info_flags & _TIF_SIGPENDING)
        do_signal (regs);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/signal_64.c.ifdefed" startline="564" endline="574">
{
    struct task_struct *me = current;
    if (show_unhandled_signals && printk_ratelimit ()) {
        printk ("%s[%d] bad frame in %s frame:%p ip:%lx sp:%lx orax:%lx", me -> comm, me -> pid, where, frame, regs -> ip, regs -> sp, regs -> orig_ax);
        print_vma_addr (" in ", regs -> ip);
        printk ("\n");
    }
    force_sig (SIGSEGV, me);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/signal_64.c.ifdefed" startline="566" endline="571">
{
    printk ("%s[%d] bad frame in %s frame:%p ip:%lx sp:%lx orax:%lx", me -> comm, me -> pid, where, frame, regs -> ip, regs -> sp, regs -> orig_ax);
    print_vma_addr (" in ", regs -> ip);
    printk ("\n");
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/ptrace.c.ifdefed" startline="64" endline="66">
{
    return unlikely (value != 0 && (value & SEGMENT_RPL_MASK) != USER_RPL);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/ptrace.c.ifdefed" startline="148" endline="151">
{
    BUILD_BUG_ON (offsetof (struct pt_regs, r15) != 0);
    return &regs->r15 + (offset / sizeof (regs->r15));
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/ptrace.c.ifdefed" startline="154" endline="192">
{
    unsigned int seg;
    switch (offset) {
    case offsetof (struct user_regs_struct, fs) :
        if (task == current) {
            asm ("movl %%fs,%0"
                : "=r" (seg)
            ) return seg;
        }
        return task->thread.fsindex;
    case offsetof (struct user_regs_struct, gs) :
        if (task == current) {
            asm ("movl %%gs,%0"
                : "=r" (seg)
            ) return seg;
        }
        return task->thread.gsindex;
    case offsetof (struct user_regs_struct, ds) :
        if (task == current) {
            asm ("movl %%ds,%0"
                : "=r" (seg)
            ) return seg;
        }
        return task->thread.ds;
    case offsetof (struct user_regs_struct, es) :
        if (task == current) {
            asm ("movl %%es,%0"
                : "=r" (seg)
            ) return seg;
        }
        return task->thread.es;
    case offsetof (struct user_regs_struct, cs) :
    case offsetof (struct user_regs_struct, ss) :
        break;
    }
    return *pt_regs_access (task_pt_regs (task), offset);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/ptrace.c.ifdefed" startline="160" endline="190">
{
case offsetof (struct user_regs_struct, fs) :
    if (task == current) {
        asm ("movl %%fs,%0"
            : "=r" (seg)
        ) return seg;
    }
    return task->thread.fsindex;
case offsetof (struct user_regs_struct, gs) :
    if (task == current) {
        asm ("movl %%gs,%0"
            : "=r" (seg)
        ) return seg;
    }
    return task->thread.gsindex;
case offsetof (struct user_regs_struct, ds) :
    if (task == current) {
        asm ("movl %%ds,%0"
            : "=r" (seg)
        ) return seg;
    }
    return task->thread.ds;
case offsetof (struct user_regs_struct, es) :
    if (task == current) {
        asm ("movl %%es,%0"
            : "=r" (seg)
        ) return seg;
    }
    return task->thread.es;
case offsetof (struct user_regs_struct, cs) :
case offsetof (struct user_regs_struct, ss) :
    break;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/ptrace.c.ifdefed" startline="162" endline="166">
{
    asm ("movl %%fs,%0"
        : "=r" (seg)
    ) return seg;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/ptrace.c.ifdefed" startline="169" endline="172">
{
    asm ("movl %%gs,%0"
        : "=r" (seg)
    ) return seg;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/ptrace.c.ifdefed" startline="175" endline="178">
{
    asm ("movl %%ds,%0"
        : "=r" (seg)
    ) return seg;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/ptrace.c.ifdefed" startline="181" endline="184">
{
    asm ("movl %%es,%0"
        : "=r" (seg)
    ) return seg;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/ptrace.c.ifdefed" startline="196" endline="265">
{
    if (invalid_selector (value))
        return -EIO;
    switch (offset) {
    case offsetof (struct user_regs_struct, fs) :
        if ((value == FS_TLS_SEL && task->thread.fsindex == 0 && task->thread.fs != 0) || (value == 0 && task->thread.fsindex == FS_TLS_SEL && task->thread.fs == 0))
            break;
        task->thread.fsindex = value;
        if (task == current)
            loadsegment (fs, task->thread.fsindex);
        break;
    case offsetof (struct user_regs_struct, gs) :
        if ((value == GS_TLS_SEL && task->thread.gsindex == 0 && task->thread.gs != 0) || (value == 0 && task->thread.gsindex == GS_TLS_SEL && task->thread.gs == 0))
            break;
        task->thread.gsindex = value;
        if (task == current)
            load_gs_index (task->thread.gsindex);
        break;
    case offsetof (struct user_regs_struct, ds) :
        task->thread.ds = value;
        if (task == current)
            loadsegment (ds, task->thread.ds);
        break;
    case offsetof (struct user_regs_struct, es) :
        task->thread.es = value;
        if (task == current)
            loadsegment (es, task->thread.es);
        break;
    case offsetof (struct user_regs_struct, cs) :
        if (unlikely (value == 0))
            return -EIO;
        break;
    case offsetof (struct user_regs_struct, ss) :
        if (unlikely (value == 0))
            return -EIO;
        break;
    }
    return 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/ptrace.c.ifdefed" startline="203" endline="262">
{
case offsetof (struct user_regs_struct, fs) :
    if ((value == FS_TLS_SEL && task->thread.fsindex == 0 && task->thread.fs != 0) || (value == 0 && task->thread.fsindex == FS_TLS_SEL && task->thread.fs == 0))
        break;
    task->thread.fsindex = value;
    if (task == current)
        loadsegment (fs, task->thread.fsindex);
    break;
case offsetof (struct user_regs_struct, gs) :
    if ((value == GS_TLS_SEL && task->thread.gsindex == 0 && task->thread.gs != 0) || (value == 0 && task->thread.gsindex == GS_TLS_SEL && task->thread.gs == 0))
        break;
    task->thread.gsindex = value;
    if (task == current)
        load_gs_index (task->thread.gsindex);
    break;
case offsetof (struct user_regs_struct, ds) :
    task->thread.ds = value;
    if (task == current)
        loadsegment (ds, task->thread.ds);
    break;
case offsetof (struct user_regs_struct, es) :
    task->thread.es = value;
    if (task == current)
        loadsegment (es, task->thread.es);
    break;
case offsetof (struct user_regs_struct, cs) :
    if (unlikely (value == 0))
        return -EIO;
    break;
case offsetof (struct user_regs_struct, ss) :
    if (unlikely (value == 0))
        return -EIO;
    break;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/ptrace.c.ifdefed" startline="268" endline="274">
{
    return TASK_SIZE64 - 7;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/ptrace.c.ifdefed" startline="279" endline="289">
{
    unsigned long retval = task_pt_regs (task)->flags;
    if (test_tsk_thread_flag (task, TIF_FORCED_TF))
        retval &= ~X86_EFLAGS_TF;
    return retval;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/ptrace.c.ifdefed" startline="292" endline="308">
{
    struct pt_regs *regs = task_pt_regs (task);
    if (value & X86_EFLAGS_TF)
        clear_tsk_thread_flag (task, TIF_FORCED_TF);
    else if (test_tsk_thread_flag (task, TIF_FORCED_TF))
        value |= X86_EFLAGS_TF;
    regs->flags = (regs->flags & ~FLAG_MASK) | (value & FLAG_MASK);
    return 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/ptrace.c.ifdefed" startline="312" endline="361">
{
    switch (offset) {
    case offsetof (struct user_regs_struct, cs) :
    case offsetof (struct user_regs_struct, ds) :
    case offsetof (struct user_regs_struct, es) :
    case offsetof (struct user_regs_struct, fs) :
    case offsetof (struct user_regs_struct, gs) :
    case offsetof (struct user_regs_struct, ss) :
        return set_segment_reg (child, offset, value);
    case offsetof (struct user_regs_struct, flags) :
        return set_flags (child, value);
    }
    *pt_regs_access (task_pt_regs (child), offset) = value;
    return 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/ptrace.c.ifdefed" startline="313" endline="357">
{
case offsetof (struct user_regs_struct, cs) :
case offsetof (struct user_regs_struct, ds) :
case offsetof (struct user_regs_struct, es) :
case offsetof (struct user_regs_struct, fs) :
case offsetof (struct user_regs_struct, gs) :
case offsetof (struct user_regs_struct, ss) :
    return set_segment_reg (child, offset, value);
case offsetof (struct user_regs_struct, flags) :
    return set_flags (child, value);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/ptrace.c.ifdefed" startline="364" endline="410">
{
    switch (offset) {
    case offsetof (struct user_regs_struct, cs) :
    case offsetof (struct user_regs_struct, ds) :
    case offsetof (struct user_regs_struct, es) :
    case offsetof (struct user_regs_struct, fs) :
    case offsetof (struct user_regs_struct, gs) :
    case offsetof (struct user_regs_struct, ss) :
        return get_segment_reg (task, offset);
    case offsetof (struct user_regs_struct, flags) :
        return get_flags (task);
    }
    return *pt_regs_access (task_pt_regs (task), offset);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/ptrace.c.ifdefed" startline="365" endline="407">
{
case offsetof (struct user_regs_struct, cs) :
case offsetof (struct user_regs_struct, ds) :
case offsetof (struct user_regs_struct, es) :
case offsetof (struct user_regs_struct, fs) :
case offsetof (struct user_regs_struct, gs) :
case offsetof (struct user_regs_struct, ss) :
    return get_segment_reg (task, offset);
case offsetof (struct user_regs_struct, flags) :
    return get_flags (task);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/ptrace.c.ifdefed" startline="416" endline="435">
{
    if (kbuf) {
        unsigned long *k = kbuf;
        while (count > 0) {
            *k++ = getreg (target, pos);
            count -= sizeof (*k);
            pos += sizeof (*k);
        }
    }
    else {
        unsigned long __user *u = ubuf;
        while (count > 0) {
            if (__put_user (getreg (target, pos), u++))
                return -EFAULT;
            count -= sizeof (*u);
            pos += sizeof (*u);
        }
    }
    return 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/ptrace.c.ifdefed" startline="417" endline="424">
{
    unsigned long *k = kbuf;
    while (count > 0) {
        *k++ = getreg (target, pos);
        count -= sizeof (*k);
        pos += sizeof (*k);
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/ptrace.c.ifdefed" startline="419" endline="423">
{
    *k++ = getreg (target, pos);
    count -= sizeof (*k);
    pos += sizeof (*k);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/ptrace.c.ifdefed" startline="424" endline="432">
{
    unsigned long __user *u = ubuf;
    while (count > 0) {
        if (__put_user (getreg (target, pos), u++))
            return -EFAULT;
        count -= sizeof (*u);
        pos += sizeof (*u);
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/ptrace.c.ifdefed" startline="426" endline="431">
{
    if (__put_user (getreg (target, pos), u++))
        return -EFAULT;
    count -= sizeof (*u);
    pos += sizeof (*u);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/ptrace.c.ifdefed" startline="441" endline="463">
{
    int ret = 0;
    if (kbuf) {
        const unsigned long *k = kbuf;
        while (count > 0 && !ret) {
            ret = putreg (target, pos, *k++);
            count -= sizeof (*k);
            pos += sizeof (*k);
        }
    }
    else {
        const unsigned long __user *u = ubuf;
        while (count > 0 && !ret) {
            unsigned long word;
            ret = __get_user (word, u++);
            if (ret)
                break;
            ret = putreg (target, pos, word);
            count -= sizeof (*u);
            pos += sizeof (*u);
        }
    }
    return ret;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/ptrace.c.ifdefed" startline="443" endline="450">
{
    const unsigned long *k = kbuf;
    while (count > 0 && !ret) {
        ret = putreg (target, pos, *k++);
        count -= sizeof (*k);
        pos += sizeof (*k);
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/ptrace.c.ifdefed" startline="445" endline="449">
{
    ret = putreg (target, pos, *k++);
    count -= sizeof (*k);
    pos += sizeof (*k);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/ptrace.c.ifdefed" startline="450" endline="461">
{
    const unsigned long __user *u = ubuf;
    while (count > 0 && !ret) {
        unsigned long word;
        ret = __get_user (word, u++);
        if (ret)
            break;
        ret = putreg (target, pos, word);
        count -= sizeof (*u);
        pos += sizeof (*u);
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/ptrace.c.ifdefed" startline="452" endline="460">
{
    unsigned long word;
    ret = __get_user (word, u++);
    if (ret)
        break;
    ret = putreg (target, pos, word);
    count -= sizeof (*u);
    pos += sizeof (*u);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/ptrace.c.ifdefed" startline="471" endline="481">
{
    switch (n) {
    case 0 :
        return child->thread.debugreg0;
    case 1 :
        return child->thread.debugreg1;
    case 2 :
        return child->thread.debugreg2;
    case 3 :
        return child->thread.debugreg3;
    case 6 :
        return child->thread.debugreg6;
    case 7 :
        return child->thread.debugreg7;
    }
    return 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/ptrace.c.ifdefed" startline="472" endline="479">
{
case 0 :
    return child->thread.debugreg0;
case 1 :
    return child->thread.debugreg1;
case 2 :
    return child->thread.debugreg2;
case 3 :
    return child->thread.debugreg3;
case 6 :
    return child->thread.debugreg6;
case 7 :
    return child->thread.debugreg7;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/ptrace.c.ifdefed" startline="485" endline="555">
{
    int i;
    if (unlikely (n == 4 || n == 5))
        return -EIO;
    if (n < 4 && unlikely (data >= debugreg_addr_limit (child)))
        return -EIO;
    switch (n) {
    case 0 :
        child->thread.debugreg0 = data;
        break;
    case 1 :
        child->thread.debugreg1 = data;
        break;
    case 2 :
        child->thread.debugreg2 = data;
        break;
    case 3 :
        child->thread.debugreg3 = data;
        break;
    case 6 :
        if ((data & ~0xffffffffUL) != 0)
            return -EIO;
        child->thread.debugreg6 = data;
        break;
    case 7 :
        data &= ~DR_CONTROL_RESERVED;
        for (i = 0; i < 4; i++)
            if ((DR7_MASK >> ((data >> (16 + 4 * i)) & 0xf)) & 1)
                return -EIO;
        child->thread.debugreg7 = data;
        if (data)
            set_tsk_thread_flag (child, TIF_DEBUG);
        else
            clear_tsk_thread_flag (child, TIF_DEBUG);
        break;
    }
    return 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/ptrace.c.ifdefed" startline="494" endline="552">
{
case 0 :
    child->thread.debugreg0 = data;
    break;
case 1 :
    child->thread.debugreg1 = data;
    break;
case 2 :
    child->thread.debugreg2 = data;
    break;
case 3 :
    child->thread.debugreg3 = data;
    break;
case 6 :
    if ((data & ~0xffffffffUL) != 0)
        return -EIO;
    child->thread.debugreg6 = data;
    break;
case 7 :
    data &= ~DR_CONTROL_RESERVED;
    for (i = 0; i < 4; i++)
        if ((DR7_MASK >> ((data >> (16 + 4 * i)) & 0xf)) & 1)
            return -EIO;
    child->thread.debugreg7 = data;
    if (data)
        set_tsk_thread_flag (child, TIF_DEBUG);
    else
        clear_tsk_thread_flag (child, TIF_DEBUG);
    break;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/ptrace.c.ifdefed" startline="850" endline="864">
{
    user_disable_single_step (child);
    if (child->thread.ds_area_msr) {
        child->thread.debugctlmsr &= ~ds_debugctl_mask ();
        if (!child->thread.debugctlmsr)
            clear_tsk_thread_flag (child, TIF_DEBUGCTLMSR);
        clear_tsk_thread_flag (child, TIF_BTS_TRACE_TS);
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/ptrace.c.ifdefed" startline="855" endline="863">
{
    child->thread.debugctlmsr &= ~ds_debugctl_mask ();
    if (!child->thread.debugctlmsr)
        clear_tsk_thread_flag (child, TIF_DEBUGCTLMSR);
    clear_tsk_thread_flag (child, TIF_BTS_TRACE_TS);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/ptrace.c.ifdefed" startline="871" endline="1019">
{
    int ret;
    unsigned long __user *datap = (unsigned long __user *) data;
    switch (request) {
    case PTRACE_PEEKUSR :
        {
            unsigned long tmp;
            ret = -EIO;
            if ((addr & (sizeof (data) - 1)) || addr < 0 || addr >= sizeof (struct user))
                break;
            tmp = 0;
            if (addr < sizeof (struct user_regs_struct))
                tmp = getreg (child, addr);
            else if (addr >= offsetof (struct user, u_debugreg[0]) && addr <= offsetof (struct user, u_debugreg[7])) {
                addr -= offsetof (struct user, u_debugreg[0]);
                tmp = ptrace_get_debugreg (child, addr / sizeof (data));
            }
            ret = put_user (tmp, datap);
            break;
        }
    case PTRACE_POKEUSR :
        ret = -EIO;
        if ((addr & (sizeof (data) - 1)) || addr < 0 || addr >= sizeof (struct user))
            break;
        if (addr < sizeof (struct user_regs_struct))
            ret = putreg (child, addr, data);
        else if (addr >= offsetof (struct user, u_debugreg[0]) && addr <= offsetof (struct user, u_debugreg[7])) {
            addr -= offsetof (struct user, u_debugreg[0]);
            ret = ptrace_set_debugreg (child, addr / sizeof (data), data);
        }
        break;
    case PTRACE_GETREGS :
        return copy_regset_to_user (child, task_user_regset_view (current), REGSET_GENERAL, 0, sizeof (struct user_regs_struct), datap);
    case PTRACE_SETREGS :
        return copy_regset_from_user (child, task_user_regset_view (current), REGSET_GENERAL, 0, sizeof (struct user_regs_struct), datap);
    case PTRACE_GETFPREGS :
        return copy_regset_to_user (child, task_user_regset_view (current), REGSET_FP, 0, sizeof (struct user_i387_struct), datap);
    case PTRACE_SETFPREGS :
        return copy_regset_from_user (child, task_user_regset_view (current), REGSET_FP, 0, sizeof (struct user_i387_struct), datap);
    default :
        ret = ptrace_request (child, request, addr, data);
        break;
    }
    return ret;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/ptrace.c.ifdefed" startline="875" endline="1016">
{
case PTRACE_PEEKUSR :
    {
        unsigned long tmp;
        ret = -EIO;
        if ((addr & (sizeof (data) - 1)) || addr < 0 || addr >= sizeof (struct user))
            break;
        tmp = 0;
        if (addr < sizeof (struct user_regs_struct))
            tmp = getreg (child, addr);
        else if (addr >= offsetof (struct user, u_debugreg[0]) && addr <= offsetof (struct user, u_debugreg[7])) {
            addr -= offsetof (struct user, u_debugreg[0]);
            tmp = ptrace_get_debugreg (child, addr / sizeof (data));
        }
        ret = put_user (tmp, datap);
        break;
    }
case PTRACE_POKEUSR :
    ret = -EIO;
    if ((addr & (sizeof (data) - 1)) || addr < 0 || addr >= sizeof (struct user))
        break;
    if (addr < sizeof (struct user_regs_struct))
        ret = putreg (child, addr, data);
    else if (addr >= offsetof (struct user, u_debugreg[0]) && addr <= offsetof (struct user, u_debugreg[7])) {
        addr -= offsetof (struct user, u_debugreg[0]);
        ret = ptrace_set_debugreg (child, addr / sizeof (data), data);
    }
    break;
case PTRACE_GETREGS :
    return copy_regset_to_user (child, task_user_regset_view (current), REGSET_GENERAL, 0, sizeof (struct user_regs_struct), datap);
case PTRACE_SETREGS :
    return copy_regset_from_user (child, task_user_regset_view (current), REGSET_GENERAL, 0, sizeof (struct user_regs_struct), datap);
case PTRACE_GETFPREGS :
    return copy_regset_to_user (child, task_user_regset_view (current), REGSET_FP, 0, sizeof (struct user_i387_struct), datap);
case PTRACE_SETFPREGS :
    return copy_regset_from_user (child, task_user_regset_view (current), REGSET_FP, 0, sizeof (struct user_i387_struct), datap);
default :
    ret = ptrace_request (child, request, addr, data);
    break;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/ptrace.c.ifdefed" startline="877" endline="895">
{
    unsigned long tmp;
    ret = -EIO;
    if ((addr & (sizeof (data) - 1)) || addr < 0 || addr >= sizeof (struct user))
        break;
    tmp = 0;
    if (addr < sizeof (struct user_regs_struct))
        tmp = getreg (child, addr);
    else if (addr >= offsetof (struct user, u_debugreg[0]) && addr <= offsetof (struct user, u_debugreg[7])) {
        addr -= offsetof (struct user, u_debugreg[0]);
        tmp = ptrace_get_debugreg (child, addr / sizeof (data));
    }
    ret = put_user (tmp, datap);
    break;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/ptrace.c.ifdefed" startline="889" endline="892">
{
    addr -= offsetof (struct user, u_debugreg[0]);
    tmp = ptrace_get_debugreg (child, addr / sizeof (data));
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/ptrace.c.ifdefed" startline="906" endline="910">
{
    addr -= offsetof (struct user, u_debugreg[0]);
    ret = ptrace_set_debugreg (child, addr / sizeof (data), data);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/ptrace.c.ifdefed" startline="1348" endline="1358">
{
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/ptrace.c.ifdefed" startline="1361" endline="1376">
{
    struct siginfo info;
    tsk->thread.trap_no = 1;
    tsk->thread.error_code = error_code;
    memset (& info, 0, sizeof (info));
    info.si_signo = SIGTRAP;
    info.si_code = TRAP_BRKPT;
    info.si_addr = user_mode_vm (regs) ? (void __user *) regs->ip : NULL;
    force_sig_info (SIGTRAP, & info, tsk);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/ptrace.c.ifdefed" startline="1379" endline="1401">
{
    if (!(current->ptrace & PT_PTRACED))
        return;
    ptrace_notify (SIGTRAP | ((current -> ptrace & PT_TRACESYSGOOD) ? 0x80 : 0));
    if (current->exit_code) {
        send_sig (current -> exit_code, current, 1);
        current->exit_code = 0;
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/ptrace.c.ifdefed" startline="1397" endline="1400">
{
    send_sig (current -> exit_code, current, 1);
    current->exit_code = 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/ptrace.c.ifdefed" startline="1416" endline="1454">
{
    long ret = 0;
    if (test_thread_flag (TIF_SINGLESTEP))
        regs->flags |= X86_EFLAGS_TF;
    secure_computing (regs -> orig_ax);
    if (unlikely (test_thread_flag (TIF_SYSCALL_EMU)))
        ret = -1L;
    if (ret || test_thread_flag (TIF_SYSCALL_TRACE))
        syscall_trace (regs);
    if (unlikely (current->audit_context)) {
        if (IS_IA32)
            audit_syscall_entry (AUDIT_ARCH_I386, regs->orig_ax, regs->bx, regs->cx, regs->dx, regs->si);
    }
    return ret ? : regs->orig_ax;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/ptrace.c.ifdefed" startline="1438" endline="1451">
{
    if (IS_IA32)
        audit_syscall_entry (AUDIT_ARCH_I386, regs->orig_ax, regs->bx, regs->cx, regs->dx, regs->si);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/ptrace.c.ifdefed" startline="1457" endline="1480">
{
    if (unlikely (current->audit_context))
        audit_syscall_exit (AUDITSC_RESULT (regs->ax), regs->ax);
    if (test_thread_flag (TIF_SYSCALL_TRACE))
        syscall_trace (regs);
    if (unlikely (test_thread_flag (TIF_SYSCALL_EMU)))
        return;
    if (test_thread_flag (TIF_SINGLESTEP) && (current->ptrace & PT_PTRACED))
        send_sigtrap (current, regs, 0);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/trampoline.c.ifdefed" startline="14" endline="18">
{
    memcpy (trampoline_base, trampoline_data, trampoline_end - trampoline_data);
    return virt_to_phys (trampoline_base);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/tce_64.c.ifdefed" startline="40" endline="46">
{
    if (cpu_has_clflush)
        clflush (tceaddr);
    else
        wbinvd ();
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/tce_64.c.ifdefed" startline="50" endline="72">
{
    u64 *tp;
    u64 t;
    u64 rpn;
    t = (1 << TCE_READ_SHIFT);
    if (direction != DMA_TO_DEVICE)
        t |= (1 << TCE_WRITE_SHIFT);
    tp = ((u64 *) tbl->it_base) + index;
    while (npages--) {
        rpn = (virt_to_bus ((void *) uaddr)) >> PAGE_SHIFT;
        t &= ~TCE_RPN_MASK;
        t |= (rpn << TCE_RPN_SHIFT);
        *tp = cpu_to_be64 (t);
        flush_tce (tp);
        uaddr += PAGE_SIZE;
        tp++;
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/tce_64.c.ifdefed" startline="61" endline="71">
{
    rpn = (virt_to_bus ((void *) uaddr)) >> PAGE_SHIFT;
    t &= ~TCE_RPN_MASK;
    t |= (rpn << TCE_RPN_SHIFT);
    *tp = cpu_to_be64 (t);
    flush_tce (tp);
    uaddr += PAGE_SIZE;
    tp++;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/tce_64.c.ifdefed" startline="75" endline="85">
{
    u64 *tp;
    tp = ((u64 *) tbl->it_base) + index;
    while (npages--) {
        *tp = cpu_to_be64 (0);
        flush_tce (tp);
        tp++;
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/tce_64.c.ifdefed" startline="80" endline="84">
{
    *tp = cpu_to_be64 (0);
    flush_tce (tp);
    tp++;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/tce_64.c.ifdefed" startline="88" endline="95">
{
    return (1 << size) << 13;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/tce_64.c.ifdefed" startline="98" endline="132">
{
    unsigned int bitmapsz;
    unsigned long bmppages;
    int ret;
    tbl->it_busno = dev->bus->number;
    tbl->it_size = table_size_to_number_of_entries (specified_table_size);
    bitmapsz = tbl->it_size / BITS_PER_BYTE;
    bmppages = __get_free_pages (GFP_KERNEL, get_order (bitmapsz));
    if (!bmppages) {
        printk (KERN_ERR "Calgary: cannot allocate bitmap\n");
        ret = -ENOMEM;
        goto done;
    }
    tbl->it_map = (unsigned long *) bmppages;
    memset (tbl -> it_map, 0, bitmapsz);
    tbl->it_hint = 0;
    spin_lock_init (& tbl -> it_lock);
    return 0;
done :
    return ret;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/tce_64.c.ifdefed" startline="114" endline="118">
{
    printk (KERN_ERR "Calgary: cannot allocate bitmap\n");
    ret = -ENOMEM;
    goto done;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/tce_64.c.ifdefed" startline="135" endline="166">
{
    struct iommu_table *tbl;
    int ret;
    if (pci_iommu (dev->bus)) {
        printk (KERN_ERR "Calgary: dev %p has sysdata->iommu %p\n", dev, pci_iommu (dev -> bus));
        BUG ();
    }
    tbl = kzalloc (sizeof (struct iommu_table), GFP_KERNEL);
    if (!tbl) {
        printk (KERN_ERR "Calgary: error allocating iommu_table\n");
        ret = -ENOMEM;
        goto done;
    }
    ret = tce_table_setparms (dev, tbl);
    if (ret)
        goto free_tbl;
    tbl->bbar = bbar;
    set_pci_iommu (dev -> bus, tbl);
    return 0;
free_tbl :
    kfree (tbl);
done :
    return ret;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/tce_64.c.ifdefed" startline="139" endline="143">
{
    printk (KERN_ERR "Calgary: dev %p has sysdata->iommu %p\n", dev, pci_iommu (dev -> bus));
    BUG ();
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/tce_64.c.ifdefed" startline="146" endline="150">
{
    printk (KERN_ERR "Calgary: error allocating iommu_table\n");
    ret = -ENOMEM;
    goto done;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/tce_64.c.ifdefed" startline="169" endline="176">
{
    unsigned int size;
    size = table_size_to_number_of_entries (specified_table_size);
    size *= TCE_ENTRY_SIZE;
    return __alloc_bootmem_low (size, size, 0);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/tce_64.c.ifdefed" startline="179" endline="189">
{
    unsigned int size;
    if (!tbl)
        return;
    size = table_size_to_number_of_entries (specified_table_size);
    size *= TCE_ENTRY_SIZE;
    free_bootmem (__pa (tbl), size);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/pci-nommu.c.ifdefed" startline="16" endline="26">
{
    if (hwdev && bus + size > *hwdev->dma_mask) {
        if (*hwdev->dma_mask >= DMA_32BIT_MASK)
            printk (KERN_ERR "nommu_%s: overflow %Lx+%zu of device mask %Lx\n", name, (long long) bus, size, (long long) *hwdev->dma_mask);
        return 0;
    }
    return 1;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/pci-nommu.c.ifdefed" startline="17" endline="24">
{
    if (*hwdev->dma_mask >= DMA_32BIT_MASK)
        printk (KERN_ERR "nommu_%s: overflow %Lx+%zu of device mask %Lx\n", name, (long long) bus, size, (long long) *hwdev->dma_mask);
    return 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/pci-nommu.c.ifdefed" startline="31" endline="38">
{
    dma_addr_t bus = paddr;
    WARN_ON (size == 0);
    if (!check_addr ("map_single", hwdev, bus, size))
        return bad_dma_address;
    flush_write_buffers ();
    return bus;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/pci-nommu.c.ifdefed" startline="58" endline="73">
{
    struct scatterlist *s;
    int i;
    WARN_ON (nents == 0 || sg [0].length == 0);

    for_each_sg (sg, s, nents, i) {
        BUG_ON (! sg_page (s));
        s->dma_address = sg_phys (s);
        if (!check_addr ("map_sg", hwdev, s->dma_address, s->length))
            return 0;
        s->dma_length = s->length;
    }

    flush_write_buffers ();
    return nents;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/pci-nommu.c.ifdefed" startline="64" endline="70">
{
    BUG_ON (! sg_page (s));
    s->dma_address = sg_phys (s);
    if (!check_addr ("map_sg", hwdev, s->dma_address, s->length))
        return 0;
    s->dma_length = s->length;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/pci-nommu.c.ifdefed" startline="82" endline="88">
{
    if (dma_ops)
        return;
    force_iommu = 0;
    dma_ops = &nommu_dma_ops;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/pci-dma.c.ifdefed" startline="51" endline="58">
{
    if (!dev->dma_mask || !dma_supported (dev, mask))
        return -EIO;
    *dev->dma_mask = mask;
    return 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/pci-dma.c.ifdefed" startline="141" endline="200">
{
    iommu_merge = 1;
    if (!p)
        return -EINVAL;
    while (*p) {
        if (!strncmp (p, "off", 3))
            no_iommu = 1;
        if (!strncmp (p, "force", 5))
            force_iommu = 1;
        if (!strncmp (p, "noforce", 7)) {
            iommu_merge = 0;
            force_iommu = 0;
        }
        if (!strncmp (p, "biomerge", 8)) {
            iommu_bio_merge = 4096;
            iommu_merge = 1;
            force_iommu = 1;
        }
        if (!strncmp (p, "panic", 5))
            panic_on_overflow = 1;
        if (!strncmp (p, "nopanic", 7))
            panic_on_overflow = 0;
        if (!strncmp (p, "merge", 5)) {
            iommu_merge = 1;
            force_iommu = 1;
        }
        if (!strncmp (p, "nomerge", 7))
            iommu_merge = 0;
        if (!strncmp (p, "forcesac", 8))
            iommu_sac_force = 1;
        if (!strncmp (p, "allowdac", 8))
            forbid_dac = 0;
        if (!strncmp (p, "nodac", 5))
            forbid_dac = -1;
        if (!strncmp (p, "usedac", 6)) {
            forbid_dac = -1;
            return 1;
        }
        gart_parse_options (p);
        p += strcspn (p, ",");
        if (*p == ',')
            ++p;
    }
    return 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/pci-dma.c.ifdefed" startline="147" endline="198">
{
    if (!strncmp (p, "off", 3))
        no_iommu = 1;
    if (!strncmp (p, "force", 5))
        force_iommu = 1;
    if (!strncmp (p, "noforce", 7)) {
        iommu_merge = 0;
        force_iommu = 0;
    }
    if (!strncmp (p, "biomerge", 8)) {
        iommu_bio_merge = 4096;
        iommu_merge = 1;
        force_iommu = 1;
    }
    if (!strncmp (p, "panic", 5))
        panic_on_overflow = 1;
    if (!strncmp (p, "nopanic", 7))
        panic_on_overflow = 0;
    if (!strncmp (p, "merge", 5)) {
        iommu_merge = 1;
        force_iommu = 1;
    }
    if (!strncmp (p, "nomerge", 7))
        iommu_merge = 0;
    if (!strncmp (p, "forcesac", 8))
        iommu_sac_force = 1;
    if (!strncmp (p, "allowdac", 8))
        forbid_dac = 0;
    if (!strncmp (p, "nodac", 5))
        forbid_dac = -1;
    if (!strncmp (p, "usedac", 6)) {
        forbid_dac = -1;
        return 1;
    }
    gart_parse_options (p);
    p += strcspn (p, ",");
    if (*p == ',')
        ++p;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/pci-dma.c.ifdefed" startline="153" endline="156">
{
    iommu_merge = 0;
    force_iommu = 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/pci-dma.c.ifdefed" startline="158" endline="162">
{
    iommu_bio_merge = 4096;
    iommu_merge = 1;
    force_iommu = 1;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/pci-dma.c.ifdefed" startline="167" endline="170">
{
    iommu_merge = 1;
    force_iommu = 1;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/pci-dma.c.ifdefed" startline="179" endline="182">
{
    forbid_dac = -1;
    return 1;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/pci-dma.c.ifdefed" startline="204" endline="241">
{
    struct dma_mapping_ops *ops = get_dma_ops (dev);
    if (ops->dma_supported)
        return ops->dma_supported (dev, mask);
    if (mask < DMA_24BIT_MASK)
        return 0;
    if (iommu_sac_force && (mask >= DMA_40BIT_MASK)) {
        dev_info (dev, "Force SAC with mask %Lx\n", mask);
        return 0;
    }
    return 1;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/pci-dma.c.ifdefed" startline="235" endline="238">
{
    dev_info (dev, "Force SAC with mask %Lx\n", mask);
    return 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/pci-dma.c.ifdefed" startline="247" endline="253">
{
    int node;
    node = dev_to_node (dev);
    return alloc_pages_node (node, gfp, order);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/pci-dma.c.ifdefed" startline="261" endline="363">
{
    struct dma_mapping_ops *ops = get_dma_ops (dev);
    void *memory = NULL;
    struct page *page;
    unsigned long dma_mask = 0;
    dma_addr_t bus;
    int noretry = 0;
    gfp &= ~(__GFP_DMA | __GFP_HIGHMEM | __GFP_DMA32);
    if (dma_alloc_from_coherent (dev, size, dma_handle, &memory))
        return memory;
    if (!dev) {
        dev = &fallback_dev;
        gfp |= GFP_DMA;
    }
    dma_mask = dev->coherent_dma_mask;
    if (dma_mask == 0)
        dma_mask = (gfp & GFP_DMA) ? DMA_24BIT_MASK : DMA_32BIT_MASK;
    if (dev->dma_mask == NULL)
        return NULL;
    if (gfp & __GFP_DMA)
        noretry = 1;
again :
    page = dma_alloc_pages (dev, noretry ? gfp | __GFP_NORETRY : gfp, get_order (size));
    if (page == NULL)
        return NULL;
    {
        int high, mmu;
        bus = page_to_phys (page);
        memory = page_address (page);
        high = (bus + size) >= dma_mask;
        mmu = high;
        if (force_iommu && !(gfp & GFP_DMA))
            mmu = 1;
        else if (high) {
            free_pages ((unsigned long) memory, get_order (size));
            if (dma_mask < DMA_32BIT_MASK && !(gfp & GFP_DMA)) {
                gfp = (gfp & ~GFP_DMA32) | GFP_DMA;
                goto again;
            }
            gfp &= ~(GFP_DMA32 | GFP_DMA);
            if (ops->alloc_coherent)
                return ops->alloc_coherent (dev, size, dma_handle, gfp);
            return NULL;
        }
        memset (memory, 0, size);
        if (!mmu) {
            *dma_handle = bus;
            return memory;
        }
    }
    if (ops->alloc_coherent) {
        free_pages ((unsigned long) memory, get_order (size));
        gfp &= ~(GFP_DMA | GFP_DMA32);
        return ops->alloc_coherent (dev, size, dma_handle, gfp);
    }
    if (ops->map_simple) {
        *dma_handle = ops->map_simple (dev, virt_to_phys (memory), size, PCI_DMA_BIDIRECTIONAL);
        if (*dma_handle != bad_dma_address)
            return memory;
    }
    if (panic_on_overflow)
        panic ("dma_alloc_coherent: IOMMU overflow by %lu bytes\n", (unsigned long) size);
    free_pages ((unsigned long) memory, get_order (size));
    return NULL;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/pci-dma.c.ifdefed" startline="275" endline="278">
{
    dev = &fallback_dev;
    gfp |= GFP_DMA;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/pci-dma.c.ifdefed" startline="309" endline="342">
{
    int high, mmu;
    bus = page_to_phys (page);
    memory = page_address (page);
    high = (bus + size) >= dma_mask;
    mmu = high;
    if (force_iommu && !(gfp & GFP_DMA))
        mmu = 1;
    else if (high) {
        free_pages ((unsigned long) memory, get_order (size));
        if (dma_mask < DMA_32BIT_MASK && !(gfp & GFP_DMA)) {
            gfp = (gfp & ~GFP_DMA32) | GFP_DMA;
            goto again;
        }
        gfp &= ~(GFP_DMA32 | GFP_DMA);
        if (ops->alloc_coherent)
            return ops->alloc_coherent (dev, size, dma_handle, gfp);
        return NULL;
    }
    memset (memory, 0, size);
    if (!mmu) {
        *dma_handle = bus;
        return memory;
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/pci-dma.c.ifdefed" startline="317" endline="335">
{
    free_pages ((unsigned long) memory, get_order (size));
    if (dma_mask < DMA_32BIT_MASK && !(gfp & GFP_DMA)) {
        gfp = (gfp & ~GFP_DMA32) | GFP_DMA;
        goto again;
    }
    gfp &= ~(GFP_DMA32 | GFP_DMA);
    if (ops->alloc_coherent)
        return ops->alloc_coherent (dev, size, dma_handle, gfp);
    return NULL;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/pci-dma.c.ifdefed" startline="323" endline="326">
{
    gfp = (gfp & ~GFP_DMA32) | GFP_DMA;
    goto again;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/pci-dma.c.ifdefed" startline="338" endline="341">
{
    *dma_handle = bus;
    return memory;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/pci-dma.c.ifdefed" startline="344" endline="348">
{
    free_pages ((unsigned long) memory, get_order (size));
    gfp &= ~(GFP_DMA | GFP_DMA32);
    return ops->alloc_coherent (dev, size, dma_handle, gfp);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/pci-dma.c.ifdefed" startline="350" endline="356">
{
    *dma_handle = ops->map_simple (dev, virt_to_phys (memory), size, PCI_DMA_BIDIRECTIONAL);
    if (*dma_handle != bad_dma_address)
        return memory;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/pci-dma.c.ifdefed" startline="372" endline="382">
{
    struct dma_mapping_ops *ops = get_dma_ops (dev);
    int order = get_order (size);
    WARN_ON (irqs_disabled ());
    if (dma_release_from_coherent (dev, order, vaddr))
        return;
    if (ops->unmap_single)
        ops->unmap_single (dev, bus, size, 0);
    free_pages ((unsigned long) vaddr, order);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/pci-dma.c.ifdefed" startline="386" endline="397">
{
    calgary_iommu_init ();
    intel_iommu_init ();
    amd_iommu_init ();
    gart_iommu_init ();
    no_iommu_init ();
    return 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/pci-dma.c.ifdefed" startline="400" endline="402">
{
    gart_iommu_shutdown ();
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/audit_64.c.ifdefed" startline="32" endline="38">
{
    return 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/audit_64.c.ifdefed" startline="41" endline="57">
{
    switch (syscall) {
    case __NR_open :
        return 2;
    case __NR_openat :
        return 3;
    case __NR_execve :
        return 5;
    default :
        return 0;
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/audit_64.c.ifdefed" startline="47" endline="56">
{
case __NR_open :
    return 2;
case __NR_openat :
    return 3;
case __NR_execve :
    return 5;
default :
    return 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/audit_64.c.ifdefed" startline="60" endline="79">
{
    audit_register_class (AUDIT_CLASS_WRITE, write_class);
    audit_register_class (AUDIT_CLASS_READ, read_class);
    audit_register_class (AUDIT_CLASS_DIR_WRITE, dir_class);
    audit_register_class (AUDIT_CLASS_CHATTR, chattr_class);
    audit_register_class (AUDIT_CLASS_SIGNAL, signal_class);
    return 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/addon_cpuid_features.c.ifdefed" startline="25" endline="49">
{
    u32 max_level;
    u32 regs [4];
    const struct cpuid_bit *cb;
    static const struct cpuid_bit cpuid_bits [] = {{X86_FEATURE_IDA, CR_EAX, 1, 0x00000006}, {0, 0, 0, 0}};
    for (cb = cpuid_bits; cb->feature; cb++) {
        max_level = cpuid_eax (cb->level & 0xffff0000);
        if (max_level < cb->level || max_level > (cb->level | 0xffff))
            continue;
        cpuid (cb -> level, & regs [CR_EAX], & regs [CR_EBX], & regs [CR_ECX], & regs [CR_EDX]);
        if (regs[cb->reg] & (1 << cb->bit))
            set_cpu_cap (c, cb->feature);
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/addon_cpuid_features.c.ifdefed" startline="35" endline="48">
{
    max_level = cpuid_eax (cb->level & 0xffff0000);
    if (max_level < cb->level || max_level > (cb->level | 0xffff))
        continue;
    cpuid (cb -> level, & regs [CR_EAX], & regs [CR_EBX], & regs [CR_ECX], & regs [CR_EDX]);
    if (regs[cb->reg] & (1 << cb->bit))
        set_cpu_cap (c, cb->feature);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/intel_cacheinfo.c.ifdefed" startline="188" endline="252">
{
    unsigned dummy;
    unsigned line_size, lines_per_tag, assoc, size_in_kb;
    union l1_cache l1i, l1d;
    union l2_cache l2;
    union l3_cache l3;
    union l1_cache *l1 = &l1d;
    eax->full = 0;
    ebx->full = 0;
    ecx->full = 0;
    cpuid (0x80000005, & dummy, & dummy, & l1d.val, & l1i.val);
    cpuid (0x80000006, & dummy, & dummy, & l2.val, & l3.val);
    switch (leaf) {
    case 1 :
        l1 = &l1i;
    case 0 :
        if (!l1->val)
            return;
        assoc = l1->assoc;
        line_size = l1->line_size;
        lines_per_tag = l1->lines_per_tag;
        size_in_kb = l1->size_in_kb;
        break;
    case 2 :
        if (!l2.val)
            return;
        assoc = l2.assoc;
        line_size = l2.line_size;
        lines_per_tag = l2.lines_per_tag;
        size_in_kb = current_cpu_data.x86_cache_size;
        break;
    case 3 :
        if (!l3.val)
            return;
        assoc = l3.assoc;
        line_size = l3.line_size;
        lines_per_tag = l3.lines_per_tag;
        size_in_kb = l3.size_encoded * 512;
        break;
    default :
        return;
    }
    eax->split.is_self_initializing = 1;
    eax->split.type = types[leaf];
    eax->split.level = levels[leaf];
    if (leaf == 3)
        eax->split.num_threads_sharing = current_cpu_data.x86_max_cores - 1;
    else
        eax->split.num_threads_sharing = 0;
    eax->split.num_cores_on_die = current_cpu_data.x86_max_cores - 1;
    if (assoc == 0xf)
        eax->split.is_fully_associative = 1;
    ebx->split.coherency_line_size = line_size - 1;
    ebx->split.ways_of_associativity = assocs[assoc] - 1;
    ebx->split.physical_line_partition = lines_per_tag - 1;
    ecx->split.number_of_sets = (size_in_kb * 1024) / line_size / (ebx->split.ways_of_associativity + 1) - 1;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/intel_cacheinfo.c.ifdefed" startline="203" endline="233">
{
case 1 :
    l1 = &l1i;
case 0 :
    if (!l1->val)
        return;
    assoc = l1->assoc;
    line_size = l1->line_size;
    lines_per_tag = l1->lines_per_tag;
    size_in_kb = l1->size_in_kb;
    break;
case 2 :
    if (!l2.val)
        return;
    assoc = l2.assoc;
    line_size = l2.line_size;
    lines_per_tag = l2.lines_per_tag;
    size_in_kb = current_cpu_data.x86_cache_size;
    break;
case 3 :
    if (!l3.val)
        return;
    assoc = l3.assoc;
    line_size = l3.line_size;
    lines_per_tag = l3.lines_per_tag;
    size_in_kb = l3.size_encoded * 512;
    break;
default :
    return;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/intel_cacheinfo.c.ifdefed" startline="255" endline="276">
{
    union _cpuid4_leaf_eax eax;
    union _cpuid4_leaf_ebx ebx;
    union _cpuid4_leaf_ecx ecx;
    unsigned edx;
    if (boot_cpu_data.x86_vendor == X86_VENDOR_AMD)
        amd_cpuid4 (index, &eax, &ebx, &ecx);
    else
        cpuid_count (4, index, &eax.full, &ebx.full, &ecx.full, &edx);
    if (eax.split.type == CACHE_TYPE_NULL)
        return -EIO;
    this_leaf->eax = eax;
    this_leaf->ebx = ebx;
    this_leaf->ecx = ecx;
    this_leaf->size = (ecx.split.number_of_sets + 1) * (ebx.split.coherency_line_size + 1) * (ebx.split.physical_line_partition + 1) * (ebx.split.ways_of_associativity + 1);
    return 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/intel_cacheinfo.c.ifdefed" startline="279" endline="291">
{
    unsigned int eax, ebx, ecx, edx;
    union _cpuid4_leaf_eax cache_eax;
    int i = -1;
    do {
        ++i;
        cpuid_count (4, i, & eax, & ebx, & ecx, & edx);
        cache_eax.full = eax;
    }
    while (cache_eax.split.type != CACHE_TYPE_NULL);
    return i;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/intel_cacheinfo.c.ifdefed" startline="284" endline="289">
{
    ++i;
    cpuid_count (4, i, & eax, & ebx, & ecx, & edx);
    cache_eax.full = eax;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/intel_cacheinfo.c.ifdefed" startline="294" endline="452">
{
    unsigned int trace = 0, l1i = 0, l1d = 0, l2 = 0, l3 = 0;
    unsigned int new_l1d = 0, new_l1i = 0;
    unsigned int new_l2 = 0, new_l3 = 0, i;
    unsigned int l2_id = 0, l3_id = 0, num_threads_sharing, index_msb;
    if (c->cpuid_level > 3) {
        static int is_initialized;
        if (is_initialized == 0) {
            num_cache_leaves = find_num_cache_leaves ();
            is_initialized++;
        }
        for (i = 0; i < num_cache_leaves; i++) {
            struct _cpuid4_info this_leaf;
            int retval;
            retval = cpuid4_cache_lookup (i, &this_leaf);
            if (retval >= 0) {
                switch (this_leaf.eax.split.level) {
                case 1 :
                    if (this_leaf.eax.split.type == CACHE_TYPE_DATA)
                        new_l1d = this_leaf.size / 1024;
                    else if (this_leaf.eax.split.type == CACHE_TYPE_INST)
                        new_l1i = this_leaf.size / 1024;
                    break;
                case 2 :
                    new_l2 = this_leaf.size / 1024;
                    num_threads_sharing = 1 + this_leaf.eax.split.num_threads_sharing;
                    index_msb = get_count_order (num_threads_sharing);
                    l2_id = c->apicid >> index_msb;
                    break;
                case 3 :
                    new_l3 = this_leaf.size / 1024;
                    num_threads_sharing = 1 + this_leaf.eax.split.num_threads_sharing;
                    index_msb = get_count_order (num_threads_sharing);
                    l3_id = c->apicid >> index_msb;
                    break;
                default :
                    break;
                }
            }
        }
    }
    if ((num_cache_leaves == 0 || c->x86 == 15) && c->cpuid_level > 1) {
        int j, n;
        unsigned int regs [4];
        unsigned char *dp = (unsigned char *) regs;
        int only_trace = 0;
        if (num_cache_leaves != 0 && c->x86 == 15)
            only_trace = 1;
        n = cpuid_eax (2) & 0xFF;
        for (i = 0; i < n; i++) {
            cpuid (2, & regs [0], & regs [1], & regs [2], & regs [3]);
            for (j = 0; j < 3; j++) {
                if (regs[j] & (1 << 31))
                    regs[j] = 0;
            }
            for (j = 1; j < 16; j++) {
                unsigned char des = dp[j];
                unsigned char k = 0;
                while (cache_table[k].descriptor != 0) {
                    if (cache_table[k].descriptor == des) {
                        if (only_trace && cache_table[k].cache_type != LVL_TRACE)
                            break;
                        switch (cache_table[k].cache_type) {
                        case LVL_1_INST :
                            l1i += cache_table[k].size;
                            break;
                        case LVL_1_DATA :
                            l1d += cache_table[k].size;
                            break;
                        case LVL_2 :
                            l2 += cache_table[k].size;
                            break;
                        case LVL_3 :
                            l3 += cache_table[k].size;
                            break;
                        case LVL_TRACE :
                            trace += cache_table[k].size;
                            break;
                        }
                        break;
                    }
                    k++;
                }
            }
        }
    }
    if (new_l1d)
        l1d = new_l1d;
    if (new_l1i)
        l1i = new_l1i;
    if (new_l2) {
        l2 = new_l2;
    }
    if (new_l3) {
        l3 = new_l3;
    }
    if (trace)
        printk (KERN_INFO "CPU: Trace cache: %dK uops", trace);
    else if (l1i)
        printk (KERN_INFO "CPU: L1 I cache: %dK", l1i);
    if (l1d)
        printk (", L1 D cache: %dK\n", l1d);
    else
        printk ("\n");
    if (l2)
        printk (KERN_INFO "CPU: L2 cache: %dK\n", l2);
    if (l3)
        printk (KERN_INFO "CPU: L3 cache: %dK\n", l3);
    c->x86_cache_size = l3 ? l3 : (l2 ? l2 : (l1i + l1d));
    return l2;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/intel_cacheinfo.c.ifdefed" startline="303" endline="349">
{
    static int is_initialized;
    if (is_initialized == 0) {
        num_cache_leaves = find_num_cache_leaves ();
        is_initialized++;
    }
    for (i = 0; i < num_cache_leaves; i++) {
        struct _cpuid4_info this_leaf;
        int retval;
        retval = cpuid4_cache_lookup (i, &this_leaf);
        if (retval >= 0) {
            switch (this_leaf.eax.split.level) {
            case 1 :
                if (this_leaf.eax.split.type == CACHE_TYPE_DATA)
                    new_l1d = this_leaf.size / 1024;
                else if (this_leaf.eax.split.type == CACHE_TYPE_INST)
                    new_l1i = this_leaf.size / 1024;
                break;
            case 2 :
                new_l2 = this_leaf.size / 1024;
                num_threads_sharing = 1 + this_leaf.eax.split.num_threads_sharing;
                index_msb = get_count_order (num_threads_sharing);
                l2_id = c->apicid >> index_msb;
                break;
            case 3 :
                new_l3 = this_leaf.size / 1024;
                num_threads_sharing = 1 + this_leaf.eax.split.num_threads_sharing;
                index_msb = get_count_order (num_threads_sharing);
                l3_id = c->apicid >> index_msb;
                break;
            default :
                break;
            }
        }
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/intel_cacheinfo.c.ifdefed" startline="306" endline="310">
{
    num_cache_leaves = find_num_cache_leaves ();
    is_initialized++;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/intel_cacheinfo.c.ifdefed" startline="316" endline="348">
{
    struct _cpuid4_info this_leaf;
    int retval;
    retval = cpuid4_cache_lookup (i, &this_leaf);
    if (retval >= 0) {
        switch (this_leaf.eax.split.level) {
        case 1 :
            if (this_leaf.eax.split.type == CACHE_TYPE_DATA)
                new_l1d = this_leaf.size / 1024;
            else if (this_leaf.eax.split.type == CACHE_TYPE_INST)
                new_l1i = this_leaf.size / 1024;
            break;
        case 2 :
            new_l2 = this_leaf.size / 1024;
            num_threads_sharing = 1 + this_leaf.eax.split.num_threads_sharing;
            index_msb = get_count_order (num_threads_sharing);
            l2_id = c->apicid >> index_msb;
            break;
        case 3 :
            new_l3 = this_leaf.size / 1024;
            num_threads_sharing = 1 + this_leaf.eax.split.num_threads_sharing;
            index_msb = get_count_order (num_threads_sharing);
            l3_id = c->apicid >> index_msb;
            break;
        default :
            break;
        }
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/intel_cacheinfo.c.ifdefed" startline="322" endline="347">
{
    switch (this_leaf.eax.split.level) {
    case 1 :
        if (this_leaf.eax.split.type == CACHE_TYPE_DATA)
            new_l1d = this_leaf.size / 1024;
        else if (this_leaf.eax.split.type == CACHE_TYPE_INST)
            new_l1i = this_leaf.size / 1024;
        break;
    case 2 :
        new_l2 = this_leaf.size / 1024;
        num_threads_sharing = 1 + this_leaf.eax.split.num_threads_sharing;
        index_msb = get_count_order (num_threads_sharing);
        l2_id = c->apicid >> index_msb;
        break;
    case 3 :
        new_l3 = this_leaf.size / 1024;
        num_threads_sharing = 1 + this_leaf.eax.split.num_threads_sharing;
        index_msb = get_count_order (num_threads_sharing);
        l3_id = c->apicid >> index_msb;
        break;
    default :
        break;
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/intel_cacheinfo.c.ifdefed" startline="323" endline="346">
{
case 1 :
    if (this_leaf.eax.split.type == CACHE_TYPE_DATA)
        new_l1d = this_leaf.size / 1024;
    else if (this_leaf.eax.split.type == CACHE_TYPE_INST)
        new_l1i = this_leaf.size / 1024;
    break;
case 2 :
    new_l2 = this_leaf.size / 1024;
    num_threads_sharing = 1 + this_leaf.eax.split.num_threads_sharing;
    index_msb = get_count_order (num_threads_sharing);
    l2_id = c->apicid >> index_msb;
    break;
case 3 :
    new_l3 = this_leaf.size / 1024;
    num_threads_sharing = 1 + this_leaf.eax.split.num_threads_sharing;
    index_msb = get_count_order (num_threads_sharing);
    l3_id = c->apicid >> index_msb;
    break;
default :
    break;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/intel_cacheinfo.c.ifdefed" startline="354" endline="411">
{
    int j, n;
    unsigned int regs [4];
    unsigned char *dp = (unsigned char *) regs;
    int only_trace = 0;
    if (num_cache_leaves != 0 && c->x86 == 15)
        only_trace = 1;
    n = cpuid_eax (2) & 0xFF;
    for (i = 0; i < n; i++) {
        cpuid (2, & regs [0], & regs [1], & regs [2], & regs [3]);
        for (j = 0; j < 3; j++) {
            if (regs[j] & (1 << 31))
                regs[j] = 0;
        }
        for (j = 1; j < 16; j++) {
            unsigned char des = dp[j];
            unsigned char k = 0;
            while (cache_table[k].descriptor != 0) {
                if (cache_table[k].descriptor == des) {
                    if (only_trace && cache_table[k].cache_type != LVL_TRACE)
                        break;
                    switch (cache_table[k].cache_type) {
                    case LVL_1_INST :
                        l1i += cache_table[k].size;
                        break;
                    case LVL_1_DATA :
                        l1d += cache_table[k].size;
                        break;
                    case LVL_2 :
                        l2 += cache_table[k].size;
                        break;
                    case LVL_3 :
                        l3 += cache_table[k].size;
                        break;
                    case LVL_TRACE :
                        trace += cache_table[k].size;
                        break;
                    }
                    break;
                }
                k++;
            }
        }
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/intel_cacheinfo.c.ifdefed" startline="367" endline="410">
{
    cpuid (2, & regs [0], & regs [1], & regs [2], & regs [3]);
    for (j = 0; j < 3; j++) {
        if (regs[j] & (1 << 31))
            regs[j] = 0;
    }
    for (j = 1; j < 16; j++) {
        unsigned char des = dp[j];
        unsigned char k = 0;
        while (cache_table[k].descriptor != 0) {
            if (cache_table[k].descriptor == des) {
                if (only_trace && cache_table[k].cache_type != LVL_TRACE)
                    break;
                switch (cache_table[k].cache_type) {
                case LVL_1_INST :
                    l1i += cache_table[k].size;
                    break;
                case LVL_1_DATA :
                    l1d += cache_table[k].size;
                    break;
                case LVL_2 :
                    l2 += cache_table[k].size;
                    break;
                case LVL_3 :
                    l3 += cache_table[k].size;
                    break;
                case LVL_TRACE :
                    trace += cache_table[k].size;
                    break;
                }
                break;
            }
            k++;
        }
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/intel_cacheinfo.c.ifdefed" startline="371" endline="373">
{
    if (regs[j] & (1 << 31))
        regs[j] = 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/intel_cacheinfo.c.ifdefed" startline="376" endline="409">
{
    unsigned char des = dp[j];
    unsigned char k = 0;
    while (cache_table[k].descriptor != 0) {
        if (cache_table[k].descriptor == des) {
            if (only_trace && cache_table[k].cache_type != LVL_TRACE)
                break;
            switch (cache_table[k].cache_type) {
            case LVL_1_INST :
                l1i += cache_table[k].size;
                break;
            case LVL_1_DATA :
                l1d += cache_table[k].size;
                break;
            case LVL_2 :
                l2 += cache_table[k].size;
                break;
            case LVL_3 :
                l3 += cache_table[k].size;
                break;
            case LVL_TRACE :
                trace += cache_table[k].size;
                break;
            }
            break;
        }
        k++;
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/intel_cacheinfo.c.ifdefed" startline="382" endline="408">
{
    if (cache_table[k].descriptor == des) {
        if (only_trace && cache_table[k].cache_type != LVL_TRACE)
            break;
        switch (cache_table[k].cache_type) {
        case LVL_1_INST :
            l1i += cache_table[k].size;
            break;
        case LVL_1_DATA :
            l1d += cache_table[k].size;
            break;
        case LVL_2 :
            l2 += cache_table[k].size;
            break;
        case LVL_3 :
            l3 += cache_table[k].size;
            break;
        case LVL_TRACE :
            trace += cache_table[k].size;
            break;
        }
        break;
    }
    k++;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/intel_cacheinfo.c.ifdefed" startline="383" endline="405">
{
    if (only_trace && cache_table[k].cache_type != LVL_TRACE)
        break;
    switch (cache_table[k].cache_type) {
    case LVL_1_INST :
        l1i += cache_table[k].size;
        break;
    case LVL_1_DATA :
        l1d += cache_table[k].size;
        break;
    case LVL_2 :
        l2 += cache_table[k].size;
        break;
    case LVL_3 :
        l3 += cache_table[k].size;
        break;
    case LVL_TRACE :
        trace += cache_table[k].size;
        break;
    }
    break;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/intel_cacheinfo.c.ifdefed" startline="386" endline="402">
{
case LVL_1_INST :
    l1i += cache_table[k].size;
    break;
case LVL_1_DATA :
    l1d += cache_table[k].size;
    break;
case LVL_2 :
    l2 += cache_table[k].size;
    break;
case LVL_3 :
    l3 += cache_table[k].size;
    break;
case LVL_TRACE :
    trace += cache_table[k].size;
    break;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/intel_cacheinfo.c.ifdefed" startline="419" endline="424">
{
    l2 = new_l2;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/intel_cacheinfo.c.ifdefed" startline="426" endline="431">
{
    l3 = new_l3;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/intel_cacheinfo.c.ifdefed" startline="498" endline="498">
{
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/intel_cacheinfo.c.ifdefed" startline="499" endline="499">
{
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/intel_cacheinfo.c.ifdefed" startline="503" endline="511">
{
    int i;
    for (i = 0; i < num_cache_leaves; i++)
        cache_remove_shared_cpu_map (cpu, i);
    kfree (per_cpu (cpuid4_info, cpu));
    per_cpu (cpuid4_info, cpu) = NULL;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/intel_cacheinfo.c.ifdefed" startline="514" endline="555">
{
    struct _cpuid4_info *this_leaf;
    unsigned long j;
    int retval;
    cpumask_t oldmask;
    if (num_cache_leaves == 0)
        return -ENOENT;
    per_cpu (cpuid4_info, cpu) = kzalloc (sizeof (struct _cpuid4_info) * num_cache_leaves, GFP_KERNEL);
    if (per_cpu (cpuid4_info, cpu) == NULL)
        return -ENOMEM;
    oldmask = current->cpus_allowed;
    retval = set_cpus_allowed_ptr (current, &cpumask_of_cpu (cpu));
    if (retval)
        goto out;
    for (j = 0; j < num_cache_leaves; j++) {
        this_leaf = CPUID4_INFO_IDX (cpu, j);
        retval = cpuid4_cache_lookup (j, this_leaf);
        if (unlikely (retval < 0)) {
            int i;
            for (i = 0; i < j; i++)
                cache_remove_shared_cpu_map (cpu, i);
            break;
        }
        cache_shared_cpu_map_setup (cpu, j);
    }
    set_cpus_allowed_ptr (current, & oldmask);
out :
    if (retval) {
        kfree (per_cpu (cpuid4_info, cpu));
        per_cpu (cpuid4_info, cpu) = NULL;
    }
    return retval;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/intel_cacheinfo.c.ifdefed" startline="534" endline="545">
{
    this_leaf = CPUID4_INFO_IDX (cpu, j);
    retval = cpuid4_cache_lookup (j, this_leaf);
    if (unlikely (retval < 0)) {
        int i;
        for (i = 0; i < j; i++)
            cache_remove_shared_cpu_map (cpu, i);
        break;
    }
    cache_shared_cpu_map_setup (cpu, j);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/intel_cacheinfo.c.ifdefed" startline="537" endline="543">
{
    int i;
    for (i = 0; i < j; i++)
        cache_remove_shared_cpu_map (cpu, i);
    break;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/intel_cacheinfo.c.ifdefed" startline="549" endline="552">
{
    kfree (per_cpu (cpuid4_info, cpu));
    per_cpu (cpuid4_info, cpu) = NULL;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/cpufreq/acpi-cpufreq.c.ifdefed" startline="80" endline="88">
{
    struct cpuinfo_x86 *cpu = &cpu_data (cpuid);
    if (cpu->x86_vendor != X86_VENDOR_INTEL || !cpu_has (cpu, X86_FEATURE_EST))
        return 0;
    return 1;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/cpufreq/acpi-cpufreq.c.ifdefed" startline="91" endline="102">
{
    struct acpi_processor_performance *perf;
    int i;
    perf = data->acpi_data;
    for (i = 0; i < perf->state_count; i++) {
        if (value == perf->states[i].status)
            return data->freq_table[i].frequency;
    }
    return 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/cpufreq/acpi-cpufreq.c.ifdefed" startline="97" endline="100">
{
    if (value == perf->states[i].status)
        return data->freq_table[i].frequency;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/cpufreq/acpi-cpufreq.c.ifdefed" startline="105" endline="117">
{
    int i;
    struct acpi_processor_performance *perf;
    msr &= INTEL_MSR_RANGE;
    perf = data->acpi_data;
    for (i = 0; data->freq_table[i].frequency != CPUFREQ_TABLE_END; i++) {
        if (msr == perf->states[data->freq_table[i].index].status)
            return data->freq_table[i].frequency;
    }
    return data->freq_table[0].frequency;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/cpufreq/acpi-cpufreq.c.ifdefed" startline="112" endline="115">
{
    if (msr == perf->states[data->freq_table[i].index].status)
        return data->freq_table[i].frequency;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/cpufreq/acpi-cpufreq.c.ifdefed" startline="120" endline="129">
{
    switch (data->cpu_feature) {
    case SYSTEM_INTEL_MSR_CAPABLE :
        return extract_msr (val, data);
    case SYSTEM_IO_CAPABLE :
        return extract_io (val, data);
    default :
        return 0;
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/cpufreq/acpi-cpufreq.c.ifdefed" startline="121" endline="128">
{
case SYSTEM_INTEL_MSR_CAPABLE :
    return extract_msr (val, data);
case SYSTEM_IO_CAPABLE :
    return extract_io (val, data);
default :
    return 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/cpufreq/acpi-cpufreq.c.ifdefed" startline="153" endline="168">
{
    u32 h;
    switch (cmd->type) {
    case SYSTEM_INTEL_MSR_CAPABLE :
        rdmsr (cmd->addr.msr.reg, cmd->val, h);
        break;
    case SYSTEM_IO_CAPABLE :
        acpi_os_read_port ((acpi_io_address) cmd->addr.io.port, &cmd->val, (u32) cmd->addr.io.bit_width);
        break;
    default :
        break;
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/cpufreq/acpi-cpufreq.c.ifdefed" startline="156" endline="167">
{
case SYSTEM_INTEL_MSR_CAPABLE :
    rdmsr (cmd->addr.msr.reg, cmd->val, h);
    break;
case SYSTEM_IO_CAPABLE :
    acpi_os_read_port ((acpi_io_address) cmd->addr.io.port, &cmd->val, (u32) cmd->addr.io.bit_width);
    break;
default :
    break;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/cpufreq/acpi-cpufreq.c.ifdefed" startline="171" endline="188">
{
    u32 lo, hi;
    switch (cmd->type) {
    case SYSTEM_INTEL_MSR_CAPABLE :
        rdmsr (cmd->addr.msr.reg, lo, hi);
        lo = (lo & ~INTEL_MSR_RANGE) | (cmd->val & INTEL_MSR_RANGE);
        wrmsr (cmd -> addr.msr.reg, lo, hi);
        break;
    case SYSTEM_IO_CAPABLE :
        acpi_os_write_port ((acpi_io_address) cmd->addr.io.port, cmd->val, (u32) cmd->addr.io.bit_width);
        break;
    default :
        break;
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/cpufreq/acpi-cpufreq.c.ifdefed" startline="174" endline="187">
{
case SYSTEM_INTEL_MSR_CAPABLE :
    rdmsr (cmd->addr.msr.reg, lo, hi);
    lo = (lo & ~INTEL_MSR_RANGE) | (cmd->val & INTEL_MSR_RANGE);
    wrmsr (cmd -> addr.msr.reg, lo, hi);
    break;
case SYSTEM_IO_CAPABLE :
    acpi_os_write_port ((acpi_io_address) cmd->addr.io.port, cmd->val, (u32) cmd->addr.io.bit_width);
    break;
default :
    break;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/cpufreq/acpi-cpufreq.c.ifdefed" startline="191" endline="198">
{
    cpumask_t saved_mask = current->cpus_allowed;
    cmd->val = 0;
    set_cpus_allowed_ptr (current, & cmd -> mask);
    do_drv_read (cmd);
    set_cpus_allowed_ptr (current, & saved_mask);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/cpufreq/acpi-cpufreq.c.ifdefed" startline="201" endline="212">
{
    cpumask_t saved_mask = current->cpus_allowed;
    unsigned int i;
    for_each_cpu_mask_nr (i, cmd -> mask) {
        set_cpus_allowed_ptr (current, &cpumask_of_cpu (i)) do_drv_write (cmd)
    } set_cpus_allowed_ptr (current, &saved_mask)
    return;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/cpufreq/acpi-cpufreq.c.ifdefed" startline="215" endline="244">
{
    struct acpi_processor_performance *perf;
    struct drv_cmd cmd;
    if (unlikely (cpus_empty (*mask)))
        return 0;
    switch (per_cpu (drv_data, first_cpu (*mask))->cpu_feature) {
    case SYSTEM_INTEL_MSR_CAPABLE :
        cmd.type = SYSTEM_INTEL_MSR_CAPABLE;
        cmd.addr.msr.reg = MSR_IA32_PERF_STATUS;
        break;
    case SYSTEM_IO_CAPABLE :
        cmd.type = SYSTEM_IO_CAPABLE;
        perf = per_cpu (drv_data, first_cpu (*mask))->acpi_data;
        cmd.addr.io.port = perf->control_register.address;
        cmd.addr.io.bit_width = perf->control_register.bit_width;
        break;
    default :
        return 0;
    }
    cmd.mask = *mask;
    drv_read (& cmd);
    dprintk ("get_cur_val = %u\n", cmd.val);
    return cmd.val;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/cpufreq/acpi-cpufreq.c.ifdefed" startline="222" endline="235">
{
case SYSTEM_INTEL_MSR_CAPABLE :
    cmd.type = SYSTEM_INTEL_MSR_CAPABLE;
    cmd.addr.msr.reg = MSR_IA32_PERF_STATUS;
    break;
case SYSTEM_IO_CAPABLE :
    cmd.type = SYSTEM_IO_CAPABLE;
    perf = per_cpu (drv_data, first_cpu (*mask))->acpi_data;
    cmd.addr.io.port = perf->control_register.address;
    cmd.addr.io.bit_width = perf->control_register.bit_width;
    break;
default :
    return 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/cpufreq/acpi-cpufreq.c.ifdefed" startline="260" endline="336">
{
    union {
        struct {
            u32 lo;
            u32 hi;
        } split;
        u64 whole;
    } aperf_cur, mperf_cur;
    cpumask_t saved_mask;
    unsigned int perf_percent;
    unsigned int retval;
    saved_mask = current->cpus_allowed;
    set_cpus_allowed_ptr (current, & cpumask_of_cpu (cpu));
    if (get_cpu () != cpu) {
        put_cpu ();
        return 0;
    }
    rdmsr (MSR_IA32_APERF, aperf_cur.split.lo, aperf_cur.split.hi);
    rdmsr (MSR_IA32_MPERF, mperf_cur.split.lo, mperf_cur.split.hi);
    wrmsr (MSR_IA32_APERF, 0, 0);
    wrmsr (MSR_IA32_MPERF, 0, 0);
    if (unlikely (((unsigned long) (-1) / 100) < aperf_cur.whole)) {
        int shift_count = 7;
        aperf_cur.whole >>= shift_count;
        mperf_cur.whole >>= shift_count;
    }
    if (aperf_cur.whole && mperf_cur.whole)
        perf_percent = (aperf_cur.whole * 100) / mperf_cur.whole;
    else
        perf_percent = 0;
    retval = per_cpu (drv_data, cpu)->max_freq * perf_percent / 100;
    put_cpu ();
    set_cpus_allowed_ptr (current, & saved_mask);
    dprintk ("cpu %d: performance percent %d\n", cpu, perf_percent);
    return retval;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/cpufreq/acpi-cpufreq.c.ifdefed" startline="275" endline="279">
{
    put_cpu ();
    return 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/cpufreq/acpi-cpufreq.c.ifdefed" startline="316" endline="320">
{
    int shift_count = 7;
    aperf_cur.whole >>= shift_count;
    mperf_cur.whole >>= shift_count;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/cpufreq/acpi-cpufreq.c.ifdefed" startline="339" endline="364">
{
    struct acpi_cpufreq_data *data = per_cpu (drv_data, cpu);
    unsigned int freq;
    unsigned int cached_freq;
    dprintk ("get_cur_freq_on_cpu (%d)\n", cpu);
    if (unlikely (data == NULL || data->acpi_data == NULL || data->freq_table == NULL)) {
        return 0;
    }
    cached_freq = data->freq_table[data->acpi_data->state].frequency;
    freq = extract_freq (get_cur_val (&cpumask_of_cpu (cpu)), data);
    if (freq != cached_freq) {
        data->resume = 1;
    }
    dprintk ("cur freq = %u\n", freq);
    return freq;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/cpufreq/acpi-cpufreq.c.ifdefed" startline="347" endline="349">
{
    return 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/cpufreq/acpi-cpufreq.c.ifdefed" startline="353" endline="359">
{
    data->resume = 1;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/cpufreq/acpi-cpufreq.c.ifdefed" startline="368" endline="379">
{
    unsigned int cur_freq;
    unsigned int i;
    for (i = 0; i < 100; i++) {
        cur_freq = extract_freq (get_cur_val (mask), data);
        if (cur_freq == freq)
            return 1;
        udelay (10);
    }
    return 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/cpufreq/acpi-cpufreq.c.ifdefed" startline="372" endline="377">
{
    cur_freq = extract_freq (get_cur_val (mask), data);
    if (cur_freq == freq)
        return 1;
    udelay (10);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/cpufreq/acpi-cpufreq.c.ifdefed" startline="383" endline="476">
{
    struct acpi_cpufreq_data *data = per_cpu (drv_data, policy->cpu);
    struct acpi_processor_performance *perf;
    struct cpufreq_freqs freqs;
    cpumask_t online_policy_cpus;
    struct drv_cmd cmd;
    unsigned int next_state = 0;
    unsigned int next_perf_state = 0;
    unsigned int i;
    int result = 0;
    dprintk ("acpi_cpufreq_target %d (%d)\n", target_freq, policy -> cpu);
    if (unlikely (data == NULL || data->acpi_data == NULL || data->freq_table == NULL)) {
        return -ENODEV;
    }
    perf = data->acpi_data;
    result = cpufreq_frequency_table_target (policy, data->freq_table, target_freq, relation, &next_state);
    if (unlikely (result))
        return -ENODEV;
    online_policy_cpus = policy->cpus;
    next_perf_state = data->freq_table[next_state].index;
    if (perf->state == next_perf_state) {
        if (unlikely (data->resume)) {
            dprintk ("Called after resume, resetting to P%d\n", next_perf_state);
            data->resume = 0;
        }
        else {
            dprintk ("Already at target state (P%d)\n", next_perf_state);
            return 0;
        }
    }
    switch (data->cpu_feature) {
    case SYSTEM_INTEL_MSR_CAPABLE :
        cmd.type = SYSTEM_INTEL_MSR_CAPABLE;
        cmd.addr.msr.reg = MSR_IA32_PERF_CTL;
        cmd.val = (u32) perf->states[next_perf_state].control;
        break;
    case SYSTEM_IO_CAPABLE :
        cmd.type = SYSTEM_IO_CAPABLE;
        cmd.addr.io.port = perf->control_register.address;
        cmd.addr.io.bit_width = perf->control_register.bit_width;
        cmd.val = (u32) perf->states[next_perf_state].control;
        break;
    default :
        return -ENODEV;
    }
    cpus_clear (cmd.mask);
    if (policy->shared_type != CPUFREQ_SHARED_TYPE_ANY)
        cmd.mask = online_policy_cpus;
    else
        cpu_set (policy->cpu, cmd.mask);
    freqs.old = perf->states[perf->state].core_frequency * 1000;
    freqs.new = data->freq_table[next_state].frequency;
    for_each_cpu_mask_nr (i, cmd.mask) {freqs
        .cpu = i cpufreq_notify_transition (&freqs, CPUFREQ_PRECHANGE)
    } drv_write (&cmd)
    if (acpi_pstate_strict) {
        if (!check_freqs (&cmd.mask, freqs.new, data)) {
            dprintk ("acpi_cpufreq_target failed (%d)\n", policy -> cpu);
            return -EAGAIN;
        }
    }
    for_each_cpu_mask_nr (i, cmd.mask) {freqs
        .cpu = i cpufreq_notify_transition (&freqs, CPUFREQ_POSTCHANGE)
    } perf->state
    = next_perf_state;
    return result;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/cpufreq/acpi-cpufreq.c.ifdefed" startline="397" endline="399">
{
    return -ENODEV;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/cpufreq/acpi-cpufreq.c.ifdefed" startline="417" endline="427">
{
    if (unlikely (data->resume)) {
        dprintk ("Called after resume, resetting to P%d\n", next_perf_state);
        data->resume = 0;
    }
    else {
        dprintk ("Already at target state (P%d)\n", next_perf_state);
        return 0;
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/cpufreq/acpi-cpufreq.c.ifdefed" startline="418" endline="422">
{
    dprintk ("Called after resume, resetting to P%d\n", next_perf_state);
    data->resume = 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/cpufreq/acpi-cpufreq.c.ifdefed" startline="422" endline="426">
{
    dprintk ("Already at target state (P%d)\n", next_perf_state);
    return 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/cpufreq/acpi-cpufreq.c.ifdefed" startline="429" endline="443">
{
case SYSTEM_INTEL_MSR_CAPABLE :
    cmd.type = SYSTEM_INTEL_MSR_CAPABLE;
    cmd.addr.msr.reg = MSR_IA32_PERF_CTL;
    cmd.val = (u32) perf->states[next_perf_state].control;
    break;
case SYSTEM_IO_CAPABLE :
    cmd.type = SYSTEM_IO_CAPABLE;
    cmd.addr.io.port = perf->control_register.address;
    cmd.addr.io.bit_width = perf->control_register.bit_width;
    cmd.val = (u32) perf->states[next_perf_state].control;
    break;
default :
    return -ENODEV;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/cpufreq/acpi-cpufreq.c.ifdefed" startline="461" endline="467">
{
    if (!check_freqs (&cmd.mask, freqs.new, data)) {
        dprintk ("acpi_cpufreq_target failed (%d)\n", policy -> cpu);
        return -EAGAIN;
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/cpufreq/acpi-cpufreq.c.ifdefed" startline="462" endline="466">
{
    dprintk ("acpi_cpufreq_target failed (%d)\n", policy -> cpu);
    return -EAGAIN;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/cpufreq/acpi-cpufreq.c.ifdefed" startline="479" endline="485">
{
    struct acpi_cpufreq_data *data = per_cpu (drv_data, policy->cpu);
    dprintk ("acpi_cpufreq_verify\n");
    return cpufreq_frequency_table_verify (policy, data->freq_table);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/cpufreq/acpi-cpufreq.c.ifdefed" startline="489" endline="513">
{
    struct acpi_processor_performance *perf = data->acpi_data;
    if (cpu_khz) {
        unsigned int i;
        unsigned long freq;
        unsigned long freqn = perf->states[0].core_frequency * 1000;
        for (i = 0; i < (perf->state_count - 1); i++) {
            freq = freqn;
            freqn = perf->states[i + 1].core_frequency * 1000;
            if ((2 * cpu_khz) > (freqn + freq)) {
                perf->state = i;
                return freq;
            }
        }
        perf->state = perf->state_count - 1;
        return freqn;
    }
    else {
        perf->state = 0;
        return perf->states[0].core_frequency * 1000;
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/cpufreq/acpi-cpufreq.c.ifdefed" startline="492" endline="508">
{
    unsigned int i;
    unsigned long freq;
    unsigned long freqn = perf->states[0].core_frequency * 1000;
    for (i = 0; i < (perf->state_count - 1); i++) {
        freq = freqn;
        freqn = perf->states[i + 1].core_frequency * 1000;
        if ((2 * cpu_khz) > (freqn + freq)) {
            perf->state = i;
            return freq;
        }
    }
    perf->state = perf->state_count - 1;
    return freqn;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/cpufreq/acpi-cpufreq.c.ifdefed" startline="498" endline="505">
{
    freq = freqn;
    freqn = perf->states[i + 1].core_frequency * 1000;
    if ((2 * cpu_khz) > (freqn + freq)) {
        perf->state = i;
        return freq;
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/cpufreq/acpi-cpufreq.c.ifdefed" startline="501" endline="504">
{
    perf->state = i;
    return freq;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/cpufreq/acpi-cpufreq.c.ifdefed" startline="508" endline="512">
{
    perf->state = 0;
    return perf->states[0].core_frequency * 1000;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/cpufreq/acpi-cpufreq.c.ifdefed" startline="524" endline="536">
{
    dprintk ("acpi_cpufreq_early_init\n");
    acpi_perf_data = alloc_percpu (struct acpi_processor_performance);
    if (!acpi_perf_data) {
        dprintk ("Memory allocation error for acpi_perf_data.\n");
        return -ENOMEM;
    }
    acpi_processor_preregister_performance (acpi_perf_data);
    return 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/cpufreq/acpi-cpufreq.c.ifdefed" startline="528" endline="531">
{
    dprintk ("Memory allocation error for acpi_perf_data.\n");
    return -ENOMEM;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/cpufreq/acpi-cpufreq.c.ifdefed" startline="568" endline="732">
{
    unsigned int i;
    unsigned int valid_states = 0;
    unsigned int cpu = policy->cpu;
    struct acpi_cpufreq_data *data;
    unsigned int result = 0;
    struct cpuinfo_x86 *c = &cpu_data (policy->cpu);
    struct acpi_processor_performance *perf;
    dprintk ("acpi_cpufreq_cpu_init\n");
    data = kzalloc (sizeof (struct acpi_cpufreq_data), GFP_KERNEL);
    if (!data)
        return -ENOMEM;
    data->acpi_data = percpu_ptr (acpi_perf_data, cpu);
    per_cpu (drv_data, cpu) = data;
    if (cpu_has (c, X86_FEATURE_CONSTANT_TSC))
        acpi_cpufreq_driver.flags |= CPUFREQ_CONST_LOOPS;
    result = acpi_processor_register_performance (data->acpi_data, cpu);
    if (result)
        goto err_free;
    perf = data->acpi_data;
    policy->shared_type = perf->shared_type;
    if (policy->shared_type == CPUFREQ_SHARED_TYPE_ALL || policy->shared_type == CPUFREQ_SHARED_TYPE_ANY) {
        policy->cpus = perf->shared_cpu_map;
    }
    policy->related_cpus = perf->shared_cpu_map;
    if (perf->state_count <= 1) {
        dprintk ("No P-States\n");
        result = -ENODEV;
        goto err_unreg;
    }
    if (perf->control_register.space_id != perf->status_register.space_id) {
        result = -ENODEV;
        goto err_unreg;
    }
    switch (perf->control_register.space_id) {
    case ACPI_ADR_SPACE_SYSTEM_IO :
        dprintk ("SYSTEM IO addr space\n");
        data->cpu_feature = SYSTEM_IO_CAPABLE;
        break;
    case ACPI_ADR_SPACE_FIXED_HARDWARE :
        dprintk ("HARDWARE addr space\n");
        if (!check_est_cpu (cpu)) {
            result = -ENODEV;
            goto err_unreg;
        }
        data->cpu_feature = SYSTEM_INTEL_MSR_CAPABLE;
        break;
    default :
        dprintk ("Unknown addr space %d\n", (u32) (perf->control_register.space_id));
        result = -ENODEV;
        goto err_unreg;
    }
    data->freq_table = kmalloc (sizeof (struct cpufreq_frequency_table) * (perf->state_count + 1), GFP_KERNEL);
    if (!data->freq_table) {
        result = -ENOMEM;
        goto err_unreg;
    }
    policy->cpuinfo.transition_latency = 0;
    for (i = 0; i < perf->state_count; i++) {
        if ((perf->states[i].transition_latency * 1000) > policy->cpuinfo.transition_latency)
            policy->cpuinfo.transition_latency = perf->states[i].transition_latency * 1000;
    }
    data->max_freq = perf->states[0].core_frequency * 1000;
    for (i = 0; i < perf->state_count; i++) {
        if (i > 0 && perf->states[i].core_frequency >= data->freq_table[valid_states - 1].frequency / 1000)
            continue;
        data->freq_table[valid_states].index = i;
        data->freq_table[valid_states].frequency = perf->states[i].core_frequency * 1000;
        valid_states++;
    }
    data->freq_table[valid_states].frequency = CPUFREQ_TABLE_END;
    perf->state = 0;
    result = cpufreq_frequency_table_cpuinfo (policy, data->freq_table);
    if (result)
        goto err_freqfree;
    switch (perf->control_register.space_id) {
    case ACPI_ADR_SPACE_SYSTEM_IO :
        policy->cur = acpi_cpufreq_guess_freq (data, policy->cpu);
        break;
    case ACPI_ADR_SPACE_FIXED_HARDWARE :
        acpi_cpufreq_driver.get = get_cur_freq_on_cpu;
        policy->cur = get_cur_freq_on_cpu (cpu);
        break;
    default :
        break;
    }
    acpi_processor_notify_smm (THIS_MODULE);
    if (c->x86_vendor == X86_VENDOR_INTEL && c->cpuid_level >= 6) {
        unsigned int ecx;
        ecx = cpuid_ecx (6);
        if (ecx & CPUID_6_ECX_APERFMPERF_CAPABILITY)
            acpi_cpufreq_driver.getavg = get_measured_perf;
    }
    dprintk ("CPU%u - ACPI performance management activated.\n", cpu);
    for (i = 0; i < perf->state_count; i++)
        dprintk ("     %cP%d: %d MHz, %d mW, %d uS\n", (i == perf->state ? '*' : ' '), i, (u32) perf->states[i].core_frequency, (u32) perf->states[i].power, (u32) perf->states[i].transition_latency);
    cpufreq_frequency_table_get_attr (data -> freq_table, policy -> cpu);
    data->resume = 1;
    return result;
err_freqfree :
    kfree (data->freq_table);
err_unreg :
    acpi_processor_unregister_performance (perf, cpu);
err_free :
    kfree (data);
    per_cpu (drv_data, cpu) = NULL;
    return result;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/cpufreq/acpi-cpufreq.c.ifdefed" startline="601" endline="603">
{
    policy->cpus = perf->shared_cpu_map;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/cpufreq/acpi-cpufreq.c.ifdefed" startline="615" endline="619">
{
    dprintk ("No P-States\n");
    result = -ENODEV;
    goto err_unreg;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/cpufreq/acpi-cpufreq.c.ifdefed" startline="621" endline="624">
{
    result = -ENODEV;
    goto err_unreg;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/cpufreq/acpi-cpufreq.c.ifdefed" startline="626" endline="644">
{
case ACPI_ADR_SPACE_SYSTEM_IO :
    dprintk ("SYSTEM IO addr space\n");
    data->cpu_feature = SYSTEM_IO_CAPABLE;
    break;
case ACPI_ADR_SPACE_FIXED_HARDWARE :
    dprintk ("HARDWARE addr space\n");
    if (!check_est_cpu (cpu)) {
        result = -ENODEV;
        goto err_unreg;
    }
    data->cpu_feature = SYSTEM_INTEL_MSR_CAPABLE;
    break;
default :
    dprintk ("Unknown addr space %d\n", (u32) (perf->control_register.space_id));
    result = -ENODEV;
    goto err_unreg;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/cpufreq/acpi-cpufreq.c.ifdefed" startline="633" endline="636">
{
    result = -ENODEV;
    goto err_unreg;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/cpufreq/acpi-cpufreq.c.ifdefed" startline="648" endline="651">
{
    result = -ENOMEM;
    goto err_unreg;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/cpufreq/acpi-cpufreq.c.ifdefed" startline="655" endline="660">
{
    if ((perf->states[i].transition_latency * 1000) > policy->cpuinfo.transition_latency)
        policy->cpuinfo.transition_latency = perf->states[i].transition_latency * 1000;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/cpufreq/acpi-cpufreq.c.ifdefed" startline="664" endline="673">
{
    if (i > 0 && perf->states[i].core_frequency >= data->freq_table[valid_states - 1].frequency / 1000)
        continue;
    data->freq_table[valid_states].index = i;
    data->freq_table[valid_states].frequency = perf->states[i].core_frequency * 1000;
    valid_states++;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/cpufreq/acpi-cpufreq.c.ifdefed" startline="681" endline="692">
{
case ACPI_ADR_SPACE_SYSTEM_IO :
    policy->cur = acpi_cpufreq_guess_freq (data, policy->cpu);
    break;
case ACPI_ADR_SPACE_FIXED_HARDWARE :
    acpi_cpufreq_driver.get = get_cur_freq_on_cpu;
    policy->cur = get_cur_freq_on_cpu (cpu);
    break;
default :
    break;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/cpufreq/acpi-cpufreq.c.ifdefed" startline="698" endline="703">
{
    unsigned int ecx;
    ecx = cpuid_ecx (6);
    if (ecx & CPUID_6_ECX_APERFMPERF_CAPABILITY)
        acpi_cpufreq_driver.getavg = get_measured_perf;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/cpufreq/acpi-cpufreq.c.ifdefed" startline="735" endline="749">
{
    struct acpi_cpufreq_data *data = per_cpu (drv_data, policy->cpu);
    dprintk ("acpi_cpufreq_cpu_exit\n");
    if (data) {
        cpufreq_frequency_table_put_attr (policy -> cpu);
        per_cpu (drv_data, policy->cpu) = NULL;
        acpi_processor_unregister_performance (data -> acpi_data, policy -> cpu);
        kfree (data);
    }
    return 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/cpufreq/acpi-cpufreq.c.ifdefed" startline="740" endline="746">
{
    cpufreq_frequency_table_put_attr (policy -> cpu);
    per_cpu (drv_data, policy->cpu) = NULL;
    acpi_processor_unregister_performance (data -> acpi_data, policy -> cpu);
    kfree (data);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/cpufreq/acpi-cpufreq.c.ifdefed" startline="752" endline="760">
{
    struct acpi_cpufreq_data *data = per_cpu (drv_data, policy->cpu);
    dprintk ("acpi_cpufreq_resume\n");
    data->resume = 1;
    return 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/cpufreq/acpi-cpufreq.c.ifdefed" startline="779" endline="789">
{
    int ret;
    dprintk ("acpi_cpufreq_init\n");
    ret = acpi_cpufreq_early_init ();
    if (ret)
        return ret;
    return cpufreq_register_driver (&acpi_cpufreq_driver);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/cpufreq/acpi-cpufreq.c.ifdefed" startline="792" endline="800">
{
    dprintk ("acpi_cpufreq_exit\n");
    cpufreq_unregister_driver (& acpi_cpufreq_driver);
    free_percpu (acpi_perf_data);
    return;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/bugs_64.c.ifdefed" startline="15" endline="33">
{
    identify_boot_cpu ();
    alternative_instructions ();
    if (!direct_gbpages)
        set_memory_4k ((unsigned long) __va (0), 1);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/centaur_64.c.ifdefed" startline="10" endline="15">
{
    if (c->x86 == 0x6 && c->x86_model >= 0xf)
        set_cpu_cap (c, X86_FEATURE_CONSTANT_TSC);
    set_cpu_cap (c, X86_FEATURE_SYSENTER32);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/centaur_64.c.ifdefed" startline="18" endline="25">
{
    if (c->x86 == 0x6 && c->x86_model >= 0xf) {
        c->x86_cache_alignment = c->x86_clflush_size * 2;
        set_cpu_cap (c, X86_FEATURE_CONSTANT_TSC);
        set_cpu_cap (c, X86_FEATURE_REP_GOOD);
    }
    set_cpu_cap (c, X86_FEATURE_LFENCE_RDTSC);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/centaur_64.c.ifdefed" startline="19" endline="23">
{
    c->x86_cache_alignment = c->x86_clflush_size * 2;
    set_cpu_cap (c, X86_FEATURE_CONSTANT_TSC);
    set_cpu_cap (c, X86_FEATURE_REP_GOOD);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/perfctr-watchdog.c.ifdefed" startline="65" endline="82">
{
    switch (boot_cpu_data.x86_vendor) {
    case X86_VENDOR_AMD :
        return (msr - MSR_K7_PERFCTR0);
    case X86_VENDOR_INTEL :
        if (cpu_has (&boot_cpu_data, X86_FEATURE_ARCH_PERFMON))
            return (msr - MSR_ARCH_PERFMON_PERFCTR0);
        switch (boot_cpu_data.x86) {
        case 6 :
            return (msr - MSR_P6_PERFCTR0);
        case 15 :
            return (msr - MSR_P4_BPU_PERFCTR0);
        }
    }
    return 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/perfctr-watchdog.c.ifdefed" startline="67" endline="80">
{
case X86_VENDOR_AMD :
    return (msr - MSR_K7_PERFCTR0);
case X86_VENDOR_INTEL :
    if (cpu_has (&boot_cpu_data, X86_FEATURE_ARCH_PERFMON))
        return (msr - MSR_ARCH_PERFMON_PERFCTR0);
    switch (boot_cpu_data.x86) {
    case 6 :
        return (msr - MSR_P6_PERFCTR0);
    case 15 :
        return (msr - MSR_P4_BPU_PERFCTR0);
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/perfctr-watchdog.c.ifdefed" startline="74" endline="79">
{
case 6 :
    return (msr - MSR_P6_PERFCTR0);
case 15 :
    return (msr - MSR_P4_BPU_PERFCTR0);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/perfctr-watchdog.c.ifdefed" startline="89" endline="107">
{
    switch (boot_cpu_data.x86_vendor) {
    case X86_VENDOR_AMD :
        return (msr - MSR_K7_EVNTSEL0);
    case X86_VENDOR_INTEL :
        if (cpu_has (&boot_cpu_data, X86_FEATURE_ARCH_PERFMON))
            return (msr - MSR_ARCH_PERFMON_EVENTSEL0);
        switch (boot_cpu_data.x86) {
        case 6 :
            return (msr - MSR_P6_EVNTSEL0);
        case 15 :
            return (msr - MSR_P4_BSU_ESCR0);
        }
    }
    return 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/perfctr-watchdog.c.ifdefed" startline="91" endline="104">
{
case X86_VENDOR_AMD :
    return (msr - MSR_K7_EVNTSEL0);
case X86_VENDOR_INTEL :
    if (cpu_has (&boot_cpu_data, X86_FEATURE_ARCH_PERFMON))
        return (msr - MSR_ARCH_PERFMON_EVENTSEL0);
    switch (boot_cpu_data.x86) {
    case 6 :
        return (msr - MSR_P6_EVNTSEL0);
    case 15 :
        return (msr - MSR_P4_BSU_ESCR0);
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/perfctr-watchdog.c.ifdefed" startline="98" endline="103">
{
case 6 :
    return (msr - MSR_P6_EVNTSEL0);
case 15 :
    return (msr - MSR_P4_BSU_ESCR0);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/perfctr-watchdog.c.ifdefed" startline="111" endline="115">
{
    BUG_ON (counter > NMI_MAX_COUNTER_BITS);
    return (!test_bit (counter, perfctr_nmi_owner));
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/perfctr-watchdog.c.ifdefed" startline="119" endline="126">
{
    unsigned int counter;
    counter = nmi_perfctr_msr_to_bit (msr);
    BUG_ON (counter > NMI_MAX_COUNTER_BITS);
    return (!test_bit (counter, perfctr_nmi_owner));
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/perfctr-watchdog.c.ifdefed" startline="130" endline="141">
{
    unsigned int counter;
    counter = nmi_perfctr_msr_to_bit (msr);
    if (counter > NMI_MAX_COUNTER_BITS)
        return 1;
    if (!test_and_set_bit (counter, perfctr_nmi_owner))
        return 1;
    return 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/perfctr-watchdog.c.ifdefed" startline="145" endline="154">
{
    unsigned int counter;
    counter = nmi_perfctr_msr_to_bit (msr);
    if (counter > NMI_MAX_COUNTER_BITS)
        return;
    clear_bit (counter, perfctr_nmi_owner);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/perfctr-watchdog.c.ifdefed" startline="158" endline="169">
{
    unsigned int counter;
    counter = nmi_evntsel_msr_to_bit (msr);
    if (counter > NMI_MAX_COUNTER_BITS)
        return 1;
    if (!test_and_set_bit (counter, evntsel_nmi_owner))
        return 1;
    return 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/perfctr-watchdog.c.ifdefed" startline="173" endline="182">
{
    unsigned int counter;
    counter = nmi_evntsel_msr_to_bit (msr);
    if (counter > NMI_MAX_COUNTER_BITS)
        return;
    clear_bit (counter, evntsel_nmi_owner);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/perfctr-watchdog.c.ifdefed" startline="186" endline="198">
{
    BUG_ON (nmi_watchdog != NMI_LOCAL_APIC);
    if (atomic_read (&nmi_active) <= 0)
        return;
    on_each_cpu (stop_apic_nmi_watchdog, NULL, 1);
    if (wd_ops)
        wd_ops->unreserve ();
    BUG_ON (atomic_read (& nmi_active) != 0);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/perfctr-watchdog.c.ifdefed" startline="201" endline="218">
{
    BUG_ON (nmi_watchdog != NMI_LOCAL_APIC);
    if (atomic_read (&nmi_active) != 0)
        return;
    if (!wd_ops)
        return;
    if (!wd_ops->reserve ()) {
        printk (KERN_ERR "NMI watchdog: cannot reserve perfctrs\n");
        return;
    }
    on_each_cpu (setup_apic_nmi_watchdog, NULL, 1);
    touch_nmi_watchdog ();
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/perfctr-watchdog.c.ifdefed" startline="211" endline="214">
{
    printk (KERN_ERR "NMI watchdog: cannot reserve perfctrs\n");
    return;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/perfctr-watchdog.c.ifdefed" startline="225" endline="244">
{
    u64 counter_val;
    unsigned int retval = hz;
    counter_val = (u64) cpu_khz * 1000;
    do_div (counter_val, retval);
    if (counter_val > 0x7fffffffULL) {
        u64 count = (u64) cpu_khz * 1000;
        do_div (count, 0x7fffffffUL);
        retval = count + 1;
    }
    return retval;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/perfctr-watchdog.c.ifdefed" startline="238" endline="242">
{
    u64 count = (u64) cpu_khz * 1000;
    do_div (count, 0x7fffffffUL);
    retval = count + 1;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/perfctr-watchdog.c.ifdefed" startline="248" endline="255">
{
    u64 count = (u64) cpu_khz * 1000;
    do_div (count, nmi_hz);
    if (descr)
        pr_debug ("setting %s to -0x%08Lx\n", descr, count);
    wrmsrl (perfctr_msr, 0 - count);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/perfctr-watchdog.c.ifdefed" startline="259" endline="266">
{
    u64 count = (u64) cpu_khz * 1000;
    do_div (count, nmi_hz);
    if (descr)
        pr_debug ("setting %s to -0x%08Lx\n", descr, count);
    wrmsr (perfctr_msr, (u32) (- count), 0);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/perfctr-watchdog.c.ifdefed" startline="280" endline="306">
{
    unsigned int perfctr_msr, evntsel_msr;
    unsigned int evntsel;
    struct nmi_watchdog_ctlblk *wd = &__get_cpu_var (nmi_watchdog_ctlblk);
    perfctr_msr = wd_ops->perfctr;
    evntsel_msr = wd_ops->evntsel;
    wrmsrl (perfctr_msr, 0UL);
    evntsel = K7_EVNTSEL_INT | K7_EVNTSEL_OS | K7_EVNTSEL_USR | K7_NMI_EVENT;
    wrmsr (evntsel_msr, evntsel, 0);
    write_watchdog_counter (perfctr_msr, "K7_PERFCTR0", nmi_hz);
    apic_write (APIC_LVTPC, APIC_DM_NMI);
    evntsel |= K7_EVNTSEL_ENABLE;
    wrmsr (evntsel_msr, evntsel, 0);
    wd->perfctr_msr = perfctr_msr;
    wd->evntsel_msr = evntsel_msr;
    wd->cccr_msr = 0;
    return 1;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/perfctr-watchdog.c.ifdefed" startline="309" endline="313">
{
    struct nmi_watchdog_ctlblk *wd = &__get_cpu_var (nmi_watchdog_ctlblk);
    wrmsr (wd -> evntsel_msr, 0, 0);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/perfctr-watchdog.c.ifdefed" startline="316" endline="325">
{
    if (!reserve_perfctr_nmi (wd_ops->perfctr))
        return 0;
    if (!reserve_evntsel_nmi (wd_ops->evntsel)) {
        release_perfctr_nmi (wd_ops -> perfctr);
        return 0;
    }
    return 1;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/perfctr-watchdog.c.ifdefed" startline="320" endline="323">
{
    release_perfctr_nmi (wd_ops -> perfctr);
    return 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/perfctr-watchdog.c.ifdefed" startline="328" endline="331">
{
    release_evntsel_nmi (wd_ops -> evntsel);
    release_perfctr_nmi (wd_ops -> perfctr);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/perfctr-watchdog.c.ifdefed" startline="334" endline="337">
{
    write_watchdog_counter (wd -> perfctr_msr, NULL, nmi_hz);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/perfctr-watchdog.c.ifdefed" startline="361" endline="390">
{
    unsigned int perfctr_msr, evntsel_msr;
    unsigned int evntsel;
    struct nmi_watchdog_ctlblk *wd = &__get_cpu_var (nmi_watchdog_ctlblk);
    perfctr_msr = wd_ops->perfctr;
    evntsel_msr = wd_ops->evntsel;
    if (wrmsr_safe (perfctr_msr, 0, 0) < 0)
        return 0;
    evntsel = P6_EVNTSEL_INT | P6_EVNTSEL_OS | P6_EVNTSEL_USR | P6_NMI_EVENT;
    wrmsr (evntsel_msr, evntsel, 0);
    nmi_hz = adjust_for_32bit_ctr (nmi_hz);
    write_watchdog_counter32 (perfctr_msr, "P6_PERFCTR0", nmi_hz);
    apic_write (APIC_LVTPC, APIC_DM_NMI);
    evntsel |= P6_EVNTSEL0_ENABLE;
    wrmsr (evntsel_msr, evntsel, 0);
    wd->perfctr_msr = perfctr_msr;
    wd->evntsel_msr = evntsel_msr;
    wd->cccr_msr = 0;
    return 1;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/perfctr-watchdog.c.ifdefed" startline="393" endline="404">
{
    apic_write (APIC_LVTPC, APIC_DM_NMI);
    write_watchdog_counter32 (wd -> perfctr_msr, NULL, nmi_hz);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/perfctr-watchdog.c.ifdefed" startline="441" endline="509">
{
    unsigned int perfctr_msr, evntsel_msr, cccr_msr;
    unsigned int evntsel, cccr_val;
    unsigned int misc_enable, dummy;
    unsigned int ht_num;
    struct nmi_watchdog_ctlblk *wd = &__get_cpu_var (nmi_watchdog_ctlblk);
    rdmsr (MSR_IA32_MISC_ENABLE, misc_enable, dummy);
    if (!(misc_enable & MSR_P4_MISC_ENABLE_PERF_AVAIL))
        return 0;
    ht_num = 0;
    if (!ht_num) {
        perfctr_msr = MSR_P4_IQ_PERFCTR0;
        evntsel_msr = MSR_P4_CRU_ESCR0;
        cccr_msr = MSR_P4_IQ_CCCR0;
        cccr_val = P4_CCCR_OVF_PMI0 | P4_CCCR_ESCR_SELECT (4);
    }
    else {
        perfctr_msr = MSR_P4_IQ_PERFCTR1;
        evntsel_msr = MSR_P4_CRU_ESCR0;
        cccr_msr = MSR_P4_IQ_CCCR1;
        if (boot_cpu_data.x86_model == 4 && boot_cpu_data.x86_mask == 4)
            cccr_val = P4_CCCR_OVF_PMI0;
        else
            cccr_val = P4_CCCR_OVF_PMI1;
        cccr_val |= P4_CCCR_ESCR_SELECT (4);
    }
    evntsel = P4_ESCR_EVENT_SELECT (0x3F) | P4_ESCR_OS | P4_ESCR_USR;
    cccr_val |= P4_CCCR_THRESHOLD (15) | P4_CCCR_COMPLEMENT | P4_CCCR_COMPARE | P4_CCCR_REQUIRED;
    wrmsr (evntsel_msr, evntsel, 0);
    wrmsr (cccr_msr, cccr_val, 0);
    write_watchdog_counter (perfctr_msr, "P4_IQ_COUNTER0", nmi_hz);
    apic_write (APIC_LVTPC, APIC_DM_NMI);
    cccr_val |= P4_CCCR_ENABLE;
    wrmsr (cccr_msr, cccr_val, 0);
    wd->perfctr_msr = perfctr_msr;
    wd->evntsel_msr = evntsel_msr;
    wd->cccr_msr = cccr_msr;
    return 1;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/perfctr-watchdog.c.ifdefed" startline="470" endline="476">
{
    perfctr_msr = MSR_P4_IQ_PERFCTR0;
    evntsel_msr = MSR_P4_CRU_ESCR0;
    cccr_msr = MSR_P4_IQ_CCCR0;
    cccr_val = P4_CCCR_OVF_PMI0 | P4_CCCR_ESCR_SELECT (4);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/perfctr-watchdog.c.ifdefed" startline="476" endline="488">
{
    perfctr_msr = MSR_P4_IQ_PERFCTR1;
    evntsel_msr = MSR_P4_CRU_ESCR0;
    cccr_msr = MSR_P4_IQ_CCCR1;
    if (boot_cpu_data.x86_model == 4 && boot_cpu_data.x86_mask == 4)
        cccr_val = P4_CCCR_OVF_PMI0;
    else
        cccr_val = P4_CCCR_OVF_PMI1;
    cccr_val |= P4_CCCR_ESCR_SELECT (4);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/perfctr-watchdog.c.ifdefed" startline="512" endline="516">
{
    struct nmi_watchdog_ctlblk *wd = &__get_cpu_var (nmi_watchdog_ctlblk);
    wrmsr (wd -> cccr_msr, 0, 0);
    wrmsr (wd -> evntsel_msr, 0, 0);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/perfctr-watchdog.c.ifdefed" startline="519" endline="538">
{
    if (!reserve_perfctr_nmi (MSR_P4_IQ_PERFCTR0))
        return 0;
    if (!reserve_evntsel_nmi (MSR_P4_CRU_ESCR0))
        goto fail2;
    return 1;
fail2 :
    release_perfctr_nmi (MSR_P4_IQ_PERFCTR0);
    return 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/perfctr-watchdog.c.ifdefed" startline="541" endline="548">
{
    release_evntsel_nmi (MSR_P4_CRU_ESCR0);
    release_perfctr_nmi (MSR_P4_IQ_PERFCTR0);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/perfctr-watchdog.c.ifdefed" startline="551" endline="566">
{
    unsigned dummy;
    rdmsrl (wd -> cccr_msr, dummy);
    dummy &= ~P4_CCCR_OVF;
    wrmsrl (wd -> cccr_msr, dummy);
    apic_write (APIC_LVTPC, APIC_DM_NMI);
    write_watchdog_counter (wd -> perfctr_msr, NULL, nmi_hz);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/perfctr-watchdog.c.ifdefed" startline="590" endline="632">
{
    unsigned int ebx;
    union cpuid10_eax eax;
    unsigned int unused;
    unsigned int perfctr_msr, evntsel_msr;
    unsigned int evntsel;
    struct nmi_watchdog_ctlblk *wd = &__get_cpu_var (nmi_watchdog_ctlblk);
    cpuid (10, & (eax.full), & ebx, & unused, & unused);
    if ((eax.split.mask_length < (ARCH_PERFMON_UNHALTED_CORE_CYCLES_INDEX + 1)) || (ebx & ARCH_PERFMON_UNHALTED_CORE_CYCLES_PRESENT))
        return 0;
    perfctr_msr = wd_ops->perfctr;
    evntsel_msr = wd_ops->evntsel;
    wrmsrl (perfctr_msr, 0UL);
    evntsel = ARCH_PERFMON_EVENTSEL_INT | ARCH_PERFMON_EVENTSEL_OS | ARCH_PERFMON_EVENTSEL_USR | ARCH_PERFMON_NMI_EVENT_SEL | ARCH_PERFMON_NMI_EVENT_UMASK;
    wrmsr (evntsel_msr, evntsel, 0);
    nmi_hz = adjust_for_32bit_ctr (nmi_hz);
    write_watchdog_counter32 (perfctr_msr, "INTEL_ARCH_PERFCTR0", nmi_hz);
    apic_write (APIC_LVTPC, APIC_DM_NMI);
    evntsel |= ARCH_PERFMON_EVENTSEL0_ENABLE;
    wrmsr (evntsel_msr, evntsel, 0);
    wd->perfctr_msr = perfctr_msr;
    wd->evntsel_msr = evntsel_msr;
    wd->cccr_msr = 0;
    intel_arch_wd_ops.checkbit = 1ULL << (eax.split.bit_width - 1);
    return 1;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/perfctr-watchdog.c.ifdefed" startline="645" endline="681">
{
    switch (boot_cpu_data.x86_vendor) {
    case X86_VENDOR_AMD :
        if (boot_cpu_data.x86 != 6 && boot_cpu_data.x86 != 15 && boot_cpu_data.x86 != 16)
            return;
        wd_ops = &k7_wd_ops;
        break;
    case X86_VENDOR_INTEL :
        if (boot_cpu_data.x86 == 6 && boot_cpu_data.x86_model == 14) {
            intel_arch_wd_ops.perfctr = MSR_ARCH_PERFMON_PERFCTR0;
            intel_arch_wd_ops.evntsel = MSR_ARCH_PERFMON_EVENTSEL0;
        }
        if (cpu_has (&boot_cpu_data, X86_FEATURE_ARCH_PERFMON)) {
            wd_ops = &intel_arch_wd_ops;
            break;
        }
        switch (boot_cpu_data.x86) {
        case 6 :
            if (boot_cpu_data.x86_model > 13)
                return;
            wd_ops = &p6_wd_ops;
            break;
        case 15 :
            wd_ops = &p4_wd_ops;
            break;
        default :
            return;
        }
        break;
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/perfctr-watchdog.c.ifdefed" startline="646" endline="680">
{
case X86_VENDOR_AMD :
    if (boot_cpu_data.x86 != 6 && boot_cpu_data.x86 != 15 && boot_cpu_data.x86 != 16)
        return;
    wd_ops = &k7_wd_ops;
    break;
case X86_VENDOR_INTEL :
    if (boot_cpu_data.x86 == 6 && boot_cpu_data.x86_model == 14) {
        intel_arch_wd_ops.perfctr = MSR_ARCH_PERFMON_PERFCTR0;
        intel_arch_wd_ops.evntsel = MSR_ARCH_PERFMON_EVENTSEL0;
    }
    if (cpu_has (&boot_cpu_data, X86_FEATURE_ARCH_PERFMON)) {
        wd_ops = &intel_arch_wd_ops;
        break;
    }
    switch (boot_cpu_data.x86) {
    case 6 :
        if (boot_cpu_data.x86_model > 13)
            return;
        wd_ops = &p6_wd_ops;
        break;
    case 15 :
        wd_ops = &p4_wd_ops;
        break;
    default :
        return;
    }
    break;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/perfctr-watchdog.c.ifdefed" startline="658" endline="661">
{
    intel_arch_wd_ops.perfctr = MSR_ARCH_PERFMON_PERFCTR0;
    intel_arch_wd_ops.evntsel = MSR_ARCH_PERFMON_EVENTSEL0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/perfctr-watchdog.c.ifdefed" startline="662" endline="665">
{
    wd_ops = &intel_arch_wd_ops;
    break;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/perfctr-watchdog.c.ifdefed" startline="666" endline="678">
{
case 6 :
    if (boot_cpu_data.x86_model > 13)
        return;
    wd_ops = &p6_wd_ops;
    break;
case 15 :
    wd_ops = &p4_wd_ops;
    break;
default :
    return;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/perfctr-watchdog.c.ifdefed" startline="686" endline="708">
{
    if (!wd_ops) {
        probe_nmi_watchdog ();
        if (!wd_ops) {
            printk (KERN_INFO "NMI watchdog: CPU not supported\n");
            return -1;
        }
        if (!wd_ops->reserve ()) {
            printk (KERN_ERR "NMI watchdog: cannot reserve perfctrs\n");
            return -1;
        }
    }
    if (!(wd_ops->setup (nmi_hz))) {
        printk (KERN_ERR "Cannot setup NMI watchdog on CPU %d\n", raw_smp_processor_id ());
        return -1;
    }
    return 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/perfctr-watchdog.c.ifdefed" startline="687" endline="699">
{
    probe_nmi_watchdog ();
    if (!wd_ops) {
        printk (KERN_INFO "NMI watchdog: CPU not supported\n");
        return -1;
    }
    if (!wd_ops->reserve ()) {
        printk (KERN_ERR "NMI watchdog: cannot reserve perfctrs\n");
        return -1;
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/perfctr-watchdog.c.ifdefed" startline="689" endline="692">
{
    printk (KERN_INFO "NMI watchdog: CPU not supported\n");
    return -1;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/perfctr-watchdog.c.ifdefed" startline="694" endline="698">
{
    printk (KERN_ERR "NMI watchdog: cannot reserve perfctrs\n");
    return -1;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/perfctr-watchdog.c.ifdefed" startline="701" endline="705">
{
    printk (KERN_ERR "Cannot setup NMI watchdog on CPU %d\n", raw_smp_processor_id ());
    return -1;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/perfctr-watchdog.c.ifdefed" startline="711" endline="714">
{
    if (wd_ops)
        wd_ops->stop ();
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/perfctr-watchdog.c.ifdefed" startline="717" endline="723">
{
    struct nmi_watchdog_ctlblk *wd = &__get_cpu_var (nmi_watchdog_ctlblk);
    if (wd->perfctr_msr == MSR_P6_PERFCTR0 || wd->perfctr_msr == MSR_ARCH_PERFMON_PERFCTR1)
        hz = adjust_for_32bit_ctr (hz);
    return hz;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/perfctr-watchdog.c.ifdefed" startline="726" endline="736">
{
    struct nmi_watchdog_ctlblk *wd = &__get_cpu_var (nmi_watchdog_ctlblk);
    u64 ctr;
    rdmsrl (wd -> perfctr_msr, ctr);
    if (ctr & wd_ops->checkbit)
        return 0;
    wd_ops->rearm (wd, nmi_hz);
    return 1;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/perfctr-watchdog.c.ifdefed" startline="739" endline="741">
{
    return wd_ops != NULL;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/common_64.c.ifdefed" startline="61" endline="67">
{
    struct desc_ptr gdt_descr;
    gdt_descr.address = (long) get_cpu_gdt_table (smp_processor_id ());
    gdt_descr.size = GDT_SIZE - 1;
    load_gdt (& gdt_descr);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/common_64.c.ifdefed" startline="72" endline="74">
{
    display_cacheinfo (c);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/common_64.c.ifdefed" startline="83" endline="95">
{
    unsigned int *v;
    if (c->extended_cpuid_level < 0x80000004)
        return 0;
    v = (unsigned int *) c->x86_model_id;
    cpuid (0x80000002, & v [0], & v [1], & v [2], & v [3]);
    cpuid (0x80000003, & v [4], & v [5], & v [6], & v [7]);
    cpuid (0x80000004, & v [8], & v [9], & v [10], & v [11]);
    c->x86_model_id[48] = 0;
    return 1;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/common_64.c.ifdefed" startline="99" endline="123">
{
    unsigned int n, dummy, ebx, ecx, edx;
    n = c->extended_cpuid_level;
    if (n >= 0x80000005) {
        cpuid (0x80000005, & dummy, & ebx, & ecx, & edx);
        printk (KERN_INFO "CPU: L1 I Cache: %dK (%d bytes/line), " "D cache %dK (%d bytes/line)\n", edx >> 24, edx & 0xFF, ecx >> 24, ecx & 0xFF);
        c->x86_cache_size = (ecx >> 24) + (edx >> 24);
        c->x86_tlbsize = 0;
    }
    if (n >= 0x80000006) {
        cpuid (0x80000006, & dummy, & ebx, & ecx, & edx);
        ecx = cpuid_ecx (0x80000006);
        c->x86_cache_size = ecx >> 16;
        c->x86_tlbsize += ((ebx >> 16) & 0xfff) + (ebx & 0xfff);
        printk (KERN_INFO "CPU: L2 Cache: %dK (%d bytes/line)\n", c -> x86_cache_size, ecx & 0xFF);
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/common_64.c.ifdefed" startline="104" endline="112">
{
    cpuid (0x80000005, & dummy, & ebx, & ecx, & edx);
    printk (KERN_INFO "CPU: L1 I Cache: %dK (%d bytes/line), " "D cache %dK (%d bytes/line)\n", edx >> 24, edx & 0xFF, ecx >> 24, ecx & 0xFF);
    c->x86_cache_size = (ecx >> 24) + (edx >> 24);
    c->x86_tlbsize = 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/common_64.c.ifdefed" startline="114" endline="122">
{
    cpuid (0x80000006, & dummy, & ebx, & ecx, & edx);
    ecx = cpuid_ecx (0x80000006);
    c->x86_cache_size = ecx >> 16;
    c->x86_tlbsize += ((ebx >> 16) & 0xfff) + (ebx & 0xfff);
    printk (KERN_INFO "CPU: L2 Cache: %dK (%d bytes/line)\n", c -> x86_cache_size, ecx & 0xFF);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/common_64.c.ifdefed" startline="126" endline="173">
{
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/common_64.c.ifdefed" startline="176" endline="198">
{
    char *v = c->x86_vendor_id;
    int i;
    static int printed;
    for (i = 0; i < X86_VENDOR_NUM; i++) {
        if (cpu_devs[i]) {
            if (!strcmp (v, cpu_devs[i]->c_ident[0]) || (cpu_devs[i]->c_ident[1] && !strcmp (v, cpu_devs[i]->c_ident[1]))) {
                c->x86_vendor = i;
                this_cpu = cpu_devs[i];
                return;
            }
        }
    }
    if (!printed) {
        printed++;
        printk (KERN_ERR "CPU: Vendor unknown, using generic init.\n");
        printk (KERN_ERR "CPU: Your system may be unstable.\n");
    }
    c->x86_vendor = X86_VENDOR_UNKNOWN;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/common_64.c.ifdefed" startline="181" endline="191">
{
    if (cpu_devs[i]) {
        if (!strcmp (v, cpu_devs[i]->c_ident[0]) || (cpu_devs[i]->c_ident[1] && !strcmp (v, cpu_devs[i]->c_ident[1]))) {
            c->x86_vendor = i;
            this_cpu = cpu_devs[i];
            return;
        }
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/common_64.c.ifdefed" startline="182" endline="190">
{
    if (!strcmp (v, cpu_devs[i]->c_ident[0]) || (cpu_devs[i]->c_ident[1] && !strcmp (v, cpu_devs[i]->c_ident[1]))) {
        c->x86_vendor = i;
        this_cpu = cpu_devs[i];
        return;
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/common_64.c.ifdefed" startline="185" endline="189">
{
    c->x86_vendor = i;
    this_cpu = cpu_devs[i];
    return;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/common_64.c.ifdefed" startline="192" endline="196">
{
    printed++;
    printk (KERN_ERR "CPU: Vendor unknown, using generic init.\n");
    printk (KERN_ERR "CPU: Your system may be unstable.\n");
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/common_64.c.ifdefed" startline="201" endline="217">
{
    int i, j;
    struct cpu_dev *cpu_devx;
    printk ("KERNEL supported cpus:\n");
    for (i = 0; i < X86_VENDOR_NUM; i++) {
        cpu_devx = cpu_devs[i];
        if (!cpu_devx)
            continue;
        for (j = 0; j < 2; j++) {
            if (!cpu_devx->c_ident[j])
                continue;
            printk ("  %s %s\n", cpu_devx -> c_vendor, cpu_devx -> c_ident [j]);
        }
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/common_64.c.ifdefed" startline="206" endline="216">
{
    cpu_devx = cpu_devs[i];
    if (!cpu_devx)
        continue;
    for (j = 0; j < 2; j++) {
        if (!cpu_devx->c_ident[j])
            continue;
        printk ("  %s %s\n", cpu_devx -> c_vendor, cpu_devx -> c_ident [j]);
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/common_64.c.ifdefed" startline="210" endline="215">
{
    if (!cpu_devx->c_ident[j])
        continue;
    printk ("  %s %s\n", cpu_devx -> c_vendor, cpu_devx -> c_ident [j]);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/common_64.c.ifdefed" startline="231" endline="250">
{
    const u32 nopl_signature = 0x888c53b1;
    u32 has_nopl = nopl_signature;
    clear_cpu_cap (c, X86_FEATURE_NOPL);
    if (c->x86 >= 6) {
        asm volatile ("\n"
            "1:      .byte 0x0f,0x1f,0xc0\n"
            "2:\n"
            "        .section .fixup,\"ax\"\n"
            "3:      xor %0,%0\n"
            "        jmp 2b\n"
            "        .previous\n"
            _ASM_EXTABLE (1b, 3b)
            : "+a" (has_nopl)
        ) if (has_nopl == nopl_signature)
            set_cpu_cap (c, X86_FEATURE_NOPL);
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/common_64.c.ifdefed" startline="236" endline="249">
{
    asm volatile ("\n"
        "1:      .byte 0x0f,0x1f,0xc0\n"
        "2:\n"
        "        .section .fixup,\"ax\"\n"
        "3:      xor %0,%0\n"
        "        jmp 2b\n"
        "        .previous\n"
        _ASM_EXTABLE (1b, 3b)
        : "+a" (has_nopl)
    ) if (has_nopl == nopl_signature)
        set_cpu_cap (c, X86_FEATURE_NOPL);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/common_64.c.ifdefed" startline="255" endline="264">
{
    struct cpu_vendor_dev *cvdev;
    for (cvdev = __x86cpuvendor_start; cvdev < __x86cpuvendor_end; cvdev++)
        cpu_devs[cvdev->vendor] = cvdev->cpu_dev;
    early_cpu_support_print ();
    early_identify_cpu (& boot_cpu_data);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/common_64.c.ifdefed" startline="270" endline="357">
{
    u32 tfms, xlvl;
    c->loops_per_jiffy = loops_per_jiffy;
    c->x86_cache_size = -1;
    c->x86_vendor = X86_VENDOR_UNKNOWN;
    c->x86_model = c->x86_mask = 0;
    c->x86_vendor_id[0] = '\0';
    c->x86_model_id[0] = '\0';
    c->x86_clflush_size = 64;
    c->x86_cache_alignment = c->x86_clflush_size;
    c->x86_max_cores = 1;
    c->x86_coreid_bits = 0;
    c->extended_cpuid_level = 0;
    memset (& c -> x86_capability, 0, sizeof c -> x86_capability);
    cpuid (0x00000000, (unsigned int *) & c -> cpuid_level, (unsigned int *) & c -> x86_vendor_id [0], (unsigned int *) & c -> x86_vendor_id [8], (unsigned int *) & c -> x86_vendor_id [4]);
    get_cpu_vendor (c);
    if (c->cpuid_level >= 0x00000001) {
        __u32 misc;
        cpuid (0x00000001, & tfms, & misc, & c -> x86_capability [4], & c -> x86_capability [0]);
        c->x86 = (tfms >> 8) & 0xf;
        c->x86_model = (tfms >> 4) & 0xf;
        c->x86_mask = tfms & 0xf;
        if (c->x86 == 0xf)
            c->x86 += (tfms >> 20) & 0xff;
        if (c->x86 >= 0x6)
            c->x86_model += ((tfms >> 16) & 0xF) << 4;
        if (test_cpu_cap (c, X86_FEATURE_CLFLSH))
            c->x86_clflush_size = ((misc >> 8) & 0xff) * 8;
    }
    else {
        c->x86 = 4;
    }
    c->initial_apicid = (cpuid_ebx (1) >> 24) & 0xff;
    xlvl = cpuid_eax (0x80000000);
    c->extended_cpuid_level = xlvl;
    if ((xlvl & 0xffff0000) == 0x80000000) {
        if (xlvl >= 0x80000001) {
            c->x86_capability[1] = cpuid_edx (0x80000001);
            c->x86_capability[6] = cpuid_ecx (0x80000001);
        }
        if (xlvl >= 0x80000004)
            get_model_name (c);
    }
    xlvl = cpuid_eax (0x80860000);
    if ((xlvl & 0xffff0000) == 0x80860000) {
        if (xlvl >= 0x80860001)
            c->x86_capability[2] = cpuid_edx (0x80860001);
    }
    if (c->extended_cpuid_level >= 0x80000007)
        c->x86_power = cpuid_edx (0x80000007);
    if (c->extended_cpuid_level >= 0x80000008) {
        u32 eax = cpuid_eax (0x80000008);
        c->x86_virt_bits = (eax >> 8) & 0xff;
        c->x86_phys_bits = eax & 0xff;
    }
    detect_nopl (c);
    if (c->x86_vendor != X86_VENDOR_UNKNOWN && cpu_devs[c->x86_vendor]->c_early_init)
        cpu_devs[c->x86_vendor]->c_early_init (c);
    validate_pat_support (c);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/common_64.c.ifdefed" startline="298" endline="311">
{
    __u32 misc;
    cpuid (0x00000001, & tfms, & misc, & c -> x86_capability [4], & c -> x86_capability [0]);
    c->x86 = (tfms >> 8) & 0xf;
    c->x86_model = (tfms >> 4) & 0xf;
    c->x86_mask = tfms & 0xf;
    if (c->x86 == 0xf)
        c->x86 += (tfms >> 20) & 0xff;
    if (c->x86 >= 0x6)
        c->x86_model += ((tfms >> 16) & 0xF) << 4;
    if (test_cpu_cap (c, X86_FEATURE_CLFLSH))
        c->x86_clflush_size = ((misc >> 8) & 0xff) * 8;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/common_64.c.ifdefed" startline="311" endline="314">
{
    c->x86 = 4;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/common_64.c.ifdefed" startline="323" endline="330">
{
    if (xlvl >= 0x80000001) {
        c->x86_capability[1] = cpuid_edx (0x80000001);
        c->x86_capability[6] = cpuid_ecx (0x80000001);
    }
    if (xlvl >= 0x80000004)
        get_model_name (c);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/common_64.c.ifdefed" startline="324" endline="327">
{
    c->x86_capability[1] = cpuid_edx (0x80000001);
    c->x86_capability[6] = cpuid_ecx (0x80000001);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/common_64.c.ifdefed" startline="334" endline="338">
{
    if (xlvl >= 0x80860001)
        c->x86_capability[2] = cpuid_edx (0x80860001);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/common_64.c.ifdefed" startline="343" endline="348">
{
    u32 eax = cpuid_eax (0x80000008);
    c->x86_virt_bits = (eax >> 8) & 0xff;
    c->x86_phys_bits = eax & 0xff;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/common_64.c.ifdefed" startline="363" endline="412">
{
    int i;
    early_identify_cpu (c);
    init_scattered_cpuid_features (c);
    c->apicid = phys_pkg_id (0);
    if (this_cpu->c_init)
        this_cpu->c_init (c);
    detect_ht (c);
    if (c != &boot_cpu_data) {
        for (i = 0; i < NCAPINTS; i++)
            boot_cpu_data.x86_capability[i] &= c->x86_capability[i];
    }
    for (i = 0; i < NCAPINTS; i++)
        c->x86_capability[i] &= ~cleared_cpu_caps[i];
    select_idle_routine (c);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/common_64.c.ifdefed" startline="393" endline="397">
{
    for (i = 0; i < NCAPINTS; i++)
        boot_cpu_data.x86_capability[i] &= c->x86_capability[i];
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/common_64.c.ifdefed" startline="415" endline="417">
{
    identify_cpu (& boot_cpu_data);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/common_64.c.ifdefed" startline="420" endline="424">
{
    BUG_ON (c == & boot_cpu_data);
    identify_cpu (c);
    mtrr_ap_init ();
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/common_64.c.ifdefed" startline="427" endline="430">
{
    setup_clear_cpu_cap (X86_FEATURE_CLFLSH);
    return 1;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/common_64.c.ifdefed" startline="434" endline="442">
{
    if (c->x86_model_id[0])
        printk (KERN_CONT "%s", c->x86_model_id);
    if (c->x86_mask || c->cpuid_level >= 0)
        printk (KERN_CONT " stepping %02x\n", c->x86_mask);
    else
        printk (KERN_CONT "\n");
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/common_64.c.ifdefed" startline="445" endline="452">
{
    int bit;
    if (get_option (&arg, &bit) && bit < NCAPINTS * 32)
        setup_clear_cpu_cap (bit);
    else
        return 0;
    return 1;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/common_64.c.ifdefed" startline="476" endline="487">
{
    if (!str)
        return -EINVAL;
    if (!strncmp (str, "on", 2)) {
        __supported_pte_mask |= _PAGE_NX;
        do_not_nx = 0;
    }
    else if (!strncmp (str, "off", 3)) {
        do_not_nx = 1;
        __supported_pte_mask &= ~_PAGE_NX;
    }
    return 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/common_64.c.ifdefed" startline="479" endline="482">
{
    __supported_pte_mask |= _PAGE_NX;
    do_not_nx = 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/common_64.c.ifdefed" startline="482" endline="485">
{
    do_not_nx = 1;
    __supported_pte_mask &= ~_PAGE_NX;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/common_64.c.ifdefed" startline="500" endline="506">
{
    if (!strcmp (str, "on"))
        force_personality32 &= ~READ_IMPLIES_EXEC;
    else if (!strcmp (str, "off"))
        force_personality32 |= READ_IMPLIES_EXEC;
    return 1;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/common_64.c.ifdefed" startline="510" endline="546">
{
    struct x8664_pda *pda = cpu_pda (cpu);
    loadsegment (fs, 0);
    loadsegment (gs, 0);
    mb ();
    wrmsrl (MSR_GS_BASE, pda);
    mb ();
    pda->cpunumber = cpu;
    pda->irqcount = -1;
    pda->kernelstack = (unsigned long) stack_thread_info () - PDA_STACKOFFSET + THREAD_SIZE;
    pda->active_mm = &init_mm;
    pda->mmu_state = 0;
    if (cpu == 0) {
        pda->pcurrent = &init_task;
        pda->irqstackptr = boot_cpu_stack;
        pda->irqstackptr += IRQSTACKSIZE - 64;
    }
    else {
        if (!pda->irqstackptr) {
            pda->irqstackptr = (char *) __get_free_pages (GFP_ATOMIC, IRQSTACK_ORDER);
            if (!pda->irqstackptr)
                panic ("cannot allocate irqstack for cpu %d", cpu);
            pda->irqstackptr += IRQSTACKSIZE - 64;
        }
        if (pda->nodenumber == 0 && cpu_to_node (cpu) != NUMA_NO_NODE)
            pda->nodenumber = cpu_to_node (cpu);
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/common_64.c.ifdefed" startline="528" endline="533">
{
    pda->pcurrent = &init_task;
    pda->irqstackptr = boot_cpu_stack;
    pda->irqstackptr += IRQSTACKSIZE - 64;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/common_64.c.ifdefed" startline="533" endline="545">
{
    if (!pda->irqstackptr) {
        pda->irqstackptr = (char *) __get_free_pages (GFP_ATOMIC, IRQSTACK_ORDER);
        if (!pda->irqstackptr)
            panic ("cannot allocate irqstack for cpu %d", cpu);
        pda->irqstackptr += IRQSTACKSIZE - 64;
    }
    if (pda->nodenumber == 0 && cpu_to_node (cpu) != NUMA_NO_NODE)
        pda->nodenumber = cpu_to_node (cpu);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/common_64.c.ifdefed" startline="534" endline="541">
{
    pda->irqstackptr = (char *) __get_free_pages (GFP_ATOMIC, IRQSTACK_ORDER);
    if (!pda->irqstackptr)
        panic ("cannot allocate irqstack for cpu %d", cpu);
    pda->irqstackptr += IRQSTACKSIZE - 64;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/common_64.c.ifdefed" startline="555" endline="572">
{
    wrmsrl (MSR_STAR, ((u64) __USER32_CS) << 48 | ((u64) __KERNEL_CS) << 32);
    wrmsrl (MSR_LSTAR, system_call);
    wrmsrl (MSR_CSTAR, ignore_sysret);
    wrmsrl (MSR_SYSCALL_MASK, X86_EFLAGS_TF | X86_EFLAGS_DF | X86_EFLAGS_IF | X86_EFLAGS_IOPL);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/common_64.c.ifdefed" startline="575" endline="581">
{
    unsigned long efer;
    rdmsrl (MSR_EFER, efer);
    if (!(efer & EFER_NX) || do_not_nx)
        __supported_pte_mask &= ~_PAGE_NX;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/common_64.c.ifdefed" startline="599" endline="712">
{
    int cpu = stack_smp_processor_id ();
    struct tss_struct *t = &per_cpu (init_tss, cpu);
    struct orig_ist *orig_ist = &per_cpu (orig_ist, cpu);
    unsigned long v;
    char *estacks = NULL;
    struct task_struct *me;
    int i;
    if (cpu != 0)
        pda_init (cpu);
    else
        estacks = boot_exception_stacks;
    me = current;
    if (cpu_test_and_set (cpu, cpu_initialized))
        panic ("CPU#%d already initialized!\n", cpu);
    printk (KERN_INFO "Initializing CPU#%d\n", cpu);
    clear_in_cr4 (X86_CR4_VME | X86_CR4_PVI | X86_CR4_TSD | X86_CR4_DE);
    switch_to_new_gdt ();
    load_idt ((const struct desc_ptr *) & idt_descr);
    memset (me -> thread.tls_array, 0, GDT_ENTRY_TLS_ENTRIES * 8);
    syscall_init ();
    wrmsrl (MSR_FS_BASE, 0);
    wrmsrl (MSR_KERNEL_GS_BASE, 0);
    barrier ();
    check_efer ();
    if (!orig_ist->ist[0]) {
        static const unsigned int order [N_EXCEPTION_STACKS] = {
            [0 ... N_EXCEPTION_STACKS - 1] = EXCEPTION_STACK_ORDER,
            [DEBUG_STACK - 1] = DEBUG_STACK_ORDER
        };
        for (v = 0; v < N_EXCEPTION_STACKS; v++) {
            if (cpu) {
                estacks = (char *) __get_free_pages (GFP_ATOMIC, order[v]);
                if (!estacks)
                    panic ("Cannot allocate exception " "stack %ld %d\n", v, cpu);
            }
            estacks += PAGE_SIZE << order[v];
            orig_ist->ist[v] = t->x86_tss.ist[v] = (unsigned long) estacks;
        }
    }
    t->x86_tss.io_bitmap_base = offsetof (struct tss_struct, io_bitmap);
    for (i = 0; i <= IO_BITMAP_LONGS; i++)
        t->io_bitmap[i] = ~0UL;
    atomic_inc (& init_mm.mm_count);
    me->active_mm = &init_mm;
    if (me->mm)
        BUG ();
    enter_lazy_tlb (& init_mm, me);
    load_sp0 (t, & current -> thread);
    set_tss_desc (cpu, t);
    load_TR_desc ();
    load_LDT (& init_mm.context);
    set_debugreg (0UL, 0);
    set_debugreg (0UL, 1);
    set_debugreg (0UL, 2);
    set_debugreg (0UL, 3);
    set_debugreg (0UL, 6);
    set_debugreg (0UL, 7);
    fpu_init ();
    raw_local_save_flags (kernel_eflags);
    if (is_uv_system ())
        uv_cpu_init ();
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/common_64.c.ifdefed" startline="643" endline="659">
{
    static const unsigned int order [N_EXCEPTION_STACKS] = {
        [0 ... N_EXCEPTION_STACKS - 1] = EXCEPTION_STACK_ORDER,
        [DEBUG_STACK - 1] = DEBUG_STACK_ORDER
    };
    for (v = 0; v < N_EXCEPTION_STACKS; v++) {
        if (cpu) {
            estacks = (char *) __get_free_pages (GFP_ATOMIC, order[v]);
            if (!estacks)
                panic ("Cannot allocate exception " "stack %ld %d\n", v, cpu);
        }
        estacks += PAGE_SIZE << order[v];
        orig_ist->ist[v] = t->x86_tss.ist[v] = (unsigned long) estacks;
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/common_64.c.ifdefed" startline="648" endline="658">
{
    if (cpu) {
        estacks = (char *) __get_free_pages (GFP_ATOMIC, order[v]);
        if (!estacks)
            panic ("Cannot allocate exception " "stack %ld %d\n", v, cpu);
    }
    estacks += PAGE_SIZE << order[v];
    orig_ist->ist[v] = t->x86_tss.ist[v] = (unsigned long) estacks;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/common_64.c.ifdefed" startline="649" endline="654">
{
    estacks = (char *) __get_free_pages (GFP_ATOMIC, order[v]);
    if (!estacks)
        panic ("Cannot allocate exception " "stack %ld %d\n", v, cpu);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/amd_64.c.ifdefed" startline="38" endline="82">
{
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/amd_64.c.ifdefed" startline="85" endline="109">
{
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/amd_64.c.ifdefed" startline="112" endline="120">
{
    early_init_amd_mc (c);
    if (c->x86_power & (1 << 8))
        set_cpu_cap (c, X86_FEATURE_CONSTANT_TSC);
    set_cpu_cap (c, X86_FEATURE_SYSCALL32);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/amd_64.c.ifdefed" startline="123" endline="214">
{
    unsigned level;
    clear_cpu_cap (c, 0 * 32 + 31);
    if (c->x86 == 0xf) {
        level = cpuid_eax (1);
        if ((level >= 0x0f48 && level < 0x0f50) || level >= 0x0f58)
            set_cpu_cap (c, X86_FEATURE_REP_GOOD);
    }
    if (c->x86 == 0x10 || c->x86 == 0x11)
        set_cpu_cap (c, X86_FEATURE_REP_GOOD);
    if (c->x86 >= 6)
        set_cpu_cap (c, X86_FEATURE_FXSAVE_LEAK);
    level = get_model_name (c);
    if (!level) {
        switch (c->x86) {
        case 0xf :
            strcpy (c->x86_model_id, "Hammer");
            break;
        }
    }
    display_cacheinfo (c);
    if (c->extended_cpuid_level >= 0x80000008)
        amd_detect_cmp (c);
    if (c->extended_cpuid_level >= 0x80000006 && (cpuid_edx (0x80000006) & 0xf000))
        num_cache_leaves = 4;
    else
        num_cache_leaves = 3;
    if (c->x86 >= 0xf && c->x86 <= 0x11)
        set_cpu_cap (c, X86_FEATURE_K8);
    set_cpu_cap (c, X86_FEATURE_MFENCE_RDTSC);
    if (c->x86 == 0x10) {
        if (c == &boot_cpu_data)
            check_enable_amd_mmconf_dmi ();
        fam10h_check_enable_mmcfg ();
    }
    if (c == &boot_cpu_data && c->x86 >= 0xf && c->x86 <= 0x11) {
        unsigned long long tseg;
        if (!rdmsrl_safe (MSR_K8_TSEG_ADDR, &tseg)) {
            printk (KERN_DEBUG "tseg: %010llx\n", tseg);
            if ((tseg >> PMD_SHIFT) < (max_low_pfn_mapped >> (PMD_SHIFT - PAGE_SHIFT)) || ((tseg >> PMD_SHIFT) < (max_pfn_mapped >> (PMD_SHIFT - PAGE_SHIFT)) && (tseg >> PMD_SHIFT) >= (1ULL << (32 - PMD_SHIFT))))
                set_memory_4k ((unsigned long) __va (tseg), 1);
        }
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/amd_64.c.ifdefed" startline="148" endline="152">
{
    level = cpuid_eax (1);
    if ((level >= 0x0f48 && level < 0x0f50) || level >= 0x0f58)
        set_cpu_cap (c, X86_FEATURE_REP_GOOD);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/amd_64.c.ifdefed" startline="161" endline="169">
{
    switch (c->x86) {
    case 0xf :
        strcpy (c->x86_model_id, "Hammer");
        break;
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/amd_64.c.ifdefed" startline="162" endline="168">
{
case 0xf :
    strcpy (c->x86_model_id, "Hammer");
    break;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/amd_64.c.ifdefed" startline="188" endline="194">
{
    if (c == &boot_cpu_data)
        check_enable_amd_mmconf_dmi ();
    fam10h_check_enable_mmcfg ();
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/amd_64.c.ifdefed" startline="196" endline="213">
{
    unsigned long long tseg;
    if (!rdmsrl_safe (MSR_K8_TSEG_ADDR, &tseg)) {
        printk (KERN_DEBUG "tseg: %010llx\n", tseg);
        if ((tseg >> PMD_SHIFT) < (max_low_pfn_mapped >> (PMD_SHIFT - PAGE_SHIFT)) || ((tseg >> PMD_SHIFT) < (max_pfn_mapped >> (PMD_SHIFT - PAGE_SHIFT)) && (tseg >> PMD_SHIFT) >= (1ULL << (32 - PMD_SHIFT))))
            set_memory_4k ((unsigned long) __va (tseg), 1);
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/amd_64.c.ifdefed" startline="204" endline="212">
{
    printk (KERN_DEBUG "tseg: %010llx\n", tseg);
    if ((tseg >> PMD_SHIFT) < (max_low_pfn_mapped >> (PMD_SHIFT - PAGE_SHIFT)) || ((tseg >> PMD_SHIFT) < (max_pfn_mapped >> (PMD_SHIFT - PAGE_SHIFT)) && (tseg >> PMD_SHIFT) >= (1ULL << (32 - PMD_SHIFT))))
        set_memory_4k ((unsigned long) __va (tseg), 1);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/mtrr/state.c.ifdefed" startline="13" endline="43">
{
    unsigned int cr0;
    local_irq_save (ctxt -> flags);
    if (use_intel () || is_cpu (CYRIX)) {
        if (cpu_has_pge) {
            ctxt->cr4val = read_cr4 ();
            write_cr4 (ctxt -> cr4val & ~ X86_CR4_PGE);
        }
        cr0 = read_cr0 () | X86_CR0_CD;
        wbinvd ();
        write_cr0 (cr0);
        wbinvd ();
        if (use_intel ())
            rdmsr (MTRRdefType_MSR, ctxt->deftype_lo, ctxt->deftype_hi);
        else
            ctxt->ccr3 = getCx86 (CX86_CCR3);
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/mtrr/state.c.ifdefed" startline="19" endline="42">
{
    if (cpu_has_pge) {
        ctxt->cr4val = read_cr4 ();
        write_cr4 (ctxt -> cr4val & ~ X86_CR4_PGE);
    }
    cr0 = read_cr0 () | X86_CR0_CD;
    wbinvd ();
    write_cr0 (cr0);
    wbinvd ();
    if (use_intel ())
        rdmsr (MTRRdefType_MSR, ctxt->deftype_lo, ctxt->deftype_hi);
    else
        ctxt->ccr3 = getCx86 (CX86_CCR3);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/mtrr/state.c.ifdefed" startline="22" endline="25">
{
    ctxt->cr4val = read_cr4 ();
    write_cr4 (ctxt -> cr4val & ~ X86_CR4_PGE);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/mtrr/state.c.ifdefed" startline="46" endline="54">
{
    if (use_intel ())
        mtrr_wrmsr (MTRRdefType_MSR, ctxt->deftype_lo & 0xf300UL, ctxt->deftype_hi);
    else if (is_cpu (CYRIX))
        setCx86 (CX86_CCR3, (ctxt->ccr3 & 0x0f) | 0x10);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/mtrr/state.c.ifdefed" startline="58" endline="81">
{
    if (use_intel () || is_cpu (CYRIX)) {
        wbinvd ();
        if (use_intel ())
            mtrr_wrmsr (MTRRdefType_MSR, ctxt->deftype_lo, ctxt->deftype_hi);
        else
            setCx86 (CX86_CCR3, ctxt->ccr3);
        write_cr0 (read_cr0 () & 0xbfffffff);
        if (cpu_has_pge)
            write_cr4 (ctxt->cr4val);
    }
    local_irq_restore (ctxt -> flags);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/mtrr/state.c.ifdefed" startline="59" endline="78">
{
    wbinvd ();
    if (use_intel ())
        mtrr_wrmsr (MTRRdefType_MSR, ctxt->deftype_lo, ctxt->deftype_hi);
    else
        setCx86 (CX86_CCR3, ctxt->ccr3);
    write_cr0 (read_cr0 () & 0xbfffffff);
    if (cpu_has_pge)
        write_cr4 (ctxt->cr4val);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/mtrr/if.c.ifdefed" startline="28" endline="30">
{
    return (x <= 6) ? mtrr_strings[x] : "?";
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/mtrr/generic.c.ifdefed" startline="55" endline="151">
{
    int i;
    u64 base, mask;
    u8 prev_match, curr_match;
    if (!mtrr_state_set)
        return 0xFF;
    if (!mtrr_state.enabled)
        return 0xFF;
    end--;
    if (mtrr_state.have_fixed && (start < 0x100000)) {
        int idx;
        if (start < 0x80000) {
            idx = 0;
            idx += (start >> 16);
            return mtrr_state.fixed_ranges[idx];
        }
        else if (start < 0xC0000) {
            idx = 1 * 8;
            idx += ((start - 0x80000) >> 14);
            return mtrr_state.fixed_ranges[idx];
        }
        else if (start < 0x1000000) {
            idx = 3 * 8;
            idx += ((start - 0xC0000) >> 12);
            return mtrr_state.fixed_ranges[idx];
        }
    }
    if (!(mtrr_state.enabled & 2)) {
        return mtrr_state.def_type;
    }
    prev_match = 0xFF;
    for (i = 0; i < num_var_ranges; ++i) {
        unsigned short start_state, end_state;
        if (!(mtrr_state.var_ranges[i].mask_lo & (1 << 11)))
            continue;
        base = (((u64) mtrr_state.var_ranges[i].base_hi) << 32) + (mtrr_state.var_ranges[i].base_lo & PAGE_MASK);
        mask = (((u64) mtrr_state.var_ranges[i].mask_hi) << 32) + (mtrr_state.var_ranges[i].mask_lo & PAGE_MASK);
        start_state = ((start & mask) == (base & mask));
        end_state = ((end & mask) == (base & mask));
        if (start_state != end_state)
            return 0xFE;
        if ((start & mask) != (base & mask)) {
            continue;
        }
        curr_match = mtrr_state.var_ranges[i].base_lo & 0xff;
        if (prev_match == 0xFF) {
            prev_match = curr_match;
            continue;
        }
        if (prev_match == MTRR_TYPE_UNCACHABLE || curr_match == MTRR_TYPE_UNCACHABLE) {
            return MTRR_TYPE_UNCACHABLE;
        }
        if ((prev_match == MTRR_TYPE_WRBACK && curr_match == MTRR_TYPE_WRTHROUGH) || (prev_match == MTRR_TYPE_WRTHROUGH && curr_match == MTRR_TYPE_WRBACK)) {
            prev_match = MTRR_TYPE_WRTHROUGH;
            curr_match = MTRR_TYPE_WRTHROUGH;
        }
        if (prev_match != curr_match) {
            return MTRR_TYPE_UNCACHABLE;
        }
    }
    if (mtrr_tom2) {
        if (start >= (1ULL << 32) && (end < mtrr_tom2))
            return MTRR_TYPE_WRBACK;
    }
    if (prev_match != 0xFF)
        return prev_match;
    return mtrr_state.def_type;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/mtrr/generic.c.ifdefed" startline="70" endline="86">
{
    int idx;
    if (start < 0x80000) {
        idx = 0;
        idx += (start >> 16);
        return mtrr_state.fixed_ranges[idx];
    }
    else if (start < 0xC0000) {
        idx = 1 * 8;
        idx += ((start - 0x80000) >> 14);
        return mtrr_state.fixed_ranges[idx];
    }
    else if (start < 0x1000000) {
        idx = 3 * 8;
        idx += ((start - 0xC0000) >> 12);
        return mtrr_state.fixed_ranges[idx];
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/mtrr/generic.c.ifdefed" startline="73" endline="77">
{
    idx = 0;
    idx += (start >> 16);
    return mtrr_state.fixed_ranges[idx];
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/mtrr/generic.c.ifdefed" startline="77" endline="81">
{
    idx = 1 * 8;
    idx += ((start - 0x80000) >> 14);
    return mtrr_state.fixed_ranges[idx];
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/mtrr/generic.c.ifdefed" startline="81" endline="85">
{
    idx = 3 * 8;
    idx += ((start - 0xC0000) >> 12);
    return mtrr_state.fixed_ranges[idx];
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/mtrr/generic.c.ifdefed" startline="93" endline="95">
{
    return mtrr_state.def_type;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/mtrr/generic.c.ifdefed" startline="98" endline="140">
{
    unsigned short start_state, end_state;
    if (!(mtrr_state.var_ranges[i].mask_lo & (1 << 11)))
        continue;
    base = (((u64) mtrr_state.var_ranges[i].base_hi) << 32) + (mtrr_state.var_ranges[i].base_lo & PAGE_MASK);
    mask = (((u64) mtrr_state.var_ranges[i].mask_hi) << 32) + (mtrr_state.var_ranges[i].mask_lo & PAGE_MASK);
    start_state = ((start & mask) == (base & mask));
    end_state = ((end & mask) == (base & mask));
    if (start_state != end_state)
        return 0xFE;
    if ((start & mask) != (base & mask)) {
        continue;
    }
    curr_match = mtrr_state.var_ranges[i].base_lo & 0xff;
    if (prev_match == 0xFF) {
        prev_match = curr_match;
        continue;
    }
    if (prev_match == MTRR_TYPE_UNCACHABLE || curr_match == MTRR_TYPE_UNCACHABLE) {
        return MTRR_TYPE_UNCACHABLE;
    }
    if ((prev_match == MTRR_TYPE_WRBACK && curr_match == MTRR_TYPE_WRTHROUGH) || (prev_match == MTRR_TYPE_WRTHROUGH && curr_match == MTRR_TYPE_WRBACK)) {
        prev_match = MTRR_TYPE_WRTHROUGH;
        curr_match = MTRR_TYPE_WRTHROUGH;
    }
    if (prev_match != curr_match) {
        return MTRR_TYPE_UNCACHABLE;
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/mtrr/generic.c.ifdefed" startline="114" endline="116">
{
    continue;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/mtrr/generic.c.ifdefed" startline="119" endline="122">
{
    prev_match = curr_match;
    continue;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/mtrr/generic.c.ifdefed" startline="125" endline="127">
{
    return MTRR_TYPE_UNCACHABLE;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/mtrr/generic.c.ifdefed" startline="132" endline="135">
{
    prev_match = MTRR_TYPE_WRTHROUGH;
    curr_match = MTRR_TYPE_WRTHROUGH;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/mtrr/generic.c.ifdefed" startline="137" endline="139">
{
    return MTRR_TYPE_UNCACHABLE;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/mtrr/generic.c.ifdefed" startline="142" endline="145">
{
    if (start >= (1ULL << 32) && (end < mtrr_tom2))
        return MTRR_TYPE_WRBACK;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/mtrr/generic.c.ifdefed" startline="156" endline="159">
{
    rdmsr (MTRRphysBase_MSR (index), vr -> base_lo, vr -> base_hi);
    rdmsr (MTRRphysMask_MSR (index), vr -> mask_lo, vr -> mask_hi);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/mtrr/generic.c.ifdefed" startline="164" endline="173">
{
    struct mtrr_var_range *vr;
    vr = mtrr_state.var_ranges;
    vr[index].base_lo = base_lo;
    vr[index].base_hi = base_hi;
    vr[index].mask_lo = mask_lo;
    vr[index].mask_hi = mask_hi;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/mtrr/generic.c.ifdefed" startline="177" endline="187">
{
    unsigned int *p = (unsigned int *) frs;
    int i;
    rdmsr (MTRRfix64K_00000_MSR, p [0], p [1]);
    for (i = 0; i < 2; i++)
        rdmsr (MTRRfix16K_80000_MSR +i, p[2 + i * 2], p[3 + i * 2]);
    for (i = 0; i < 8; i++)
        rdmsr (MTRRfix4K_C0000_MSR +i, p[6 + i * 2], p[7 + i * 2]);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/mtrr/generic.c.ifdefed" startline="190" endline="193">
{
    if (cpu_has_mtrr)
        get_fixed_ranges (mtrr_state.fixed_ranges);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/mtrr/generic.c.ifdefed" startline="196" endline="202">
{
    unsigned i;
    for (i = 0; i < 8; ++i, ++types, base += step)
        printk (KERN_INFO "MTRR %05X-%05X %s\n", base, base +step - 1, mtrr_attrib_to_str (*types));
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/mtrr/generic.c.ifdefed" startline="209" endline="284">
{
    unsigned int i;
    struct mtrr_var_range *vrs;
    unsigned lo, dummy;
    unsigned long flags;
    vrs = mtrr_state.var_ranges;
    rdmsr (MTRRcap_MSR, lo, dummy);
    mtrr_state.have_fixed = (lo >> 8) & 1;
    for (i = 0; i < num_var_ranges; i++)
        get_mtrr_var_range (i, &vrs[i]);
    if (mtrr_state.have_fixed)
        get_fixed_ranges (mtrr_state.fixed_ranges);
    rdmsr (MTRRdefType_MSR, lo, dummy);
    mtrr_state.def_type = (lo & 0xff);
    mtrr_state.enabled = (lo & 0xc00) >> 10;
    if (amd_special_default_mtrr ()) {
        unsigned low, high;
        rdmsr (MSR_K8_TOP_MEM2, low, high);
        mtrr_tom2 = high;
        mtrr_tom2 <<= 32;
        mtrr_tom2 |= low;
        mtrr_tom2 &= 0xffffff800000ULL;
    }
    if (mtrr_show) {
        int high_width;
        printk (KERN_INFO "MTRR default type: %s\n", mtrr_attrib_to_str (mtrr_state.def_type));
        if (mtrr_state.have_fixed) {
            printk (KERN_INFO "MTRR fixed ranges %sabled:\n", mtrr_state.enabled & 1 ? "en" : "dis");
            print_fixed (0x00000, 0x10000, mtrr_state.fixed_ranges + 0);
            for (i = 0; i < 2; ++i)
                print_fixed (0x80000 + i * 0x20000, 0x04000, mtrr_state.fixed_ranges + (i + 1) * 8);
            for (i = 0; i < 8; ++i)
                print_fixed (0xC0000 + i * 0x08000, 0x01000, mtrr_state.fixed_ranges + (i + 3) * 8);
        }
        printk (KERN_INFO "MTRR variable ranges %sabled:\n", mtrr_state.enabled & 2 ? "en" : "dis");
        high_width = ((size_or_mask ? ffs (size_or_mask) - 1 : 32) - (32 - PAGE_SHIFT) + 3) / 4;
        for (i = 0; i < num_var_ranges; ++i) {
            if (mtrr_state.var_ranges[i].mask_lo & (1 << 11))
                printk (KERN_INFO "MTRR %u base %0*X%05X000 mask %0*X%05X000 %s\n", i, high_width, mtrr_state.var_ranges[i].base_hi, mtrr_state.var_ranges[i].base_lo >> 12, high_width, mtrr_state.var_ranges[i].mask_hi, mtrr_state.var_ranges[i].mask_lo >> 12, mtrr_attrib_to_str (mtrr_state.var_ranges[i].base_lo & 0xff));
            else
                printk (KERN_INFO "MTRR %u disabled\n", i);
        }
        if (mtrr_tom2) {
            printk (KERN_INFO "TOM2: %016llx aka %lldM\n", mtrr_tom2, mtrr_tom2 >> 20);
        }
    }
    mtrr_state_set = 1;
    local_irq_save (flags);
    prepare_set ();
    pat_init ();
    post_set ();
    local_irq_restore (flags);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/mtrr/generic.c.ifdefed" startline="229" endline="237">
{
    unsigned low, high;
    rdmsr (MSR_K8_TOP_MEM2, low, high);
    mtrr_tom2 = high;
    mtrr_tom2 <<= 32;
    mtrr_tom2 |= low;
    mtrr_tom2 &= 0xffffff800000ULL;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/mtrr/generic.c.ifdefed" startline="238" endline="272">
{
    int high_width;
    printk (KERN_INFO "MTRR default type: %s\n", mtrr_attrib_to_str (mtrr_state.def_type));
    if (mtrr_state.have_fixed) {
        printk (KERN_INFO "MTRR fixed ranges %sabled:\n", mtrr_state.enabled & 1 ? "en" : "dis");
        print_fixed (0x00000, 0x10000, mtrr_state.fixed_ranges + 0);
        for (i = 0; i < 2; ++i)
            print_fixed (0x80000 + i * 0x20000, 0x04000, mtrr_state.fixed_ranges + (i + 1) * 8);
        for (i = 0; i < 8; ++i)
            print_fixed (0xC0000 + i * 0x08000, 0x01000, mtrr_state.fixed_ranges + (i + 3) * 8);
    }
    printk (KERN_INFO "MTRR variable ranges %sabled:\n", mtrr_state.enabled & 2 ? "en" : "dis");
    high_width = ((size_or_mask ? ffs (size_or_mask) - 1 : 32) - (32 - PAGE_SHIFT) + 3) / 4;
    for (i = 0; i < num_var_ranges; ++i) {
        if (mtrr_state.var_ranges[i].mask_lo & (1 << 11))
            printk (KERN_INFO "MTRR %u base %0*X%05X000 mask %0*X%05X000 %s\n", i, high_width, mtrr_state.var_ranges[i].base_hi, mtrr_state.var_ranges[i].base_lo >> 12, high_width, mtrr_state.var_ranges[i].mask_hi, mtrr_state.var_ranges[i].mask_lo >> 12, mtrr_attrib_to_str (mtrr_state.var_ranges[i].base_lo & 0xff));
        else
            printk (KERN_INFO "MTRR %u disabled\n", i);
    }
    if (mtrr_tom2) {
        printk (KERN_INFO "TOM2: %016llx aka %lldM\n", mtrr_tom2, mtrr_tom2 >> 20);
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/mtrr/generic.c.ifdefed" startline="242" endline="250">
{
    printk (KERN_INFO "MTRR fixed ranges %sabled:\n", mtrr_state.enabled & 1 ? "en" : "dis");
    print_fixed (0x00000, 0x10000, mtrr_state.fixed_ranges + 0);
    for (i = 0; i < 2; ++i)
        print_fixed (0x80000 + i * 0x20000, 0x04000, mtrr_state.fixed_ranges + (i + 1) * 8);
    for (i = 0; i < 8; ++i)
        print_fixed (0xC0000 + i * 0x08000, 0x01000, mtrr_state.fixed_ranges + (i + 3) * 8);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/mtrr/generic.c.ifdefed" startline="254" endline="267">
{
    if (mtrr_state.var_ranges[i].mask_lo & (1 << 11))
        printk (KERN_INFO "MTRR %u base %0*X%05X000 mask %0*X%05X000 %s\n", i, high_width, mtrr_state.var_ranges[i].base_hi, mtrr_state.var_ranges[i].base_lo >> 12, high_width, mtrr_state.var_ranges[i].mask_hi, mtrr_state.var_ranges[i].mask_lo >> 12, mtrr_attrib_to_str (mtrr_state.var_ranges[i].base_lo & 0xff));
    else
        printk (KERN_INFO "MTRR %u disabled\n", i);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/mtrr/generic.c.ifdefed" startline="268" endline="271">
{
    printk (KERN_INFO "TOM2: %016llx aka %lldM\n", mtrr_tom2, mtrr_tom2 >> 20);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/mtrr/generic.c.ifdefed" startline="288" endline="301">
{
    unsigned long mask = smp_changes_mask;
    if (!mask)
        return;
    if (mask & MTRR_CHANGE_MASK_FIXED)
        printk (KERN_WARNING "mtrr: your CPUs had inconsistent fixed MTRR settings\n");
    if (mask & MTRR_CHANGE_MASK_VARIABLE)
        printk (KERN_WARNING "mtrr: your CPUs had inconsistent variable MTRR settings\n");
    if (mask & MTRR_CHANGE_MASK_DEFTYPE)
        printk (KERN_WARNING "mtrr: your CPUs had inconsistent MTRRdefType settings\n");
    printk (KERN_INFO "mtrr: probably your BIOS does not setup all CPUs.\n");
    printk (KERN_INFO "mtrr: corrected configuration.\n");
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/mtrr/generic.c.ifdefed" startline="307" endline="312">
{
    if (wrmsr_safe (msr, a, b) < 0)
        printk (KERN_ERR "MTRR: CPU %u: Writing MSR %x to %x:%x failed\n", smp_processor_id (), msr, a, b);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/mtrr/generic.c.ifdefed" startline="319" endline="326">
{
    unsigned lo, hi;
    rdmsr (MSR_K8_SYSCFG, lo, hi);
    mtrr_wrmsr (MSR_K8_SYSCFG, lo | K8_MTRRFIXRANGE_DRAM_ENABLE | K8_MTRRFIXRANGE_DRAM_MODIFY, hi);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/mtrr/generic.c.ifdefed" startline="338" endline="351">
{
    unsigned lo, hi;
    rdmsr (msr, lo, hi);
    if (lo != msrwords[0] || hi != msrwords[1]) {
        if (boot_cpu_data.x86_vendor == X86_VENDOR_AMD && (boot_cpu_data.x86 >= 0x0f && boot_cpu_data.x86 <= 0x11) && ((msrwords[0] | msrwords[1]) & K8_MTRR_RDMEM_WRMEM_MASK))
            k8_enable_fixed_iorrs ();
        mtrr_wrmsr (msr, msrwords [0], msrwords [1]);
        *changed = true;
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/mtrr/generic.c.ifdefed" startline="343" endline="350">
{
    if (boot_cpu_data.x86_vendor == X86_VENDOR_AMD && (boot_cpu_data.x86 >= 0x0f && boot_cpu_data.x86 <= 0x11) && ((msrwords[0] | msrwords[1]) & K8_MTRR_RDMEM_WRMEM_MASK))
        k8_enable_fixed_iorrs ();
    mtrr_wrmsr (msr, msrwords [0], msrwords [1]);
    *changed = true;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/mtrr/generic.c.ifdefed" startline="362" endline="376">
{
    int i, max;
    mtrr_type ltype;
    unsigned long lbase, lsize;
    max = num_var_ranges;
    if (replace_reg >= 0 && replace_reg < max)
        return replace_reg;
    for (i = 0; i < max; ++i) {
        mtrr_if->get (i, &lbase, &lsize, &ltype);
        if (lsize == 0)
            return i;
    }
    return -ENOSPC;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/mtrr/generic.c.ifdefed" startline="370" endline="374">
{
    mtrr_if->get (i, &lbase, &lsize, &ltype);
    if (lsize == 0)
        return i;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/mtrr/generic.c.ifdefed" startline="380" endline="419">
{
    unsigned int mask_lo, mask_hi, base_lo, base_hi;
    unsigned int tmp, hi;
    rdmsr (MTRRphysMask_MSR (reg), mask_lo, mask_hi);
    if ((mask_lo & 0x800) == 0) {
        *base = 0;
        *size = 0;
        *type = 0;
        return;
    }
    rdmsr (MTRRphysBase_MSR (reg), base_lo, base_hi);
    tmp = mask_hi << (32 - PAGE_SHIFT) | mask_lo >> PAGE_SHIFT;
    mask_lo = size_or_mask | tmp;
    hi = fls (tmp);
    if (hi > 0) {
        tmp |= ~((1 << (hi - 1)) - 1);
        if (tmp != mask_lo) {
            static int once = 1;
            if (once) {
                printk (KERN_INFO "mtrr: your BIOS has set up an incorrect mask, fixing it up.\n");
                once = 0;
            }
            mask_lo = tmp;
        }
    }
    *size = -mask_lo;
    *base = base_hi << (32 - PAGE_SHIFT) | base_lo >> PAGE_SHIFT;
    *type = base_lo & 0xff;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/mtrr/generic.c.ifdefed" startline="385" endline="391">
{
    *base = 0;
    *size = 0;
    *type = 0;
    return;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/mtrr/generic.c.ifdefed" startline="400" endline="412">
{
    tmp |= ~((1 << (hi - 1)) - 1);
    if (tmp != mask_lo) {
        static int once = 1;
        if (once) {
            printk (KERN_INFO "mtrr: your BIOS has set up an incorrect mask, fixing it up.\n");
            once = 0;
        }
        mask_lo = tmp;
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/mtrr/generic.c.ifdefed" startline="403" endline="411">
{
    static int once = 1;
    if (once) {
        printk (KERN_INFO "mtrr: your BIOS has set up an incorrect mask, fixing it up.\n");
        once = 0;
    }
    mask_lo = tmp;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/mtrr/generic.c.ifdefed" startline="406" endline="409">
{
    printk (KERN_INFO "mtrr: your BIOS has set up an incorrect mask, fixing it up.\n");
    once = 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/mtrr/generic.c.ifdefed" startline="426" endline="437">
{
    unsigned long long *saved = (unsigned long long *) frs;
    bool changed = false;
    int block = -1, range;
    while (fixed_range_blocks[++block].ranges)
        for (range = 0; range < fixed_range_blocks[block].ranges; range++)
            set_fixed_range (fixed_range_blocks[block].base_msr + range, &changed, (unsigned int *) saved++);
    return changed;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/mtrr/generic.c.ifdefed" startline="442" endline="463">
{
    unsigned int lo, hi;
    bool changed = false;
    rdmsr (MTRRphysBase_MSR (index), lo, hi);
    if ((vr->base_lo & 0xfffff0ffUL) != (lo & 0xfffff0ffUL) || (vr->base_hi & (size_and_mask >> (32 - PAGE_SHIFT))) != (hi & (size_and_mask >> (32 - PAGE_SHIFT)))) {
        mtrr_wrmsr (MTRRphysBase_MSR (index), vr -> base_lo, vr -> base_hi);
        changed = true;
    }
    rdmsr (MTRRphysMask_MSR (index), lo, hi);
    if ((vr->mask_lo & 0xfffff800UL) != (lo & 0xfffff800UL) || (vr->mask_hi & (size_and_mask >> (32 - PAGE_SHIFT))) != (hi & (size_and_mask >> (32 - PAGE_SHIFT)))) {
        mtrr_wrmsr (MTRRphysMask_MSR (index), vr -> mask_lo, vr -> mask_hi);
        changed = true;
    }
    return changed;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/mtrr/generic.c.ifdefed" startline="449" endline="452">
{
    mtrr_wrmsr (MTRRphysBase_MSR (index), vr -> base_lo, vr -> base_hi);
    changed = true;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/mtrr/generic.c.ifdefed" startline="458" endline="461">
{
    mtrr_wrmsr (MTRRphysMask_MSR (index), vr -> mask_lo, vr -> mask_hi);
    changed = true;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/mtrr/generic.c.ifdefed" startline="474" endline="494">
{
    unsigned int i;
    unsigned long change_mask = 0;
    for (i = 0; i < num_var_ranges; i++)
        if (set_mtrr_var_ranges (i, &mtrr_state.var_ranges[i]))
            change_mask |= MTRR_CHANGE_MASK_VARIABLE;
    if (mtrr_state.have_fixed && set_fixed_ranges (mtrr_state.fixed_ranges))
        change_mask |= MTRR_CHANGE_MASK_FIXED;
    if ((deftype_lo & 0xff) != mtrr_state.def_type || ((deftype_lo & 0xc00) >> 10) != mtrr_state.enabled) {
        deftype_lo = (deftype_lo & ~0xcff) | mtrr_state.def_type | (mtrr_state.enabled << 10);
        change_mask |= MTRR_CHANGE_MASK_DEFTYPE;
    }
    return change_mask;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/mtrr/generic.c.ifdefed" startline="488" endline="491">
{
    deftype_lo = (deftype_lo & ~0xcff) | mtrr_state.def_type | (mtrr_state.enabled << 10);
    change_mask |= MTRR_CHANGE_MASK_DEFTYPE;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/mtrr/generic.c.ifdefed" startline="508" endline="536">
{
    unsigned long cr0;
    spin_lock (& set_atomicity_lock);
    cr0 = read_cr0 () | X86_CR0_CD;
    write_cr0 (cr0);
    wbinvd ();
    if (cpu_has_pge) {
        cr4 = read_cr4 ();
        write_cr4 (cr4 & ~ X86_CR4_PGE);
    }
    __flush_tlb ();
    rdmsr (MTRRdefType_MSR, deftype_lo, deftype_hi);
    mtrr_wrmsr (MTRRdefType_MSR, deftype_lo & ~ 0xcff, deftype_hi);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/mtrr/generic.c.ifdefed" startline="523" endline="526">
{
    cr4 = read_cr4 ();
    write_cr4 (cr4 & ~ X86_CR4_PGE);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/mtrr/generic.c.ifdefed" startline="539" endline="553">
{
    __flush_tlb ();
    mtrr_wrmsr (MTRRdefType_MSR, deftype_lo, deftype_hi);
    write_cr0 (read_cr0 () & 0xbfffffff);
    if (cpu_has_pge)
        write_cr4 (cr4);
    spin_unlock (& set_atomicity_lock);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/mtrr/generic.c.ifdefed" startline="556" endline="579">
{
    unsigned long mask, count;
    unsigned long flags;
    local_irq_save (flags);
    prepare_set ();
    mask = set_mtrr_state ();
    pat_init ();
    post_set ();
    local_irq_restore (flags);
    for (count = 0; count < sizeof mask * 8; ++count) {
        if (mask & 0x01)
            set_bit (count, &smp_changes_mask);
        mask >>= 1;
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/mtrr/generic.c.ifdefed" startline="573" endline="577">
{
    if (mask & 0x01)
        set_bit (count, &smp_changes_mask);
    mask >>= 1;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/mtrr/generic.c.ifdefed" startline="590" endline="616">
{
    unsigned long flags;
    struct mtrr_var_range *vr;
    vr = &mtrr_state.var_ranges[reg];
    local_irq_save (flags);
    prepare_set ();
    if (size == 0) {
        mtrr_wrmsr (MTRRphysMask_MSR (reg), 0, 0);
        memset (vr, 0, sizeof (struct mtrr_var_range));
    }
    else {
        vr->base_lo = base << PAGE_SHIFT | type;
        vr->base_hi = (base & size_and_mask) >> (32 - PAGE_SHIFT);
        vr->mask_lo = -size << PAGE_SHIFT | 0x800;
        vr->mask_hi = (-size & size_and_mask) >> (32 - PAGE_SHIFT);
        mtrr_wrmsr (MTRRphysBase_MSR (reg), vr -> base_lo, vr -> base_hi);
        mtrr_wrmsr (MTRRphysMask_MSR (reg), vr -> mask_lo, vr -> mask_hi);
    }
    post_set ();
    local_irq_restore (flags);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/mtrr/generic.c.ifdefed" startline="599" endline="604">
{
    mtrr_wrmsr (MTRRphysMask_MSR (reg), 0, 0);
    memset (vr, 0, sizeof (struct mtrr_var_range));
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/mtrr/generic.c.ifdefed" startline="604" endline="612">
{
    vr->base_lo = base << PAGE_SHIFT | type;
    vr->base_hi = (base & size_and_mask) >> (32 - PAGE_SHIFT);
    vr->mask_lo = -size << PAGE_SHIFT | 0x800;
    vr->mask_hi = (-size & size_and_mask) >> (32 - PAGE_SHIFT);
    mtrr_wrmsr (MTRRphysBase_MSR (reg), vr -> base_lo, vr -> base_hi);
    mtrr_wrmsr (MTRRphysMask_MSR (reg), vr -> mask_lo, vr -> mask_hi);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/mtrr/generic.c.ifdefed" startline="619" endline="650">
{
    unsigned long lbase, last;
    if (is_cpu (INTEL) && boot_cpu_data.x86 == 6 && boot_cpu_data.x86_model == 1 && boot_cpu_data.x86_mask <= 7) {
        if (base & ((1 << (22 - PAGE_SHIFT)) - 1)) {
            printk (KERN_WARNING "mtrr: base(0x%lx000) is not 4 MiB aligned\n", base);
            return -EINVAL;
        }
        if (!(base + size < 0x70000 || base > 0x7003F) && (type == MTRR_TYPE_WRCOMB || type == MTRR_TYPE_WRBACK)) {
            printk (KERN_WARNING "mtrr: writable mtrr between 0x70000000 and 0x7003FFFF may hang the CPU.\n");
            return -EINVAL;
        }
    }
    last = base + size - 1;
    for (lbase = base; !(lbase & 1) && (last & 1); lbase = lbase >> 1, last = last >> 1)
        ;
    if (lbase != last) {
        printk (KERN_WARNING "mtrr: base(0x%lx000) is not aligned on a size(0x%lx000) boundary\n", base, size);
        return -EINVAL;
    }
    return 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/mtrr/generic.c.ifdefed" startline="626" endline="637">
{
    if (base & ((1 << (22 - PAGE_SHIFT)) - 1)) {
        printk (KERN_WARNING "mtrr: base(0x%lx000) is not 4 MiB aligned\n", base);
        return -EINVAL;
    }
    if (!(base + size < 0x70000 || base > 0x7003F) && (type == MTRR_TYPE_WRCOMB || type == MTRR_TYPE_WRBACK)) {
        printk (KERN_WARNING "mtrr: writable mtrr between 0x70000000 and 0x7003FFFF may hang the CPU.\n");
        return -EINVAL;
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/mtrr/generic.c.ifdefed" startline="627" endline="630">
{
    printk (KERN_WARNING "mtrr: base(0x%lx000) is not 4 MiB aligned\n", base);
    return -EINVAL;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/mtrr/generic.c.ifdefed" startline="633" endline="636">
{
    printk (KERN_WARNING "mtrr: writable mtrr between 0x70000000 and 0x7003FFFF may hang the CPU.\n");
    return -EINVAL;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/mtrr/generic.c.ifdefed" startline="644" endline="648">
{
    printk (KERN_WARNING "mtrr: base(0x%lx000) is not aligned on a size(0x%lx000) boundary\n", base, size);
    return -EINVAL;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/mtrr/generic.c.ifdefed" startline="654" endline="658">
{
    unsigned long config, dummy;
    rdmsr (MTRRcap_MSR, config, dummy);
    return (config & (1 << 10));
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/mtrr/generic.c.ifdefed" startline="661" endline="663">
{
    return 1;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/mtrr/main.c.ifdefed" startline="65" endline="68">
{
    if (ops->vendor && ops->vendor < X86_VENDOR_NUM)
        mtrr_ops[ops->vendor] = ops;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/mtrr/main.c.ifdefed" startline="72" endline="99">
{
    struct pci_dev *dev;
    u8 rev;
    if ((dev = pci_get_class (PCI_CLASS_BRIDGE_HOST << 8, NULL)) != NULL) {
        if (dev->vendor == PCI_VENDOR_ID_SERVERWORKS && dev->device == PCI_DEVICE_ID_SERVERWORKS_LE) {
            pci_read_config_byte (dev, PCI_CLASS_REVISION, & rev);
            if (rev <= 5) {
                printk (KERN_INFO "mtrr: Serverworks LE rev < 6 detected. Write-combining disabled.\n");
                pci_dev_put (dev);
                return 0;
            }
        }
        if (dev->vendor == PCI_VENDOR_ID_INTEL && dev->device == PCI_DEVICE_ID_INTEL_82451NX) {
            printk (KERN_INFO "mtrr: Intel 450NX MMC detected. Write-combining disabled.\n");
            pci_dev_put (dev);
            return 0;
        }
        pci_dev_put (dev);
    }
    return (mtrr_if->have_wrcomb ? mtrr_if->have_wrcomb () : 0);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/mtrr/main.c.ifdefed" startline="76" endline="97">
{
    if (dev->vendor == PCI_VENDOR_ID_SERVERWORKS && dev->device == PCI_DEVICE_ID_SERVERWORKS_LE) {
        pci_read_config_byte (dev, PCI_CLASS_REVISION, & rev);
        if (rev <= 5) {
            printk (KERN_INFO "mtrr: Serverworks LE rev < 6 detected. Write-combining disabled.\n");
            pci_dev_put (dev);
            return 0;
        }
    }
    if (dev->vendor == PCI_VENDOR_ID_INTEL && dev->device == PCI_DEVICE_ID_INTEL_82451NX) {
        printk (KERN_INFO "mtrr: Intel 450NX MMC detected. Write-combining disabled.\n");
        pci_dev_put (dev);
        return 0;
    }
    pci_dev_put (dev);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/mtrr/main.c.ifdefed" startline="80" endline="87">
{
    pci_read_config_byte (dev, PCI_CLASS_REVISION, & rev);
    if (rev <= 5) {
        printk (KERN_INFO "mtrr: Serverworks LE rev < 6 detected. Write-combining disabled.\n");
        pci_dev_put (dev);
        return 0;
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/mtrr/main.c.ifdefed" startline="82" endline="86">
{
    printk (KERN_INFO "mtrr: Serverworks LE rev < 6 detected. Write-combining disabled.\n");
    pci_dev_put (dev);
    return 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/mtrr/main.c.ifdefed" startline="91" endline="95">
{
    printk (KERN_INFO "mtrr: Intel 450NX MMC detected. Write-combining disabled.\n");
    pci_dev_put (dev);
    return 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/mtrr/main.c.ifdefed" startline="103" endline="113">
{
    unsigned long config = 0, dummy;
    if (use_intel ()) {
        rdmsr (MTRRcap_MSR, config, dummy);
    }
    else if (is_cpu (AMD))
        config = 2;
    else if (is_cpu (CYRIX) || is_cpu (CENTAUR))
        config = 8;
    num_var_ranges = config & 0xff;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/mtrr/main.c.ifdefed" startline="106" endline="108">
{
    rdmsr (MTRRcap_MSR, config, dummy);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/mtrr/main.c.ifdefed" startline="116" endline="122">
{
    int i, max;
    max = num_var_ranges;
    for (i = 0; i < max; i++)
        mtrr_usage_table[i] = 1;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/mtrr/main.c.ifdefed" startline="137" endline="162">
{
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/mtrr/main.c.ifdefed" startline="164" endline="169">
{
    return type1 == MTRR_TYPE_UNCACHABLE || type2 == MTRR_TYPE_UNCACHABLE || (type1 == MTRR_TYPE_WRTHROUGH && type2 == MTRR_TYPE_WRBACK) || (type1 == MTRR_TYPE_WRBACK && type2 == MTRR_TYPE_WRTHROUGH);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/mtrr/main.c.ifdefed" startline="212" endline="266">
{
    struct set_mtrr_data data;
    unsigned long flags;
    data.smp_reg = reg;
    data.smp_base = base;
    data.smp_size = size;
    data.smp_type = type;
    atomic_set (& data.count, num_booting_cpus () - 1);
    smp_wmb ();
    atomic_set (& data.gate, 0);
    if (smp_call_function (ipi_handler, &data, 0) != 0)
        panic ("mtrr: timed out waiting for other CPUs\n");
    local_irq_save (flags);
    while (atomic_read (&data.count))
        cpu_relax ();
    atomic_set (& data.count, num_booting_cpus () - 1);
    smp_wmb ();
    atomic_set (& data.gate, 1);
    if (reg != ~0U)
        mtrr_if->set (reg, base, size, type);
    while (atomic_read (&data.count))
        cpu_relax ();
    atomic_set (& data.count, num_booting_cpus () - 1);
    smp_wmb ();
    atomic_set (& data.gate, 0);
    while (atomic_read (&data.count))
        cpu_relax ();
    local_irq_restore (flags);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/mtrr/main.c.ifdefed" startline="306" endline="403">
{
    int i, replace, error;
    mtrr_type ltype;
    unsigned long lbase, lsize;
    if (!mtrr_if)
        return -ENXIO;
    if ((error = mtrr_if->validate_add_page (base, size, type)))
        return error;
    if (type >= MTRR_NUM_TYPES) {
        printk (KERN_WARNING "mtrr: type: %u invalid\n", type);
        return -EINVAL;
    }
    if ((type == MTRR_TYPE_WRCOMB) && !have_wrcomb ()) {
        printk (KERN_WARNING "mtrr: your processor doesn't support write-combining\n");
        return -ENOSYS;
    }
    if (!size) {
        printk (KERN_WARNING "mtrr: zero sized request\n");
        return -EINVAL;
    }
    if (base & size_or_mask || size & size_or_mask) {
        printk (KERN_WARNING "mtrr: base or size exceeds the MTRR width\n");
        return -EINVAL;
    }
    error = -EINVAL;
    replace = -1;
    get_online_cpus ();
    mutex_lock (& mtrr_mutex);
    for (i = 0; i < num_var_ranges; ++i) {
        mtrr_if->get (i, &lbase, &lsize, &ltype);
        if (!lsize || base > lbase + lsize - 1 || base + size - 1 < lbase)
            continue;
        if (base < lbase || base + size - 1 > lbase + lsize - 1) {
            if (base <= lbase && base + size - 1 >= lbase + lsize - 1) {
                if (type == ltype) {
                    replace = replace == -1 ? i : -2;
                    continue;
                }
                else if (types_compatible (type, ltype))
                    continue;
            }
            printk (KERN_WARNING "mtrr: 0x%lx000,0x%lx000 overlaps existing" " 0x%lx000,0x%lx000\n", base, size, lbase, lsize);
            goto out;
        }
        if (ltype != type) {
            if (types_compatible (type, ltype))
                continue;
            printk (KERN_WARNING "mtrr: type mismatch for %lx000,%lx000 old: %s new: %s\n", base, size, mtrr_attrib_to_str (ltype), mtrr_attrib_to_str (type));
            goto out;
        }
        if (increment)
            ++mtrr_usage_table[i];
        error = i;
        goto out;
    }
    i = mtrr_if->get_free_region (base, size, replace);
    if (i >= 0) {
        set_mtrr (i, base, size, type);
        if (likely (replace < 0)) {
            mtrr_usage_table[i] = 1;
        }
        else {
            mtrr_usage_table[i] = mtrr_usage_table[replace];
            if (increment)
                mtrr_usage_table[i]++;
            if (unlikely (replace != i)) {
                set_mtrr (replace, 0, 0, 0);
                mtrr_usage_table[replace] = 0;
            }
        }
    }
    else
        printk (KERN_INFO "mtrr: no more MTRRs available\n");
    error = i;
out :
    mutex_unlock (&mtrr_mutex);
    put_online_cpus ();
    return error;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/mtrr/main.c.ifdefed" startline="317" endline="320">
{
    printk (KERN_WARNING "mtrr: type: %u invalid\n", type);
    return -EINVAL;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/mtrr/main.c.ifdefed" startline="323" endline="327">
{
    printk (KERN_WARNING "mtrr: your processor doesn't support write-combining\n");
    return -ENOSYS;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/mtrr/main.c.ifdefed" startline="329" endline="332">
{
    printk (KERN_WARNING "mtrr: zero sized request\n");
    return -EINVAL;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/mtrr/main.c.ifdefed" startline="334" endline="337">
{
    printk (KERN_WARNING "mtrr: base or size exceeds the MTRR width\n");
    return -EINVAL;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/mtrr/main.c.ifdefed" startline="346" endline="380">
{
    mtrr_if->get (i, &lbase, &lsize, &ltype);
    if (!lsize || base > lbase + lsize - 1 || base + size - 1 < lbase)
        continue;
    if (base < lbase || base + size - 1 > lbase + lsize - 1) {
        if (base <= lbase && base + size - 1 >= lbase + lsize - 1) {
            if (type == ltype) {
                replace = replace == -1 ? i : -2;
                continue;
            }
            else if (types_compatible (type, ltype))
                continue;
        }
        printk (KERN_WARNING "mtrr: 0x%lx000,0x%lx000 overlaps existing" " 0x%lx000,0x%lx000\n", base, size, lbase, lsize);
        goto out;
    }
    if (ltype != type) {
        if (types_compatible (type, ltype))
            continue;
        printk (KERN_WARNING "mtrr: type mismatch for %lx000,%lx000 old: %s new: %s\n", base, size, mtrr_attrib_to_str (ltype), mtrr_attrib_to_str (type));
        goto out;
    }
    if (increment)
        ++mtrr_usage_table[i];
    error = i;
    goto out;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/mtrr/main.c.ifdefed" startline="351" endline="366">
{
    if (base <= lbase && base + size - 1 >= lbase + lsize - 1) {
        if (type == ltype) {
            replace = replace == -1 ? i : -2;
            continue;
        }
        else if (types_compatible (type, ltype))
            continue;
    }
    printk (KERN_WARNING "mtrr: 0x%lx000,0x%lx000 overlaps existing" " 0x%lx000,0x%lx000\n", base, size, lbase, lsize);
    goto out;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/mtrr/main.c.ifdefed" startline="352" endline="360">
{
    if (type == ltype) {
        replace = replace == -1 ? i : -2;
        continue;
    }
    else if (types_compatible (type, ltype))
        continue;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/mtrr/main.c.ifdefed" startline="354" endline="357">
{
    replace = replace == -1 ? i : -2;
    continue;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/mtrr/main.c.ifdefed" startline="368" endline="375">
{
    if (types_compatible (type, ltype))
        continue;
    printk (KERN_WARNING "mtrr: type mismatch for %lx000,%lx000 old: %s new: %s\n", base, size, mtrr_attrib_to_str (ltype), mtrr_attrib_to_str (type));
    goto out;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/mtrr/main.c.ifdefed" startline="383" endline="396">
{
    set_mtrr (i, base, size, type);
    if (likely (replace < 0)) {
        mtrr_usage_table[i] = 1;
    }
    else {
        mtrr_usage_table[i] = mtrr_usage_table[replace];
        if (increment)
            mtrr_usage_table[i]++;
        if (unlikely (replace != i)) {
            set_mtrr (replace, 0, 0, 0);
            mtrr_usage_table[replace] = 0;
        }
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/mtrr/main.c.ifdefed" startline="385" endline="387">
{
    mtrr_usage_table[i] = 1;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/mtrr/main.c.ifdefed" startline="387" endline="395">
{
    mtrr_usage_table[i] = mtrr_usage_table[replace];
    if (increment)
        mtrr_usage_table[i]++;
    if (unlikely (replace != i)) {
        set_mtrr (replace, 0, 0, 0);
        mtrr_usage_table[replace] = 0;
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/mtrr/main.c.ifdefed" startline="391" endline="394">
{
    set_mtrr (replace, 0, 0, 0);
    mtrr_usage_table[replace] = 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/mtrr/main.c.ifdefed" startline="406" endline="416">
{
    if ((base & (PAGE_SIZE - 1)) || (size & (PAGE_SIZE - 1))) {
        printk (KERN_WARNING "mtrr: size and base must be multiples of 4 kiB\n");
        printk (KERN_DEBUG "mtrr: size: 0x%lx  base: 0x%lx\n", size, base);
        dump_stack ();
        return -1;
    }
    return 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/mtrr/main.c.ifdefed" startline="407" endline="414">
{
    printk (KERN_WARNING "mtrr: size and base must be multiples of 4 kiB\n");
    printk (KERN_DEBUG "mtrr: size: 0x%lx  base: 0x%lx\n", size, base);
    dump_stack ();
    return -1;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/mtrr/main.c.ifdefed" startline="457" endline="462">
{
    if (mtrr_check (base, size))
        return -EINVAL;
    return mtrr_add_page (base >> PAGE_SHIFT, size >> PAGE_SHIFT, type, increment);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/mtrr/main.c.ifdefed" startline="480" endline="528">
{
    int i, max;
    mtrr_type ltype;
    unsigned long lbase, lsize;
    int error = -EINVAL;
    if (!mtrr_if)
        return -ENXIO;
    max = num_var_ranges;
    get_online_cpus ();
    mutex_lock (& mtrr_mutex);
    if (reg < 0) {
        for (i = 0; i < max; ++i) {
            mtrr_if->get (i, &lbase, &lsize, &ltype);
            if (lbase == base && lsize == size) {
                reg = i;
                break;
            }
        }
        if (reg < 0) {
            printk (KERN_DEBUG "mtrr: no MTRR for %lx000,%lx000 found\n", base, size);
            goto out;
        }
    }
    if (reg >= max) {
        printk (KERN_WARNING "mtrr: register: %d too big\n", reg);
        goto out;
    }
    mtrr_if->get (reg, &lbase, &lsize, &ltype);
    if (lsize < 1) {
        printk (KERN_WARNING "mtrr: MTRR %d not used\n", reg);
        goto out;
    }
    if (mtrr_usage_table[reg] < 1) {
        printk (KERN_WARNING "mtrr: reg: %d has count=0\n", reg);
        goto out;
    }
    if (--mtrr_usage_table[reg] < 1)
        set_mtrr (reg, 0, 0, 0);
    error = reg;
out :
    mutex_unlock (&mtrr_mutex);
    put_online_cpus ();
    return error;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/mtrr/main.c.ifdefed" startline="493" endline="507">
{
    for (i = 0; i < max; ++i) {
        mtrr_if->get (i, &lbase, &lsize, &ltype);
        if (lbase == base && lsize == size) {
            reg = i;
            break;
        }
    }
    if (reg < 0) {
        printk (KERN_DEBUG "mtrr: no MTRR for %lx000,%lx000 found\n", base, size);
        goto out;
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/mtrr/main.c.ifdefed" startline="495" endline="501">
{
    mtrr_if->get (i, &lbase, &lsize, &ltype);
    if (lbase == base && lsize == size) {
        reg = i;
        break;
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/mtrr/main.c.ifdefed" startline="497" endline="500">
{
    reg = i;
    break;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/mtrr/main.c.ifdefed" startline="502" endline="506">
{
    printk (KERN_DEBUG "mtrr: no MTRR for %lx000,%lx000 found\n", base, size);
    goto out;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/mtrr/main.c.ifdefed" startline="508" endline="511">
{
    printk (KERN_WARNING "mtrr: register: %d too big\n", reg);
    goto out;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/mtrr/main.c.ifdefed" startline="513" endline="516">
{
    printk (KERN_WARNING "mtrr: MTRR %d not used\n", reg);
    goto out;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/mtrr/main.c.ifdefed" startline="517" endline="520">
{
    printk (KERN_WARNING "mtrr: reg: %d has count=0\n", reg);
    goto out;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/mtrr/main.c.ifdefed" startline="546" endline="550">
{
    if (mtrr_check (base, size))
        return -EINVAL;
    return mtrr_del_page (reg, base >> PAGE_SHIFT, size >> PAGE_SHIFT);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/mtrr/main.c.ifdefed" startline="560" endline="566">
{
    amd_init_mtrr ();
    cyrix_init_mtrr ();
    centaur_init_mtrr ();
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/mtrr/main.c.ifdefed" startline="580" endline="590">
{
    int i;
    for (i = 0; i < num_var_ranges; i++) {
        mtrr_if->get (i, &mtrr_state[i].lbase, &mtrr_state[i].lsize, &mtrr_state[i].ltype);
    }
    return 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/mtrr/main.c.ifdefed" startline="583" endline="588">
{
    mtrr_if->get (i, &mtrr_state[i].lbase, &mtrr_state[i].lsize, &mtrr_state[i].ltype);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/mtrr/main.c.ifdefed" startline="593" endline="604">
{
    int i;
    for (i = 0; i < num_var_ranges; i++) {
        if (mtrr_state[i].lsize)
            set_mtrr (i, mtrr_state[i].lbase, mtrr_state[i].lsize, mtrr_state[i].ltype);
    }
    return 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/mtrr/main.c.ifdefed" startline="596" endline="602">
{
    if (mtrr_state[i].lsize)
        set_mtrr (i, mtrr_state[i].lbase, mtrr_state[i].lsize, mtrr_state[i].ltype);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/mtrr/main.c.ifdefed" startline="624" endline="635">
{
    if (nr_range >= RANGE_NUM)
        return nr_range;
    range[nr_range].start = start;
    range[nr_range].end = end;
    nr_range++;
    return nr_range;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/mtrr/main.c.ifdefed" startline="640" endline="666">
{
    int i;
    for (i = 0; i < nr_range; i++) {
        unsigned long final_start, final_end;
        unsigned long common_start, common_end;
        if (!range[i].end)
            continue;
        common_start = max (range[i].start, start);
        common_end = min (range[i].end, end);
        if (common_start > common_end + 1)
            continue;
        final_start = min (range[i].start, start);
        final_end = max (range[i].end, end);
        range[i].start = final_start;
        range[i].end = final_end;
        return nr_range;
    }
    return add_range (range, nr_range, start, end);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/mtrr/main.c.ifdefed" startline="644" endline="662">
{
    unsigned long final_start, final_end;
    unsigned long common_start, common_end;
    if (!range[i].end)
        continue;
    common_start = max (range[i].start, start);
    common_end = min (range[i].end, end);
    if (common_start > common_end + 1)
        continue;
    final_start = min (range[i].start, start);
    final_end = max (range[i].end, end);
    range[i].start = final_start;
    range[i].end = final_end;
    return nr_range;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/mtrr/main.c.ifdefed" startline="670" endline="712">
{
    int i, j;
    for (j = 0; j < RANGE_NUM; j++) {
        if (!range[j].end)
            continue;
        if (start <= range[j].start && end >= range[j].end) {
            range[j].start = 0;
            range[j].end = 0;
            continue;
        }
        if (start <= range[j].start && end < range[j].end && range[j].start < end + 1) {
            range[j].start = end + 1;
            continue;
        }
        if (start > range[j].start && end >= range[j].end && range[j].end > start - 1) {
            range[j].end = start - 1;
            continue;
        }
        if (start > range[j].start && end < range[j].end) {
            for (i = 0; i < RANGE_NUM; i++) {
                if (range[i].end == 0)
                    break;
            }
            if (i < RANGE_NUM) {
                range[i].end = range[j].end;
                range[i].start = end + 1;
            }
            else {
                printk (KERN_ERR "run of slot in ranges\n");
            }
            range[j].end = start - 1;
            continue;
        }
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/mtrr/main.c.ifdefed" startline="673" endline="711">
{
    if (!range[j].end)
        continue;
    if (start <= range[j].start && end >= range[j].end) {
        range[j].start = 0;
        range[j].end = 0;
        continue;
    }
    if (start <= range[j].start && end < range[j].end && range[j].start < end + 1) {
        range[j].start = end + 1;
        continue;
    }
    if (start > range[j].start && end >= range[j].end && range[j].end > start - 1) {
        range[j].end = start - 1;
        continue;
    }
    if (start > range[j].start && end < range[j].end) {
        for (i = 0; i < RANGE_NUM; i++) {
            if (range[i].end == 0)
                break;
        }
        if (i < RANGE_NUM) {
            range[i].end = range[j].end;
            range[i].start = end + 1;
        }
        else {
            printk (KERN_ERR "run of slot in ranges\n");
        }
        range[j].end = start - 1;
        continue;
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/mtrr/main.c.ifdefed" startline="677" endline="681">
{
    range[j].start = 0;
    range[j].end = 0;
    continue;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/mtrr/main.c.ifdefed" startline="684" endline="687">
{
    range[j].start = end + 1;
    continue;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/mtrr/main.c.ifdefed" startline="691" endline="694">
{
    range[j].end = start - 1;
    continue;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/mtrr/main.c.ifdefed" startline="696" endline="710">
{
    for (i = 0; i < RANGE_NUM; i++) {
        if (range[i].end == 0)
            break;
    }
    if (i < RANGE_NUM) {
        range[i].end = range[j].end;
        range[i].start = end + 1;
    }
    else {
        printk (KERN_ERR "run of slot in ranges\n");
    }
    range[j].end = start - 1;
    continue;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/mtrr/main.c.ifdefed" startline="698" endline="701">
{
    if (range[i].end == 0)
        break;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/mtrr/main.c.ifdefed" startline="702" endline="705">
{
    range[i].end = range[j].end;
    range[i].start = end + 1;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/mtrr/main.c.ifdefed" startline="705" endline="707">
{
    printk (KERN_ERR "run of slot in ranges\n");
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/mtrr/main.c.ifdefed" startline="715" endline="724">
{
    const struct res_range *r1 = x1;
    const struct res_range *r2 = x2;
    long start1, start2;
    start1 = r1->start;
    start2 = r2->start;
    return start1 - start2;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/mtrr/main.c.ifdefed" startline="739" endline="802">
{
    unsigned long i, base, size;
    mtrr_type type;
    for (i = 0; i < num_var_ranges; i++) {
        type = range_state[i].type;
        if (type != MTRR_TYPE_WRBACK)
            continue;
        base = range_state[i].base_pfn;
        size = range_state[i].size_pfn;
        nr_range = add_range_with_merge (range, nr_range, base, base +size - 1);
    }
    if (debug_print) {
        printk (KERN_DEBUG "After WB checking\n");
        for (i = 0; i < nr_range; i++)
            printk (KERN_DEBUG "MTRR MAP PFN: %016lx - %016lx\n", range[i].start, range[i].end + 1);
    }
    for (i = 0; i < num_var_ranges; i++) {
        type = range_state[i].type;
        if (type != MTRR_TYPE_UNCACHABLE)
            continue;
        size = range_state[i].size_pfn;
        if (!size)
            continue;
        base = range_state[i].base_pfn;
        subtract_range (range, base, base + size - 1);
    }
    if (extra_remove_size)
        subtract_range (range, extra_remove_base, extra_remove_base +extra_remove_size - 1);
    nr_range = 0;
    for (i = 0; i < RANGE_NUM; i++) {
        if (!range[i].end)
            continue;
        nr_range++;
    }
    if (debug_print) {
        printk (KERN_DEBUG "After UC checking\n");
        for (i = 0; i < nr_range; i++)
            printk (KERN_DEBUG "MTRR MAP PFN: %016lx - %016lx\n", range[i].start, range[i].end + 1);
    }
    sort (range, nr_range, sizeof (struct res_range), cmp_range, NULL);
    if (debug_print) {
        printk (KERN_DEBUG "After sorting\n");
        for (i = 0; i < nr_range; i++)
            printk (KERN_DEBUG "MTRR MAP PFN: %016lx - %016lx\n", range[i].start, range[i].end + 1);
    }
    for (i = nr_range; i < RANGE_NUM; i++)
        memset (&range[i], 0, sizeof (range[i]));
    return nr_range;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/mtrr/main.c.ifdefed" startline="743" endline="751">
{
    type = range_state[i].type;
    if (type != MTRR_TYPE_WRBACK)
        continue;
    base = range_state[i].base_pfn;
    size = range_state[i].size_pfn;
    nr_range = add_range_with_merge (range, nr_range, base, base +size - 1);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/mtrr/main.c.ifdefed" startline="752" endline="757">
{
    printk (KERN_DEBUG "After WB checking\n");
    for (i = 0; i < nr_range; i++)
        printk (KERN_DEBUG "MTRR MAP PFN: %016lx - %016lx\n", range[i].start, range[i].end + 1);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/mtrr/main.c.ifdefed" startline="760" endline="769">
{
    type = range_state[i].type;
    if (type != MTRR_TYPE_UNCACHABLE)
        continue;
    size = range_state[i].size_pfn;
    if (!size)
        continue;
    base = range_state[i].base_pfn;
    subtract_range (range, base, base + size - 1);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/mtrr/main.c.ifdefed" startline="776" endline="780">
{
    if (!range[i].end)
        continue;
    nr_range++;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/mtrr/main.c.ifdefed" startline="781" endline="786">
{
    printk (KERN_DEBUG "After UC checking\n");
    for (i = 0; i < nr_range; i++)
        printk (KERN_DEBUG "MTRR MAP PFN: %016lx - %016lx\n", range[i].start, range[i].end + 1);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/mtrr/main.c.ifdefed" startline="790" endline="795">
{
    printk (KERN_DEBUG "After sorting\n");
    for (i = 0; i < nr_range; i++)
        printk (KERN_DEBUG "MTRR MAP PFN: %016lx - %016lx\n", range[i].start, range[i].end + 1);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/mtrr/main.c.ifdefed" startline="1387" endline="1389">
{
    return 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/mtrr/main.c.ifdefed" startline="1397" endline="1400">
{
    disable_mtrr_trim = 1;
    return 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/mtrr/main.c.ifdefed" startline="1413" endline="1431">
{
    u32 l, h;
    if (boot_cpu_data.x86_vendor != X86_VENDOR_AMD)
        return 0;
    if (boot_cpu_data.x86 < 0xf || boot_cpu_data.x86 > 0x11)
        return 0;
    if (rdmsr_safe (MSR_K8_SYSCFG, &l, &h) < 0)
        return 0;
    if ((l & (Tom2Enabled | Tom2ForceMemTypeWB)) == (Tom2Enabled | Tom2ForceMemTypeWB))
        return 1;
    return 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/mtrr/main.c.ifdefed" startline="1435" endline="1445">
{
    u64 trim_start, trim_size;
    trim_start = start_pfn;
    trim_start <<= PAGE_SHIFT;
    trim_size = limit_pfn;
    trim_size <<= PAGE_SHIFT;
    trim_size -= trim_start;
    return e820_update_range (trim_start, trim_size, E820_RAM, E820_RESERVED);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/mtrr/main.c.ifdefed" startline="1458" endline="1567">
{
    unsigned long i, base, size, highest_pfn = 0, def, dummy;
    mtrr_type type;
    int nr_range;
    u64 total_trim_size;
    int num [MTRR_NUM_TYPES + 1];
    if (!is_cpu (INTEL) || disable_mtrr_trim)
        return 0;
    rdmsr (MTRRdefType_MSR, def, dummy);
    def &= 0xff;
    if (def != MTRR_TYPE_UNCACHABLE)
        return 0;
    memset (range_state, 0, sizeof (range_state));
    for (i = 0; i < num_var_ranges; i++) {
        mtrr_if->get (i, &base, &size, &type);
        range_state[i].base_pfn = base;
        range_state[i].size_pfn = size;
        range_state[i].type = type;
    }
    for (i = 0; i < num_var_ranges; i++) {
        type = range_state[i].type;
        if (type != MTRR_TYPE_WRBACK)
            continue;
        base = range_state[i].base_pfn;
        size = range_state[i].size_pfn;
        if (highest_pfn < base + size)
            highest_pfn = base + size;
    }
    if (!highest_pfn) {
        WARN (! kvm_para_available (), KERN_WARNING "WARNING: strange, CPU MTRRs all blank?\n");
        return 0;
    }
    memset (num, 0, sizeof (num));
    for (i = 0; i < num_var_ranges; i++) {
        type = range_state[i].type;
        if (type >= MTRR_NUM_TYPES)
            continue;
        size = range_state[i].size_pfn;
        if (!size)
            type = MTRR_NUM_TYPES;
        num[type]++;
    }
    if (!num[MTRR_TYPE_WRBACK])
        return 0;
    if (num[MTRR_TYPE_WRBACK] + num[MTRR_TYPE_UNCACHABLE] != num_var_ranges - num[MTRR_NUM_TYPES])
        return 0;
    memset (range, 0, sizeof (range));
    nr_range = 0;
    if (mtrr_tom2) {
        range[nr_range].start = (1ULL << (32 - PAGE_SHIFT));
        range[nr_range].end = (mtrr_tom2 >> PAGE_SHIFT) - 1;
        if (highest_pfn < range[nr_range].end + 1)
            highest_pfn = range[nr_range].end + 1;
        nr_range++;
    }
    nr_range = x86_get_mtrr_mem_range (range, nr_range, 0, 0);
    total_trim_size = 0;
    if (range[0].start)
        total_trim_size += real_trim_memory (0, range[0].start);
    for (i = 0; i < nr_range - 1; i++) {
        if (range[i].end + 1 < range[i + 1].start)
            total_trim_size += real_trim_memory (range[i].end + 1, range[i + 1].start);
    }
    i = nr_range - 1;
    if (range[i].end + 1 < end_pfn)
        total_trim_size += real_trim_memory (range[i].end + 1, end_pfn);
    if (total_trim_size) {
        printk (KERN_WARNING "WARNING: BIOS bug: CPU MTRRs don't cover" " all of memory, losing %lluMB of RAM.\n", total_trim_size >> 20);
        if (!changed_by_mtrr_cleanup)
            WARN_ON (1);
        printk (KERN_INFO "update e820 for mtrr\n");
        update_e820 ();
        return 1;
    }
    return 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/mtrr/main.c.ifdefed" startline="1479" endline="1484">
{
    mtrr_if->get (i, &base, &size, &type);
    range_state[i].base_pfn = base;
    range_state[i].size_pfn = size;
    range_state[i].type = type;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/mtrr/main.c.ifdefed" startline="1487" endline="1495">
{
    type = range_state[i].type;
    if (type != MTRR_TYPE_WRBACK)
        continue;
    base = range_state[i].base_pfn;
    size = range_state[i].size_pfn;
    if (highest_pfn < base + size)
        highest_pfn = base + size;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/mtrr/main.c.ifdefed" startline="1498" endline="1502">
{
    WARN (! kvm_para_available (), KERN_WARNING "WARNING: strange, CPU MTRRs all blank?\n");
    return 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/mtrr/main.c.ifdefed" startline="1506" endline="1514">
{
    type = range_state[i].type;
    if (type >= MTRR_NUM_TYPES)
        continue;
    size = range_state[i].size_pfn;
    if (!size)
        type = MTRR_NUM_TYPES;
    num[type]++;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/mtrr/main.c.ifdefed" startline="1527" endline="1533">
{
    range[nr_range].start = (1ULL << (32 - PAGE_SHIFT));
    range[nr_range].end = (mtrr_tom2 >> PAGE_SHIFT) - 1;
    if (highest_pfn < range[nr_range].end + 1)
        highest_pfn = range[nr_range].end + 1;
    nr_range++;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/mtrr/main.c.ifdefed" startline="1541" endline="1545">
{
    if (range[i].end + 1 < range[i + 1].start)
        total_trim_size += real_trim_memory (range[i].end + 1, range[i + 1].start);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/mtrr/main.c.ifdefed" startline="1552" endline="1564">
{
    printk (KERN_WARNING "WARNING: BIOS bug: CPU MTRRs don't cover" " all of memory, losing %lluMB of RAM.\n", total_trim_size >> 20);
    if (!changed_by_mtrr_cleanup)
        WARN_ON (1);
    printk (KERN_INFO "update e820 for mtrr\n");
    update_e820 ();
    return 1;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/mtrr/main.c.ifdefed" startline="1577" endline="1654">
{
    u32 phys_addr;
    init_ifs ();
    phys_addr = 32;
    if (cpu_has_mtrr) {
        mtrr_if = &generic_mtrr_ops;
        size_or_mask = 0xff000000;
        size_and_mask = 0x00f00000;
        phys_addr = 36;
        if (cpuid_eax (0x80000000) >= 0x80000008) {
            phys_addr = cpuid_eax (0x80000008) & 0xff;
            if (boot_cpu_data.x86_vendor == X86_VENDOR_INTEL && boot_cpu_data.x86 == 0xF && boot_cpu_data.x86_model == 0x3 && (boot_cpu_data.x86_mask == 0x3 || boot_cpu_data.x86_mask == 0x4))
                phys_addr = 36;
            size_or_mask = ~((1ULL << (phys_addr - PAGE_SHIFT)) - 1);
            size_and_mask = ~size_or_mask & 0xfffff00000ULL;
        }
        else if (boot_cpu_data.x86_vendor == X86_VENDOR_CENTAUR && boot_cpu_data.x86 == 6) {
            size_or_mask = 0xfff00000;
            size_and_mask = 0;
            phys_addr = 32;
        }
    }
    else {
        switch (boot_cpu_data.x86_vendor) {
        case X86_VENDOR_AMD :
            if (cpu_has_k6_mtrr) {
                mtrr_if = mtrr_ops[X86_VENDOR_AMD];
                size_or_mask = 0xfff00000;
                size_and_mask = 0;
            }
            break;
        case X86_VENDOR_CENTAUR :
            if (cpu_has_centaur_mcr) {
                mtrr_if = mtrr_ops[X86_VENDOR_CENTAUR];
                size_or_mask = 0xfff00000;
                size_and_mask = 0;
            }
            break;
        case X86_VENDOR_CYRIX :
            if (cpu_has_cyrix_arr) {
                mtrr_if = mtrr_ops[X86_VENDOR_CYRIX];
                size_or_mask = 0xfff00000;
                size_and_mask = 0;
            }
            break;
        default :
            break;
        }
    }
    if (mtrr_if) {
        set_num_var_ranges ();
        init_table ();
        if (use_intel ()) {
            get_mtrr_state ();
            if (mtrr_cleanup (phys_addr)) {
                changed_by_mtrr_cleanup = 1;
                mtrr_if->set_all ();
            }
        }
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/mtrr/main.c.ifdefed" startline="1583" endline="1612">
{
    mtrr_if = &generic_mtrr_ops;
    size_or_mask = 0xff000000;
    size_and_mask = 0x00f00000;
    phys_addr = 36;
    if (cpuid_eax (0x80000000) >= 0x80000008) {
        phys_addr = cpuid_eax (0x80000008) & 0xff;
        if (boot_cpu_data.x86_vendor == X86_VENDOR_INTEL && boot_cpu_data.x86 == 0xF && boot_cpu_data.x86_model == 0x3 && (boot_cpu_data.x86_mask == 0x3 || boot_cpu_data.x86_mask == 0x4))
            phys_addr = 36;
        size_or_mask = ~((1ULL << (phys_addr - PAGE_SHIFT)) - 1);
        size_and_mask = ~size_or_mask & 0xfffff00000ULL;
    }
    else if (boot_cpu_data.x86_vendor == X86_VENDOR_CENTAUR && boot_cpu_data.x86 == 6) {
        size_or_mask = 0xfff00000;
        size_and_mask = 0;
        phys_addr = 32;
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/mtrr/main.c.ifdefed" startline="1592" endline="1604">
{
    phys_addr = cpuid_eax (0x80000008) & 0xff;
    if (boot_cpu_data.x86_vendor == X86_VENDOR_INTEL && boot_cpu_data.x86 == 0xF && boot_cpu_data.x86_model == 0x3 && (boot_cpu_data.x86_mask == 0x3 || boot_cpu_data.x86_mask == 0x4))
        phys_addr = 36;
    size_or_mask = ~((1ULL << (phys_addr - PAGE_SHIFT)) - 1);
    size_and_mask = ~size_or_mask & 0xfffff00000ULL;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/mtrr/main.c.ifdefed" startline="1605" endline="1611">
{
    size_or_mask = 0xfff00000;
    size_and_mask = 0;
    phys_addr = 32;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/mtrr/main.c.ifdefed" startline="1612" endline="1639">
{
    switch (boot_cpu_data.x86_vendor) {
    case X86_VENDOR_AMD :
        if (cpu_has_k6_mtrr) {
            mtrr_if = mtrr_ops[X86_VENDOR_AMD];
            size_or_mask = 0xfff00000;
            size_and_mask = 0;
        }
        break;
    case X86_VENDOR_CENTAUR :
        if (cpu_has_centaur_mcr) {
            mtrr_if = mtrr_ops[X86_VENDOR_CENTAUR];
            size_or_mask = 0xfff00000;
            size_and_mask = 0;
        }
        break;
    case X86_VENDOR_CYRIX :
        if (cpu_has_cyrix_arr) {
            mtrr_if = mtrr_ops[X86_VENDOR_CYRIX];
            size_or_mask = 0xfff00000;
            size_and_mask = 0;
        }
        break;
    default :
        break;
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/mtrr/main.c.ifdefed" startline="1613" endline="1638">
{
case X86_VENDOR_AMD :
    if (cpu_has_k6_mtrr) {
        mtrr_if = mtrr_ops[X86_VENDOR_AMD];
        size_or_mask = 0xfff00000;
        size_and_mask = 0;
    }
    break;
case X86_VENDOR_CENTAUR :
    if (cpu_has_centaur_mcr) {
        mtrr_if = mtrr_ops[X86_VENDOR_CENTAUR];
        size_or_mask = 0xfff00000;
        size_and_mask = 0;
    }
    break;
case X86_VENDOR_CYRIX :
    if (cpu_has_cyrix_arr) {
        mtrr_if = mtrr_ops[X86_VENDOR_CYRIX];
        size_or_mask = 0xfff00000;
        size_and_mask = 0;
    }
    break;
default :
    break;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/mtrr/main.c.ifdefed" startline="1615" endline="1620">
{
    mtrr_if = mtrr_ops[X86_VENDOR_AMD];
    size_or_mask = 0xfff00000;
    size_and_mask = 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/mtrr/main.c.ifdefed" startline="1623" endline="1627">
{
    mtrr_if = mtrr_ops[X86_VENDOR_CENTAUR];
    size_or_mask = 0xfff00000;
    size_and_mask = 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/mtrr/main.c.ifdefed" startline="1630" endline="1634">
{
    mtrr_if = mtrr_ops[X86_VENDOR_CYRIX];
    size_or_mask = 0xfff00000;
    size_and_mask = 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/mtrr/main.c.ifdefed" startline="1641" endline="1653">
{
    set_num_var_ranges ();
    init_table ();
    if (use_intel ()) {
        get_mtrr_state ();
        if (mtrr_cleanup (phys_addr)) {
            changed_by_mtrr_cleanup = 1;
            mtrr_if->set_all ();
        }
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/mtrr/main.c.ifdefed" startline="1644" endline="1652">
{
    get_mtrr_state ();
    if (mtrr_cleanup (phys_addr)) {
        changed_by_mtrr_cleanup = 1;
        mtrr_if->set_all ();
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/mtrr/main.c.ifdefed" startline="1647" endline="1650">
{
    changed_by_mtrr_cleanup = 1;
    mtrr_if->set_all ();
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/mtrr/main.c.ifdefed" startline="1657" endline="1675">
{
    unsigned long flags;
    if (!mtrr_if || !use_intel ())
        return;
    local_irq_save (flags);
    mtrr_if->set_all ();
    local_irq_restore (flags);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/mtrr/main.c.ifdefed" startline="1681" endline="1683">
{
    smp_call_function_single (0, mtrr_save_fixed_ranges, NULL, 1);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/mtrr/main.c.ifdefed" startline="1686" endline="1703">
{
    if (!mtrr_if)
        return 0;
    if (use_intel ()) {
        if (!changed_by_mtrr_cleanup)
            mtrr_state_warn ();
    }
    else {
        sysdev_driver_register (& cpu_sysdev_class, & mtrr_sysdev_driver);
    }
    return 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/mtrr/main.c.ifdefed" startline="1689" endline="1692">
{
    if (!changed_by_mtrr_cleanup)
        mtrr_state_warn ();
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/mtrr/main.c.ifdefed" startline="1692" endline="1701">
{
    sysdev_driver_register (& cpu_sysdev_class, & mtrr_sysdev_driver);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/intel_64.c.ifdefed" startline="11" endline="17">
{
    if ((c->x86 == 0xf && c->x86_model >= 0x03) || (c->x86 == 0x6 && c->x86_model >= 0x0e))
        set_cpu_cap (c, X86_FEATURE_CONSTANT_TSC);
    set_cpu_cap (c, X86_FEATURE_SYSENTER32);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/intel_64.c.ifdefed" startline="23" endline="35">
{
    unsigned int eax, t;
    if (c->cpuid_level < 4)
        return 1;
    cpuid_count (4, 0, & eax, & t, & t, & t);
    if (eax & 0x1f)
        return ((eax >> 26) + 1);
    else
        return 1;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/intel_64.c.ifdefed" startline="38" endline="53">
{
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/intel_64.c.ifdefed" startline="56" endline="86">
{
    init_intel_cacheinfo (c);
    if (c->cpuid_level > 9) {
        unsigned eax = cpuid_eax (10);
        if ((eax & 0xff) && (((eax >> 8) & 0xff) > 1))
            set_cpu_cap (c, X86_FEATURE_ARCH_PERFMON);
    }
    if (cpu_has_ds) {
        unsigned int l1, l2;
        rdmsr (MSR_IA32_MISC_ENABLE, l1, l2);
        if (!(l1 & (1 << 11)))
            set_cpu_cap (c, X86_FEATURE_BTS);
        if (!(l1 & (1 << 12)))
            set_cpu_cap (c, X86_FEATURE_PEBS);
    }
    if (cpu_has_bts)
        ds_init_intel (c);
    if (c->x86 == 15)
        c->x86_cache_alignment = c->x86_clflush_size * 2;
    if (c->x86 == 6)
        set_cpu_cap (c, X86_FEATURE_REP_GOOD);
    set_cpu_cap (c, X86_FEATURE_LFENCE_RDTSC);
    c->x86_max_cores = intel_num_cpu_cores (c);
    srat_detect_node ();
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/intel_64.c.ifdefed" startline="58" endline="63">
{
    unsigned eax = cpuid_eax (10);
    if ((eax & 0xff) && (((eax >> 8) & 0xff) > 1))
        set_cpu_cap (c, X86_FEATURE_ARCH_PERFMON);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/intel_64.c.ifdefed" startline="65" endline="72">
{
    unsigned int l1, l2;
    rdmsr (MSR_IA32_MISC_ENABLE, l1, l2);
    if (!(l1 & (1 << 11)))
        set_cpu_cap (c, X86_FEATURE_BTS);
    if (!(l1 & (1 << 12)))
        set_cpu_cap (c, X86_FEATURE_PEBS);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/proc.c.ifdefed" startline="55" endline="67">
{
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/proc.c.ifdefed" startline="70" endline="77">
{
    seq_printf (m, "fpu\t\t: yes\n" "fpu_exception\t: yes\n" "cpuid level\t: %d\n" "wp\t\t: yes\n", c -> cpuid_level);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/proc.c.ifdefed" startline="81" endline="157">
{
    struct cpuinfo_x86 *c = v;
    unsigned int cpu = 0;
    int i;
    seq_printf (m, "processor\t: %u\n" "vendor_id\t: %s\n" "cpu family\t: %d\n" "model\t\t: %u\n" "model name\t: %s\n", cpu, c -> x86_vendor_id [0] ? c -> x86_vendor_id : "unknown", c -> x86, c -> x86_model, c -> x86_model_id [0] ? c -> x86_model_id : "unknown");
    if (c->x86_mask || c->cpuid_level >= 0)
        seq_printf (m, "stepping\t: %d\n", c->x86_mask);
    else
        seq_printf (m, "stepping\t: unknown\n");
    if (cpu_has (c, X86_FEATURE_TSC)) {
        unsigned int freq = cpufreq_quick_get (cpu);
        if (!freq)
            freq = cpu_khz;
        seq_printf (m, "cpu MHz\t\t: %u.%03u\n", freq / 1000, (freq % 1000));
    }
    if (c->x86_cache_size >= 0)
        seq_printf (m, "cache size\t: %d KB\n", c->x86_cache_size);
    show_cpuinfo_core (m, c, cpu);
    show_cpuinfo_misc (m, c);
    seq_printf (m, "flags\t\t:");
    for (i = 0; i < 32 * NCAPINTS; i++)
        if (cpu_has (c, i) && x86_cap_flags[i] != NULL)
            seq_printf (m, " %s", x86_cap_flags[i]);
    seq_printf (m, "\nbogomips\t: %lu.%02lu\n", c -> loops_per_jiffy / (500000 / HZ), (c -> loops_per_jiffy / (5000 / HZ)) % 100);
    seq_printf (m, "clflush size\t: %u\n", c -> x86_clflush_size);
    seq_printf (m, "power management:");
    for (i = 0; i < 32; i++) {
        if (c->x86_power & (1 << i)) {
            if (i < ARRAY_SIZE (x86_power_flags) && x86_power_flags[i])
                seq_printf (m, "%s%s", x86_power_flags[i][0] ? " " : "", x86_power_flags[i]);
            else
                seq_printf (m, " [%d]", i);
        }
    }
    seq_printf (m, "\n\n");
    return 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/proc.c.ifdefed" startline="105" endline="112">
{
    unsigned int freq = cpufreq_quick_get (cpu);
    if (!freq)
        freq = cpu_khz;
    seq_printf (m, "cpu MHz\t\t: %u.%03u\n", freq / 1000, (freq % 1000));
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/proc.c.ifdefed" startline="142" endline="152">
{
    if (c->x86_power & (1 << i)) {
        if (i < ARRAY_SIZE (x86_power_flags) && x86_power_flags[i])
            seq_printf (m, "%s%s", x86_power_flags[i][0] ? " " : "", x86_power_flags[i]);
        else
            seq_printf (m, " [%d]", i);
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/proc.c.ifdefed" startline="143" endline="151">
{
    if (i < ARRAY_SIZE (x86_power_flags) && x86_power_flags[i])
        seq_printf (m, "%s%s", x86_power_flags[i][0] ? " " : "", x86_power_flags[i]);
    else
        seq_printf (m, " [%d]", i);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/proc.c.ifdefed" startline="160" endline="166">
{
    if (*pos == 0)
        *pos = first_cpu (cpu_online_map);
    if ((*pos) < nr_cpu_ids && cpu_online (*pos))
        return &cpu_data (*pos);
    return NULL;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/proc.c.ifdefed" startline="169" endline="172">
{
    *pos = next_cpu (*pos, cpu_online_map);
    return c_start (m, pos);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/proc.c.ifdefed" startline="175" endline="176">
{
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/topology.c.ifdefed" startline="61" endline="63">
{
    return register_cpu (&per_cpu (cpu_devices, num).cpu, num);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/topology.c.ifdefed" startline="67" endline="78">
{
    int i;
    for_each_present_cpu (i)
    arch_register_cpu (i);
    return 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/time_64.c.ifdefed" startline="30" endline="44">
{
    unsigned long pc = instruction_pointer (regs);
    if (!user_mode (regs) && in_lock_functions (pc)) {
        unsigned long *sp = (unsigned long *) regs->sp;
        if (sp[0] >> 22)
            return sp[0];
        if (sp[1] >> 22)
            return sp[1];
    }
    return pc;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/time_64.c.ifdefed" startline="36" endline="42">
{
    unsigned long *sp = (unsigned long *) regs->sp;
    if (sp[0] >> 22)
        return sp[0];
    if (sp[1] >> 22)
        return sp[1];
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/time_64.c.ifdefed" startline="48" endline="54">
{
    add_pda (irq0_irqs, 1);
    global_clock_event->event_handler (global_clock_event);
    return IRQ_HANDLED;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/time_64.c.ifdefed" startline="60" endline="100">
{
    int tsc_start, tsc_now;
    int i, no_ctr_free;
    unsigned long evntsel3 = 0, pmc3 = 0, pmc_now = 0;
    unsigned long flags;
    for (i = 0; i < 4; i++)
        if (avail_to_resrv_perfctr_nmi_bit (i))
            break;
    no_ctr_free = (i == 4);
    if (no_ctr_free) {
        i = 3;
        rdmsrl (MSR_K7_EVNTSEL3, evntsel3);
        wrmsrl (MSR_K7_EVNTSEL3, 0);
        rdmsrl (MSR_K7_PERFCTR3, pmc3);
    }
    else {
        reserve_perfctr_nmi (MSR_K7_PERFCTR0 + i);
        reserve_evntsel_nmi (MSR_K7_EVNTSEL0 + i);
    }
    local_irq_save (flags);
    wrmsrl (MSR_K7_PERFCTR0 + i, 0);
    wrmsrl (MSR_K7_EVNTSEL0 + i, 1 << 22 | 3 << 16 | 0x76);
    rdtscl (tsc_start);
    do {
        rdmsrl (MSR_K7_PERFCTR0 + i, pmc_now);
        tsc_now = get_cycles ();
    }
    while ((tsc_now - tsc_start) < TICK_COUNT);
    local_irq_restore (flags);
    if (no_ctr_free) {
        wrmsrl (MSR_K7_EVNTSEL3, 0);
        wrmsrl (MSR_K7_PERFCTR3, pmc3);
        wrmsrl (MSR_K7_EVNTSEL3, evntsel3);
    }
    else {
        release_perfctr_nmi (MSR_K7_PERFCTR0 + i);
        release_evntsel_nmi (MSR_K7_EVNTSEL0 + i);
    }
    return pmc_now * tsc_khz / (tsc_now - tsc_start);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/time_64.c.ifdefed" startline="70" endline="75">
{
    i = 3;
    rdmsrl (MSR_K7_EVNTSEL3, evntsel3);
    wrmsrl (MSR_K7_EVNTSEL3, 0);
    rdmsrl (MSR_K7_PERFCTR3, pmc3);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/time_64.c.ifdefed" startline="75" endline="78">
{
    reserve_perfctr_nmi (MSR_K7_PERFCTR0 + i);
    reserve_evntsel_nmi (MSR_K7_EVNTSEL0 + i);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/time_64.c.ifdefed" startline="84" endline="87">
{
    rdmsrl (MSR_K7_PERFCTR0 + i, pmc_now);
    tsc_now = get_cycles ();
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/time_64.c.ifdefed" startline="90" endline="94">
{
    wrmsrl (MSR_K7_EVNTSEL3, 0);
    wrmsrl (MSR_K7_PERFCTR3, pmc3);
    wrmsrl (MSR_K7_EVNTSEL3, evntsel3);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/time_64.c.ifdefed" startline="94" endline="97">
{
    release_perfctr_nmi (MSR_K7_PERFCTR0 + i);
    release_evntsel_nmi (MSR_K7_EVNTSEL0 + i);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/time_64.c.ifdefed" startline="110" endline="115">
{
    if (!hpet_enable ())
        setup_pit_timer ();
    setup_irq (0, & irq0);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/time_64.c.ifdefed" startline="118" endline="126">
{
    tsc_init ();
    if (cpu_has (&boot_cpu_data, X86_FEATURE_RDTSCP))
        vgetcpu_mode = VGETCPU_RDTSCP;
    else
        vgetcpu_mode = VGETCPU_LSL;
    late_time_init = choose_time_init ();
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/setup_percpu.c.ifdefed" startline="51" endline="51">
{
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/e820.c.ifdefed" startline="60" endline="73">
{
    int i;
    for (i = 0; i < e820.nr_map; i++) {
        struct e820entry *ei = &e820.map[i];
        if (type && ei->type != type)
            continue;
        if (ei->addr >= end || ei->addr + ei->size <= start)
            continue;
        return 1;
    }
    return 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/e820.c.ifdefed" startline="63" endline="71">
{
    struct e820entry *ei = &e820.map[i];
    if (type && ei->type != type)
        continue;
    if (ei->addr >= end || ei->addr + ei->size <= start)
        continue;
    return 1;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/e820.c.ifdefed" startline="83" endline="108">
{
    int i;
    for (i = 0; i < e820.nr_map; i++) {
        struct e820entry *ei = &e820.map[i];
        if (type && ei->type != type)
            continue;
        if (ei->addr >= end || ei->addr + ei->size <= start)
            continue;
        if (ei->addr <= start)
            start = ei->addr + ei->size;
        if (start >= end)
            return 1;
    }
    return 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/e820.c.ifdefed" startline="86" endline="106">
{
    struct e820entry *ei = &e820.map[i];
    if (type && ei->type != type)
        continue;
    if (ei->addr >= end || ei->addr + ei->size <= start)
        continue;
    if (ei->addr <= start)
        start = ei->addr + ei->size;
    if (start >= end)
        return 1;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/e820.c.ifdefed" startline="114" endline="126">
{
    int x = e820.nr_map;
    if (x == ARRAY_SIZE (e820.map)) {
        printk (KERN_ERR "Ooops! Too many entries in the memory map!\n");
        return;
    }
    e820.map[x].addr = start;
    e820.map[x].size = size;
    e820.map[x].type = type;
    e820.nr_map++;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/e820.c.ifdefed" startline="117" endline="120">
{
    printk (KERN_ERR "Ooops! Too many entries in the memory map!\n");
    return;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/e820.c.ifdefed" startline="129" endline="156">
{
    int i;
    for (i = 0; i < e820.nr_map; i++) {
        printk (KERN_INFO " %s: %016Lx - %016Lx ", who, (unsigned long long) e820.map [i].addr, (unsigned long long) (e820.map [i].addr + e820.map [i].size));
        switch (e820.map[i].type) {
        case E820_RAM :
        case E820_RESERVED_KERN :
            printk (KERN_CONT "(usable)\n");
            break;
        case E820_RESERVED :
            printk (KERN_CONT "(reserved)\n");
            break;
        case E820_ACPI :
            printk (KERN_CONT "(ACPI data)\n");
            break;
        case E820_NVS :
            printk (KERN_CONT "(ACPI NVS)\n");
            break;
        default :
            printk (KERN_CONT "type %u\n", e820.map[i].type);
            break;
        }
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/e820.c.ifdefed" startline="132" endline="155">
{
    printk (KERN_INFO " %s: %016Lx - %016Lx ", who, (unsigned long long) e820.map [i].addr, (unsigned long long) (e820.map [i].addr + e820.map [i].size));
    switch (e820.map[i].type) {
    case E820_RAM :
    case E820_RESERVED_KERN :
        printk (KERN_CONT "(usable)\n");
        break;
    case E820_RESERVED :
        printk (KERN_CONT "(reserved)\n");
        break;
    case E820_ACPI :
        printk (KERN_CONT "(ACPI data)\n");
        break;
    case E820_NVS :
        printk (KERN_CONT "(ACPI NVS)\n");
        break;
    default :
        printk (KERN_CONT "type %u\n", e820.map[i].type);
        break;
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/e820.c.ifdefed" startline="137" endline="154">
{
case E820_RAM :
case E820_RESERVED_KERN :
    printk (KERN_CONT "(usable)\n");
    break;
case E820_RESERVED :
    printk (KERN_CONT "(reserved)\n");
    break;
case E820_ACPI :
    printk (KERN_CONT "(ACPI data)\n");
    break;
case E820_NVS :
    printk (KERN_CONT "(ACPI NVS)\n");
    break;
default :
    printk (KERN_CONT "type %u\n", e820.map[i].type);
    break;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/e820.c.ifdefed" startline="222" endline="377">
{
    struct change_member {
        struct e820entry *pbios;
        unsigned long long addr;
    };
    static struct change_member change_point_list [2 * E820_X_MAX] __initdata;
    static struct change_member *change_point [2 * E820_X_MAX] __initdata;
    static struct e820entry *overlap_list [E820_X_MAX] __initdata;
    static struct e820entry new_bios [E820_X_MAX] __initdata;
    struct change_member *change_tmp;
    unsigned long current_type, last_type;
    unsigned long long last_addr;
    int chgidx, still_changing;
    int overlap_entries;
    int new_bios_entry;
    int old_nr, new_nr, chg_nr;
    int i;
    if (*pnr_map < 2)
        return -1;
    old_nr = *pnr_map;
    BUG_ON (old_nr > max_nr_map);
    for (i = 0; i < old_nr; i++)
        if (biosmap[i].addr + biosmap[i].size < biosmap[i].addr)
            return -1;
    for (i = 0; i < 2 * old_nr; i++)
        change_point[i] = &change_point_list[i];
    chgidx = 0;
    for (i = 0; i < old_nr; i++) {
        if (biosmap[i].size != 0) {
            change_point[chgidx]->addr = biosmap[i].addr;
            change_point[chgidx++]->pbios = &biosmap[i];
            change_point[chgidx]->addr = biosmap[i].addr + biosmap[i].size;
            change_point[chgidx++]->pbios = &biosmap[i];
        }
    }
    chg_nr = chgidx;
    still_changing = 1;
    while (still_changing) {
        still_changing = 0;
        for (i = 1; i < chg_nr; i++) {
            unsigned long long curaddr, lastaddr;
            unsigned long long curpbaddr, lastpbaddr;
            curaddr = change_point[i]->addr;
            lastaddr = change_point[i - 1]->addr;
            curpbaddr = change_point[i]->pbios->addr;
            lastpbaddr = change_point[i - 1]->pbios->addr;
            if (curaddr < lastaddr || (curaddr == lastaddr && curaddr == curpbaddr && lastaddr != lastpbaddr)) {
                change_tmp = change_point[i];
                change_point[i] = change_point[i - 1];
                change_point[i - 1] = change_tmp;
                still_changing = 1;
            }
        }
    }
    overlap_entries = 0;
    new_bios_entry = 0;
    last_type = 0;
    last_addr = 0;
    for (chgidx = 0; chgidx < chg_nr; chgidx++) {
        if (change_point[chgidx]->addr == change_point[chgidx]->pbios->addr) {
            overlap_list[overlap_entries++] = change_point[chgidx]->pbios;
        }
        else {
            for (i = 0; i < overlap_entries; i++) {
                if (overlap_list[i] == change_point[chgidx]->pbios)
                    overlap_list[i] = overlap_list[overlap_entries - 1];
            }
            overlap_entries--;
        }
        current_type = 0;
        for (i = 0; i < overlap_entries; i++)
            if (overlap_list[i]->type > current_type)
                current_type = overlap_list[i]->type;
        if (current_type != last_type) {
            if (last_type != 0) {
                new_bios[new_bios_entry].size = change_point[chgidx]->addr - last_addr;
                if (new_bios[new_bios_entry].size != 0)
                    if (++new_bios_entry >= max_nr_map)
                        break;
            }
            if (current_type != 0) {
                new_bios[new_bios_entry].addr = change_point[chgidx]->addr;
                new_bios[new_bios_entry].type = current_type;
                last_addr = change_point[chgidx]->addr;
            }
            last_type = current_type;
        }
    }
    new_nr = new_bios_entry;
    memcpy (biosmap, new_bios, new_nr * sizeof (struct e820entry));
    *pnr_map = new_nr;
    return 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/e820.c.ifdefed" startline="259" endline="267">
{
    if (biosmap[i].size != 0) {
        change_point[chgidx]->addr = biosmap[i].addr;
        change_point[chgidx++]->pbios = &biosmap[i];
        change_point[chgidx]->addr = biosmap[i].addr + biosmap[i].size;
        change_point[chgidx++]->pbios = &biosmap[i];
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/e820.c.ifdefed" startline="260" endline="266">
{
    change_point[chgidx]->addr = biosmap[i].addr;
    change_point[chgidx++]->pbios = &biosmap[i];
    change_point[chgidx]->addr = biosmap[i].addr + biosmap[i].size;
    change_point[chgidx++]->pbios = &biosmap[i];
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/e820.c.ifdefed" startline="272" endline="299">
{
    still_changing = 0;
    for (i = 1; i < chg_nr; i++) {
        unsigned long long curaddr, lastaddr;
        unsigned long long curpbaddr, lastpbaddr;
        curaddr = change_point[i]->addr;
        lastaddr = change_point[i - 1]->addr;
        curpbaddr = change_point[i]->pbios->addr;
        lastpbaddr = change_point[i - 1]->pbios->addr;
        if (curaddr < lastaddr || (curaddr == lastaddr && curaddr == curpbaddr && lastaddr != lastpbaddr)) {
            change_tmp = change_point[i];
            change_point[i] = change_point[i - 1];
            change_point[i - 1] = change_tmp;
            still_changing = 1;
        }
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/e820.c.ifdefed" startline="274" endline="298">
{
    unsigned long long curaddr, lastaddr;
    unsigned long long curpbaddr, lastpbaddr;
    curaddr = change_point[i]->addr;
    lastaddr = change_point[i - 1]->addr;
    curpbaddr = change_point[i]->pbios->addr;
    lastpbaddr = change_point[i - 1]->pbios->addr;
    if (curaddr < lastaddr || (curaddr == lastaddr && curaddr == curpbaddr && lastaddr != lastpbaddr)) {
        change_tmp = change_point[i];
        change_point[i] = change_point[i - 1];
        change_point[i - 1] = change_tmp;
        still_changing = 1;
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/e820.c.ifdefed" startline="292" endline="297">
{
    change_tmp = change_point[i];
    change_point[i] = change_point[i - 1];
    change_point[i - 1] = change_tmp;
    still_changing = 1;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/e820.c.ifdefed" startline="308" endline="368">
{
    if (change_point[chgidx]->addr == change_point[chgidx]->pbios->addr) {
        overlap_list[overlap_entries++] = change_point[chgidx]->pbios;
    }
    else {
        for (i = 0; i < overlap_entries; i++) {
            if (overlap_list[i] == change_point[chgidx]->pbios)
                overlap_list[i] = overlap_list[overlap_entries - 1];
        }
        overlap_entries--;
    }
    current_type = 0;
    for (i = 0; i < overlap_entries; i++)
        if (overlap_list[i]->type > current_type)
            current_type = overlap_list[i]->type;
    if (current_type != last_type) {
        if (last_type != 0) {
            new_bios[new_bios_entry].size = change_point[chgidx]->addr - last_addr;
            if (new_bios[new_bios_entry].size != 0)
                if (++new_bios_entry >= max_nr_map)
                    break;
        }
        if (current_type != 0) {
            new_bios[new_bios_entry].addr = change_point[chgidx]->addr;
            new_bios[new_bios_entry].type = current_type;
            last_addr = change_point[chgidx]->addr;
        }
        last_type = current_type;
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/e820.c.ifdefed" startline="311" endline="318">
{
    overlap_list[overlap_entries++] = change_point[chgidx]->pbios;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/e820.c.ifdefed" startline="318" endline="330">
{
    for (i = 0; i < overlap_entries; i++) {
        if (overlap_list[i] == change_point[chgidx]->pbios)
            overlap_list[i] = overlap_list[overlap_entries - 1];
    }
    overlap_entries--;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/e820.c.ifdefed" startline="323" endline="328">
{
    if (overlap_list[i] == change_point[chgidx]->pbios)
        overlap_list[i] = overlap_list[overlap_entries - 1];
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/e820.c.ifdefed" startline="344" endline="367">
{
    if (last_type != 0) {
        new_bios[new_bios_entry].size = change_point[chgidx]->addr - last_addr;
        if (new_bios[new_bios_entry].size != 0)
            if (++new_bios_entry >= max_nr_map)
                break;
    }
    if (current_type != 0) {
        new_bios[new_bios_entry].addr = change_point[chgidx]->addr;
        new_bios[new_bios_entry].type = current_type;
        last_addr = change_point[chgidx]->addr;
    }
    last_type = current_type;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/e820.c.ifdefed" startline="345" endline="359">
{
    new_bios[new_bios_entry].size = change_point[chgidx]->addr - last_addr;
    if (new_bios[new_bios_entry].size != 0)
        if (++new_bios_entry >= max_nr_map)
            break;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/e820.c.ifdefed" startline="360" endline="365">
{
    new_bios[new_bios_entry].addr = change_point[chgidx]->addr;
    new_bios[new_bios_entry].type = current_type;
    last_addr = change_point[chgidx]->addr;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/e820.c.ifdefed" startline="380" endline="397">
{
    while (nr_map) {
        u64 start = biosmap->addr;
        u64 size = biosmap->size;
        u64 end = start + size;
        u32 type = biosmap->type;
        if (start > end)
            return -1;
        e820_add_region (start, size, type);
        biosmap++;
        nr_map--;
    }
    return 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/e820.c.ifdefed" startline="381" endline="395">
{
    u64 start = biosmap->addr;
    u64 size = biosmap->size;
    u64 end = start + size;
    u32 type = biosmap->type;
    if (start > end)
        return -1;
    e820_add_region (start, size, type);
    biosmap++;
    nr_map--;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/e820.c.ifdefed" startline="409" endline="415">
{
    if (nr_map < 2)
        return -1;
    return __append_e820_map (biosmap, nr_map);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/e820.c.ifdefed" startline="420" endline="456">
{
    int i;
    u64 real_updated_size = 0;
    BUG_ON (old_type == new_type);
    if (size > (ULLONG_MAX - start))
        size = ULLONG_MAX - start;
    for (i = 0; i < e820.nr_map; i++) {
        struct e820entry *ei = &e820x->map[i];
        u64 final_start, final_end;
        if (ei->type != old_type)
            continue;
        if (ei->addr >= start && (ei->addr + ei->size) <= (start + size)) {
            ei->type = new_type;
            real_updated_size += ei->size;
            continue;
        }
        final_start = max (start, ei->addr);
        final_end = min (start +size, ei->addr + ei->size);
        if (final_start >= final_end)
            continue;
        e820_add_region (final_start, final_end - final_start, new_type);
        real_updated_size += final_end - final_start;
        ei->size -= final_end - final_start;
        if (ei->addr < final_start)
            continue;
        ei->addr = final_end;
    }
    return real_updated_size;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/e820.c.ifdefed" startline="429" endline="454">
{
    struct e820entry *ei = &e820x->map[i];
    u64 final_start, final_end;
    if (ei->type != old_type)
        continue;
    if (ei->addr >= start && (ei->addr + ei->size) <= (start + size)) {
        ei->type = new_type;
        real_updated_size += ei->size;
        continue;
    }
    final_start = max (start, ei->addr);
    final_end = min (start +size, ei->addr + ei->size);
    if (final_start >= final_end)
        continue;
    e820_add_region (final_start, final_end - final_start, new_type);
    real_updated_size += final_end - final_start;
    ei->size -= final_end - final_start;
    if (ei->addr < final_start)
        continue;
    ei->addr = final_end;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/e820.c.ifdefed" startline="436" endline="440">
{
    ei->type = new_type;
    real_updated_size += ei->size;
    continue;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/e820.c.ifdefed" startline="460" endline="462">
{
    return e820_update_range_map (&e820, start, size, old_type, new_type);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/e820.c.ifdefed" startline="466" endline="469">
{
    return e820_update_range_map (&e820_saved, start, size, old_type, new_type);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/e820.c.ifdefed" startline="474" endline="507">
{
    int i;
    u64 real_removed_size = 0;
    if (size > (ULLONG_MAX - start))
        size = ULLONG_MAX - start;
    for (i = 0; i < e820.nr_map; i++) {
        struct e820entry *ei = &e820.map[i];
        u64 final_start, final_end;
        if (checktype && ei->type != old_type)
            continue;
        if (ei->addr >= start && (ei->addr + ei->size) <= (start + size)) {
            real_removed_size += ei->size;
            memset (ei, 0, sizeof (struct e820entry));
            continue;
        }
        final_start = max (start, ei->addr);
        final_end = min (start +size, ei->addr + ei->size);
        if (final_start >= final_end)
            continue;
        real_removed_size += final_end - final_start;
        ei->size -= final_end - final_start;
        if (ei->addr < final_start)
            continue;
        ei->addr = final_end;
    }
    return real_removed_size;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/e820.c.ifdefed" startline="481" endline="505">
{
    struct e820entry *ei = &e820.map[i];
    u64 final_start, final_end;
    if (checktype && ei->type != old_type)
        continue;
    if (ei->addr >= start && (ei->addr + ei->size) <= (start + size)) {
        real_removed_size += ei->size;
        memset (ei, 0, sizeof (struct e820entry));
        continue;
    }
    final_start = max (start, ei->addr);
    final_end = min (start +size, ei->addr + ei->size);
    if (final_start >= final_end)
        continue;
    real_removed_size += final_end - final_start;
    ei->size -= final_end - final_start;
    if (ei->addr < final_start)
        continue;
    ei->addr = final_end;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/e820.c.ifdefed" startline="489" endline="493">
{
    real_removed_size += ei->size;
    memset (ei, 0, sizeof (struct e820entry));
    continue;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/e820.c.ifdefed" startline="510" endline="519">
{
    int nr_map;
    nr_map = e820.nr_map;
    if (sanitize_e820_map (e820.map, ARRAY_SIZE (e820.map), &nr_map))
        return;
    e820.nr_map = nr_map;
    printk (KERN_INFO "modified physical RAM map:\n");
    e820_print_map ("modified");
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/e820.c.ifdefed" startline="521" endline="528">
{
    int nr_map;
    nr_map = e820_saved.nr_map;
    if (sanitize_e820_map (e820_saved.map, ARRAY_SIZE (e820_saved.map), &nr_map))
        return;
    e820_saved.nr_map = nr_map;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/e820.c.ifdefed" startline="535" endline="566">
{
    unsigned long long last;
    int i = e820.nr_map;
    int found = 0;
    last = (end_addr && end_addr < MAX_GAP_END) ? end_addr : MAX_GAP_END;
    while (--i >= 0) {
        unsigned long long start = e820.map[i].addr;
        unsigned long long end = start + e820.map[i].size;
        if (end < start_addr)
            continue;
        if (last > end) {
            unsigned long gap = last - end;
            if (gap >= *gapsize) {
                *gapsize = gap;
                *gapstart = end;
                found = 1;
            }
        }
        if (start < last)
            last = start;
    }
    return found;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/e820.c.ifdefed" startline="542" endline="564">
{
    unsigned long long start = e820.map[i].addr;
    unsigned long long end = start + e820.map[i].size;
    if (end < start_addr)
        continue;
    if (last > end) {
        unsigned long gap = last - end;
        if (gap >= *gapsize) {
            *gapsize = gap;
            *gapstart = end;
            found = 1;
        }
    }
    if (start < last)
        last = start;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/e820.c.ifdefed" startline="553" endline="561">
{
    unsigned long gap = last - end;
    if (gap >= *gapsize) {
        *gapsize = gap;
        *gapstart = end;
        found = 1;
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/e820.c.ifdefed" startline="556" endline="560">
{
    *gapsize = gap;
    *gapstart = end;
    found = 1;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/e820.c.ifdefed" startline="575" endline="606">
{
    unsigned long gapstart, gapsize, round;
    int found;
    gapstart = 0x10000000;
    gapsize = 0x400000;
    found = e820_search_gap (&gapstart, &gapsize, 0, MAX_GAP_END);
    round = 0x100000;
    while ((gapsize >> 4) > round)
        round += round;
    pci_mem_start = (gapstart + round) & -round;
    printk (KERN_INFO "Allocating PCI resources starting at %lx (gap: %lx:%lx)\n", pci_mem_start, gapstart, gapsize);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/e820.c.ifdefed" startline="615" endline="631">
{
    u32 map_len;
    int entries;
    struct e820entry *extmap;
    entries = sdata->len / sizeof (struct e820entry);
    map_len = sdata->len + sizeof (struct setup_data);
    if (map_len > PAGE_SIZE)
        sdata = early_ioremap (pa_data, map_len);
    extmap = (struct e820entry *) (sdata->data);
    __append_e820_map (extmap, entries);
    sanitize_e820_map (e820.map, ARRAY_SIZE (e820.map), & e820.nr_map);
    if (map_len > PAGE_SIZE)
        early_iounmap (sdata, map_len);
    printk (KERN_INFO "extended physical RAM map:\n");
    e820_print_map ("extended");
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/e820.c.ifdefed" startline="697" endline="708">
{
    int i;
    struct early_res *r;
    for (i = 0; i < MAX_EARLY_RES && early_res[i].end; i++) {
        r = &early_res[i];
        if (end > r->start && start < r->end)
            break;
    }
    return i;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/e820.c.ifdefed" startline="701" endline="705">
{
    r = &early_res[i];
    if (end > r->start && start < r->end)
        break;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/e820.c.ifdefed" startline="716" endline="726">
{
    int j;
    for (j = i + 1; j < MAX_EARLY_RES && early_res[j].end; j++)
        ;
    memmove (& early_res [i], & early_res [i + 1], (j - 1 - i) * sizeof (struct early_res));
    early_res[j - 1].end = 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/e820.c.ifdefed" startline="739" endline="793">
{
    int i;
    struct early_res *r;
    u64 lower_start, lower_end;
    u64 upper_start, upper_end;
    char name [16];
    for (i = 0; i < MAX_EARLY_RES && early_res[i].end; i++) {
        r = &early_res[i];
        if (end <= r->start || start >= r->end)
            continue;
        if (!r->overlap_ok)
            return;
        strncpy (name, r -> name, sizeof (name) - 1);
        lower_start = lower_end = 0;
        upper_start = upper_end = 0;
        if (r->start < start) {
            lower_start = r->start;
            lower_end = start;
        }
        if (r->end > end) {
            upper_start = end;
            upper_end = r->end;
        }
        drop_range (i);
        i--;
        if (lower_end)
            reserve_early_overlap_ok (lower_start, lower_end, name);
        if (upper_end)
            reserve_early_overlap_ok (upper_start, upper_end, name);
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/e820.c.ifdefed" startline="746" endline="792">
{
    r = &early_res[i];
    if (end <= r->start || start >= r->end)
        continue;
    if (!r->overlap_ok)
        return;
    strncpy (name, r -> name, sizeof (name) - 1);
    lower_start = lower_end = 0;
    upper_start = upper_end = 0;
    if (r->start < start) {
        lower_start = r->start;
        lower_end = start;
    }
    if (r->end > end) {
        upper_start = end;
        upper_end = r->end;
    }
    drop_range (i);
    i--;
    if (lower_end)
        reserve_early_overlap_ok (lower_start, lower_end, name);
    if (upper_end)
        reserve_early_overlap_ok (upper_start, upper_end, name);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/e820.c.ifdefed" startline="773" endline="776">
{
    lower_start = r->start;
    lower_end = start;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/e820.c.ifdefed" startline="777" endline="780">
{
    upper_start = end;
    upper_end = r->end;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/e820.c.ifdefed" startline="797" endline="815">
{
    int i;
    struct early_res *r;
    i = find_overlapped_early (start, end);
    if (i >= MAX_EARLY_RES)
        panic ("Too many early reservations");
    r = &early_res[i];
    if (r->end)
        panic ("Overlapping early reservations " "%llx-%llx %s to %llx-%llx %s\n", start, end -1, name ? name : "", r->start, r->end - 1, r->name);
    r->start = start;
    r->end = end;
    r->overlap_ok = overlap_ok;
    if (name)
        strncpy (r->name, name, sizeof (r->name) - 1);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/e820.c.ifdefed" startline="838" endline="841">
{
    drop_overlaps_that_are_ok (start, end);
    __reserve_early (start, end, name, 1);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/e820.c.ifdefed" startline="852" endline="855">
{
    drop_overlaps_that_are_ok (start, end);
    __reserve_early (start, end, name, 0);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/e820.c.ifdefed" startline="858" endline="869">
{
    struct early_res *r;
    int i;
    i = find_overlapped_early (start, end);
    r = &early_res[i];
    if (i >= MAX_EARLY_RES || r->end != end || r->start != start)
        panic ("free_early on not reserved area: %llx-%llx!", start, end -1);
    drop_range (i);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/e820.c.ifdefed" startline="872" endline="897">
{
    int i, count;
    u64 final_start, final_end;
    count = 0;
    for (i = 0; i < MAX_EARLY_RES && early_res[i].end; i++)
        count++;
    printk (KERN_INFO "(%d early reservations) ==> bootmem [%010llx - %010llx]\n", count, start, end);
    for (i = 0; i < count; i++) {
        struct early_res *r = &early_res[i];
        printk (KERN_INFO "  #%d [%010llx - %010llx] %16s", i, r -> start, r -> end, r -> name);
        final_start = max (start, r->start);
        final_end = min (end, r->end);
        if (final_start >= final_end) {
            printk (KERN_CONT "\n");
            continue;
        }
        printk (KERN_CONT " ==> [%010llx - %010llx]\n", final_start, final_end);
        reserve_bootmem_generic (final_start, final_end - final_start, BOOTMEM_DEFAULT);
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/e820.c.ifdefed" startline="882" endline="896">
{
    struct early_res *r = &early_res[i];
    printk (KERN_INFO "  #%d [%010llx - %010llx] %16s", i, r -> start, r -> end, r -> name);
    final_start = max (start, r->start);
    final_end = min (end, r->end);
    if (final_start >= final_end) {
        printk (KERN_CONT "\n");
        continue;
    }
    printk (KERN_CONT " ==> [%010llx - %010llx]\n", final_start, final_end);
    reserve_bootmem_generic (final_start, final_end - final_start, BOOTMEM_DEFAULT);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/e820.c.ifdefed" startline="888" endline="891">
{
    printk (KERN_CONT "\n");
    continue;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/e820.c.ifdefed" startline="901" endline="915">
{
    int i;
    u64 addr = *addrp;
    int changed = 0;
    struct early_res *r;
again :
    i = find_overlapped_early (addr, addr +size);
    r = &early_res[i];
    if (i < MAX_EARLY_RES && r->end) {
        *addrp = addr = round_up (r->end, align);
        changed = 1;
        goto again;
    }
    return changed;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/e820.c.ifdefed" startline="909" endline="913">
{
    *addrp = addr = round_up (r->end, align);
    changed = 1;
    goto again;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/e820.c.ifdefed" startline="919" endline="949">
{
    int i;
    u64 addr = *addrp, last;
    u64 size = *sizep;
    int changed = 0;
again :
    last = addr + size;
    for (i = 0; i < MAX_EARLY_RES && early_res[i].end; i++) {
        struct early_res *r = &early_res[i];
        if (last > r->start && addr < r->start) {
            size = r->start - addr;
            changed = 1;
            goto again;
        }
        if (last > r->end && addr < r->end) {
            addr = round_up (r->end, align);
            size = last - addr;
            changed = 1;
            goto again;
        }
        if (last <= r->end && addr >= r->start) {
            (*sizep)++;
            return 0;
        }
    }
    if (changed) {
        *addrp = addr;
        *sizep = size;
    }
    return changed;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/e820.c.ifdefed" startline="926" endline="943">
{
    struct early_res *r = &early_res[i];
    if (last > r->start && addr < r->start) {
        size = r->start - addr;
        changed = 1;
        goto again;
    }
    if (last > r->end && addr < r->end) {
        addr = round_up (r->end, align);
        size = last - addr;
        changed = 1;
        goto again;
    }
    if (last <= r->end && addr >= r->start) {
        (*sizep)++;
        return 0;
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/e820.c.ifdefed" startline="928" endline="932">
{
    size = r->start - addr;
    changed = 1;
    goto again;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/e820.c.ifdefed" startline="933" endline="938">
{
    addr = round_up (r->end, align);
    size = last - addr;
    changed = 1;
    goto again;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/e820.c.ifdefed" startline="939" endline="942">
{
    (*sizep)++;
    return 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/e820.c.ifdefed" startline="944" endline="947">
{
    *addrp = addr;
    *sizep = size;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/e820.c.ifdefed" startline="955" endline="981">
{
    int i;
    for (i = 0; i < e820.nr_map; i++) {
        struct e820entry *ei = &e820.map[i];
        u64 addr, last;
        u64 ei_last;
        if (ei->type != E820_RAM)
            continue;
        addr = round_up (ei->addr, align);
        ei_last = ei->addr + ei->size;
        if (addr < start)
            addr = round_up (start, align);
        if (addr >= ei_last)
            continue;
        while (bad_addr (&addr, size, align) && addr + size <= ei_last)
            ;
        last = addr + size;
        if (last > ei_last)
            continue;
        if (last > end)
            continue;
        return addr;
    }
    return -1ULL;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/e820.c.ifdefed" startline="958" endline="979">
{
    struct e820entry *ei = &e820.map[i];
    u64 addr, last;
    u64 ei_last;
    if (ei->type != E820_RAM)
        continue;
    addr = round_up (ei->addr, align);
    ei_last = ei->addr + ei->size;
    if (addr < start)
        addr = round_up (start, align);
    if (addr >= ei_last)
        continue;
    while (bad_addr (&addr, size, align) && addr + size <= ei_last)
        ;
    last = addr + size;
    if (last > ei_last)
        continue;
    if (last > end)
        continue;
    return addr;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/e820.c.ifdefed" startline="987" endline="1014">
{
    int i;
    for (i = 0; i < e820.nr_map; i++) {
        struct e820entry *ei = &e820.map[i];
        u64 addr, last;
        u64 ei_last;
        if (ei->type != E820_RAM)
            continue;
        addr = round_up (ei->addr, align);
        ei_last = ei->addr + ei->size;
        if (addr < start)
            addr = round_up (start, align);
        if (addr >= ei_last)
            continue;
        *sizep = ei_last - addr;
        while (bad_addr_size (&addr, sizep, align) && addr + *sizep <= ei_last)
            ;
        last = addr + *sizep;
        if (last > ei_last)
            continue;
        return addr;
    }
    return -1UL;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/e820.c.ifdefed" startline="990" endline="1011">
{
    struct e820entry *ei = &e820.map[i];
    u64 addr, last;
    u64 ei_last;
    if (ei->type != E820_RAM)
        continue;
    addr = round_up (ei->addr, align);
    ei_last = ei->addr + ei->size;
    if (addr < start)
        addr = round_up (start, align);
    if (addr >= ei_last)
        continue;
    *sizep = ei_last - addr;
    while (bad_addr_size (&addr, sizep, align) && addr + *sizep <= ei_last)
        ;
    last = addr + *sizep;
    if (last > ei_last)
        continue;
    return addr;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/e820.c.ifdefed" startline="1020" endline="1040">
{
    u64 size = 0;
    u64 addr;
    u64 start;
    start = startt;
    while (size < sizet)
        start = find_e820_area_size (start, &size, align);
    if (size < sizet)
        return 0;
    addr = round_down (start +size - sizet, align);
    e820_update_range (addr, sizet, E820_RAM, E820_RESERVED);
    e820_update_range_saved (addr, sizet, E820_RAM, E820_RESERVED);
    printk (KERN_INFO "update e820 for early_reserve_e820\n");
    update_e820 ();
    update_e820_saved ();
    return addr;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/e820.c.ifdefed" startline="1056" endline="1088">
{
    int i;
    unsigned long last_pfn = 0;
    unsigned long max_arch_pfn = MAX_ARCH_PFN;
    for (i = 0; i < e820.nr_map; i++) {
        struct e820entry *ei = &e820.map[i];
        unsigned long start_pfn;
        unsigned long end_pfn;
        if (ei->type != type)
            continue;
        start_pfn = ei->addr >> PAGE_SHIFT;
        end_pfn = (ei->addr + ei->size) >> PAGE_SHIFT;
        if (start_pfn >= limit_pfn)
            continue;
        if (end_pfn > limit_pfn) {
            last_pfn = limit_pfn;
            break;
        }
        if (end_pfn > last_pfn)
            last_pfn = end_pfn;
    }
    if (last_pfn > max_arch_pfn)
        last_pfn = max_arch_pfn;
    printk (KERN_INFO "last_pfn = %#lx max_arch_pfn = %#lx\n", last_pfn, max_arch_pfn);
    return last_pfn;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/e820.c.ifdefed" startline="1061" endline="1080">
{
    struct e820entry *ei = &e820.map[i];
    unsigned long start_pfn;
    unsigned long end_pfn;
    if (ei->type != type)
        continue;
    start_pfn = ei->addr >> PAGE_SHIFT;
    end_pfn = (ei->addr + ei->size) >> PAGE_SHIFT;
    if (start_pfn >= limit_pfn)
        continue;
    if (end_pfn > limit_pfn) {
        last_pfn = limit_pfn;
        break;
    }
    if (end_pfn > last_pfn)
        last_pfn = end_pfn;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/e820.c.ifdefed" startline="1074" endline="1077">
{
    last_pfn = limit_pfn;
    break;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/e820.c.ifdefed" startline="1090" endline="1092">
{
    return e820_end_pfn (MAX_ARCH_PFN, E820_RAM);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/e820.c.ifdefed" startline="1095" endline="1097">
{
    return e820_end_pfn (1UL << (32 - PAGE_SHIFT), E820_RAM);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/e820.c.ifdefed" startline="1107" endline="1129">
{
    u64 align = PAGE_SIZE;
    *ei_startpfn = round_up (ei->addr, align) >> PAGE_SHIFT;
    *ei_endpfn = round_down (ei->addr + ei->size, align) >> PAGE_SHIFT;
    if (*ei_startpfn >= *ei_endpfn)
        return 0;
    if (ei->type != E820_RAM || *ei_endpfn <= start_pfn || *ei_startpfn >= last_pfn)
        return 0;
    if (*ei_startpfn < start_pfn)
        *ei_startpfn = start_pfn;
    if (*ei_endpfn > last_pfn)
        *ei_endpfn = last_pfn;
    return 1;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/e820.c.ifdefed" startline="1134" endline="1144">
{
    unsigned long ei_startpfn;
    unsigned long ei_endpfn;
    int i;
    for (i = 0; i < e820.nr_map; i++)
        if (e820_find_active_region (&e820.map[i], start_pfn, last_pfn, &ei_startpfn, &ei_endpfn))
            add_active_range (nid, ei_startpfn, ei_endpfn);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/e820.c.ifdefed" startline="1152" endline="1165">
{
    unsigned long start_pfn = start >> PAGE_SHIFT;
    unsigned long last_pfn = end >> PAGE_SHIFT;
    unsigned long ei_startpfn, ei_endpfn, ram = 0;
    int i;
    for (i = 0; i < e820.nr_map; i++) {
        if (e820_find_active_region (&e820.map[i], start_pfn, last_pfn, &ei_startpfn, &ei_endpfn))
            ram += ei_endpfn - ei_startpfn;
    }
    return end - start - ((u64) ram << PAGE_SHIFT);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/e820.c.ifdefed" startline="1158" endline="1163">
{
    if (e820_find_active_region (&e820.map[i], start_pfn, last_pfn, &ei_startpfn, &ei_endpfn))
        ram += ei_endpfn - ei_startpfn;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/e820.c.ifdefed" startline="1168" endline="1171">
{
    early_printk (msg);
    panic (msg);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/e820.c.ifdefed" startline="1177" endline="1195">
{
    u64 mem_size;
    if (!p)
        return -EINVAL;
    userdef = 1;
    mem_size = memparse (p, &p);
    e820_remove_range (mem_size, ULLONG_MAX - mem_size, E820_RAM, 1);
    return 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/e820.c.ifdefed" startline="1199" endline="1239">
{
    char *oldp;
    u64 start_at, mem_size;
    if (!p)
        return -EINVAL;
    if (!strncmp (p, "exactmap", 8)) {
        e820.nr_map = 0;
        userdef = 1;
        return 0;
    }
    oldp = p;
    mem_size = memparse (p, &p);
    if (p == oldp)
        return -EINVAL;
    userdef = 1;
    if (*p == '@') {
        start_at = memparse (p +1, &p);
        e820_add_region (start_at, mem_size, E820_RAM);
    }
    else if (*p == '#') {
        start_at = memparse (p +1, &p);
        e820_add_region (start_at, mem_size, E820_ACPI);
    }
    else if (*p == '$') {
        start_at = memparse (p +1, &p);
        e820_add_region (start_at, mem_size, E820_RESERVED);
    }
    else
        e820_remove_range (mem_size, ULLONG_MAX -mem_size, E820_RAM, 1);
    return *p == '\0' ? 0 : -EINVAL;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/e820.c.ifdefed" startline="1206" endline="1218">
{
    e820.nr_map = 0;
    userdef = 1;
    return 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/e820.c.ifdefed" startline="1226" endline="1229">
{
    start_at = memparse (p +1, &p);
    e820_add_region (start_at, mem_size, E820_RAM);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/e820.c.ifdefed" startline="1229" endline="1232">
{
    start_at = memparse (p +1, &p);
    e820_add_region (start_at, mem_size, E820_ACPI);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/e820.c.ifdefed" startline="1232" endline="1235">
{
    start_at = memparse (p +1, &p);
    e820_add_region (start_at, mem_size, E820_RESERVED);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/e820.c.ifdefed" startline="1243" endline="1254">
{
    if (userdef) {
        int nr = e820.nr_map;
        if (sanitize_e820_map (e820.map, ARRAY_SIZE (e820.map), &nr) < 0)
            early_panic ("Invalid user supplied memory map");
        e820.nr_map = nr;
        printk (KERN_INFO "user-defined physical RAM map:\n");
        e820_print_map ("user");
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/e820.c.ifdefed" startline="1244" endline="1253">
{
    int nr = e820.nr_map;
    if (sanitize_e820_map (e820.map, ARRAY_SIZE (e820.map), &nr) < 0)
        early_panic ("Invalid user supplied memory map");
    e820.nr_map = nr;
    printk (KERN_INFO "user-defined physical RAM map:\n");
    e820_print_map ("user");
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/e820.c.ifdefed" startline="1257" endline="1265">
{
    switch (e820_type) {
    case E820_RESERVED_KERN :
    case E820_RAM :
        return "System RAM";
    case E820_ACPI :
        return "ACPI Tables";
    case E820_NVS :
        return "ACPI Non-volatile Storage";
    default :
        return "reserved";
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/e820.c.ifdefed" startline="1258" endline="1264">
{
case E820_RESERVED_KERN :
case E820_RAM :
    return "System RAM";
case E820_ACPI :
    return "ACPI Tables";
case E820_NVS :
    return "ACPI Non-volatile Storage";
default :
    return "reserved";
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/e820.c.ifdefed" startline="1271" endline="1300">
{
    int i;
    struct resource *res;
    u64 end;
    res = alloc_bootmem_low (sizeof (struct resource) * e820.nr_map);
    for (i = 0; i < e820.nr_map; i++) {
        end = e820.map[i].addr + e820.map[i].size - 1;
        if (end > 0x100000000ULL) {
            res++;
            continue;
        }
        res->name = e820_type_to_string (e820.map[i].type);
        res->start = e820.map[i].addr;
        res->end = end;
        res->flags = IORESOURCE_MEM | IORESOURCE_BUSY;
        insert_resource (& iomem_resource, res);
        res++;
    }
    for (i = 0; i < e820_saved.nr_map; i++) {
        struct e820entry *entry = &e820_saved.map[i];
        firmware_map_add_early (entry -> addr, entry -> addr + entry -> size - 1, e820_type_to_string (entry -> type));
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/e820.c.ifdefed" startline="1277" endline="1292">
{
    end = e820.map[i].addr + e820.map[i].size - 1;
    if (end > 0x100000000ULL) {
        res++;
        continue;
    }
    res->name = e820_type_to_string (e820.map[i].type);
    res->start = e820.map[i].addr;
    res->end = end;
    res->flags = IORESOURCE_MEM | IORESOURCE_BUSY;
    insert_resource (& iomem_resource, res);
    res++;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/e820.c.ifdefed" startline="1280" endline="1283">
{
    res++;
    continue;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/e820.c.ifdefed" startline="1294" endline="1299">
{
    struct e820entry *entry = &e820_saved.map[i];
    firmware_map_add_early (entry -> addr, entry -> addr + entry -> size - 1, e820_type_to_string (entry -> type));
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/e820.c.ifdefed" startline="1303" endline="1338">
{
    char *who = "BIOS-e820";
    int new_nr;
    new_nr = boot_params.e820_entries;
    sanitize_e820_map (boot_params.e820_map, ARRAY_SIZE (boot_params.e820_map), & new_nr);
    boot_params.e820_entries = new_nr;
    if (append_e820_map (boot_params.e820_map, boot_params.e820_entries) < 0) {
        u64 mem_size;
        if (boot_params.alt_mem_k < boot_params.screen_info.ext_mem_k) {
            mem_size = boot_params.screen_info.ext_mem_k;
            who = "BIOS-88";
        }
        else {
            mem_size = boot_params.alt_mem_k;
            who = "BIOS-e801";
        }
        e820.nr_map = 0;
        e820_add_region (0, LOWMEMSIZE (), E820_RAM);
        e820_add_region (HIGH_MEMORY, mem_size << 10, E820_RAM);
    }
    return who;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/e820.c.ifdefed" startline="1318" endline="1334">
{
    u64 mem_size;
    if (boot_params.alt_mem_k < boot_params.screen_info.ext_mem_k) {
        mem_size = boot_params.screen_info.ext_mem_k;
        who = "BIOS-88";
    }
    else {
        mem_size = boot_params.alt_mem_k;
        who = "BIOS-e801";
    }
    e820.nr_map = 0;
    e820_add_region (0, LOWMEMSIZE (), E820_RAM);
    e820_add_region (HIGH_MEMORY, mem_size << 10, E820_RAM);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/e820.c.ifdefed" startline="1323" endline="1326">
{
    mem_size = boot_params.screen_info.ext_mem_k;
    who = "BIOS-88";
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/e820.c.ifdefed" startline="1326" endline="1329">
{
    mem_size = boot_params.alt_mem_k;
    who = "BIOS-e801";
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/e820.c.ifdefed" startline="1341" endline="1349">
{
    if (x86_quirks->arch_memory_setup) {
        char *who = x86_quirks->arch_memory_setup ();
        if (who)
            return who;
    }
    return default_machine_specific_memory_setup ();
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/e820.c.ifdefed" startline="1342" endline="1347">
{
    char *who = x86_quirks->arch_memory_setup ();
    if (who)
        return who;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/e820.c.ifdefed" startline="1353" endline="1355">
{
    return machine_specific_memory_setup ();
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/e820.c.ifdefed" startline="1358" endline="1365">
{
    char *who;
    who = memory_setup ();
    memcpy (& e820_saved, & e820, sizeof (struct e820map));
    printk (KERN_INFO "BIOS-provided physical RAM map:\n");
    e820_print_map (who);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/k8.c.ifdefed" startline="29" endline="36">
{
    do {
        dev = pci_get_device (PCI_ANY_ID, PCI_ANY_ID, dev);
        if (!dev)
            break;
    }
    while (!pci_match_id (&k8_nb_ids[0], dev));
    return dev;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/k8.c.ifdefed" startline="30" endline="34">
{
    dev = pci_get_device (PCI_ANY_ID, PCI_ANY_ID, dev);
    if (!dev)
        break;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/k8.c.ifdefed" startline="39" endline="74">
{
    int i;
    struct pci_dev *dev;
    if (num_k8_northbridges)
        return 0;
    dev = NULL;
    while ((dev = next_k8_northbridge (dev)) != NULL)
        num_k8_northbridges++;
    k8_northbridges = kmalloc ((num_k8_northbridges + 1) * sizeof (void *), GFP_KERNEL);
    if (!k8_northbridges)
        return -ENOMEM;
    if (!num_k8_northbridges) {
        k8_northbridges[0] = NULL;
        return 0;
    }
    flush_words = kmalloc (num_k8_northbridges * sizeof (u32), GFP_KERNEL);
    if (!flush_words) {
        kfree (k8_northbridges);
        return -ENOMEM;
    }
    dev = NULL;
    i = 0;
    while ((dev = next_k8_northbridge (dev)) != NULL) {
        k8_northbridges[i] = dev;
        pci_read_config_dword (dev, 0x9c, & flush_words [i ++]);
    }
    k8_northbridges[i] = NULL;
    return 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/k8.c.ifdefed" startline="55" endline="58">
{
    k8_northbridges[0] = NULL;
    return 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/k8.c.ifdefed" startline="61" endline="64">
{
    kfree (k8_northbridges);
    return -ENOMEM;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/k8.c.ifdefed" startline="68" endline="71">
{
    k8_northbridges[i] = dev;
    pci_read_config_dword (dev, 0x9c, & flush_words [i ++]);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/k8.c.ifdefed" startline="80" endline="88">
{
    struct pci_device_id *id;
    u32 vendor = device & 0xffff;
    device >>= 16;
    for (id = k8_nb_ids; id->vendor; id++)
        if (vendor == id->vendor && device == id->device)
            return 1;
    return 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/k8.c.ifdefed" startline="91" endline="121">
{
    int flushed, i;
    unsigned long flags;
    static DEFINE_SPINLOCK (gart_lock);
    spin_lock_irqsave (& gart_lock, flags);
    flushed = 0;
    for (i = 0; i < num_k8_northbridges; i++) {
        pci_write_config_dword (k8_northbridges [i], 0x9c, flush_words [i] | 1);
        flushed++;
    }
    for (i = 0; i < num_k8_northbridges; i++) {
        u32 w;
        for (;;) {
            pci_read_config_dword (k8_northbridges [i], 0x9c, & w);
            if (!(w & 1))
                break;
            cpu_relax ();
        }
    }
    spin_unlock_irqrestore (& gart_lock, flags);
    if (!flushed)
        printk ("nothing to flush?\n");
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/k8.c.ifdefed" startline="102" endline="106">
{
    pci_write_config_dword (k8_northbridges [i], 0x9c, flush_words [i] | 1);
    flushed++;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/k8.c.ifdefed" startline="107" endline="117">
{
    u32 w;
    for (;;) {
        pci_read_config_dword (k8_northbridges [i], 0x9c, & w);
        if (!(w & 1))
            break;
        cpu_relax ();
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/k8.c.ifdefed" startline="110" endline="116">
{
    pci_read_config_dword (k8_northbridges [i], 0x9c, & w);
    if (!(w & 1))
        break;
    cpu_relax ();
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/irqinit_64.c.ifdefed" startline="139" endline="163">
{
    int i;
    init_bsp_APIC ();
    init_8259A (0);
    for (i = 0; i < NR_IRQS; i++) {
        irq_desc[i].status = IRQ_DISABLED;
        irq_desc[i].action = NULL;
        irq_desc[i].depth = 1;
        if (i < 16) {
            set_irq_chip_and_handler_name (i, & i8259A_chip, handle_level_irq, "XT");
        }
        else {
            irq_desc[i].chip = &no_irq_chip;
        }
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/irqinit_64.c.ifdefed" startline="145" endline="162">
{
    irq_desc[i].status = IRQ_DISABLED;
    irq_desc[i].action = NULL;
    irq_desc[i].depth = 1;
    if (i < 16) {
        set_irq_chip_and_handler_name (i, & i8259A_chip, handle_level_irq, "XT");
    }
    else {
        irq_desc[i].chip = &no_irq_chip;
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/irqinit_64.c.ifdefed" startline="150" endline="156">
{
    set_irq_chip_and_handler_name (i, & i8259A_chip, handle_level_irq, "XT");
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/irqinit_64.c.ifdefed" startline="156" endline="161">
{
    irq_desc[i].chip = &no_irq_chip;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/irqinit_64.c.ifdefed" startline="168" endline="222">
{
    int i;
    init_ISA_irqs ();
    for (i = 0; i < (NR_VECTORS - FIRST_EXTERNAL_VECTOR); i++) {
        int vector = FIRST_EXTERNAL_VECTOR + i;
        if (vector != IA32_SYSCALL_VECTOR)
            set_intr_gate (vector, interrupt[i]);
    }
    alloc_intr_gate (THERMAL_APIC_VECTOR, thermal_interrupt);
    alloc_intr_gate (THRESHOLD_APIC_VECTOR, threshold_interrupt);
    alloc_intr_gate (LOCAL_TIMER_VECTOR, apic_timer_interrupt);
    alloc_intr_gate (SPURIOUS_APIC_VECTOR, spurious_interrupt);
    alloc_intr_gate (ERROR_APIC_VECTOR, error_interrupt);
    if (!acpi_ioapic)
        setup_irq (2, &irq2);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/irqinit_64.c.ifdefed" startline="177" endline="181">
{
    int vector = FIRST_EXTERNAL_VECTOR + i;
    if (vector != IA32_SYSCALL_VECTOR)
        set_intr_gate (vector, interrupt[i]);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/process.c.ifdefed" startline="21" endline="32">
{
    *dst = *src;
    if (src->thread.xstate) {
        dst->thread.xstate = kmem_cache_alloc (task_xstate_cachep, GFP_KERNEL);
        if (!dst->thread.xstate)
            return -ENOMEM;
        WARN_ON ((unsigned long) dst -> thread.xstate & 15);
        memcpy (dst -> thread.xstate, src -> thread.xstate, xstate_size);
    }
    return 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/process.c.ifdefed" startline="23" endline="30">
{
    dst->thread.xstate = kmem_cache_alloc (task_xstate_cachep, GFP_KERNEL);
    if (!dst->thread.xstate)
        return -ENOMEM;
    WARN_ON ((unsigned long) dst -> thread.xstate & 15);
    memcpy (dst -> thread.xstate, src -> thread.xstate, xstate_size);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/process.c.ifdefed" startline="35" endline="40">
{
    if (tsk->thread.xstate) {
        kmem_cache_free (task_xstate_cachep, tsk -> thread.xstate);
        tsk->thread.xstate = NULL;
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/process.c.ifdefed" startline="36" endline="39">
{
    kmem_cache_free (task_xstate_cachep, tsk -> thread.xstate);
    tsk->thread.xstate = NULL;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/process.c.ifdefed" startline="43" endline="46">
{
    free_thread_xstate (ti -> task);
    free_pages ((unsigned long) ti, get_order (THREAD_SIZE));
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/process.c.ifdefed" startline="49" endline="54">
{
    task_xstate_cachep = kmem_cache_create ("task_xstate", xstate_size, __alignof__ (union thread_xstate), SLAB_PANIC, NULL);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/process.c.ifdefed" startline="92" endline="94">
{
    return 1;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/process.c.ifdefed" startline="102" endline="121">
{
    if (hlt_use_halt ()) {
        current_thread_info ()->status &= ~TS_POLLING;
        smp_mb ();
        if (!need_resched ())
            safe_halt ();
        else
            local_irq_enable ();
        current_thread_info ()->status |= TS_POLLING;
    }
    else {
        local_irq_enable ();
        cpu_relax ();
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/process.c.ifdefed" startline="103" endline="116">
{
    current_thread_info ()->status &= ~TS_POLLING;
    smp_mb ();
    if (!need_resched ())
        safe_halt ();
    else
        local_irq_enable ();
    current_thread_info ()->status |= TS_POLLING;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/process.c.ifdefed" startline="116" endline="120">
{
    local_irq_enable ();
    cpu_relax ();
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/process.c.ifdefed" startline="127" endline="128">
{
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/process.c.ifdefed" startline="139" endline="143">
{
    smp_mb ();
    smp_call_function (do_nothing, NULL, 1);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/process.c.ifdefed" startline="157" endline="164">
{
    if (!need_resched ()) {
        __monitor ((void *) & current_thread_info () -> flags, 0, 0);
        smp_mb ();
        if (!need_resched ())
            __mwait (ax, cx);
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/process.c.ifdefed" startline="158" endline="163">
{
    __monitor ((void *) & current_thread_info () -> flags, 0, 0);
    smp_mb ();
    if (!need_resched ())
        __mwait (ax, cx);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/process.c.ifdefed" startline="168" endline="178">
{
    if (!need_resched ()) {
        __monitor ((void *) & current_thread_info () -> flags, 0, 0);
        smp_mb ();
        if (!need_resched ())
            __sti_mwait (0, 0);
        else
            local_irq_enable ();
    }
    else
        local_irq_enable ();
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/process.c.ifdefed" startline="169" endline="176">
{
    __monitor ((void *) & current_thread_info () -> flags, 0, 0);
    smp_mb ();
    if (!need_resched ())
        __sti_mwait (0, 0);
    else
        local_irq_enable ();
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/process.c.ifdefed" startline="186" endline="189">
{
    local_irq_enable ();
    cpu_relax ();
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/process.c.ifdefed" startline="210" endline="229">
{
    u32 eax, ebx, ecx, edx;
    if (force_mwait)
        return 1;
    if (c->cpuid_level < MWAIT_INFO)
        return 0;
    cpuid (MWAIT_INFO, & eax, & ebx, & ecx, & edx);
    if (!(ecx & MWAIT_ECX_EXTENDED_INFO))
        return 1;
    return (edx & MWAIT_EDX_C1);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/process.c.ifdefed" startline="235" endline="247">
{
    if (c->x86_vendor != X86_VENDOR_AMD)
        return 0;
    if (c->x86 < 0x0F)
        return 0;
    if (c->x86 == 0x0f && c->x86_model < 0x40)
        return 0;
    return 1;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/process.c.ifdefed" startline="253" endline="255">
{
    cpu_clear (cpu, c1e_mask);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/process.c.ifdefed" startline="263" endline="310">
{
    if (need_resched ())
        return;
    if (!c1e_detected) {
        u32 lo, hi;
        rdmsr (MSR_K8_INT_PENDING_MSG, lo, hi);
        if (lo & K8_INTP_C1E_ACTIVE_MASK) {
            c1e_detected = 1;
            if (!boot_cpu_has (X86_FEATURE_CONSTANT_TSC))
                mark_tsc_unstable ("TSC halt in AMD C1E");
            printk (KERN_INFO "System has AMD C1E enabled\n");
            set_cpu_cap (& boot_cpu_data, X86_FEATURE_AMDC1E);
        }
    }
    if (c1e_detected) {
        int cpu = smp_processor_id ();
        if (!cpu_isset (cpu, c1e_mask)) {
            cpu_set (cpu, c1e_mask);
            local_irq_enable ();
            clockevents_notify (CLOCK_EVT_NOTIFY_BROADCAST_FORCE, & cpu);
            printk (KERN_INFO "Switch to broadcast mode on CPU%d\n", cpu);
            local_irq_disable ();
        }
        clockevents_notify (CLOCK_EVT_NOTIFY_BROADCAST_ENTER, & cpu);
        default_idle ();
        local_irq_disable ();
        clockevents_notify (CLOCK_EVT_NOTIFY_BROADCAST_EXIT, & cpu);
        local_irq_enable ();
    }
    else
        default_idle ();
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/process.c.ifdefed" startline="267" endline="278">
{
    u32 lo, hi;
    rdmsr (MSR_K8_INT_PENDING_MSG, lo, hi);
    if (lo & K8_INTP_C1E_ACTIVE_MASK) {
        c1e_detected = 1;
        if (!boot_cpu_has (X86_FEATURE_CONSTANT_TSC))
            mark_tsc_unstable ("TSC halt in AMD C1E");
        printk (KERN_INFO "System has AMD C1E enabled\n");
        set_cpu_cap (& boot_cpu_data, X86_FEATURE_AMDC1E);
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/process.c.ifdefed" startline="271" endline="277">
{
    c1e_detected = 1;
    if (!boot_cpu_has (X86_FEATURE_CONSTANT_TSC))
        mark_tsc_unstable ("TSC halt in AMD C1E");
    printk (KERN_INFO "System has AMD C1E enabled\n");
    set_cpu_cap (& boot_cpu_data, X86_FEATURE_AMDC1E);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/process.c.ifdefed" startline="280" endline="308">
{
    int cpu = smp_processor_id ();
    if (!cpu_isset (cpu, c1e_mask)) {
        cpu_set (cpu, c1e_mask);
        local_irq_enable ();
        clockevents_notify (CLOCK_EVT_NOTIFY_BROADCAST_FORCE, & cpu);
        printk (KERN_INFO "Switch to broadcast mode on CPU%d\n", cpu);
        local_irq_disable ();
    }
    clockevents_notify (CLOCK_EVT_NOTIFY_BROADCAST_ENTER, & cpu);
    default_idle ();
    local_irq_disable ();
    clockevents_notify (CLOCK_EVT_NOTIFY_BROADCAST_EXIT, & cpu);
    local_irq_enable ();
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/process.c.ifdefed" startline="283" endline="296">
{
    cpu_set (cpu, c1e_mask);
    local_irq_enable ();
    clockevents_notify (CLOCK_EVT_NOTIFY_BROADCAST_FORCE, & cpu);
    printk (KERN_INFO "Switch to broadcast mode on CPU%d\n", cpu);
    local_irq_disable ();
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/process.c.ifdefed" startline="313" endline="334">
{
    if (pm_idle)
        return;
    if (cpu_has (c, X86_FEATURE_MWAIT) && mwait_usable (c)) {
        printk (KERN_INFO "using mwait in idle threads.\n");
        pm_idle = mwait_idle;
    }
    else if (check_c1e_idle (c)) {
        printk (KERN_INFO "using C1E aware idle routine\n");
        pm_idle = c1e_idle;
    }
    else
        pm_idle = default_idle;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/process.c.ifdefed" startline="323" endline="329">
{
    printk (KERN_INFO "using mwait in idle threads.\n");
    pm_idle = mwait_idle;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/process.c.ifdefed" startline="329" endline="332">
{
    printk (KERN_INFO "using C1E aware idle routine\n");
    pm_idle = c1e_idle;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/process.c.ifdefed" startline="337" endline="371">
{
    if (!str)
        return -EINVAL;
    if (!strcmp (str, "poll")) {
        printk ("using polling idle threads.\n");
        pm_idle = poll_idle;
    }
    else if (!strcmp (str, "mwait"))
        force_mwait = 1;
    else if (!strcmp (str, "halt")) {
        pm_idle = default_idle;
        idle_halt = 1;
        return 0;
    }
    else if (!strcmp (str, "nomwait")) {
        idle_nomwait = 1;
        return 0;
    }
    else
        return -1;
    boot_option_idle_override = 1;
    return 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/process.c.ifdefed" startline="341" endline="344">
{
    printk ("using polling idle threads.\n");
    pm_idle = poll_idle;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/process.c.ifdefed" startline="346" endline="357">
{
    pm_idle = default_idle;
    idle_halt = 1;
    return 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/process.c.ifdefed" startline="357" endline="366">
{
    idle_nomwait = 1;
    return 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/kdebugfs.c.ifdefed" startline="214" endline="226">
{
    int error = 0;
    arch_debugfs_dir = debugfs_create_dir ("x86", NULL);
    if (!arch_debugfs_dir)
        return -ENOMEM;
    return error;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/kprobes.c.ifdefed" startline="164" endline="172">
{
    struct __arch_jmp_op {
        char op;
        s32 raddr;
    } __attribute__ ((packed)) *jop;
    jop = (struct __arch_jmp_op *) from;
    jop->raddr = (s32) ((long) (to) -((long) (from) +5));
    jop->op = RELATIVEJUMP_INSTRUCTION;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/kprobes.c.ifdefed" startline="179" endline="185">
{
    return 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/kprobes.c.ifdefed" startline="192" endline="242">
{
    kprobe_opcode_t opcode;
    kprobe_opcode_t *orig_opcodes = opcodes;
retry :
    if (opcodes - orig_opcodes > MAX_INSN_SIZE - 1)
        return 0;
    opcode = *(opcodes++);
    if (opcode == 0x0f) {
        if (opcodes - orig_opcodes > MAX_INSN_SIZE - 1)
            return 0;
        return test_bit (*opcodes, (unsigned long *) twobyte_is_boostable);
    }
    switch (opcode & 0xf0) {
    case 0x60 :
        if (0x63 < opcode && opcode < 0x67)
            goto retry;
        return (opcode != 0x62 && opcode != 0x67);
    case 0x70 :
        return 0;
    case 0xc0 :
        return (0xc1 < opcode && opcode < 0xcc) || opcode == 0xcf;
    case 0xd0 :
        return (opcode == 0xd4 || opcode == 0xd5 || opcode == 0xd7);
    case 0xe0 :
        return ((opcode & 0x04) || opcode == 0xea);
    case 0xf0 :
        if ((opcode & 0x0c) == 0 && opcode != 0xf1)
            goto retry;
        return (opcode == 0xf5 || (0xf7 < opcode && opcode < 0xfe));
    default :
        if (opcode == 0x26 || opcode == 0x36 || opcode == 0x3e)
            goto retry;
        return (opcode != 0x2e && opcode != 0x9a);
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/kprobes.c.ifdefed" startline="202" endline="207">
{
    if (opcodes - orig_opcodes > MAX_INSN_SIZE - 1)
        return 0;
    return test_bit (*opcodes, (unsigned long *) twobyte_is_boostable);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/kprobes.c.ifdefed" startline="209" endline="241">
{
case 0x60 :
    if (0x63 < opcode && opcode < 0x67)
        goto retry;
    return (opcode != 0x62 && opcode != 0x67);
case 0x70 :
    return 0;
case 0xc0 :
    return (0xc1 < opcode && opcode < 0xcc) || opcode == 0xcf;
case 0xd0 :
    return (opcode == 0xd4 || opcode == 0xd5 || opcode == 0xd7);
case 0xe0 :
    return ((opcode & 0x04) || opcode == 0xea);
case 0xf0 :
    if ((opcode & 0x0c) == 0 && opcode != 0xf1)
        goto retry;
    return (opcode == 0xf5 || (0xf7 < opcode && opcode < 0xfe));
default :
    if (opcode == 0x26 || opcode == 0x36 || opcode == 0x3e)
        goto retry;
    return (opcode != 0x2e && opcode != 0x9a);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/kprobes.c.ifdefed" startline="248" endline="265">
{
    switch (*insn) {
    case 0xfa :
    case 0xfb :
    case 0xcf :
    case 0x9d :
        return 1;
    }
    if (is_REX_prefix (insn))
        return is_IF_modifier (++insn);
    return 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/kprobes.c.ifdefed" startline="249" endline="255">
{
case 0xfa :
case 0xfb :
case 0xcf :
case 0x9d :
    return 1;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/kprobes.c.ifdefed" startline="275" endline="341">
{
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/kprobes.c.ifdefed" startline="344" endline="355">
{
    memcpy (p -> ainsn.insn, p -> addr, MAX_INSN_SIZE * sizeof (kprobe_opcode_t));
    fix_riprel (p);
    if (can_boost (p->addr))
        p->ainsn.boostable = 0;
    else
        p->ainsn.boostable = -1;
    p->opcode = *p->addr;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/kprobes.c.ifdefed" startline="358" endline="365">
{
    p->ainsn.insn = get_insn_slot ();
    if (!p->ainsn.insn)
        return -ENOMEM;
    arch_copy_kprobe (p);
    return 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/kprobes.c.ifdefed" startline="368" endline="370">
{
    text_poke (p -> addr, ((unsigned char []) {BREAKPOINT_INSTRUCTION}), 1);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/kprobes.c.ifdefed" startline="373" endline="375">
{
    text_poke (p -> addr, & p -> opcode, 1);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/kprobes.c.ifdefed" startline="378" endline="382">
{
    mutex_lock (& kprobe_mutex);
    free_insn_slot (p -> ainsn.insn, (p -> ainsn.boostable == 1));
    mutex_unlock (& kprobe_mutex);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/kprobes.c.ifdefed" startline="385" endline="390">
{
    kcb->prev_kprobe.kp = kprobe_running ();
    kcb->prev_kprobe.status = kcb->kprobe_status;
    kcb->prev_kprobe.old_flags = kcb->kprobe_old_flags;
    kcb->prev_kprobe.saved_flags = kcb->kprobe_saved_flags;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/kprobes.c.ifdefed" startline="393" endline="398">
{
    __get_cpu_var (current_kprobe) = kcb->prev_kprobe.kp;
    kcb->kprobe_status = kcb->prev_kprobe.status;
    kcb->kprobe_old_flags = kcb->prev_kprobe.old_flags;
    kcb->kprobe_saved_flags = kcb->prev_kprobe.saved_flags;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/kprobes.c.ifdefed" startline="402" endline="408">
{
    __get_cpu_var (current_kprobe) = p;
    kcb->kprobe_saved_flags = kcb->kprobe_old_flags = (regs->flags & (X86_EFLAGS_TF | X86_EFLAGS_IF));
    if (is_IF_modifier (p->ainsn.insn))
        kcb->kprobe_saved_flags &= ~X86_EFLAGS_IF;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/kprobes.c.ifdefed" startline="411" endline="414">
{
    if (test_thread_flag (TIF_DEBUGCTLMSR))
        update_debugctlmsr (0);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/kprobes.c.ifdefed" startline="417" endline="420">
{
    if (test_thread_flag (TIF_DEBUGCTLMSR))
        update_debugctlmsr (current->thread.debugctlmsr);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/kprobes.c.ifdefed" startline="423" endline="432">
{
    clear_btf ();
    regs->flags |= X86_EFLAGS_TF;
    regs->flags &= ~X86_EFLAGS_IF;
    if (p->opcode == BREAKPOINT_INSTRUCTION)
        regs->ip = (unsigned long) p->addr;
    else
        regs->ip = (unsigned long) p->ainsn.insn;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/kprobes.c.ifdefed" startline="436" endline="443">
{
    unsigned long *sara = stack_addr (regs);
    ri->ret_addr = (kprobe_opcode_t *) *sara;
    *sara = (unsigned long) &kretprobe_trampoline;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/kprobes.c.ifdefed" startline="447" endline="459">
{
    prepare_singlestep (p, regs);
    kcb->kprobe_status = KPROBE_HIT_SS;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/kprobes.c.ifdefed" startline="468" endline="509">
{
    switch (kcb->kprobe_status) {
    case KPROBE_HIT_SSDONE :
    case KPROBE_HIT_ACTIVE :
        save_previous_kprobe (kcb);
        set_current_kprobe (p, regs, kcb);
        kprobes_inc_nmissed_count (p);
        prepare_singlestep (p, regs);
        kcb->kprobe_status = KPROBE_REENTER;
        break;
    case KPROBE_HIT_SS :
        if (p == kprobe_running ()) {
            regs->flags &= ~X86_EFLAGS_TF;
            regs->flags |= kcb->kprobe_saved_flags;
            return 0;
        }
        else {
        }
    default :
        WARN_ON (1);
        return 0;
    }
    return 1;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/kprobes.c.ifdefed" startline="469" endline="506">
{
case KPROBE_HIT_SSDONE :
case KPROBE_HIT_ACTIVE :
    save_previous_kprobe (kcb);
    set_current_kprobe (p, regs, kcb);
    kprobes_inc_nmissed_count (p);
    prepare_singlestep (p, regs);
    kcb->kprobe_status = KPROBE_REENTER;
    break;
case KPROBE_HIT_SS :
    if (p == kprobe_running ()) {
        regs->flags &= ~X86_EFLAGS_TF;
        regs->flags |= kcb->kprobe_saved_flags;
        return 0;
    }
    else {
    }
default :
    WARN_ON (1);
    return 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/kprobes.c.ifdefed" startline="490" endline="494">
{
    regs->flags &= ~X86_EFLAGS_TF;
    regs->flags |= kcb->kprobe_saved_flags;
    return 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/kprobes.c.ifdefed" startline="494" endline="501">
{
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/kprobes.c.ifdefed" startline="516" endline="577">
{
    kprobe_opcode_t *addr;
    struct kprobe *p;
    struct kprobe_ctlblk *kcb;
    addr = (kprobe_opcode_t *) (regs->ip - sizeof (kprobe_opcode_t));
    if (*addr != BREAKPOINT_INSTRUCTION) {
        regs->ip = (unsigned long) addr;
        return 1;
    }
    preempt_disable ();
    kcb = get_kprobe_ctlblk ();
    p = get_kprobe (addr);
    if (p) {
        if (kprobe_running ()) {
            if (reenter_kprobe (p, regs, kcb))
                return 1;
        }
        else {
            set_current_kprobe (p, regs, kcb);
            kcb->kprobe_status = KPROBE_HIT_ACTIVE;
            if (!p->pre_handler || !p->pre_handler (p, regs))
                setup_singlestep (p, regs, kcb);
            return 1;
        }
    }
    else if (kprobe_running ()) {
        p = __get_cpu_var (current_kprobe);
        if (p->break_handler && p->break_handler (p, regs)) {
            setup_singlestep (p, regs, kcb);
            return 1;
        }
    }
    preempt_enable_no_resched ();
    return 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/kprobes.c.ifdefed" startline="522" endline="534">
{
    regs->ip = (unsigned long) addr;
    return 1;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/kprobes.c.ifdefed" startline="547" endline="567">
{
    if (kprobe_running ()) {
        if (reenter_kprobe (p, regs, kcb))
            return 1;
    }
    else {
        set_current_kprobe (p, regs, kcb);
        kcb->kprobe_status = KPROBE_HIT_ACTIVE;
        if (!p->pre_handler || !p->pre_handler (p, regs))
            setup_singlestep (p, regs, kcb);
        return 1;
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/kprobes.c.ifdefed" startline="548" endline="551">
{
    if (reenter_kprobe (p, regs, kcb))
        return 1;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/kprobes.c.ifdefed" startline="551" endline="566">
{
    set_current_kprobe (p, regs, kcb);
    kcb->kprobe_status = KPROBE_HIT_ACTIVE;
    if (!p->pre_handler || !p->pre_handler (p, regs))
        setup_singlestep (p, regs, kcb);
    return 1;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/kprobes.c.ifdefed" startline="567" endline="573">
{
    p = __get_cpu_var (current_kprobe);
    if (p->break_handler && p->break_handler (p, regs)) {
        setup_singlestep (p, regs, kcb);
        return 1;
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/kprobes.c.ifdefed" startline="569" endline="572">
{
    setup_singlestep (p, regs, kcb);
    return 1;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/kprobes.c.ifdefed" startline="584" endline="670">
{
    asm volatile (".global kretprobe_trampoline\n"
        "kretprobe_trampoline: \n"
        "	pushf\n"
        "	subl $12, %esp\n"
        "	pushl %fs\n"
        "	pushl %ds\n"
        "	pushl %es\n"
        "	pushl %eax\n"
        "	pushl %ebp\n"
        "	pushl %edi\n"
        "	pushl %esi\n"
        "	pushl %edx\n"
        "	pushl %ecx\n"
        "	pushl %ebx\n"
        "	movl %esp, %eax\n"
        "	call trampoline_handler\n"
        "	movl 52(%esp), %edx\n"
        "	movl %edx, 48(%esp)\n"
        "	movl %eax, 52(%esp)\n"
        "	popl %ebx\n"
        "	popl %ecx\n"
        "	popl %edx\n"
        "	popl %esi\n"
        "	popl %edi\n"
        "	popl %ebp\n"
        "	popl %eax\n"
        "	addl $20, %esp\n"
        "	popf\n"
        "	ret\n"
    )}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/kprobes.c.ifdefed" startline="676" endline="740">
{
    struct kretprobe_instance *ri = NULL;
    struct hlist_head *head, empty_rp;
    struct hlist_node *node, *tmp;
    unsigned long flags, orig_ret_address = 0;
    unsigned long trampoline_address = (unsigned long) &kretprobe_trampoline;
    INIT_HLIST_HEAD (& empty_rp);
    kretprobe_hash_lock (current, & head, & flags);
    regs->cs = __KERNEL_CS | get_kernel_rpl ();
    regs->ip = trampoline_address;
    regs->orig_ax = ~0UL;
    hlist_for_each_entry_safe (ri, node, tmp, head, hlist) {
        if (ri->task != current)
            continue;
        if (ri->rp && ri->rp->handler) {
            __get_cpu_var (current_kprobe) = &ri->rp->kp;
            get_kprobe_ctlblk ()->kprobe_status = KPROBE_HIT_ACTIVE;
            ri->rp->handler (ri, regs);
            __get_cpu_var (current_kprobe) = NULL;
        }
        orig_ret_address = (unsigned long) ri->ret_addr;
        recycle_rp_inst (ri, & empty_rp);
        if (orig_ret_address != trampoline_address)
            break;
    }
    kretprobe_assert (ri, orig_ret_address, trampoline_address);
    kretprobe_hash_unlock (current, & flags);
    hlist_for_each_entry_safe (ri, node, tmp, &empty_rp, hlist) {
        hlist_del (& ri -> hlist);
        kfree (ri);
    }
    return (void *) orig_ret_address;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/kprobes.c.ifdefed" startline="707" endline="729">
{
    if (ri->task != current)
        continue;
    if (ri->rp && ri->rp->handler) {
        __get_cpu_var (current_kprobe) = &ri->rp->kp;
        get_kprobe_ctlblk ()->kprobe_status = KPROBE_HIT_ACTIVE;
        ri->rp->handler (ri, regs);
        __get_cpu_var (current_kprobe) = NULL;
    }
    orig_ret_address = (unsigned long) ri->ret_addr;
    recycle_rp_inst (ri, & empty_rp);
    if (orig_ret_address != trampoline_address)
        break;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/kprobes.c.ifdefed" startline="712" endline="717">
{
    __get_cpu_var (current_kprobe) = &ri->rp->kp;
    get_kprobe_ctlblk ()->kprobe_status = KPROBE_HIT_ACTIVE;
    ri->rp->handler (ri, regs);
    __get_cpu_var (current_kprobe) = NULL;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/kprobes.c.ifdefed" startline="735" endline="738">
{
    hlist_del (& ri -> hlist);
    kfree (ri);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/kprobes.c.ifdefed" startline="771" endline="845">
{
    unsigned long *tos = stack_addr (regs);
    unsigned long copy_ip = (unsigned long) p->ainsn.insn;
    unsigned long orig_ip = (unsigned long) p->addr;
    kprobe_opcode_t *insn = p->ainsn.insn;
    if (is_REX_prefix (insn))
        insn++;
    regs->flags &= ~X86_EFLAGS_TF;
    switch (*insn) {
    case 0x9c :
        *tos &= ~(X86_EFLAGS_TF | X86_EFLAGS_IF);
        *tos |= kcb->kprobe_old_flags;
        break;
    case 0xc2 :
    case 0xc3 :
    case 0xca :
    case 0xcb :
    case 0xcf :
    case 0xea :
        p->ainsn.boostable = 1;
        goto no_change;
    case 0xe8 :
        *tos = orig_ip + (*tos - copy_ip);
        break;
    case 0xff :
        if ((insn[1] & 0x30) == 0x10) {
            *tos = orig_ip + (*tos - copy_ip);
            goto no_change;
        }
        else if (((insn[1] & 0x31) == 0x20) || ((insn[1] & 0x31) == 0x21)) {
            p->ainsn.boostable = 1;
            goto no_change;
        }
    default :
        break;
    }
    if (p->ainsn.boostable == 0) {
        if ((regs->ip > copy_ip) && (regs->ip - copy_ip) + 5 < MAX_INSN_SIZE) {
            set_jmp_op ((void *) regs -> ip, (void *) orig_ip + (regs -> ip - copy_ip));
            p->ainsn.boostable = 1;
        }
        else {
            p->ainsn.boostable = -1;
        }
    }
    regs->ip += orig_ip - copy_ip;
no_change :
    restore_btf ();
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/kprobes.c.ifdefed" startline="782" endline="824">
{
case 0x9c :
    *tos &= ~(X86_EFLAGS_TF | X86_EFLAGS_IF);
    *tos |= kcb->kprobe_old_flags;
    break;
case 0xc2 :
case 0xc3 :
case 0xca :
case 0xcb :
case 0xcf :
case 0xea :
    p->ainsn.boostable = 1;
    goto no_change;
case 0xe8 :
    *tos = orig_ip + (*tos - copy_ip);
    break;
case 0xff :
    if ((insn[1] & 0x30) == 0x10) {
        *tos = orig_ip + (*tos - copy_ip);
        goto no_change;
    }
    else if (((insn[1] & 0x31) == 0x20) || ((insn[1] & 0x31) == 0x21)) {
        p->ainsn.boostable = 1;
        goto no_change;
    }
default :
    break;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/kprobes.c.ifdefed" startline="805" endline="813">
{
    *tos = orig_ip + (*tos - copy_ip);
    goto no_change;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/kprobes.c.ifdefed" startline="814" endline="821">
{
    p->ainsn.boostable = 1;
    goto no_change;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/kprobes.c.ifdefed" startline="826" endline="839">
{
    if ((regs->ip > copy_ip) && (regs->ip - copy_ip) + 5 < MAX_INSN_SIZE) {
        set_jmp_op ((void *) regs -> ip, (void *) orig_ip + (regs -> ip - copy_ip));
        p->ainsn.boostable = 1;
    }
    else {
        p->ainsn.boostable = -1;
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/kprobes.c.ifdefed" startline="828" endline="836">
{
    set_jmp_op ((void *) regs -> ip, (void *) orig_ip + (regs -> ip - copy_ip));
    p->ainsn.boostable = 1;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/kprobes.c.ifdefed" startline="836" endline="838">
{
    p->ainsn.boostable = -1;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/kprobes.c.ifdefed" startline="852" endline="885">
{
    struct kprobe *cur = kprobe_running ();
    struct kprobe_ctlblk *kcb = get_kprobe_ctlblk ();
    if (!cur)
        return 0;
    resume_execution (cur, regs, kcb);
    regs->flags |= kcb->kprobe_saved_flags;
    if ((kcb->kprobe_status != KPROBE_REENTER) && cur->post_handler) {
        kcb->kprobe_status = KPROBE_HIT_SSDONE;
        cur->post_handler (cur, regs, 0);
    }
    if (kcb->kprobe_status == KPROBE_REENTER) {
        restore_previous_kprobe (kcb);
        goto out;
    }
    reset_current_kprobe ();
out :
    preempt_enable_no_resched ();
    if (regs->flags & X86_EFLAGS_TF)
        return 0;
    return 1;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/kprobes.c.ifdefed" startline="862" endline="865">
{
    kcb->kprobe_status = KPROBE_HIT_SSDONE;
    cur->post_handler (cur, regs, 0);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/kprobes.c.ifdefed" startline="868" endline="871">
{
    restore_previous_kprobe (kcb);
    goto out;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/kprobes.c.ifdefed" startline="888" endline="945">
{
    struct kprobe *cur = kprobe_running ();
    struct kprobe_ctlblk *kcb = get_kprobe_ctlblk ();
    switch (kcb->kprobe_status) {
    case KPROBE_HIT_SS :
    case KPROBE_REENTER :
        regs->ip = (unsigned long) cur->addr;
        regs->flags |= kcb->kprobe_old_flags;
        if (kcb->kprobe_status == KPROBE_REENTER)
            restore_previous_kprobe (kcb);
        else
            reset_current_kprobe ();
        preempt_enable_no_resched ();
        break;
    case KPROBE_HIT_ACTIVE :
    case KPROBE_HIT_SSDONE :
        kprobes_inc_nmissed_count (cur);
        if (cur->fault_handler && cur->fault_handler (cur, regs, trapnr))
            return 1;
        if (fixup_exception (regs))
            return 1;
        break;
    default :
        break;
    }
    return 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/kprobes.c.ifdefed" startline="892" endline="943">
{
case KPROBE_HIT_SS :
case KPROBE_REENTER :
    regs->ip = (unsigned long) cur->addr;
    regs->flags |= kcb->kprobe_old_flags;
    if (kcb->kprobe_status == KPROBE_REENTER)
        restore_previous_kprobe (kcb);
    else
        reset_current_kprobe ();
    preempt_enable_no_resched ();
    break;
case KPROBE_HIT_ACTIVE :
case KPROBE_HIT_SSDONE :
    kprobes_inc_nmissed_count (cur);
    if (cur->fault_handler && cur->fault_handler (cur, regs, trapnr))
        return 1;
    if (fixup_exception (regs))
        return 1;
    break;
default :
    break;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/kprobes.c.ifdefed" startline="952" endline="982">
{
    struct die_args *args = data;
    int ret = NOTIFY_DONE;
    if (args->regs && user_mode_vm (args->regs))
        return ret;
    switch (val) {
    case DIE_INT3 :
        if (kprobe_handler (args->regs))
            ret = NOTIFY_STOP;
        break;
    case DIE_DEBUG :
        if (post_kprobe_handler (args->regs))
            ret = NOTIFY_STOP;
        break;
    case DIE_GPF :
        if (!preemptible () && kprobe_running () && kprobe_fault_handler (args->regs, args->trapnr))
            ret = NOTIFY_STOP;
        break;
    default :
        break;
    }
    return ret;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/kprobes.c.ifdefed" startline="959" endline="980">
{
case DIE_INT3 :
    if (kprobe_handler (args->regs))
        ret = NOTIFY_STOP;
    break;
case DIE_DEBUG :
    if (post_kprobe_handler (args->regs))
        ret = NOTIFY_STOP;
    break;
case DIE_GPF :
    if (!preemptible () && kprobe_running () && kprobe_fault_handler (args->regs, args->trapnr))
        ret = NOTIFY_STOP;
    break;
default :
    break;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/kprobes.c.ifdefed" startline="985" endline="1007">
{
    struct jprobe *jp = container_of (p, struct jprobe, kp);
    unsigned long addr;
    struct kprobe_ctlblk *kcb = get_kprobe_ctlblk ();
    kcb->jprobe_saved_regs = *regs;
    kcb->jprobe_saved_sp = stack_addr (regs);
    addr = (unsigned long) (kcb->jprobe_saved_sp);
    memcpy (kcb -> jprobes_stack, (kprobe_opcode_t *) addr, MIN_STACK_SIZE (addr));
    regs->flags &= ~X86_EFLAGS_IF;
    trace_hardirqs_off ();
    regs->ip = (unsigned long) (jp->entry);
    return 1;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/kprobes.c.ifdefed" startline="1010" endline="1024">
{
    struct kprobe_ctlblk *kcb = get_kprobe_ctlblk ();
    asm volatile ("       xchgl   %%ebx,%%esp	\n"
        "       int3			\n"
        "       .globl jprobe_return_end\n"
        "       jprobe_return_end:	\n"
        "       nop			\n"
        :
        : "b" (kcb->jprobe_saved_sp)
        : "memory"
    )}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/kprobes.c.ifdefed" startline="1027" endline="1053">
{
    struct kprobe_ctlblk *kcb = get_kprobe_ctlblk ();
    u8 *addr = (u8 *) (regs->ip - 1);
    struct jprobe *jp = container_of (p, struct jprobe, kp);
    if ((addr > (u8 *) jprobe_return) && (addr < (u8 *) jprobe_return_end)) {
        if (stack_addr (regs) != kcb->jprobe_saved_sp) {
            struct pt_regs *saved_regs = &kcb->jprobe_saved_regs;
            printk (KERN_ERR "current sp %p does not match saved sp %p\n", stack_addr (regs), kcb -> jprobe_saved_sp);
            printk (KERN_ERR "Saved registers for jprobe %p\n", jp);
            show_registers (saved_regs);
            printk (KERN_ERR "Current registers\n");
            show_registers (regs);
            BUG ();
        }
        *regs = kcb->jprobe_saved_regs;
        memcpy ((kprobe_opcode_t *) (kcb -> jprobe_saved_sp), kcb -> jprobes_stack, MIN_STACK_SIZE (kcb -> jprobe_saved_sp));
        preempt_enable_no_resched ();
        return 1;
    }
    return 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/kprobes.c.ifdefed" startline="1033" endline="1051">
{
    if (stack_addr (regs) != kcb->jprobe_saved_sp) {
        struct pt_regs *saved_regs = &kcb->jprobe_saved_regs;
        printk (KERN_ERR "current sp %p does not match saved sp %p\n", stack_addr (regs), kcb -> jprobe_saved_sp);
        printk (KERN_ERR "Saved registers for jprobe %p\n", jp);
        show_registers (saved_regs);
        printk (KERN_ERR "Current registers\n");
        show_registers (regs);
        BUG ();
    }
    *regs = kcb->jprobe_saved_regs;
    memcpy ((kprobe_opcode_t *) (kcb -> jprobe_saved_sp), kcb -> jprobes_stack, MIN_STACK_SIZE (kcb -> jprobe_saved_sp));
    preempt_enable_no_resched ();
    return 1;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/kprobes.c.ifdefed" startline="1034" endline="1044">
{
    struct pt_regs *saved_regs = &kcb->jprobe_saved_regs;
    printk (KERN_ERR "current sp %p does not match saved sp %p\n", stack_addr (regs), kcb -> jprobe_saved_sp);
    printk (KERN_ERR "Saved registers for jprobe %p\n", jp);
    show_registers (saved_regs);
    printk (KERN_ERR "Current registers\n");
    show_registers (regs);
    BUG ();
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/kprobes.c.ifdefed" startline="1056" endline="1058">
{
    return 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/kprobes.c.ifdefed" startline="1061" endline="1063">
{
    return 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/pcspeaker.c.ifdefed" startline="6" endline="19">
{
    struct platform_device *pd;
    int ret;
    pd = platform_device_alloc ("pcspkr", -1);
    if (!pd)
        return -ENOMEM;
    ret = platform_device_add (pd);
    if (ret)
        platform_device_put (pd);
    return ret;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/tls.c.ifdefed" startline="20" endline="28">
{
    struct thread_struct *t = &current->thread;
    int idx;
    for (idx = 0; idx < GDT_ENTRY_TLS_ENTRIES; idx++)
        if (desc_empty (&t->tls_array[idx]))
            return idx + GDT_ENTRY_TLS_MIN;
    return -ESRCH;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/tls.c.ifdefed" startline="32" endline="55">
{
    struct thread_struct *t = &p->thread;
    struct desc_struct *desc = &t->tls_array[idx - GDT_ENTRY_TLS_MIN];
    int cpu;
    cpu = get_cpu ();
    while (n-- > 0) {
        if (LDT_empty (info))
            desc->a = desc->b = 0;
        else
            fill_ldt (desc, info);
        ++info;
        ++desc;
    }
    if (t == &current->thread)
        load_TLS (t, cpu);
    put_cpu ();
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/tls.c.ifdefed" startline="42" endline="49">
{
    if (LDT_empty (info))
        desc->a = desc->b = 0;
    else
        fill_ldt (desc, info);
    ++info;
    ++desc;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/tls.c.ifdefed" startline="63" endline="90">
{
    struct user_desc info;
    if (copy_from_user (&info, u_info, sizeof (info)))
        return -EFAULT;
    if (idx == -1)
        idx = info.entry_number;
    if (idx == -1 && can_allocate) {
        idx = get_free_idx ();
        if (idx < 0)
            return idx;
        if (put_user (idx, &u_info->entry_number))
            return -EFAULT;
    }
    if (idx < GDT_ENTRY_TLS_MIN || idx > GDT_ENTRY_TLS_MAX)
        return -EINVAL;
    set_tls_desc (p, idx, & info, 1);
    return 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/tls.c.ifdefed" startline="76" endline="82">
{
    idx = get_free_idx ();
    if (idx < 0)
        return idx;
    if (put_user (idx, &u_info->entry_number))
        return -EFAULT;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/tls.c.ifdefed" startline="93" endline="97">
{
    int ret = do_set_thread_area (current, -1, u_info, 1);
    asmlinkage_protect (1, ret, u_info);
    return ret;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/tls.c.ifdefed" startline="107" endline="121">
{
    memset (info, 0, sizeof (* info));
    info->entry_number = idx;
    info->base_addr = get_desc_base (desc);
    info->limit = get_desc_limit (desc);
    info->seg_32bit = desc->d;
    info->contents = desc->type >> 2;
    info->read_exec_only = !(desc->type & 2);
    info->limit_in_pages = desc->g;
    info->seg_not_present = !desc->p;
    info->useable = desc->avl;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/tls.c.ifdefed" startline="125" endline="140">
{
    struct user_desc info;
    if (idx == -1 && get_user (idx, &u_info->entry_number))
        return -EFAULT;
    if (idx < GDT_ENTRY_TLS_MIN || idx > GDT_ENTRY_TLS_MAX)
        return -EINVAL;
    fill_user_desc (& info, idx, & p -> thread.tls_array [idx - GDT_ENTRY_TLS_MIN]);
    if (copy_to_user (u_info, &info, sizeof (info)))
        return -EFAULT;
    return 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/tls.c.ifdefed" startline="143" endline="147">
{
    int ret = do_get_thread_area (current, -1, u_info);
    asmlinkage_protect (1, ret, u_info);
    return ret;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/tls.c.ifdefed" startline="151" endline="157">
{
    struct thread_struct *t = &target->thread;
    int n = GDT_ENTRY_TLS_ENTRIES;
    while (n > 0 && desc_empty (&t->tls_array[n - 1]))
        --n;
    return n;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/tls.c.ifdefed" startline="162" endline="191">
{
    const struct desc_struct *tls;
    if (pos > GDT_ENTRY_TLS_ENTRIES * sizeof (struct user_desc) || (pos % sizeof (struct user_desc)) != 0 || (count % sizeof (struct user_desc)) != 0)
        return -EINVAL;
    pos /= sizeof (struct user_desc);
    count /= sizeof (struct user_desc);
    tls = &target->thread.tls_array[pos];
    if (kbuf) {
        struct user_desc *info = kbuf;
        while (count-- > 0)
            fill_user_desc (info++, GDT_ENTRY_TLS_MIN +pos++, tls++);
    }
    else {
        struct user_desc __user *u_info = ubuf;
        while (count-- > 0) {
            struct user_desc info;
            fill_user_desc (& info, GDT_ENTRY_TLS_MIN + pos ++, tls ++);
            if (__copy_to_user (u_info++, &info, sizeof (info)))
                return -EFAULT;
        }
    }
    return 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/tls.c.ifdefed" startline="175" endline="180">
{
    struct user_desc *info = kbuf;
    while (count-- > 0)
        fill_user_desc (info++, GDT_ENTRY_TLS_MIN +pos++, tls++);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/tls.c.ifdefed" startline="180" endline="188">
{
    struct user_desc __user *u_info = ubuf;
    while (count-- > 0) {
        struct user_desc info;
        fill_user_desc (& info, GDT_ENTRY_TLS_MIN + pos ++, tls ++);
        if (__copy_to_user (u_info++, &info, sizeof (info)))
            return -EFAULT;
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/tls.c.ifdefed" startline="182" endline="187">
{
    struct user_desc info;
    fill_user_desc (& info, GDT_ENTRY_TLS_MIN + pos ++, tls ++);
    if (__copy_to_user (u_info++, &info, sizeof (info)))
        return -EFAULT;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/tls.c.ifdefed" startline="196" endline="217">
{
    struct user_desc infobuf [GDT_ENTRY_TLS_ENTRIES];
    const struct user_desc *info;
    if (pos > GDT_ENTRY_TLS_ENTRIES * sizeof (struct user_desc) || (pos % sizeof (struct user_desc)) != 0 || (count % sizeof (struct user_desc)) != 0)
        return -EINVAL;
    if (kbuf)
        info = kbuf;
    else if (__copy_from_user (infobuf, ubuf, count))
        return -EFAULT;
    else
        info = infobuf;
    set_tls_desc (target, GDT_ENTRY_TLS_MIN + (pos / sizeof (struct user_desc)), info, count / sizeof (struct user_desc));
    return 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/i8237.c.ifdefed" startline="25" endline="46">
{
    unsigned long flags;
    int i;
    flags = claim_dma_lock ();
    dma_outb (DMA1_RESET_REG, 0);
    dma_outb (DMA2_RESET_REG, 0);
    for (i = 0; i < 8; i++) {
        set_dma_addr (i, 0x000000);
        set_dma_count (i, 1);
    }
    enable_dma (4);
    release_dma_lock (flags);
    return 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/i8237.c.ifdefed" startline="34" endline="38">
{
    set_dma_addr (i, 0x000000);
    set_dma_count (i, 1);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/i8237.c.ifdefed" startline="49" endline="51">
{
    return 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/i8237.c.ifdefed" startline="65" endline="70">
{
    int error = sysdev_class_register (&i8237_sysdev_class);
    if (!error)
        error = sysdev_register (&device_i8237A);
    return error;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/pci-gart_64.c.ifdefed" startline="86" endline="116">
{
    unsigned long offset, flags;
    unsigned long boundary_size;
    unsigned long base_index;
    base_index = ALIGN (iommu_bus_base &dma_get_seg_boundary (dev), PAGE_SIZE) >> PAGE_SHIFT;
    boundary_size = ALIGN (dma_get_seg_boundary (dev) +1, PAGE_SIZE) >> PAGE_SHIFT;
    spin_lock_irqsave (& iommu_bitmap_lock, flags);
    offset = iommu_area_alloc (iommu_gart_bitmap, iommu_pages, next_bit, size, base_index, boundary_size, 0);
    if (offset == -1) {
        need_flush = 1;
        offset = iommu_area_alloc (iommu_gart_bitmap, iommu_pages, 0, size, base_index, boundary_size, 0);
    }
    if (offset != -1) {
        next_bit = offset + size;
        if (next_bit >= iommu_pages) {
            next_bit = 0;
            need_flush = 1;
        }
    }
    if (iommu_fullflush)
        need_flush = 1;
    spin_unlock_irqrestore (& iommu_bitmap_lock, flags);
    return offset;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/pci-gart_64.c.ifdefed" startline="99" endline="103">
{
    need_flush = 1;
    offset = iommu_area_alloc (iommu_gart_bitmap, iommu_pages, 0, size, base_index, boundary_size, 0);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/pci-gart_64.c.ifdefed" startline="104" endline="110">
{
    next_bit = offset + size;
    if (next_bit >= iommu_pages) {
        next_bit = 0;
        need_flush = 1;
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/pci-gart_64.c.ifdefed" startline="106" endline="109">
{
    next_bit = 0;
    need_flush = 1;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/pci-gart_64.c.ifdefed" startline="119" endline="125">
{
    unsigned long flags;
    spin_lock_irqsave (& iommu_bitmap_lock, flags);
    iommu_area_free (iommu_gart_bitmap, offset, size);
    spin_unlock_irqrestore (& iommu_bitmap_lock, flags);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/pci-gart_64.c.ifdefed" startline="131" endline="140">
{
    unsigned long flags;
    spin_lock_irqsave (& iommu_bitmap_lock, flags);
    if (need_flush) {
        k8_flush_garts ();
        need_flush = 0;
    }
    spin_unlock_irqrestore (& iommu_bitmap_lock, flags);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/pci-gart_64.c.ifdefed" startline="135" endline="138">
{
    k8_flush_garts ();
    need_flush = 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/pci-gart_64.c.ifdefed" startline="187" endline="210">
{
    dev_err (dev, "PCI-DMA: Out of IOMMU space for %lu bytes\n", size);
    if (size > PAGE_SIZE * EMERGENCY_PAGES) {
        if (dir == PCI_DMA_FROMDEVICE || dir == PCI_DMA_BIDIRECTIONAL)
            panic ("PCI-DMA: Memory would be corrupted\n");
        if (dir == PCI_DMA_TODEVICE || dir == PCI_DMA_BIDIRECTIONAL)
            panic (KERN_ERR "PCI-DMA: Random memory would be DMAed\n");
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/pci-gart_64.c.ifdefed" startline="200" endline="206">
{
    if (dir == PCI_DMA_FROMDEVICE || dir == PCI_DMA_BIDIRECTIONAL)
        panic ("PCI-DMA: Memory would be corrupted\n");
    if (dir == PCI_DMA_TODEVICE || dir == PCI_DMA_BIDIRECTIONAL)
        panic (KERN_ERR "PCI-DMA: Random memory would be DMAed\n");
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/pci-gart_64.c.ifdefed" startline="214" endline="223">
{
    u64 mask = *dev->dma_mask;
    int high = addr + size > mask;
    int mmu = high;
    if (force_iommu)
        mmu = 1;
    return mmu;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/pci-gart_64.c.ifdefed" startline="227" endline="233">
{
    u64 mask = *dev->dma_mask;
    int high = addr + size > mask;
    int mmu = high;
    return mmu;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/pci-gart_64.c.ifdefed" startline="240" endline="260">
{
    unsigned long npages = iommu_num_pages (phys_mem, size);
    unsigned long iommu_page = alloc_iommu (dev, npages);
    int i;
    if (iommu_page == -1) {
        if (!nonforced_iommu (dev, phys_mem, size))
            return phys_mem;
        if (panic_on_overflow)
            panic ("dma_map_area overflow %lu bytes\n", size);
        iommu_full (dev, size, dir);
        return bad_dma_address;
    }
    for (i = 0; i < npages; i++) {
        iommu_gatt_base[iommu_page + i] = GPTE_ENCODE (phys_mem);
        SET_LEAK (iommu_page + i);
        phys_mem += PAGE_SIZE;
    }
    return iommu_bus_base + iommu_page * PAGE_SIZE + (phys_mem & ~PAGE_MASK);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/pci-gart_64.c.ifdefed" startline="245" endline="252">
{
    if (!nonforced_iommu (dev, phys_mem, size))
        return phys_mem;
    if (panic_on_overflow)
        panic ("dma_map_area overflow %lu bytes\n", size);
    iommu_full (dev, size, dir);
    return bad_dma_address;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/pci-gart_64.c.ifdefed" startline="254" endline="258">
{
    iommu_gatt_base[iommu_page + i] = GPTE_ENCODE (phys_mem);
    SET_LEAK (iommu_page + i);
    phys_mem += PAGE_SIZE;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/pci-gart_64.c.ifdefed" startline="264" endline="270">
{
    dma_addr_t map = dma_map_area (dev, paddr, size, dir);
    flush_gart ();
    return map;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/pci-gart_64.c.ifdefed" startline="275" endline="287">
{
    unsigned long bus;
    if (!dev)
        dev = &fallback_dev;
    if (!need_iommu (dev, paddr, size))
        return paddr;
    bus = gart_map_simple (dev, paddr, size, dir);
    return bus;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/pci-gart_64.c.ifdefed" startline="294" endline="310">
{
    unsigned long iommu_page;
    int npages;
    int i;
    if (dma_addr < iommu_bus_base + EMERGENCY_PAGES * PAGE_SIZE || dma_addr >= iommu_bus_base + iommu_size)
        return;
    iommu_page = (dma_addr - iommu_bus_base) >> PAGE_SHIFT;
    npages = iommu_num_pages (dma_addr, size);
    for (i = 0; i < npages; i++) {
        iommu_gatt_base[iommu_page + i] = gart_unmapped_entry;
        CLEAR_LEAK (iommu_page + i);
    }
    free_iommu (iommu_page, npages);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/pci-gart_64.c.ifdefed" startline="305" endline="308">
{
    iommu_gatt_base[iommu_page + i] = gart_unmapped_entry;
    CLEAR_LEAK (iommu_page + i);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/pci-gart_64.c.ifdefed" startline="317" endline="326">
{
    struct scatterlist *s;
    int i;

    for_each_sg (sg, s, nents, i) {
        if (!s->dma_length || !s->length)
            break;
        gart_unmap_single (dev, s -> dma_address, s -> dma_length, dir);
    }

}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/pci-gart_64.c.ifdefed" startline="321" endline="325">
{
    if (!s->dma_length || !s->length)
        break;
    gart_unmap_single (dev, s -> dma_address, s -> dma_length, dir);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/pci-gart_64.c.ifdefed" startline="331" endline="358">
{
    struct scatterlist *s;
    int i;

    for_each_sg (sg, s, nents, i) {
        unsigned long addr = sg_phys (s);
        if (nonforced_iommu (dev, addr, s->length)) {
            addr = dma_map_area (dev, addr, s->length, dir);
            if (addr == bad_dma_address) {
                if (i > 0)
                    gart_unmap_sg (dev, sg, i, dir);
                nents = 0;
                sg[0].dma_length = 0;
                break;
            }
        }
        s->dma_address = addr;
        s->dma_length = s->length;
    }

    flush_gart ();
    return nents;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/pci-gart_64.c.ifdefed" startline="339" endline="354">
{
    unsigned long addr = sg_phys (s);
    if (nonforced_iommu (dev, addr, s->length)) {
        addr = dma_map_area (dev, addr, s->length, dir);
        if (addr == bad_dma_address) {
            if (i > 0)
                gart_unmap_sg (dev, sg, i, dir);
            nents = 0;
            sg[0].dma_length = 0;
            break;
        }
    }
    s->dma_address = addr;
    s->dma_length = s->length;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/pci-gart_64.c.ifdefed" startline="342" endline="351">
{
    addr = dma_map_area (dev, addr, s->length, dir);
    if (addr == bad_dma_address) {
        if (i > 0)
            gart_unmap_sg (dev, sg, i, dir);
        nents = 0;
        sg[0].dma_length = 0;
        break;
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/pci-gart_64.c.ifdefed" startline="344" endline="350">
{
    if (i > 0)
        gart_unmap_sg (dev, sg, i, dir);
    nents = 0;
    sg[0].dma_length = 0;
    break;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/pci-gart_64.c.ifdefed" startline="364" endline="398">
{
    unsigned long iommu_start = alloc_iommu (dev, pages);
    unsigned long iommu_page = iommu_start;
    struct scatterlist *s;
    int i;
    if (iommu_start == -1)
        return -1;

    for_each_sg (start, s, nelems, i) {
        unsigned long pages, addr;
        unsigned long phys_addr = s->dma_address;
        BUG_ON (s != start && s -> offset);
        if (s == start) {
            sout->dma_address = iommu_bus_base;
            sout->dma_address += iommu_page * PAGE_SIZE + s->offset;
            sout->dma_length = s->length;
        }
        else {
            sout->dma_length += s->length;
        }
        addr = phys_addr;
        pages = iommu_num_pages (s->offset, s->length);
        while (pages--) {
            iommu_gatt_base[iommu_page] = GPTE_ENCODE (addr);
            SET_LEAK (iommu_page);
            addr += PAGE_SIZE;
            iommu_page++;
        }
    }

    BUG_ON (iommu_page - iommu_start != pages);
    return 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/pci-gart_64.c.ifdefed" startline="373" endline="394">
{
    unsigned long pages, addr;
    unsigned long phys_addr = s->dma_address;
    BUG_ON (s != start && s -> offset);
    if (s == start) {
        sout->dma_address = iommu_bus_base;
        sout->dma_address += iommu_page * PAGE_SIZE + s->offset;
        sout->dma_length = s->length;
    }
    else {
        sout->dma_length += s->length;
    }
    addr = phys_addr;
    pages = iommu_num_pages (s->offset, s->length);
    while (pages--) {
        iommu_gatt_base[iommu_page] = GPTE_ENCODE (addr);
        SET_LEAK (iommu_page);
        addr += PAGE_SIZE;
        iommu_page++;
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/pci-gart_64.c.ifdefed" startline="378" endline="382">
{
    sout->dma_address = iommu_bus_base;
    sout->dma_address += iommu_page * PAGE_SIZE + s->offset;
    sout->dma_length = s->length;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/pci-gart_64.c.ifdefed" startline="382" endline="384">
{
    sout->dma_length += s->length;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/pci-gart_64.c.ifdefed" startline="388" endline="393">
{
    iommu_gatt_base[iommu_page] = GPTE_ENCODE (addr);
    SET_LEAK (iommu_page);
    addr += PAGE_SIZE;
    iommu_page++;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/pci-gart_64.c.ifdefed" startline="403" endline="411">
{
    if (!need) {
        BUG_ON (nelems != 1);
        sout->dma_address = start->dma_address;
        sout->dma_length = start->length;
        return 0;
    }
    return __dma_map_cont (dev, start, nelems, sout, pages);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/pci-gart_64.c.ifdefed" startline="404" endline="409">
{
    BUG_ON (nelems != 1);
    sout->dma_address = start->dma_address;
    sout->dma_length = start->length;
    return 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/pci-gart_64.c.ifdefed" startline="419" endline="500">
{
    struct scatterlist *s, *ps, *start_sg, *sgmap;
    int need = 0, nextneed, i, out, start;
    unsigned long pages = 0;
    unsigned int seg_size;
    unsigned int max_seg_size;
    if (nents == 0)
        return 0;
    if (!dev)
        dev = &fallback_dev;
    out = 0;
    start = 0;
    start_sg = sgmap = sg;
    seg_size = 0;
    max_seg_size = dma_get_max_seg_size (dev);
    ps = NULL;

    for_each_sg (sg, s, nents, i) {
        dma_addr_t addr = sg_phys (s);
        s->dma_address = addr;
        BUG_ON (s -> length == 0);
        nextneed = need_iommu (dev, addr, s->length);
        if (i > start) {
            if (!iommu_merge || !nextneed || !need || s->offset || (s->length + seg_size > max_seg_size) || (ps->offset + ps->length) % PAGE_SIZE) {
                if (dma_map_cont (dev, start_sg, i -start, sgmap, pages, need) < 0)
                    goto error;
                out++;
                seg_size = 0;
                sgmap = sg_next (sgmap);
                pages = 0;
                start = i;
                start_sg = s;
            }
        }
        seg_size += s->length;
        need = nextneed;
        pages += iommu_num_pages (s->offset, s->length);
        ps = s;
    }

    if (dma_map_cont (dev, start_sg, i -start, sgmap, pages, need) < 0)
        goto error;
    out++;
    flush_gart ();
    if (out < nents) {
        sgmap = sg_next (sgmap);
        sgmap->dma_length = 0;
    }
    return out;
error :
    flush_gart ();
    gart_unmap_sg (dev, sg, out, dir);
    if (force_iommu || iommu_merge) {
        out = dma_map_sg_nonforce (dev, sg, nents, dir);
        if (out > 0)
            return out;
    }
    if (panic_on_overflow)
        panic ("dma_map_sg: overflow on %lu pages\n", pages);
    iommu_full (dev, pages << PAGE_SHIFT, dir);
    for_each_sg (sg, s, nents, i)
    s->dma_address = bad_dma_address;
    return 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/pci-gart_64.c.ifdefed" startline="438" endline="472">
{
    dma_addr_t addr = sg_phys (s);
    s->dma_address = addr;
    BUG_ON (s -> length == 0);
    nextneed = need_iommu (dev, addr, s->length);
    if (i > start) {
        if (!iommu_merge || !nextneed || !need || s->offset || (s->length + seg_size > max_seg_size) || (ps->offset + ps->length) % PAGE_SIZE) {
            if (dma_map_cont (dev, start_sg, i -start, sgmap, pages, need) < 0)
                goto error;
            out++;
            seg_size = 0;
            sgmap = sg_next (sgmap);
            pages = 0;
            start = i;
            start_sg = s;
        }
    }
    seg_size += s->length;
    need = nextneed;
    pages += iommu_num_pages (s->offset, s->length);
    ps = s;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/pci-gart_64.c.ifdefed" startline="447" endline="466">
{
    if (!iommu_merge || !nextneed || !need || s->offset || (s->length + seg_size > max_seg_size) || (ps->offset + ps->length) % PAGE_SIZE) {
        if (dma_map_cont (dev, start_sg, i -start, sgmap, pages, need) < 0)
            goto error;
        out++;
        seg_size = 0;
        sgmap = sg_next (sgmap);
        pages = 0;
        start = i;
        start_sg = s;
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/pci-gart_64.c.ifdefed" startline="455" endline="465">
{
    if (dma_map_cont (dev, start_sg, i -start, sgmap, pages, need) < 0)
        goto error;
    out++;
    seg_size = 0;
    sgmap = sg_next (sgmap);
    pages = 0;
    start = i;
    start_sg = s;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/pci-gart_64.c.ifdefed" startline="477" endline="480">
{
    sgmap = sg_next (sgmap);
    sgmap->dma_length = 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/pci-gart_64.c.ifdefed" startline="488" endline="492">
{
    out = dma_map_sg_nonforce (dev, sg, nents, dir);
    if (out > 0)
        return out;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/pci-gart_64.c.ifdefed" startline="505" endline="525">
{
    unsigned long a;
    if (!iommu_size) {
        iommu_size = aper_size;
        if (!no_agp)
            iommu_size /= 2;
    }
    a = aper + iommu_size;
    iommu_size -= round_up (a, PMD_PAGE_SIZE) - a;
    if (iommu_size < 64 * 1024 * 1024) {
        printk (KERN_WARNING "PCI-DMA: Warning: Small IOMMU %luMB." " Consider increasing the AGP aperture in BIOS\n", iommu_size >> 20);
    }
    return iommu_size;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/pci-gart_64.c.ifdefed" startline="508" endline="512">
{
    iommu_size = aper_size;
    if (!no_agp)
        iommu_size /= 2;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/pci-gart_64.c.ifdefed" startline="517" endline="522">
{
    printk (KERN_WARNING "PCI-DMA: Warning: Small IOMMU %luMB." " Consider increasing the AGP aperture in BIOS\n", iommu_size >> 20);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/pci-gart_64.c.ifdefed" startline="528" endline="545">
{
    unsigned aper_size = 0, aper_base_32, aper_order;
    u64 aper_base;
    pci_read_config_dword (dev, AMD64_GARTAPERTUREBASE, & aper_base_32);
    pci_read_config_dword (dev, AMD64_GARTAPERTURECTL, & aper_order);
    aper_order = (aper_order >> 1) & 7;
    aper_base = aper_base_32 & 0x7fff;
    aper_base <<= 25;
    aper_size = (32 * 1024 * 1024) << aper_order;
    if (aper_base + aper_size > 0x100000000UL || !aper_size)
        aper_base = 0;
    *size = aper_size;
    return aper_base;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/pci-gart_64.c.ifdefed" startline="548" endline="556">
{
    int i;
    for (i = 0; i < num_k8_northbridges; i++) {
        struct pci_dev *dev = k8_northbridges[i];
        enable_gart_translation (dev, __pa (agp_gatt_table));
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/pci-gart_64.c.ifdefed" startline="551" endline="555">
{
    struct pci_dev *dev = k8_northbridges[i];
    enable_gart_translation (dev, __pa (agp_gatt_table));
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/pci-gart_64.c.ifdefed" startline="567" endline="571">
{
    fix_up_north_bridges = true;
    aperture_order = aper_order;
    aperture_alloc = aper_alloc;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/pci-gart_64.c.ifdefed" startline="574" endline="599">
{
    printk (KERN_INFO "PCI-DMA: Resuming GART IOMMU\n");
    if (fix_up_north_bridges) {
        int i;
        printk (KERN_INFO "PCI-DMA: Restoring GART aperture settings\n");
        for (i = 0; i < num_k8_northbridges; i++) {
            struct pci_dev *dev = k8_northbridges[i];
            pci_write_config_dword (dev, AMD64_GARTAPERTURECTL, aperture_order << 1);
            pci_write_config_dword (dev, AMD64_GARTAPERTUREBASE, aperture_alloc >> 25);
        }
    }
    enable_gart_translations ();
    return 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/pci-gart_64.c.ifdefed" startline="577" endline="594">
{
    int i;
    printk (KERN_INFO "PCI-DMA: Restoring GART aperture settings\n");
    for (i = 0; i < num_k8_northbridges; i++) {
        struct pci_dev *dev = k8_northbridges[i];
        pci_write_config_dword (dev, AMD64_GARTAPERTURECTL, aperture_order << 1);
        pci_write_config_dword (dev, AMD64_GARTAPERTUREBASE, aperture_alloc >> 25);
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/pci-gart_64.c.ifdefed" startline="582" endline="593">
{
    struct pci_dev *dev = k8_northbridges[i];
    pci_write_config_dword (dev, AMD64_GARTAPERTURECTL, aperture_order << 1);
    pci_write_config_dword (dev, AMD64_GARTAPERTUREBASE, aperture_alloc >> 25);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/pci-gart_64.c.ifdefed" startline="602" endline="604">
{
    return 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/pci-gart_64.c.ifdefed" startline="623" endline="681">
{
    unsigned aper_size, gatt_size, new_aper_size;
    unsigned aper_base, new_aper_base;
    struct pci_dev *dev;
    void *gatt;
    int i, error;
    printk (KERN_INFO "PCI-DMA: Disabling AGP.\n");
    aper_size = aper_base = info->aper_size = 0;
    dev = NULL;
    for (i = 0; i < num_k8_northbridges; i++) {
        dev = k8_northbridges[i];
        new_aper_base = read_aperture (dev, &new_aper_size);
        if (!new_aper_base)
            goto nommu;
        if (!aper_base) {
            aper_size = new_aper_size;
            aper_base = new_aper_base;
        }
        if (aper_size != new_aper_size || aper_base != new_aper_base)
            goto nommu;
    }
    if (!aper_base)
        goto nommu;
    info->aper_base = aper_base;
    info->aper_size = aper_size >> 20;
    gatt_size = (aper_size >> PAGE_SHIFT) * sizeof (u32);
    gatt = (void *) __get_free_pages (GFP_KERNEL, get_order (gatt_size));
    if (!gatt)
        panic ("Cannot allocate GATT table");
    if (set_memory_uc ((unsigned long) gatt, gatt_size >> PAGE_SHIFT))
        panic ("Could not set GART PTEs to uncacheable pages");
    memset (gatt, 0, gatt_size);
    agp_gatt_table = gatt;
    enable_gart_translations ();
    error = sysdev_class_register (&gart_sysdev_class);
    if (!error)
        error = sysdev_register (&device_gart);
    if (error)
        panic ("Could not register gart_sysdev -- would corrupt data on next suspend");
    flush_gart ();
    printk (KERN_INFO "PCI-DMA: aperture base @ %x size %u KB\n", aper_base, aper_size >> 10);
    return 0;
nommu :
    printk (KERN_WARNING "PCI-DMA: More than 4GB of RAM and no IOMMU\n" KERN_WARNING "falling back to iommu=soft.\n");
    return -1;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/pci-gart_64.c.ifdefed" startline="633" endline="645">
{
    dev = k8_northbridges[i];
    new_aper_base = read_aperture (dev, &new_aper_size);
    if (!new_aper_base)
        goto nommu;
    if (!aper_base) {
        aper_size = new_aper_size;
        aper_base = new_aper_base;
    }
    if (aper_size != new_aper_size || aper_base != new_aper_base)
        goto nommu;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/pci-gart_64.c.ifdefed" startline="639" endline="642">
{
    aper_size = new_aper_size;
    aper_base = new_aper_base;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/pci-gart_64.c.ifdefed" startline="700" endline="717">
{
    struct pci_dev *dev;
    int i;
    if (no_agp && (dma_ops != &gart_dma_ops))
        return;
    for (i = 0; i < num_k8_northbridges; i++) {
        u32 ctl;
        dev = k8_northbridges[i];
        pci_read_config_dword (dev, AMD64_GARTAPERTURECTL, & ctl);
        ctl &= ~GARTEN;
        pci_write_config_dword (dev, AMD64_GARTAPERTURECTL, ctl);
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/pci-gart_64.c.ifdefed" startline="707" endline="716">
{
    u32 ctl;
    dev = k8_northbridges[i];
    pci_read_config_dword (dev, AMD64_GARTAPERTURECTL, & ctl);
    ctl &= ~GARTEN;
    pci_write_config_dword (dev, AMD64_GARTAPERTURECTL, ctl);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/pci-gart_64.c.ifdefed" startline="720" endline="845">
{
    struct agp_kern_info info;
    unsigned long iommu_start;
    unsigned long aper_base, aper_size;
    unsigned long start_pfn, end_pfn;
    unsigned long scratch;
    long i;
    if (cache_k8_northbridges () < 0 || num_k8_northbridges == 0) {
        printk (KERN_INFO "PCI-GART: No AMD northbridge found.\n");
        return;
    }
    no_agp = 1;
    if (swiotlb)
        return;
    if (iommu_detected && !gart_iommu_aperture)
        return;
    if (no_iommu || (!force_iommu && max_pfn <= MAX_DMA32_PFN) || !gart_iommu_aperture || (no_agp && init_k8_gatt (&info) < 0)) {
        if (max_pfn > MAX_DMA32_PFN) {
            printk (KERN_WARNING "More than 4GB of memory " "but GART IOMMU not available.\n" KERN_WARNING "falling back to iommu=soft.\n");
        }
        return;
    }
    aper_size = info.aper_size << 20;
    aper_base = info.aper_base;
    end_pfn = (aper_base >> PAGE_SHIFT) + (aper_size >> PAGE_SHIFT);
    if (end_pfn > max_low_pfn_mapped) {
        start_pfn = (aper_base >> PAGE_SHIFT);
        init_memory_mapping (start_pfn << PAGE_SHIFT, end_pfn << PAGE_SHIFT);
    }
    printk (KERN_INFO "PCI-DMA: using GART IOMMU.\n");
    iommu_size = check_iommu_size (info.aper_base, aper_size);
    iommu_pages = iommu_size >> PAGE_SHIFT;
    iommu_gart_bitmap = (void *) __get_free_pages (GFP_KERNEL, get_order (iommu_pages / 8));
    if (!iommu_gart_bitmap)
        panic ("Cannot allocate iommu bitmap\n");
    memset (iommu_gart_bitmap, 0, iommu_pages / 8);
    set_bit_string (iommu_gart_bitmap, 0, EMERGENCY_PAGES);
    agp_memory_reserved = iommu_size;
    printk (KERN_INFO "PCI-DMA: Reserving %luMB of IOMMU area in the AGP aperture\n", iommu_size >> 20);
    iommu_start = aper_size - iommu_size;
    iommu_bus_base = info.aper_base + iommu_start;
    bad_dma_address = iommu_bus_base;
    iommu_gatt_base = agp_gatt_table + (iommu_start >> PAGE_SHIFT);
    set_memory_np ((unsigned long) __va (iommu_bus_base), iommu_size >> PAGE_SHIFT);
    wbinvd ();
    scratch = get_zeroed_page (GFP_KERNEL);
    if (!scratch)
        panic ("Cannot allocate iommu scratch page");
    gart_unmapped_entry = GPTE_ENCODE (__pa (scratch));
    for (i = EMERGENCY_PAGES; i < iommu_pages; i++)
        iommu_gatt_base[i] = gart_unmapped_entry;
    flush_gart ();
    dma_ops = &gart_dma_ops;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/pci-gart_64.c.ifdefed" startline="728" endline="731">
{
    printk (KERN_INFO "PCI-GART: No AMD northbridge found.\n");
    return;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/pci-gart_64.c.ifdefed" startline="753" endline="760">
{
    if (max_pfn > MAX_DMA32_PFN) {
        printk (KERN_WARNING "More than 4GB of memory " "but GART IOMMU not available.\n" KERN_WARNING "falling back to iommu=soft.\n");
    }
    return;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/pci-gart_64.c.ifdefed" startline="754" endline="758">
{
    printk (KERN_WARNING "More than 4GB of memory " "but GART IOMMU not available.\n" KERN_WARNING "falling back to iommu=soft.\n");
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/pci-gart_64.c.ifdefed" startline="766" endline="769">
{
    start_pfn = (aper_base >> PAGE_SHIFT);
    init_memory_mapping (start_pfn << PAGE_SHIFT, end_pfn << PAGE_SHIFT);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/pci-gart_64.c.ifdefed" startline="848" endline="884">
{
    int arg;
    if (isdigit (*p) && get_option (&p, &arg))
        iommu_size = arg;
    if (!strncmp (p, "fullflush", 8))
        iommu_fullflush = 1;
    if (!strncmp (p, "nofullflush", 11))
        iommu_fullflush = 0;
    if (!strncmp (p, "noagp", 5))
        no_agp = 1;
    if (!strncmp (p, "noaperture", 10))
        fix_aperture = 0;
    if (!strncmp (p, "force", 5))
        gart_iommu_aperture_allowed = 1;
    if (!strncmp (p, "allowed", 7))
        gart_iommu_aperture_allowed = 1;
    if (!strncmp (p, "memaper", 7)) {
        fallback_aper_force = 1;
        p += 7;
        if (*p == '=') {
            ++p;
            if (get_option (&p, &arg))
                fallback_aper_order = arg;
        }
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/pci-gart_64.c.ifdefed" startline="875" endline="883">
{
    fallback_aper_force = 1;
    p += 7;
    if (*p == '=') {
        ++p;
        if (get_option (&p, &arg))
            fallback_aper_order = arg;
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/pci-gart_64.c.ifdefed" startline="878" endline="882">
{
    ++p;
    if (get_option (&p, &arg))
        fallback_aper_order = arg;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/i8259.c.ifdefed" startline="68" endline="79">
{
    unsigned int mask = 1 << irq;
    unsigned long flags;
    spin_lock_irqsave (& i8259A_lock, flags);
    cached_irq_mask |= mask;
    if (irq & 8)
        outb (cached_slave_mask, PIC_SLAVE_IMR);
    else
        outb (cached_master_mask, PIC_MASTER_IMR);
    spin_unlock_irqrestore (& i8259A_lock, flags);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/i8259.c.ifdefed" startline="82" endline="93">
{
    unsigned int mask = ~(1 << irq);
    unsigned long flags;
    spin_lock_irqsave (& i8259A_lock, flags);
    cached_irq_mask &= mask;
    if (irq & 8)
        outb (cached_slave_mask, PIC_SLAVE_IMR);
    else
        outb (cached_master_mask, PIC_MASTER_IMR);
    spin_unlock_irqrestore (& i8259A_lock, flags);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/i8259.c.ifdefed" startline="96" endline="109">
{
    unsigned int mask = 1 << irq;
    unsigned long flags;
    int ret;
    spin_lock_irqsave (& i8259A_lock, flags);
    if (irq < 8)
        ret = inb (PIC_MASTER_CMD) & mask;
    else
        ret = inb (PIC_SLAVE_CMD) & (mask >> 8);
    spin_unlock_irqrestore (& i8259A_lock, flags);
    return ret;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/i8259.c.ifdefed" startline="112" endline="118">
{
    disable_irq_nosync (irq);
    io_apic_irqs &= ~(1 << irq);
    set_irq_chip_and_handler_name (irq, & i8259A_chip, handle_level_irq, "XT");
    enable_irq (irq);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/i8259.c.ifdefed" startline="127" endline="141">
{
    int value;
    int irqmask = 1 << irq;
    if (irq < 8) {
        outb (0x0B, PIC_MASTER_CMD);
        value = inb (PIC_MASTER_CMD) & irqmask;
        outb (0x0A, PIC_MASTER_CMD);
        return value;
    }
    outb (0x0B, PIC_SLAVE_CMD);
    value = inb (PIC_SLAVE_CMD) & (irqmask >> 8);
    outb (0x0A, PIC_SLAVE_CMD);
    return value;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/i8259.c.ifdefed" startline="131" endline="136">
{
    outb (0x0B, PIC_MASTER_CMD);
    value = inb (PIC_MASTER_CMD) & irqmask;
    outb (0x0A, PIC_MASTER_CMD);
    return value;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/i8259.c.ifdefed" startline="150" endline="220">
{
    unsigned int irqmask = 1 << irq;
    unsigned long flags;
    spin_lock_irqsave (& i8259A_lock, flags);
    if (cached_irq_mask & irqmask)
        goto spurious_8259A_irq;
    cached_irq_mask |= irqmask;
handle_real_irq :
    if (irq & 8) {
        inb (PIC_SLAVE_IMR);
        outb (cached_slave_mask, PIC_SLAVE_IMR);
        outb (0x60 + (irq & 7), PIC_SLAVE_CMD);
        outb (0x60 + PIC_CASCADE_IR, PIC_MASTER_CMD);
    }
    else {
        inb (PIC_MASTER_IMR);
        outb (cached_master_mask, PIC_MASTER_IMR);
        outb (0x60 + irq, PIC_MASTER_CMD);
    }
    spin_unlock_irqrestore (& i8259A_lock, flags);
    return;
spurious_8259A_irq :
    if (i8259A_irq_real (irq))
        goto handle_real_irq;
    {
        static int spurious_irq_mask;
        if (!(spurious_irq_mask & irqmask)) {
            printk (KERN_DEBUG "spurious 8259A interrupt: IRQ%d.\n", irq);
            spurious_irq_mask |= irqmask;
        }
        atomic_inc (& irq_err_count);
        goto handle_real_irq;
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/i8259.c.ifdefed" startline="175" endline="182">
{
    inb (PIC_SLAVE_IMR);
    outb (cached_slave_mask, PIC_SLAVE_IMR);
    outb (0x60 + (irq & 7), PIC_SLAVE_CMD);
    outb (0x60 + PIC_CASCADE_IR, PIC_MASTER_CMD);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/i8259.c.ifdefed" startline="182" endline="186">
{
    inb (PIC_MASTER_IMR);
    outb (cached_master_mask, PIC_MASTER_IMR);
    outb (0x60 + irq, PIC_MASTER_CMD);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/i8259.c.ifdefed" startline="201" endline="219">
{
    static int spurious_irq_mask;
    if (!(spurious_irq_mask & irqmask)) {
        printk (KERN_DEBUG "spurious 8259A interrupt: IRQ%d.\n", irq);
        spurious_irq_mask |= irqmask;
    }
    atomic_inc (& irq_err_count);
    goto handle_real_irq;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/i8259.c.ifdefed" startline="207" endline="211">
{
    printk (KERN_DEBUG "spurious 8259A interrupt: IRQ%d.\n", irq);
    spurious_irq_mask |= irqmask;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/i8259.c.ifdefed" startline="227" endline="230">
{
    outb (trigger [0], 0x4d0);
    outb (trigger [1], 0x4d1);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/i8259.c.ifdefed" startline="233" endline="237">
{
    trigger[0] = inb (0x4d0) & 0xF8;
    trigger[1] = inb (0x4d1) & 0xDE;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/i8259.c.ifdefed" startline="240" endline="244">
{
    init_8259A (i8259A_auto_eoi);
    restore_ELCR (irq_trigger);
    return 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/i8259.c.ifdefed" startline="247" endline="250">
{
    save_ELCR (irq_trigger);
    return 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/i8259.c.ifdefed" startline="253" endline="261">
{
    outb (0xff, PIC_MASTER_IMR);
    outb (0xff, PIC_SLAVE_IMR);
    return 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/i8259.c.ifdefed" startline="276" endline="281">
{
    int error = sysdev_class_register (&i8259_sysdev_class);
    if (!error)
        error = sysdev_register (&device_i8259A);
    return error;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/i8259.c.ifdefed" startline="286" endline="337">
{
    unsigned long flags;
    i8259A_auto_eoi = auto_eoi;
    spin_lock_irqsave (& i8259A_lock, flags);
    outb (0xff, PIC_MASTER_IMR);
    outb (0xff, PIC_SLAVE_IMR);
    outb_pic (0x11, PIC_MASTER_CMD);
    outb_pic (IRQ0_VECTOR, PIC_MASTER_IMR);
    outb_pic (1U << PIC_CASCADE_IR, PIC_MASTER_IMR);
    if (auto_eoi)
        outb_pic (MASTER_ICW4_DEFAULT | PIC_ICW4_AEOI, PIC_MASTER_IMR);
    else
        outb_pic (MASTER_ICW4_DEFAULT, PIC_MASTER_IMR);
    outb_pic (0x11, PIC_SLAVE_CMD);
    outb_pic (IRQ8_VECTOR, PIC_SLAVE_IMR);
    outb_pic (PIC_CASCADE_IR, PIC_SLAVE_IMR);
    outb_pic (SLAVE_ICW4_DEFAULT, PIC_SLAVE_IMR);
    if (auto_eoi)
        i8259A_chip.mask_ack = disable_8259A_irq;
    else
        i8259A_chip.mask_ack = mask_and_ack_8259A;
    udelay (100);
    outb (cached_master_mask, PIC_MASTER_IMR);
    outb (cached_slave_mask, PIC_SLAVE_IMR);
    spin_unlock_irqrestore (& i8259A_lock, flags);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/i387.c.ifdefed" startline="42" endline="55">
{
    unsigned long mask = 0;
    clts ();
    if (cpu_has_fxsr) {
        memset (& fx_scratch, 0, sizeof (struct i387_fxsave_struct));
        asm volatile ("fxsave %0"
            :
            : "m" (fx_scratch)
        ) mask = fx_scratch.mxcsr_mask;
        if (mask == 0)
            mask = 0x0000ffbf;
    }
    mxcsr_feature_mask &= mask;
    stts ();
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/i387.c.ifdefed" startline="46" endline="52">
{
    memset (& fx_scratch, 0, sizeof (struct i387_fxsave_struct));
    asm volatile ("fxsave %0"
        :
        : "m" (fx_scratch)
    ) mask = fx_scratch.mxcsr_mask;
    if (mask == 0)
        mask = 0x0000ffbf;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/i387.c.ifdefed" startline="58" endline="70">
{
    if (!HAVE_HWFP) {
        xstate_size = sizeof (struct i387_soft_struct);
        return;
    }
    if (cpu_has_fxsr)
        xstate_size = sizeof (struct i387_fxsave_struct);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/i387.c.ifdefed" startline="59" endline="62">
{
    xstate_size = sizeof (struct i387_soft_struct);
    return;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/i387.c.ifdefed" startline="100" endline="146">
{
    if (tsk_used_math (tsk)) {
        if (HAVE_HWFP && tsk == current)
            unlazy_fpu (tsk);
        return 0;
    }
    if (!tsk->thread.xstate) {
        tsk->thread.xstate = kmem_cache_alloc (task_xstate_cachep, GFP_KERNEL);
        if (!tsk->thread.xstate)
            return -ENOMEM;
    }
    if (cpu_has_fxsr) {
        struct i387_fxsave_struct *fx = &tsk->thread.xstate->fxsave;
        memset (fx, 0, xstate_size);
        fx->cwd = 0x37f;
        if (cpu_has_xmm)
            fx->mxcsr = MXCSR_DEFAULT;
    }
    else {
        struct i387_fsave_struct *fp = &tsk->thread.xstate->fsave;
        memset (fp, 0, xstate_size);
        fp->cwd = 0xffff037fu;
        fp->swd = 0xffff0000u;
        fp->twd = 0xffffffffu;
        fp->fos = 0xffff0000u;
    }
    set_stopped_child_used_math (tsk);
    return 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/i387.c.ifdefed" startline="101" endline="105">
{
    if (HAVE_HWFP && tsk == current)
        unlazy_fpu (tsk);
    return 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/i387.c.ifdefed" startline="110" endline="115">
{
    tsk->thread.xstate = kmem_cache_alloc (task_xstate_cachep, GFP_KERNEL);
    if (!tsk->thread.xstate)
        return -ENOMEM;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/i387.c.ifdefed" startline="126" endline="133">
{
    struct i387_fxsave_struct *fx = &tsk->thread.xstate->fxsave;
    memset (fx, 0, xstate_size);
    fx->cwd = 0x37f;
    if (cpu_has_xmm)
        fx->mxcsr = MXCSR_DEFAULT;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/i387.c.ifdefed" startline="133" endline="140">
{
    struct i387_fsave_struct *fp = &tsk->thread.xstate->fsave;
    memset (fp, 0, xstate_size);
    fp->cwd = 0xffff037fu;
    fp->swd = 0xffff0000u;
    fp->twd = 0xffffffffu;
    fp->fos = 0xffff0000u;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/i387.c.ifdefed" startline="149" endline="151">
{
    return tsk_used_math (target) ? regset->n : 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/i387.c.ifdefed" startline="154" endline="156">
{
    return (cpu_has_fxsr && tsk_used_math (target)) ? regset->n : 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/i387.c.ifdefed" startline="161" endline="173">
{
    int ret;
    if (!cpu_has_fxsr)
        return -ENODEV;
    ret = init_fpu (target);
    if (ret)
        return ret;
    return user_regset_copyout (&pos, &count, &kbuf, &ubuf, &target->thread.xstate->fxsave, 0, -1);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/i387.c.ifdefed" startline="178" endline="199">
{
    int ret;
    if (!cpu_has_fxsr)
        return -ENODEV;
    ret = init_fpu (target);
    if (ret)
        return ret;
    set_stopped_child_used_math (target);
    ret = user_regset_copyin (&pos, &count, &kbuf, &ubuf, &target->thread.xstate->fxsave, 0, -1);
    target->thread.xstate->fxsave.mxcsr &= mxcsr_feature_mask;
    return ret;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/vsmp_64.c.ifdefed" startline="109" endline="110">
{
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/vsmp_64.c.ifdefed" startline="140" endline="141">
{
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/vsmp_64.c.ifdefed" startline="143" endline="145">
{
    return 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/vsmp_64.c.ifdefed" startline="149" endline="156">
{
    detect_vsmp_box ();
    if (!is_vsmp_box ())
        return;
    set_vsmp_pv_ops ();
    return;
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/gup.c.ifdefed" startline="15" endline="63">
{
    return *ptep;
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/gup.c.ifdefed" startline="72" endline="99">
{
    unsigned long mask;
    pte_t *ptep;
    mask = _PAGE_PRESENT | _PAGE_USER;
    if (write)
        mask |= _PAGE_RW;
    ptep = pte_offset_map (&pmd, addr);
    do {
        pte_t pte = gup_get_pte (ptep);
        struct page *page;
        if ((pte_val (pte) & (mask | _PAGE_SPECIAL)) != mask) {
            pte_unmap (ptep);
            return 0;
        }
        VM_BUG_ON (! pfn_valid (pte_pfn (pte)));
        page = pte_page (pte);
        get_page (page);
        pages[*nr] = page;
        (*nr)++;
    }
    while (ptep++, addr += PAGE_SIZE, addr != end);
    pte_unmap (ptep - 1);
    return 1;
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/gup.c.ifdefed" startline="81" endline="95">
{
    pte_t pte = gup_get_pte (ptep);
    struct page *page;
    if ((pte_val (pte) & (mask | _PAGE_SPECIAL)) != mask) {
        pte_unmap (ptep);
        return 0;
    }
    VM_BUG_ON (! pfn_valid (pte_pfn (pte)));
    page = pte_page (pte);
    get_page (page);
    pages[*nr] = page;
    (*nr)++;
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/gup.c.ifdefed" startline="85" endline="88">
{
    pte_unmap (ptep);
    return 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/gup.c.ifdefed" startline="102" endline="106">
{
    VM_BUG_ON (page != compound_head (page));
    VM_BUG_ON (page_count (page) == 0);
    atomic_add (nr, & page -> _count);
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/gup.c.ifdefed" startline="110" endline="138">
{
    unsigned long mask;
    pte_t pte = *(pte_t*) &pmd;
    struct page *head, *page;
    int refs;
    mask = _PAGE_PRESENT | _PAGE_USER;
    if (write)
        mask |= _PAGE_RW;
    if ((pte_val (pte) & mask) != mask)
        return 0;
    VM_BUG_ON (pte_val (pte) & _PAGE_SPECIAL);
    VM_BUG_ON (! pfn_valid (pte_pfn (pte)));
    refs = 0;
    head = pte_page (pte);
    page = head + ((addr & ~PMD_MASK) >> PAGE_SHIFT);
    do {
        VM_BUG_ON (compound_head (page) != head);
        pages[*nr] = page;
        (*nr)++;
        page++;
        refs++;
    }
    while (addr += PAGE_SIZE, addr != end);
    get_head_page_multiple (head, refs);
    return 1;
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/gup.c.ifdefed" startline="128" endline="134">
{
    VM_BUG_ON (compound_head (page) != head);
    pages[*nr] = page;
    (*nr)++;
    page++;
    refs++;
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/gup.c.ifdefed" startline="142" endline="163">
{
    unsigned long next;
    pmd_t *pmdp;
    pmdp = pmd_offset (&pud, addr);
    do {
        pmd_t pmd = *pmdp;
        next = pmd_addr_end (addr, end);
        if (pmd_none (pmd))
            return 0;
        if (unlikely (pmd_large (pmd))) {
            if (!gup_huge_pmd (pmd, addr, next, write, pages, nr))
                return 0;
        }
        else {
            if (!gup_pte_range (pmd, addr, next, write, pages, nr))
                return 0;
        }
    }
    while (pmdp++, addr = next, addr != end);
    return 1;
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/gup.c.ifdefed" startline="147" endline="160">
{
    pmd_t pmd = *pmdp;
    next = pmd_addr_end (addr, end);
    if (pmd_none (pmd))
        return 0;
    if (unlikely (pmd_large (pmd))) {
        if (!gup_huge_pmd (pmd, addr, next, write, pages, nr))
            return 0;
    }
    else {
        if (!gup_pte_range (pmd, addr, next, write, pages, nr))
            return 0;
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/gup.c.ifdefed" startline="153" endline="156">
{
    if (!gup_huge_pmd (pmd, addr, next, write, pages, nr))
        return 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/gup.c.ifdefed" startline="156" endline="159">
{
    if (!gup_pte_range (pmd, addr, next, write, pages, nr))
        return 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/gup.c.ifdefed" startline="167" endline="195">
{
    unsigned long mask;
    pte_t pte = *(pte_t*) &pud;
    struct page *head, *page;
    int refs;
    mask = _PAGE_PRESENT | _PAGE_USER;
    if (write)
        mask |= _PAGE_RW;
    if ((pte_val (pte) & mask) != mask)
        return 0;
    VM_BUG_ON (pte_val (pte) & _PAGE_SPECIAL);
    VM_BUG_ON (! pfn_valid (pte_pfn (pte)));
    refs = 0;
    head = pte_page (pte);
    page = head + ((addr & ~PUD_MASK) >> PAGE_SHIFT);
    do {
        VM_BUG_ON (compound_head (page) != head);
        pages[*nr] = page;
        (*nr)++;
        page++;
        refs++;
    }
    while (addr += PAGE_SIZE, addr != end);
    get_head_page_multiple (head, refs);
    return 1;
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/gup.c.ifdefed" startline="185" endline="191">
{
    VM_BUG_ON (compound_head (page) != head);
    pages[*nr] = page;
    (*nr)++;
    page++;
    refs++;
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/gup.c.ifdefed" startline="199" endline="220">
{
    unsigned long next;
    pud_t *pudp;
    pudp = pud_offset (&pgd, addr);
    do {
        pud_t pud = *pudp;
        next = pud_addr_end (addr, end);
        if (pud_none (pud))
            return 0;
        if (unlikely (pud_large (pud))) {
            if (!gup_huge_pud (pud, addr, next, write, pages, nr))
                return 0;
        }
        else {
            if (!gup_pmd_range (pud, addr, next, write, pages, nr))
                return 0;
        }
    }
    while (pudp++, addr = next, addr != end);
    return 1;
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/gup.c.ifdefed" startline="204" endline="217">
{
    pud_t pud = *pudp;
    next = pud_addr_end (addr, end);
    if (pud_none (pud))
        return 0;
    if (unlikely (pud_large (pud))) {
        if (!gup_huge_pud (pud, addr, next, write, pages, nr))
            return 0;
    }
    else {
        if (!gup_pmd_range (pud, addr, next, write, pages, nr))
            return 0;
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/gup.c.ifdefed" startline="210" endline="213">
{
    if (!gup_huge_pud (pud, addr, next, write, pages, nr))
        return 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/gup.c.ifdefed" startline="213" endline="216">
{
    if (!gup_pmd_range (pud, addr, next, write, pages, nr))
        return 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/gup.c.ifdefed" startline="224" endline="298">
{
    struct mm_struct *mm = current->mm;
    unsigned long addr, len, end;
    unsigned long next;
    pgd_t *pgdp;
    int nr = 0;
    start &= PAGE_MASK;
    addr = start;
    len = (unsigned long) nr_pages << PAGE_SHIFT;
    end = start + len;
    if (unlikely (!access_ok (write ? VERIFY_WRITE : VERIFY_READ, start, len)))
        goto slow_irqon;
    local_irq_disable ();
    pgdp = pgd_offset (mm, addr);
    do {
        pgd_t pgd = *pgdp;
        next = pgd_addr_end (addr, end);
        if (pgd_none (pgd))
            goto slow;
        if (!gup_pud_range (pgd, addr, next, write, pages, &nr))
            goto slow;
    }
    while (pgdp++, addr = next, addr != end);
    local_irq_enable ();
    VM_BUG_ON (nr != (end - start) >> PAGE_SHIFT);
    return nr;
    {
        int ret;
    slow :
        local_irq_enable ();
    slow_irqon :
        start += nr << PAGE_SHIFT;
        pages += nr;
        down_read (& mm -> mmap_sem);
        ret = get_user_pages (current, mm, start, (end - start) >> PAGE_SHIFT, write, 0, pages, NULL);
        up_read (& mm -> mmap_sem);
        if (nr > 0) {
            if (ret < 0)
                ret = nr;
            else
                ret += nr;
        }
        return ret;
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/gup.c.ifdefed" startline="259" endline="267">
{
    pgd_t pgd = *pgdp;
    next = pgd_addr_end (addr, end);
    if (pgd_none (pgd))
        goto slow;
    if (!gup_pud_range (pgd, addr, next, write, pages, &nr))
        goto slow;
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/gup.c.ifdefed" startline="273" endline="297">
{
    int ret;
slow :
    local_irq_enable ();
slow_irqon :
    start += nr << PAGE_SHIFT;
    pages += nr;
    down_read (& mm -> mmap_sem);
    ret = get_user_pages (current, mm, start, (end - start) >> PAGE_SHIFT, write, 0, pages, NULL);
    up_read (& mm -> mmap_sem);
    if (nr > 0) {
        if (ret < 0)
            ret = nr;
        else
            ret += nr;
    }
    return ret;
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/gup.c.ifdefed" startline="289" endline="294">
{
    if (ret < 0)
        ret = nr;
    else
        ret += nr;
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/extable.c.ifdefed" startline="7" endline="31">
{
    const struct exception_table_entry *fixup;
    fixup = search_exception_tables (regs->ip);
    if (fixup) {
        regs->ip = fixup->fixup;
        return 1;
    }
    return 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/extable.c.ifdefed" startline="25" endline="28">
{
    regs->ip = fixup->fixup;
    return 1;
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/srat_64.c.ifdefed" startline="44" endline="46">
{
    return acpi_map_pxm_to_node (pxm);
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/srat_64.c.ifdefed" startline="49" endline="61">
{
    int i;
    for (i = 0; i < num_node_memblks; i++) {
        struct bootnode *nd = &node_memblk_range[i];
        if (nd->start == nd->end)
            continue;
        if (nd->end > start && nd->start < end)
            return memblk_nodeid[i];
        if (nd->end == end && nd->start == start)
            return memblk_nodeid[i];
    }
    return -1;
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/srat_64.c.ifdefed" startline="51" endline="59">
{
    struct bootnode *nd = &node_memblk_range[i];
    if (nd->start == nd->end)
        continue;
    if (nd->end > start && nd->start < end)
        return memblk_nodeid[i];
    if (nd->end == end && nd->start == start)
        return memblk_nodeid[i];
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/srat_64.c.ifdefed" startline="64" endline="80">
{
    struct bootnode *nd = &nodes[i];
    if (found_add_area)
        return;
    if (nd->start < start) {
        nd->start = start;
        if (nd->end < nd->start)
            nd->start = nd->end;
    }
    if (nd->end > end) {
        nd->end = end;
        if (nd->start > nd->end)
            nd->start = nd->end;
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/srat_64.c.ifdefed" startline="70" endline="74">
{
    nd->start = start;
    if (nd->end < nd->start)
        nd->start = nd->end;
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/srat_64.c.ifdefed" startline="75" endline="79">
{
    nd->end = end;
    if (nd->start > nd->end)
        nd->start = nd->end;
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/srat_64.c.ifdefed" startline="83" endline="93">
{
    int i;
    printk (KERN_ERR "SRAT: SRAT not used.\n");
    acpi_numa = -1;
    found_add_area = 0;
    for (i = 0; i < MAX_LOCAL_APIC; i++)
        apicid_to_node[i] = NUMA_NO_NODE;
    for (i = 0; i < MAX_NUMNODES; i++)
        nodes_add[i].start = nodes[i].end = 0;
    remove_all_active_ranges ();
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/srat_64.c.ifdefed" startline="96" endline="98">
{
    return numa_off || acpi_numa < 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/srat_64.c.ifdefed" startline="102" endline="116">
{
    unsigned length;
    unsigned long phys;
    length = slit->header.length;
    phys = find_e820_area (0, max_pfn_mapped << PAGE_SHIFT, length, PAGE_SIZE);
    if (phys == -1L)
        panic (" Can not save slit!\n");
    acpi_slit = __va (phys);
    memcpy (acpi_slit, slit, length);
    reserve_early (phys, phys + length, "ACPI SLIT");
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/srat_64.c.ifdefed" startline="121" endline="149">
{
    int pxm, node;
    int apic_id;
    if (srat_disabled ())
        return;
    if (pa->header.length != sizeof (struct acpi_srat_cpu_affinity)) {
        bad_srat ();
        return;
    }
    if ((pa->flags & ACPI_SRAT_CPU_ENABLED) == 0)
        return;
    pxm = pa->proximity_domain_lo;
    node = setup_node (pxm);
    if (node < 0) {
        printk (KERN_ERR "SRAT: Too many proximity domains %x\n", pxm);
        bad_srat ();
        return;
    }
    if (is_uv_system ())
        apic_id = (pa->apic_id << 8) | pa->local_sapic_eid;
    else
        apic_id = pa->apic_id;
    apicid_to_node[apic_id] = node;
    acpi_numa = 1;
    printk (KERN_INFO "SRAT: PXM %u -> APIC %u -> Node %u\n", pxm, apic_id, node);
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/srat_64.c.ifdefed" startline="127" endline="130">
{
    bad_srat ();
    return;
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/srat_64.c.ifdefed" startline="135" endline="139">
{
    printk (KERN_ERR "SRAT: Too many proximity domains %x\n", pxm);
    bad_srat ();
    return;
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/srat_64.c.ifdefed" startline="151" endline="151">
{
    return -1;
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/srat_64.c.ifdefed" startline="152" endline="152">
{
    return 1;
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/srat_64.c.ifdefed" startline="156" endline="156">
{
    return 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/srat_64.c.ifdefed" startline="165" endline="219">
{
    unsigned long s_pfn = start >> PAGE_SHIFT;
    unsigned long e_pfn = end >> PAGE_SHIFT;
    int ret = 0, changed = 0;
    struct bootnode *nd = &nodes_add[node];
    if ((signed long) (end - start) < NODE_MIN_SIZE) {
        printk (KERN_ERR "SRAT: Hotplug area too small\n");
        return -1;
    }
    if (absent_pages_in_range (s_pfn, e_pfn) != e_pfn - s_pfn) {
        printk (KERN_ERR "SRAT: Hotplug area %lu -> %lu has existing memory\n", s_pfn, e_pfn);
        return -1;
    }
    if (!hotadd_enough_memory (&nodes_add[node])) {
        printk (KERN_ERR "SRAT: Hotplug area too large\n");
        return -1;
    }
    if (nd->start == nd->end) {
        nd->start = start;
        nd->end = end;
        changed = 1;
    }
    else {
        if (nd->start == end) {
            nd->start = start;
            changed = 1;
        }
        if (nd->end == start) {
            nd->end = end;
            changed = 1;
        }
        if (!changed)
            printk (KERN_ERR "SRAT: Hotplug zone not continuous. Partly ignored\n");
    }
    ret = update_end_of_memory (nd->end);
    if (changed)
        printk (KERN_INFO "SRAT: hot plug zone found %Lx - %Lx\n", nd->start, nd->end);
    return ret;
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/srat_64.c.ifdefed" startline="177" endline="180">
{
    printk (KERN_ERR "SRAT: Hotplug area too small\n");
    return -1;
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/srat_64.c.ifdefed" startline="183" endline="188">
{
    printk (KERN_ERR "SRAT: Hotplug area %lu -> %lu has existing memory\n", s_pfn, e_pfn);
    return -1;
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/srat_64.c.ifdefed" startline="190" endline="193">
{
    printk (KERN_ERR "SRAT: Hotplug area too large\n");
    return -1;
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/srat_64.c.ifdefed" startline="197" endline="201">
{
    nd->start = start;
    nd->end = end;
    changed = 1;
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/srat_64.c.ifdefed" startline="201" endline="212">
{
    if (nd->start == end) {
        nd->start = start;
        changed = 1;
    }
    if (nd->end == start) {
        nd->end = end;
        changed = 1;
    }
    if (!changed)
        printk (KERN_ERR "SRAT: Hotplug zone not continuous. Partly ignored\n");
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/srat_64.c.ifdefed" startline="202" endline="205">
{
    nd->start = start;
    changed = 1;
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/srat_64.c.ifdefed" startline="206" endline="209">
{
    nd->end = end;
    changed = 1;
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/srat_64.c.ifdefed" startline="224" endline="295">
{
    struct bootnode *nd, oldnode;
    unsigned long start, end;
    int node, pxm;
    int i;
    if (srat_disabled ())
        return;
    if (ma->header.length != sizeof (struct acpi_srat_mem_affinity)) {
        bad_srat ();
        return;
    }
    if ((ma->flags & ACPI_SRAT_MEM_ENABLED) == 0)
        return;
    if ((ma->flags & ACPI_SRAT_MEM_HOT_PLUGGABLE) && !save_add_info ())
        return;
    start = ma->base_address;
    end = start + ma->length;
    pxm = ma->proximity_domain;
    node = setup_node (pxm);
    if (node < 0) {
        printk (KERN_ERR "SRAT: Too many proximity domains.\n");
        bad_srat ();
        return;
    }
    i = conflicting_memblks (start, end);
    if (i == node) {
        printk (KERN_WARNING "SRAT: Warning: PXM %d (%lx-%lx) overlaps with itself (%Lx-%Lx)\n", pxm, start, end, nodes [i].start, nodes [i].end);
    }
    else if (i >= 0) {
        printk (KERN_ERR "SRAT: PXM %d (%lx-%lx) overlaps with PXM %d (%Lx-%Lx)\n", pxm, start, end, node_to_pxm (i), nodes [i].start, nodes [i].end);
        bad_srat ();
        return;
    }
    nd = &nodes[node];
    oldnode = *nd;
    if (!node_test_and_set (node, nodes_parsed)) {
        nd->start = start;
        nd->end = end;
    }
    else {
        if (start < nd->start)
            nd->start = start;
        if (nd->end < end)
            nd->end = end;
    }
    printk (KERN_INFO "SRAT: Node %u PXM %u %lx-%lx\n", node, pxm, start, end);
    e820_register_active_regions (node, start >> PAGE_SHIFT, end >> PAGE_SHIFT);
    push_node_boundaries (node, nd -> start >> PAGE_SHIFT, nd -> end >> PAGE_SHIFT);
    if ((ma->flags & ACPI_SRAT_MEM_HOT_PLUGGABLE) && (reserve_hotadd (node, start, end) < 0)) {
        printk (KERN_NOTICE "SRAT: Hotplug region ignored\n");
        *nd = oldnode;
        if ((nd->start | nd->end) == 0)
            node_clear (node, nodes_parsed);
    }
    node_memblk_range[num_node_memblks].start = start;
    node_memblk_range[num_node_memblks].end = end;
    memblk_nodeid[num_node_memblks] = node;
    num_node_memblks++;
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/srat_64.c.ifdefed" startline="232" endline="235">
{
    bad_srat ();
    return;
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/srat_64.c.ifdefed" startline="245" endline="249">
{
    printk (KERN_ERR "SRAT: Too many proximity domains.\n");
    bad_srat ();
    return;
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/srat_64.c.ifdefed" startline="251" endline="255">
{
    printk (KERN_WARNING "SRAT: Warning: PXM %d (%lx-%lx) overlaps with itself (%Lx-%Lx)\n", pxm, start, end, nodes [i].start, nodes [i].end);
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/srat_64.c.ifdefed" startline="255" endline="262">
{
    printk (KERN_ERR "SRAT: PXM %d (%lx-%lx) overlaps with PXM %d (%Lx-%Lx)\n", pxm, start, end, node_to_pxm (i), nodes [i].start, nodes [i].end);
    bad_srat ();
    return;
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/srat_64.c.ifdefed" startline="265" endline="268">
{
    nd->start = start;
    nd->end = end;
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/srat_64.c.ifdefed" startline="268" endline="273">
{
    if (start < nd->start)
        nd->start = start;
    if (nd->end < end)
        nd->end = end;
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/srat_64.c.ifdefed" startline="283" endline="289">
{
    printk (KERN_NOTICE "SRAT: Hotplug region ignored\n");
    *nd = oldnode;
    if ((nd->start | nd->end) == 0)
        node_clear (node, nodes_parsed);
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/srat_64.c.ifdefed" startline="300" endline="324">
{
    int i;
    unsigned long pxmram, e820ram;
    pxmram = 0;

    for_each_node_mask (i, nodes_parsed) {
        unsigned long s = nodes[i].start >> PAGE_SHIFT;
        unsigned long e = nodes[i].end >> PAGE_SHIFT;
        pxmram += e - s;
        pxmram -= absent_pages_in_range (s, e);
        if ((long) pxmram < 0)
            pxmram = 0;
    }

    e820ram = max_pfn - absent_pages_in_range (0, max_pfn);
    if ((long) (e820ram - pxmram) >= 1 * 1024 * 1024) {
        printk (KERN_ERR "SRAT: PXMs only cover %luMB of your %luMB e820 RAM. Not used.\n", (pxmram << PAGE_SHIFT) >> 20, (e820ram << PAGE_SHIFT) >> 20);
        return 0;
    }
    return 1;
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/srat_64.c.ifdefed" startline="305" endline="312">
{
    unsigned long s = nodes[i].start >> PAGE_SHIFT;
    unsigned long e = nodes[i].end >> PAGE_SHIFT;
    pxmram += e - s;
    pxmram -= absent_pages_in_range (s, e);
    if ((long) pxmram < 0)
        pxmram = 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/srat_64.c.ifdefed" startline="316" endline="322">
{
    printk (KERN_ERR "SRAT: PXMs only cover %luMB of your %luMB e820 RAM. Not used.\n", (pxmram << PAGE_SHIFT) >> 20, (e820ram << PAGE_SHIFT) >> 20);
    return 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/srat_64.c.ifdefed" startline="327" endline="334">
{
    int i;
    node_clear (node, nodes_parsed);
    for (i = 0; i < MAX_LOCAL_APIC; i++) {
        if (apicid_to_node[i] == node)
            apicid_to_node[i] = NUMA_NO_NODE;
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/srat_64.c.ifdefed" startline="330" endline="333">
{
    if (apicid_to_node[i] == node)
        apicid_to_node[i] = NUMA_NO_NODE;
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/srat_64.c.ifdefed" startline="336" endline="336">
{
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/srat_64.c.ifdefed" startline="340" endline="395">
{
    int i;
    if (acpi_numa <= 0)
        return -1;
    for (i = 0; i < MAX_NUMNODES; i++) {
        cutoff_node (i, start, end);
        if (nodes[i].end && (nodes[i].end - nodes[i].start) < NODE_MIN_SIZE) {
            unparse_node (i);
            node_set_offline (i);
        }
    }
    if (!nodes_cover_memory (nodes)) {
        bad_srat ();
        return -1;
    }
    memnode_shift = compute_hash_shift (node_memblk_range, num_node_memblks, memblk_nodeid);
    if (memnode_shift < 0) {
        printk (KERN_ERR "SRAT: No NUMA node hash function found. Contact maintainer\n");
        bad_srat ();
        return -1;
    }
    node_possible_map = nodes_parsed;
    for_each_node_mask (i, node_possible_map)
    setup_node_bootmem (i, nodes [i].start, nodes [i].end);
    for_each_node_mask (i, node_possible_map)
    if (!node_online (i))
        setup_node_bootmem (i, nodes[i].start, nodes[i].end);
    for (i = 0; i < NR_CPUS; i++) {
        int node = early_cpu_to_node (i);
        if (node == NUMA_NO_NODE)
            continue;
        if (!node_isset (node, node_possible_map))
            numa_clear_node (i);
    }
    numa_init_array ();
    return 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/srat_64.c.ifdefed" startline="347" endline="358">
{
    cutoff_node (i, start, end);
    if (nodes[i].end && (nodes[i].end - nodes[i].start) < NODE_MIN_SIZE) {
        unparse_node (i);
        node_set_offline (i);
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/srat_64.c.ifdefed" startline="354" endline="357">
{
    unparse_node (i);
    node_set_offline (i);
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/srat_64.c.ifdefed" startline="360" endline="363">
{
    bad_srat ();
    return -1;
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/srat_64.c.ifdefed" startline="367" endline="372">
{
    printk (KERN_ERR "SRAT: No NUMA node hash function found. Contact maintainer\n");
    bad_srat ();
    return -1;
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/srat_64.c.ifdefed" startline="385" endline="392">
{
    int node = early_cpu_to_node (i);
    if (node == NUMA_NO_NODE)
        continue;
    if (!node_isset (node, node_possible_map))
        numa_clear_node (i);
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/srat_64.c.ifdefed" startline="472" endline="474">
{
    return a == b;
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/srat_64.c.ifdefed" startline="478" endline="495">
{
    if (found_add_area && nodes_add[nodeid].end) {
        u64 total_mb;
        printk (KERN_INFO "SRAT: Reserving hot-add memory space " "for node %d at %Lx-%Lx\n", nodeid, nodes_add [nodeid].start, nodes_add [nodeid].end);
        total_mb = (nodes_add[nodeid].end - nodes_add[nodeid].start) >> PAGE_SHIFT;
        total_mb *= sizeof (struct page);
        total_mb >>= 20;
        printk (KERN_INFO "SRAT: This will cost you %Lu MB of " "pre-allocated memory.\n", (unsigned long long) total_mb);
        reserve_bootmem_node (NODE_DATA (nodeid), nodes_add [nodeid].start, nodes_add [nodeid].end - nodes_add [nodeid].start, BOOTMEM_DEFAULT);
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/srat_64.c.ifdefed" startline="479" endline="494">
{
    u64 total_mb;
    printk (KERN_INFO "SRAT: Reserving hot-add memory space " "for node %d at %Lx-%Lx\n", nodeid, nodes_add [nodeid].start, nodes_add [nodeid].end);
    total_mb = (nodes_add[nodeid].end - nodes_add[nodeid].start) >> PAGE_SHIFT;
    total_mb *= sizeof (struct page);
    total_mb >>= 20;
    printk (KERN_INFO "SRAT: This will cost you %Lu MB of " "pre-allocated memory.\n", (unsigned long long) total_mb);
    reserve_bootmem_node (NODE_DATA (nodeid), nodes_add [nodeid].start, nodes_add [nodeid].end - nodes_add [nodeid].start, BOOTMEM_DEFAULT);
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/srat_64.c.ifdefed" startline="498" endline="506">
{
    int index;
    if (!acpi_slit)
        return null_slit_node_compare (a, b) ? LOCAL_DISTANCE : REMOTE_DISTANCE;
    index = acpi_slit->locality_count * node_to_pxm (a);
    return acpi_slit->entry[index + node_to_pxm (b)];
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/pat.c.ifdefed" startline="50" endline="53">
{
    debug_enable = 1;
    return 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/pat.c.ifdefed" startline="74" endline="115">
{
    u64 pat;
    if (!pat_enabled)
        return;
    if (!cpu_has_pat && boot_pat_state) {
        printk (KERN_ERR "PAT enabled, " "but not supported by secondary CPU\n");
        BUG ();
    }
    pat = PAT (0, WB) | PAT (1, WC) | PAT (2, UC_MINUS) | PAT (3, UC) | PAT (4, WB) | PAT (5, WC) | PAT (6, UC_MINUS) | PAT (7, UC);
    if (!boot_pat_state)
        rdmsrl (MSR_IA32_CR_PAT, boot_pat_state);
    wrmsrl (MSR_IA32_CR_PAT, pat);
    printk (KERN_INFO "x86 PAT enabled: cpu %d, old 0x%Lx, new 0x%Lx\n", smp_processor_id (), boot_pat_state, pat);
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/pat.c.ifdefed" startline="81" endline="90">
{
    printk (KERN_ERR "PAT enabled, " "but not supported by secondary CPU\n");
    BUG ();
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/pat.c.ifdefed" startline="120" endline="128">
{
    switch (flags & _PAGE_CACHE_MASK) {
    case _PAGE_CACHE_UC :
        return "uncached";
    case _PAGE_CACHE_UC_MINUS :
        return "uncached-minus";
    case _PAGE_CACHE_WB :
        return "write-back";
    case _PAGE_CACHE_WC :
        return "write-combining";
    default :
        return "broken";
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/pat.c.ifdefed" startline="121" endline="127">
{
case _PAGE_CACHE_UC :
    return "uncached";
case _PAGE_CACHE_UC_MINUS :
    return "uncached-minus";
case _PAGE_CACHE_WB :
    return "write-back";
case _PAGE_CACHE_WC :
    return "write-combining";
default :
    return "broken";
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/pat.c.ifdefed" startline="165" endline="181">
{
    if (req_type == _PAGE_CACHE_WB) {
        u8 mtrr_type;
        mtrr_type = mtrr_type_lookup (start, end);
        if (mtrr_type == MTRR_TYPE_UNCACHABLE)
            return _PAGE_CACHE_UC;
        if (mtrr_type == MTRR_TYPE_WRCOMB)
            return _PAGE_CACHE_WC;
    }
    return req_type;
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/pat.c.ifdefed" startline="170" endline="178">
{
    u8 mtrr_type;
    mtrr_type = mtrr_type_lookup (start, end);
    if (mtrr_type == MTRR_TYPE_UNCACHABLE)
        return _PAGE_CACHE_UC;
    if (mtrr_type == MTRR_TYPE_WRCOMB)
        return _PAGE_CACHE_WC;
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/pat.c.ifdefed" startline="185" endline="208">
{
    if (new->type != entry->type) {
        if (type) {
            new->type = entry->type;
            *type = entry->type;
        }
        else
            goto conflict;
    }
    list_for_each_entry_continue (entry, &memtype_list, nd) {
        if (new->end <= entry->start)
            break;
        else if (new->type != entry->type)
            goto conflict;
    }
    return 0;
conflict :
    printk (KERN_INFO "%s:%d conflicting memory types " "%Lx-%Lx %s<->%s\n", current->comm, current->pid, new->start, new->end, cattr_name (new->type), cattr_name (entry->type));
    return -EBUSY;
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/pat.c.ifdefed" startline="186" endline="192">
{
    if (type) {
        new->type = entry->type;
        *type = entry->type;
    }
    else
        goto conflict;
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/pat.c.ifdefed" startline="187" endline="190">
{
    new->type = entry->type;
    *type = entry->type;
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/pat.c.ifdefed" startline="195" endline="200">
{
    if (new->end <= entry->start)
        break;
    else if (new->type != entry->type)
        goto conflict;
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/pat.c.ifdefed" startline="230" endline="355">
{
    struct memtype *new, *entry;
    unsigned long actual_type;
    struct list_head *where;
    int err = 0;
    BUG_ON (start >= end);
    if (!pat_enabled) {
        if (new_type) {
            if (req_type == -1)
                *new_type = _PAGE_CACHE_WB;
            else
                *new_type = req_type & _PAGE_CACHE_MASK;
        }
        return 0;
    }
    if (is_ISA_range (start, end -1)) {
        if (new_type)
            *new_type = _PAGE_CACHE_WB;
        return 0;
    }
    if (req_type == -1) {
        u8 mtrr_type = mtrr_type_lookup (start, end);
        if (mtrr_type == MTRR_TYPE_WRBACK)
            actual_type = _PAGE_CACHE_WB;
        else
            actual_type = _PAGE_CACHE_UC_MINUS;
    }
    else
        actual_type = pat_x_mtrr_type (start, end, req_type &_PAGE_CACHE_MASK);
    new = kmalloc (sizeof (struct memtype), GFP_KERNEL);
    if (!new)
        return -ENOMEM;
    new->start = start;
    new->end = end;
    new->type = actual_type;
    if (new_type)
        *new_type = actual_type;
    spin_lock (& memtype_lock);
    if (cached_entry && start >= cached_start)
        entry = cached_entry;
    else
        entry = list_entry (&memtype_list, struct memtype, nd);
    where = NULL;
    list_for_each_entry_continue (entry, &memtype_list, nd) {
        if (end <= entry->start) {
            where = entry->nd.prev;
            cached_entry = list_entry (where, struct memtype, nd);
            break;
        }
        else if (start <= entry->start) {
            err = chk_conflict (new, entry, new_type);
            if (!err) {
                dprintk ("Overlap at 0x%Lx-0x%Lx\n", entry -> start, entry -> end);
                where = entry->nd.prev;
                cached_entry = list_entry (where, struct memtype, nd);
            }
            break;
        }
        else if (start < entry->end) {
            err = chk_conflict (new, entry, new_type);
            if (!err) {
                dprintk ("Overlap at 0x%Lx-0x%Lx\n", entry -> start, entry -> end);
                cached_entry = list_entry (entry->nd.prev, struct memtype, nd);
                list_for_each_entry_continue (entry, &memtype_list, nd) {
                    if (start <= entry->start) {
                        where = entry->nd.prev;
                        break;
                    }
                }
            }
            break;
        }
    }
    if (err) {
        printk (KERN_INFO "reserve_memtype failed 0x%Lx-0x%Lx, " "track %s, req %s\n", start, end, cattr_name (new -> type), cattr_name (req_type));
        kfree (new);
        spin_unlock (& memtype_lock);
        return err;
    }
    cached_start = start;
    if (where)
        list_add (&new->nd, where);
    else
        list_add_tail (&new->nd, &memtype_list);
    spin_unlock (& memtype_lock);
    dprintk ("reserve_memtype added 0x%Lx-0x%Lx, track %s, req %s, ret %s\n", start, end, cattr_name (new -> type), cattr_name (req_type), new_type ? cattr_name (* new_type) : "-");
    return err;
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/pat.c.ifdefed" startline="238" endline="247">
{
    if (new_type) {
        if (req_type == -1)
            *new_type = _PAGE_CACHE_WB;
        else
            *new_type = req_type & _PAGE_CACHE_MASK;
    }
    return 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/pat.c.ifdefed" startline="240" endline="245">
{
    if (req_type == -1)
        *new_type = _PAGE_CACHE_WB;
    else
        *new_type = req_type & _PAGE_CACHE_MASK;
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/pat.c.ifdefed" startline="250" endline="254">
{
    if (new_type)
        *new_type = _PAGE_CACHE_WB;
    return 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/pat.c.ifdefed" startline="256" endline="269">
{
    u8 mtrr_type = mtrr_type_lookup (start, end);
    if (mtrr_type == MTRR_TYPE_WRBACK)
        actual_type = _PAGE_CACHE_WB;
    else
        actual_type = _PAGE_CACHE_UC_MINUS;
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/pat.c.ifdefed" startline="293" endline="330">
{
    if (end <= entry->start) {
        where = entry->nd.prev;
        cached_entry = list_entry (where, struct memtype, nd);
        break;
    }
    else if (start <= entry->start) {
        err = chk_conflict (new, entry, new_type);
        if (!err) {
            dprintk ("Overlap at 0x%Lx-0x%Lx\n", entry -> start, entry -> end);
            where = entry->nd.prev;
            cached_entry = list_entry (where, struct memtype, nd);
        }
        break;
    }
    else if (start < entry->end) {
        err = chk_conflict (new, entry, new_type);
        if (!err) {
            dprintk ("Overlap at 0x%Lx-0x%Lx\n", entry -> start, entry -> end);
            cached_entry = list_entry (entry->nd.prev, struct memtype, nd);
            list_for_each_entry_continue (entry, &memtype_list, nd) {
                if (start <= entry->start) {
                    where = entry->nd.prev;
                    break;
                }
            }
        }
        break;
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/pat.c.ifdefed" startline="294" endline="298">
{
    where = entry->nd.prev;
    cached_entry = list_entry (where, struct memtype, nd);
    break;
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/pat.c.ifdefed" startline="298" endline="308">
{
    err = chk_conflict (new, entry, new_type);
    if (!err) {
        dprintk ("Overlap at 0x%Lx-0x%Lx\n", entry -> start, entry -> end);
        where = entry->nd.prev;
        cached_entry = list_entry (where, struct memtype, nd);
    }
    break;
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/pat.c.ifdefed" startline="300" endline="306">
{
    dprintk ("Overlap at 0x%Lx-0x%Lx\n", entry -> start, entry -> end);
    where = entry->nd.prev;
    cached_entry = list_entry (where, struct memtype, nd);
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/pat.c.ifdefed" startline="308" endline="329">
{
    err = chk_conflict (new, entry, new_type);
    if (!err) {
        dprintk ("Overlap at 0x%Lx-0x%Lx\n", entry -> start, entry -> end);
        cached_entry = list_entry (entry->nd.prev, struct memtype, nd);
        list_for_each_entry_continue (entry, &memtype_list, nd) {
            if (start <= entry->start) {
                where = entry->nd.prev;
                break;
            }
        }
    }
    break;
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/pat.c.ifdefed" startline="310" endline="327">
{
    dprintk ("Overlap at 0x%Lx-0x%Lx\n", entry -> start, entry -> end);
    cached_entry = list_entry (entry->nd.prev, struct memtype, nd);
    list_for_each_entry_continue (entry, &memtype_list, nd) {
        if (start <= entry->start) {
            where = entry->nd.prev;
            break;
        }
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/pat.c.ifdefed" startline="321" endline="326">
{
    if (start <= entry->start) {
        where = entry->nd.prev;
        break;
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/pat.c.ifdefed" startline="322" endline="325">
{
    where = entry->nd.prev;
    break;
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/pat.c.ifdefed" startline="332" endline="339">
{
    printk (KERN_INFO "reserve_memtype failed 0x%Lx-0x%Lx, " "track %s, req %s\n", start, end, cattr_name (new -> type), cattr_name (req_type));
    kfree (new);
    spin_unlock (& memtype_lock);
    return err;
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/pat.c.ifdefed" startline="358" endline="390">
{
    struct memtype *entry;
    int err = -EINVAL;
    if (!pat_enabled)
        return 0;
    if (is_ISA_range (start, end -1))
        return 0;
    spin_lock (& memtype_lock);
    list_for_each_entry (entry, &memtype_list, nd) {
        if (entry->start == start && entry->end == end) {
            if (cached_entry == entry || cached_start == start)
                cached_entry = NULL;
            list_del (& entry -> nd);
            kfree (entry);
            err = 0;
            break;
        }
    }
    spin_unlock (& memtype_lock);
    if (err) {
        printk (KERN_INFO "%s:%d freeing invalid memtype %Lx-%Lx\n", current -> comm, current -> pid, start, end);
    }
    dprintk ("free_memtype request 0x%Lx-0x%Lx\n", start, end);
    return err;
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/pat.c.ifdefed" startline="370" endline="380">
{
    if (entry->start == start && entry->end == end) {
        if (cached_entry == entry || cached_start == start)
            cached_entry = NULL;
        list_del (& entry -> nd);
        kfree (entry);
        err = 0;
        break;
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/pat.c.ifdefed" startline="371" endline="379">
{
    if (cached_entry == entry || cached_start == start)
        cached_entry = NULL;
    list_del (& entry -> nd);
    kfree (entry);
    err = 0;
    break;
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/pat.c.ifdefed" startline="383" endline="386">
{
    printk (KERN_INFO "%s:%d freeing invalid memtype %Lx-%Lx\n", current -> comm, current -> pid, start, end);
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/pat.c.ifdefed" startline="395" endline="397">
{
    return vma_prot;
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/pat.c.ifdefed" startline="407" endline="423">
{
    u64 from = ((u64) pfn) << PAGE_SHIFT;
    u64 to = from + size;
    u64 cursor = from;
    while (cursor < to) {
        if (!devmem_is_allowed (pfn)) {
            printk (KERN_INFO "Program %s tried to access /dev/mem between %Lx->%Lx.\n", current -> comm, from, to);
            return 0;
        }
        cursor += PAGE_SIZE;
        pfn++;
    }
    return 1;
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/pat.c.ifdefed" startline="412" endline="421">
{
    if (!devmem_is_allowed (pfn)) {
        printk (KERN_INFO "Program %s tried to access /dev/mem between %Lx->%Lx.\n", current -> comm, from, to);
        return 0;
    }
    cursor += PAGE_SIZE;
    pfn++;
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/pat.c.ifdefed" startline="413" endline="418">
{
    printk (KERN_INFO "Program %s tried to access /dev/mem between %Lx->%Lx.\n", current -> comm, from, to);
    return 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/pat.c.ifdefed" startline="428" endline="491">
{
    u64 offset = ((u64) pfn) << PAGE_SHIFT;
    unsigned long flags = -1;
    int retval;
    if (!range_is_allowed (pfn, size))
        return 0;
    if (file->f_flags & O_SYNC) {
        flags = _PAGE_CACHE_UC_MINUS;
    }
    if (flags != -1) {
        retval = reserve_memtype (offset, offset +size, flags, NULL);
    }
    else {
        retval = reserve_memtype (offset, offset +size, -1, &flags);
    }
    if (retval < 0)
        return 0;
    if (((pfn < max_low_pfn_mapped) || (pfn >= (1UL << (32 - PAGE_SHIFT)) && pfn < max_pfn_mapped)) && ioremap_change_attr ((unsigned long) __va (offset), size, flags) < 0) {
        free_memtype (offset, offset + size);
        printk (KERN_INFO "%s:%d /dev/mem ioremap_change_attr failed %s for %Lx-%Lx\n", current -> comm, current -> pid, cattr_name (flags), offset, (unsigned long long) (offset + size));
        return 0;
    }
    *vma_prot = __pgprot ((pgprot_val (*vma_prot) & ~_PAGE_CACHE_MASK) | flags);
    return 1;
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/pat.c.ifdefed" startline="436" endline="438">
{
    flags = _PAGE_CACHE_UC_MINUS;
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/pat.c.ifdefed" startline="467" endline="469">
{
    retval = reserve_memtype (offset, offset +size, flags, NULL);
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/pat.c.ifdefed" startline="469" endline="471">
{
    retval = reserve_memtype (offset, offset +size, -1, &flags);
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/pat.c.ifdefed" startline="478" endline="486">
{
    free_memtype (offset, offset + size);
    printk (KERN_INFO "%s:%d /dev/mem ioremap_change_attr failed %s for %Lx-%Lx\n", current -> comm, current -> pid, cattr_name (flags), offset, (unsigned long long) (offset + size));
    return 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/pat.c.ifdefed" startline="494" endline="508">
{
    u64 addr = (u64) pfn << PAGE_SHIFT;
    unsigned long flags;
    unsigned long want_flags = (pgprot_val (vma_prot) & _PAGE_CACHE_MASK);
    reserve_memtype (addr, addr + size, want_flags, & flags);
    if (flags != want_flags) {
        printk (KERN_INFO "%s:%d /dev/mem expected mapping type %s for %Lx-%Lx, got %s\n", current -> comm, current -> pid, cattr_name (want_flags), addr, (unsigned long long) (addr + size), cattr_name (flags));
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/pat.c.ifdefed" startline="500" endline="507">
{
    printk (KERN_INFO "%s:%d /dev/mem expected mapping type %s for %Lx-%Lx, got %s\n", current -> comm, current -> pid, cattr_name (want_flags), addr, (unsigned long long) (addr + size), cattr_name (flags));
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/pat.c.ifdefed" startline="511" endline="515">
{
    u64 addr = (u64) pfn << PAGE_SHIFT;
    free_memtype (addr, addr + size);
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/numa_64.c.ifdefed" startline="45" endline="71">
{
    unsigned long addr, end;
    int i, res = -1;
    memset (memnodemap, 0xff, sizeof (s16) * memnodemapsize);
    for (i = 0; i < numnodes; i++) {
        addr = nodes[i].start;
        end = nodes[i].end;
        if (addr >= end)
            continue;
        if ((end >> shift) >= memnodemapsize)
            return 0;
        do {
            if (memnodemap[addr >> shift] != NUMA_NO_NODE)
                return -1;
            if (!nodeids)
                memnodemap[addr >> shift] = i;
            else
                memnodemap[addr >> shift] = nodeids[i];
            addr += (1UL << shift);
        }
        while (addr < end);
        res = 1;
    }
    return res;
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/numa_64.c.ifdefed" startline="50" endline="69">
{
    addr = nodes[i].start;
    end = nodes[i].end;
    if (addr >= end)
        continue;
    if ((end >> shift) >= memnodemapsize)
        return 0;
    do {
        if (memnodemap[addr >> shift] != NUMA_NO_NODE)
            return -1;
        if (!nodeids)
            memnodemap[addr >> shift] = i;
        else
            memnodemap[addr >> shift] = nodeids[i];
        addr += (1UL << shift);
    }
    while (addr < end);
    res = 1;
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/numa_64.c.ifdefed" startline="57" endline="67">
{
    if (memnodemap[addr >> shift] != NUMA_NO_NODE)
        return -1;
    if (!nodeids)
        memnodemap[addr >> shift] = i;
    else
        memnodemap[addr >> shift] = nodeids[i];
    addr += (1UL << shift);
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/numa_64.c.ifdefed" startline="74" endline="97">
{
    unsigned long addr;
    memnodemap = memnode.embedded_map;
    if (memnodemapsize <= ARRAY_SIZE (memnode.embedded_map))
        return 0;
    addr = 0x8000;
    nodemap_size = round_up (sizeof (s16) * memnodemapsize, L1_CACHE_BYTES);
    nodemap_addr = find_e820_area (addr, max_pfn << PAGE_SHIFT, nodemap_size, L1_CACHE_BYTES);
    if (nodemap_addr == -1UL) {
        printk (KERN_ERR "NUMA: Unable to allocate Memory to Node hash map\n");
        nodemap_addr = nodemap_size = 0;
        return -1;
    }
    memnodemap = phys_to_virt (nodemap_addr);
    reserve_early (nodemap_addr, nodemap_addr + nodemap_size, "MEMNODEMAP");
    printk (KERN_DEBUG "NUMA: Allocated memnodemap from %lx - %lx\n", nodemap_addr, nodemap_addr + nodemap_size);
    return 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/numa_64.c.ifdefed" startline="85" endline="90">
{
    printk (KERN_ERR "NUMA: Unable to allocate Memory to Node hash map\n");
    nodemap_addr = nodemap_size = 0;
    return -1;
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/numa_64.c.ifdefed" startline="105" endline="126">
{
    int i, nodes_used = 0;
    unsigned long start, end;
    unsigned long bitfield = 0, memtop = 0;
    for (i = 0; i < numnodes; i++) {
        start = nodes[i].start;
        end = nodes[i].end;
        if (start >= end)
            continue;
        bitfield |= start;
        nodes_used++;
        if (end > memtop)
            memtop = end;
    }
    if (nodes_used <= 1)
        i = 63;
    else
        i = find_first_bit (&bitfield, sizeof (unsigned long) * 8);
    memnodemapsize = (memtop >> i) + 1;
    return i;
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/numa_64.c.ifdefed" startline="110" endline="119">
{
    start = nodes[i].start;
    end = nodes[i].end;
    if (start >= end)
        continue;
    bitfield |= start;
    nodes_used++;
    if (end > memtop)
        memtop = end;
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/numa_64.c.ifdefed" startline="130" endline="146">
{
    int shift;
    shift = extract_lsb_from_nodes (nodes, numnodes);
    if (allocate_cachealigned_memnodemap ())
        return -1;
    printk (KERN_DEBUG "NUMA: Using %d for the hash shift.\n", shift);
    if (populate_memnodemap (nodes, numnodes, shift, nodeids) != 1) {
        printk (KERN_INFO "Your memory is not aligned you need to " "rebuild your kernel with a bigger NODEMAPSIZE " "shift=%d\n", shift);
        return -1;
    }
    return shift;
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/numa_64.c.ifdefed" startline="139" endline="144">
{
    printk (KERN_INFO "Your memory is not aligned you need to " "rebuild your kernel with a bigger NODEMAPSIZE " "shift=%d\n", shift);
    return -1;
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/numa_64.c.ifdefed" startline="149" endline="151">
{
    return phys_to_nid (pfn << PAGE_SHIFT);
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/numa_64.c.ifdefed" startline="156" endline="170">
{
    unsigned long mem = find_e820_area (start, end, size, align);
    void *ptr;
    if (mem != -1L)
        return __va (mem);
    ptr = __alloc_bootmem_nopanic (size, align, __pa (MAX_DMA_ADDRESS));
    if (ptr == NULL) {
        printk (KERN_ERR "Cannot find %lu bytes in node %d\n", size, nodeid);
        return NULL;
    }
    return ptr;
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/numa_64.c.ifdefed" startline="164" endline="168">
{
    printk (KERN_ERR "Cannot find %lu bytes in node %d\n", size, nodeid);
    return NULL;
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/numa_64.c.ifdefed" startline="175" endline="267">
{
    unsigned long start_pfn, last_pfn, bootmap_pages, bootmap_size;
    unsigned long bootmap_start, nodedata_phys;
    void *bootmap;
    const int pgdat_size = round_up (sizeof (pg_data_t), PAGE_SIZE);
    int nid;
    start = round_up (start, ZONE_ALIGN);
    printk (KERN_INFO "Bootmem setup node %d %016lx-%016lx\n", nodeid, start, end);
    start_pfn = start >> PAGE_SHIFT;
    last_pfn = end >> PAGE_SHIFT;
    node_data[nodeid] = early_node_mem (nodeid, start, end, pgdat_size, SMP_CACHE_BYTES);
    if (node_data[nodeid] == NULL)
        return;
    nodedata_phys = __pa (node_data[nodeid]);
    printk (KERN_INFO "  NODE_DATA [%016lx - %016lx]\n", nodedata_phys, nodedata_phys + pgdat_size - 1);
    memset (NODE_DATA (nodeid), 0, sizeof (pg_data_t));
    NODE_DATA (nodeid)->bdata = &bootmem_node_data[nodeid];
    NODE_DATA (nodeid)->node_start_pfn = start_pfn;
    NODE_DATA (nodeid)->node_spanned_pages = last_pfn - start_pfn;
    bootmap_pages = bootmem_bootmap_pages (last_pfn -start_pfn);
    nid = phys_to_nid (nodedata_phys);
    if (nid == nodeid)
        bootmap_start = round_up (nodedata_phys +pgdat_size, PAGE_SIZE);
    else
        bootmap_start = round_up (start, PAGE_SIZE);
    bootmap = early_node_mem (nodeid, bootmap_start, end, bootmap_pages << PAGE_SHIFT, PAGE_SIZE);
    if (bootmap == NULL) {
        if (nodedata_phys < start || nodedata_phys >= end)
            free_bootmem (nodedata_phys, pgdat_size);
        node_data[nodeid] = NULL;
        return;
    }
    bootmap_start = __pa (bootmap);
    bootmap_size = init_bootmem_node (NODE_DATA (nodeid), bootmap_start >> PAGE_SHIFT, start_pfn, last_pfn);
    printk (KERN_INFO "  bootmap [%016lx -  %016lx] pages %lx\n", bootmap_start, bootmap_start + bootmap_size - 1, bootmap_pages);
    free_bootmem_with_active_regions (nodeid, end);
    early_res_to_bootmem (start, end);
    if (nid != nodeid)
        printk (KERN_INFO "    NODE_DATA(%d) on node %d\n", nodeid, nid);
    else
        reserve_bootmem_node (NODE_DATA (nodeid), nodedata_phys, pgdat_size, BOOTMEM_DEFAULT);
    nid = phys_to_nid (bootmap_start);
    if (nid != nodeid)
        printk (KERN_INFO "    bootmap(%d) on node %d\n", nodeid, nid);
    else
        reserve_bootmem_node (NODE_DATA (nodeid), bootmap_start, bootmap_pages << PAGE_SHIFT, BOOTMEM_DEFAULT);
    node_set_online (nodeid);
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/numa_64.c.ifdefed" startline="222" endline="227">
{
    if (nodedata_phys < start || nodedata_phys >= end)
        free_bootmem (nodedata_phys, pgdat_size);
    node_data[nodeid] = NULL;
    return;
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/numa_64.c.ifdefed" startline="277" endline="289">
{
    int rr, i;
    rr = first_node (node_online_map);
    for (i = 0; i < NR_CPUS; i++) {
        if (early_cpu_to_node (i) != NUMA_NO_NODE)
            continue;
        numa_set_node (i, rr);
        rr = next_node (rr, node_online_map);
        if (rr == MAX_NUMNODES)
            rr = first_node (node_online_map);
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/numa_64.c.ifdefed" startline="281" endline="288">
{
    if (early_cpu_to_node (i) != NUMA_NO_NODE)
        continue;
    numa_set_node (i, rr);
    rr = next_node (rr, node_online_map);
    if (rr == MAX_NUMNODES)
        rr = first_node (node_online_map);
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/numa_64.c.ifdefed" startline="512" endline="556">
{
    int i;
    nodes_clear (node_possible_map);
    nodes_clear (node_online_map);
    printk (KERN_INFO "%s\n", numa_off ? "NUMA turned off" : "No NUMA configuration found");
    printk (KERN_INFO "Faking a node at %016lx-%016lx\n", start_pfn << PAGE_SHIFT, last_pfn << PAGE_SHIFT);
    memnode_shift = 63;
    memnodemap = memnode.embedded_map;
    memnodemap[0] = 0;
    node_set_online (0);
    node_set (0, node_possible_map);
    for (i = 0; i < NR_CPUS; i++)
        numa_set_node (i, 0);
    e820_register_active_regions (0, start_pfn, last_pfn);
    setup_node_bootmem (0, start_pfn << PAGE_SHIFT, last_pfn << PAGE_SHIFT);
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/numa_64.c.ifdefed" startline="559" endline="567">
{
    unsigned long pages = 0;
    int i;
    for_each_online_node (i)
    pages += free_all_bootmem_node (NODE_DATA (i));
    return pages;
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/numa_64.c.ifdefed" startline="570" endline="582">
{
    unsigned long max_zone_pfns [MAX_NR_ZONES];
    memset (max_zone_pfns, 0, sizeof (max_zone_pfns));
    max_zone_pfns[ZONE_DMA] = MAX_DMA_PFN;
    max_zone_pfns[ZONE_DMA32] = MAX_DMA32_PFN;
    max_zone_pfns[ZONE_NORMAL] = max_pfn;
    sparse_memory_present_with_active_regions (MAX_NUMNODES);
    sparse_init ();
    free_area_init_nodes (max_zone_pfns);
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/numa_64.c.ifdefed" startline="585" endline="601">
{
    if (!opt)
        return -EINVAL;
    if (!strncmp (opt, "off", 3))
        numa_off = 1;
    return 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/k8topology_64.c.ifdefed" startline="28" endline="49">
{
    int num;
    for (num = 0; num < 32; num++) {
        u32 header;
        header = read_pci_config (0, num, 0, 0x00);
        if (header != (PCI_VENDOR_ID_AMD | (0x1100 << 16)) && header != (PCI_VENDOR_ID_AMD | (0x1200 << 16)) && header != (PCI_VENDOR_ID_AMD | (0x1300 << 16)))
            continue;
        header = read_pci_config (0, num, 1, 0x00);
        if (header != (PCI_VENDOR_ID_AMD | (0x1101 << 16)) && header != (PCI_VENDOR_ID_AMD | (0x1201 << 16)) && header != (PCI_VENDOR_ID_AMD | (0x1301 << 16)))
            continue;
        return num;
    }
    return -1;
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/k8topology_64.c.ifdefed" startline="31" endline="46">
{
    u32 header;
    header = read_pci_config (0, num, 0, 0x00);
    if (header != (PCI_VENDOR_ID_AMD | (0x1100 << 16)) && header != (PCI_VENDOR_ID_AMD | (0x1200 << 16)) && header != (PCI_VENDOR_ID_AMD | (0x1300 << 16)))
        continue;
    header = read_pci_config (0, num, 1, 0x00);
    if (header != (PCI_VENDOR_ID_AMD | (0x1101 << 16)) && header != (PCI_VENDOR_ID_AMD | (0x1201 << 16)) && header != (PCI_VENDOR_ID_AMD | (0x1301 << 16)))
        continue;
    return num;
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/k8topology_64.c.ifdefed" startline="52" endline="77">
{
    early_init_lapic_mapping ();
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/k8topology_64.c.ifdefed" startline="80" endline="224">
{
    unsigned numnodes, cores, bits, apicid_base;
    unsigned long prevbase;
    struct bootnode nodes [8];
    unsigned char nodeids [8];
    int i, j, nb, found = 0;
    u32 nodeid, reg;
    if (!early_pci_allowed ())
        return -1;
    nb = find_northbridge ();
    if (nb < 0)
        return nb;
    printk (KERN_INFO "Scanning NUMA topology in Northbridge %d\n", nb);
    reg = read_pci_config (0, nb, 0, 0x60);
    numnodes = ((reg >> 4) & 0xF) + 1;
    if (numnodes <= 1)
        return -1;
    printk (KERN_INFO "Number of nodes %d\n", numnodes);
    memset (& nodes, 0, sizeof (nodes));
    prevbase = 0;
    for (i = 0; i < 8; i++) {
        unsigned long base, limit;
        base = read_pci_config (0, nb, 1, 0x40 + i * 8);
        limit = read_pci_config (0, nb, 1, 0x44 + i * 8);
        nodeid = limit & 7;
        nodeids[i] = nodeid;
        if ((base & 3) == 0) {
            if (i < numnodes)
                printk ("Skipping disabled node %d\n", i);
            continue;
        }
        if (nodeid >= numnodes) {
            printk ("Ignoring excess node %d (%lx:%lx)\n", nodeid, base, limit);
            continue;
        }
        if (!limit) {
            printk (KERN_INFO "Skipping node entry %d (base %lx)\n", i, base);
            continue;
        }
        if ((base >> 8) & 3 || (limit >> 8) & 3) {
            printk (KERN_ERR "Node %d using interleaving mode %lx/%lx\n", nodeid, (base >> 8) & 3, (limit >> 8) & 3);
            return -1;
        }
        if (node_isset (nodeid, node_possible_map)) {
            printk (KERN_INFO "Node %d already present. Skipping\n", nodeid);
            continue;
        }
        limit >>= 16;
        limit <<= 24;
        limit |= (1 << 24) - 1;
        limit++;
        if (limit > max_pfn << PAGE_SHIFT)
            limit = max_pfn << PAGE_SHIFT;
        if (limit <= base)
            continue;
        base >>= 16;
        base <<= 24;
        if (base < start)
            base = start;
        if (limit > end)
            limit = end;
        if (limit == base) {
            printk (KERN_ERR "Empty node %d\n", nodeid);
            continue;
        }
        if (limit < base) {
            printk (KERN_ERR "Node %d bogus settings %lx-%lx.\n", nodeid, base, limit);
            continue;
        }
        if (prevbase > base) {
            printk (KERN_ERR "Node map not sorted %lx,%lx\n", prevbase, base);
            return -1;
        }
        printk (KERN_INFO "Node %d MemBase %016lx Limit %016lx\n", nodeid, base, limit);
        found++;
        nodes[nodeid].start = base;
        nodes[nodeid].end = limit;
        e820_register_active_regions (nodeid, nodes [nodeid].start >> PAGE_SHIFT, nodes [nodeid].end >> PAGE_SHIFT);
        prevbase = base;
        node_set (nodeid, node_possible_map);
    }
    if (!found)
        return -1;
    memnode_shift = compute_hash_shift (nodes, 8, NULL);
    if (memnode_shift < 0) {
        printk (KERN_ERR "No NUMA node hash function found. Contact maintainer\n");
        return -1;
    }
    printk (KERN_INFO "Using node hash shift of %d\n", memnode_shift);
    bits = boot_cpu_data.x86_coreid_bits;
    cores = (1 << bits);
    apicid_base = 0;
    early_get_boot_cpu_id ();
    if (boot_cpu_physical_apicid > 0) {
        printk (KERN_INFO "BSP APIC ID: %02x\n", boot_cpu_physical_apicid);
        apicid_base = boot_cpu_physical_apicid;
    }
    for (i = 0; i < 8; i++) {
        if (nodes[i].start != nodes[i].end) {
            nodeid = nodeids[i];
            for (j = apicid_base; j < cores + apicid_base; j++)
                apicid_to_node[(nodeid << bits) + j] = i;
            setup_node_bootmem (i, nodes [i].start, nodes [i].end);
        }
    }
    numa_init_array ();
    return 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/k8topology_64.c.ifdefed" startline="106" endline="189">
{
    unsigned long base, limit;
    base = read_pci_config (0, nb, 1, 0x40 + i * 8);
    limit = read_pci_config (0, nb, 1, 0x44 + i * 8);
    nodeid = limit & 7;
    nodeids[i] = nodeid;
    if ((base & 3) == 0) {
        if (i < numnodes)
            printk ("Skipping disabled node %d\n", i);
        continue;
    }
    if (nodeid >= numnodes) {
        printk ("Ignoring excess node %d (%lx:%lx)\n", nodeid, base, limit);
        continue;
    }
    if (!limit) {
        printk (KERN_INFO "Skipping node entry %d (base %lx)\n", i, base);
        continue;
    }
    if ((base >> 8) & 3 || (limit >> 8) & 3) {
        printk (KERN_ERR "Node %d using interleaving mode %lx/%lx\n", nodeid, (base >> 8) & 3, (limit >> 8) & 3);
        return -1;
    }
    if (node_isset (nodeid, node_possible_map)) {
        printk (KERN_INFO "Node %d already present. Skipping\n", nodeid);
        continue;
    }
    limit >>= 16;
    limit <<= 24;
    limit |= (1 << 24) - 1;
    limit++;
    if (limit > max_pfn << PAGE_SHIFT)
        limit = max_pfn << PAGE_SHIFT;
    if (limit <= base)
        continue;
    base >>= 16;
    base <<= 24;
    if (base < start)
        base = start;
    if (limit > end)
        limit = end;
    if (limit == base) {
        printk (KERN_ERR "Empty node %d\n", nodeid);
        continue;
    }
    if (limit < base) {
        printk (KERN_ERR "Node %d bogus settings %lx-%lx.\n", nodeid, base, limit);
        continue;
    }
    if (prevbase > base) {
        printk (KERN_ERR "Node map not sorted %lx,%lx\n", prevbase, base);
        return -1;
    }
    printk (KERN_INFO "Node %d MemBase %016lx Limit %016lx\n", nodeid, base, limit);
    found++;
    nodes[nodeid].start = base;
    nodes[nodeid].end = limit;
    e820_register_active_regions (nodeid, nodes [nodeid].start >> PAGE_SHIFT, nodes [nodeid].end >> PAGE_SHIFT);
    prevbase = base;
    node_set (nodeid, node_possible_map);
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/k8topology_64.c.ifdefed" startline="114" endline="118">
{
    if (i < numnodes)
        printk ("Skipping disabled node %d\n", i);
    continue;
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/k8topology_64.c.ifdefed" startline="119" endline="123">
{
    printk ("Ignoring excess node %d (%lx:%lx)\n", nodeid, base, limit);
    continue;
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/k8topology_64.c.ifdefed" startline="125" endline="129">
{
    printk (KERN_INFO "Skipping node entry %d (base %lx)\n", i, base);
    continue;
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/k8topology_64.c.ifdefed" startline="130" endline="134">
{
    printk (KERN_ERR "Node %d using interleaving mode %lx/%lx\n", nodeid, (base >> 8) & 3, (limit >> 8) & 3);
    return -1;
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/k8topology_64.c.ifdefed" startline="135" endline="139">
{
    printk (KERN_INFO "Node %d already present. Skipping\n", nodeid);
    continue;
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/k8topology_64.c.ifdefed" startline="158" endline="161">
{
    printk (KERN_ERR "Empty node %d\n", nodeid);
    continue;
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/k8topology_64.c.ifdefed" startline="162" endline="166">
{
    printk (KERN_ERR "Node %d bogus settings %lx-%lx.\n", nodeid, base, limit);
    continue;
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/k8topology_64.c.ifdefed" startline="169" endline="173">
{
    printk (KERN_ERR "Node map not sorted %lx,%lx\n", prevbase, base);
    return -1;
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/k8topology_64.c.ifdefed" startline="195" endline="198">
{
    printk (KERN_ERR "No NUMA node hash function found. Contact maintainer\n");
    return -1;
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/k8topology_64.c.ifdefed" startline="207" endline="211">
{
    printk (KERN_INFO "BSP APIC ID: %02x\n", boot_cpu_physical_apicid);
    apicid_base = boot_cpu_physical_apicid;
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/k8topology_64.c.ifdefed" startline="213" endline="220">
{
    if (nodes[i].start != nodes[i].end) {
        nodeid = nodeids[i];
        for (j = apicid_base; j < cores + apicid_base; j++)
            apicid_to_node[(nodeid << bits) + j] = i;
        setup_node_bootmem (i, nodes [i].start, nodes [i].end);
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/k8topology_64.c.ifdefed" startline="214" endline="219">
{
    nodeid = nodeids[i];
    for (j = apicid_base; j < cores + apicid_base; j++)
        apicid_to_node[(nodeid << bits) + j] = i;
    setup_node_bootmem (i, nodes [i].start, nodes [i].end);
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/init_64.c.ifdefed" startline="70" endline="73">
{
    direct_gbpages = 0;
    return 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/init_64.c.ifdefed" startline="77" endline="80">
{
    direct_gbpages = 1;
    return 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/init_64.c.ifdefed" startline="96" endline="112">
{
    void *ptr;
    if (after_bootmem)
        ptr = (void *) get_zeroed_page (GFP_ATOMIC);
    else
        ptr = alloc_bootmem_pages (PAGE_SIZE);
    if (!ptr || ((unsigned long) ptr & ~PAGE_MASK)) {
        panic ("set_pte_phys: cannot allocate page data %s\n", after_bootmem ? "after bootmem" : "");
    }
    pr_debug ("spp_getpage %p\n", ptr);
    return ptr;
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/init_64.c.ifdefed" startline="104" endline="107">
{
    panic ("set_pte_phys: cannot allocate page data %s\n", after_bootmem ? "after bootmem" : "");
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/init_64.c.ifdefed" startline="116" endline="152">
{
    pud_t *pud;
    pmd_t *pmd;
    pte_t *pte;
    pud = pud_page + pud_index (vaddr);
    if (pud_none (*pud)) {
        pmd = (pmd_t *) spp_getpage ();
        pud_populate (& init_mm, pud, pmd);
        if (pmd != pmd_offset (pud, 0)) {
            printk (KERN_ERR "PAGETABLE BUG #01! %p <-> %p\n", pmd, pmd_offset (pud, 0));
            return;
        }
    }
    pmd = pmd_offset (pud, vaddr);
    if (pmd_none (*pmd)) {
        pte = (pte_t *) spp_getpage ();
        pmd_populate_kernel (& init_mm, pmd, pte);
        if (pte != pte_offset_kernel (pmd, 0)) {
            printk (KERN_ERR "PAGETABLE BUG #02!\n");
            return;
        }
    }
    pte = pte_offset_kernel (pmd, vaddr);
    if (!pte_none (*pte) && pte_val (new_pte) && pte_val (*pte) != (pte_val (new_pte) & __supported_pte_mask))
        pte_ERROR (*pte);
    set_pte (pte, new_pte);
    __flush_tlb_one (vaddr);
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/init_64.c.ifdefed" startline="122" endline="130">
{
    pmd = (pmd_t *) spp_getpage ();
    pud_populate (& init_mm, pud, pmd);
    if (pmd != pmd_offset (pud, 0)) {
        printk (KERN_ERR "PAGETABLE BUG #01! %p <-> %p\n", pmd, pmd_offset (pud, 0));
        return;
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/init_64.c.ifdefed" startline="125" endline="129">
{
    printk (KERN_ERR "PAGETABLE BUG #01! %p <-> %p\n", pmd, pmd_offset (pud, 0));
    return;
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/init_64.c.ifdefed" startline="132" endline="139">
{
    pte = (pte_t *) spp_getpage ();
    pmd_populate_kernel (& init_mm, pmd, pte);
    if (pte != pte_offset_kernel (pmd, 0)) {
        printk (KERN_ERR "PAGETABLE BUG #02!\n");
        return;
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/init_64.c.ifdefed" startline="135" endline="138">
{
    printk (KERN_ERR "PAGETABLE BUG #02!\n");
    return;
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/init_64.c.ifdefed" startline="156" endline="170">
{
    pgd_t *pgd;
    pud_t *pud_page;
    pr_debug ("set_pte_vaddr %lx to %lx\n", vaddr, native_pte_val (pteval));
    pgd = pgd_offset_k (vaddr);
    if (pgd_none (*pgd)) {
        printk (KERN_ERR "PGD FIXMAP MISSING, it should be setup in head.S!\n");
        return;
    }
    pud_page = (pud_t *) pgd_page_vaddr (*pgd);
    set_pte_vaddr_pud (pud_page, vaddr, pteval);
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/init_64.c.ifdefed" startline="163" endline="167">
{
    printk (KERN_ERR "PGD FIXMAP MISSING, it should be setup in head.S!\n");
    return;
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/init_64.c.ifdefed" startline="177" endline="200">
{
    pgd_t *pgd;
    pud_t *pud;
    pmd_t *pmd;
    BUG_ON ((phys & ~ PMD_MASK) || (size & ~ PMD_MASK));
    for (; size; phys += PMD_SIZE, size -= PMD_SIZE) {
        pgd = pgd_offset_k ((unsigned long) __va (phys));
        if (pgd_none (*pgd)) {
            pud = (pud_t *) spp_getpage ();
            set_pgd (pgd, __pgd (__pa (pud) | _KERNPG_TABLE | _PAGE_USER));
        }
        pud = pud_offset (pgd, (unsigned long) __va (phys));
        if (pud_none (*pud)) {
            pmd = (pmd_t *) spp_getpage ();
            set_pud (pud, __pud (__pa (pmd) | _KERNPG_TABLE | _PAGE_USER));
        }
        pmd = pmd_offset (pud, phys);
        BUG_ON (! pmd_none (* pmd));
        set_pmd (pmd, __pmd (phys | pgprot_val (prot)));
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/init_64.c.ifdefed" startline="183" endline="199">
{
    pgd = pgd_offset_k ((unsigned long) __va (phys));
    if (pgd_none (*pgd)) {
        pud = (pud_t *) spp_getpage ();
        set_pgd (pgd, __pgd (__pa (pud) | _KERNPG_TABLE | _PAGE_USER));
    }
    pud = pud_offset (pgd, (unsigned long) __va (phys));
    if (pud_none (*pud)) {
        pmd = (pmd_t *) spp_getpage ();
        set_pud (pud, __pud (__pa (pmd) | _KERNPG_TABLE | _PAGE_USER));
    }
    pmd = pmd_offset (pud, phys);
    BUG_ON (! pmd_none (* pmd));
    set_pmd (pmd, __pmd (phys | pgprot_val (prot)));
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/init_64.c.ifdefed" startline="185" endline="189">
{
    pud = (pud_t *) spp_getpage ();
    set_pgd (pgd, __pgd (__pa (pud) | _KERNPG_TABLE | _PAGE_USER));
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/init_64.c.ifdefed" startline="191" endline="195">
{
    pmd = (pmd_t *) spp_getpage ();
    set_pud (pud, __pud (__pa (pmd) | _KERNPG_TABLE | _PAGE_USER));
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/init_64.c.ifdefed" startline="203" endline="205">
{
    __init_extra_mapping (phys, size, PAGE_KERNEL_LARGE);
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/init_64.c.ifdefed" startline="208" endline="210">
{
    __init_extra_mapping (phys, size, PAGE_KERNEL_LARGE_NOCACHE);
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/init_64.c.ifdefed" startline="226" endline="238">
{
    unsigned long vaddr = __START_KERNEL_map;
    unsigned long end = round_up ((unsigned long) _end, PMD_SIZE) - 1;
    pmd_t *pmd = level2_kernel_pgt;
    pmd_t *last_pmd = pmd + PTRS_PER_PMD;
    for (; pmd < last_pmd; pmd++, vaddr += PMD_SIZE) {
        if (pmd_none (*pmd))
            continue;
        if (vaddr < (unsigned long) _text || vaddr > end)
            set_pmd (pmd, __pmd (0));
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/init_64.c.ifdefed" startline="232" endline="237">
{
    if (pmd_none (*pmd))
        continue;
    if (vaddr < (unsigned long) _text || vaddr > end)
        set_pmd (pmd, __pmd (0));
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/init_64.c.ifdefed" startline="245" endline="263">
{
    unsigned long pfn = table_end++;
    void *adr;
    if (after_bootmem) {
        adr = (void *) get_zeroed_page (GFP_ATOMIC);
        *phys = __pa (adr);
        return adr;
    }
    if (pfn >= table_top)
        panic ("alloc_low_page: ran out of memory");
    adr = early_ioremap (pfn *PAGE_SIZE, PAGE_SIZE);
    memset (adr, 0, PAGE_SIZE);
    *phys = pfn * PAGE_SIZE;
    return adr;
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/init_64.c.ifdefed" startline="249" endline="254">
{
    adr = (void *) get_zeroed_page (GFP_ATOMIC);
    *phys = __pa (adr);
    return adr;
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/init_64.c.ifdefed" startline="266" endline="271">
{
    if (after_bootmem)
        return;
    early_iounmap (adr, PAGE_SIZE);
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/init_64.c.ifdefed" startline="275" endline="305">
{
    unsigned pages = 0;
    unsigned long last_map_addr = end;
    int i;
    pte_t *pte = pte_page + pte_index (addr);
    for (i = pte_index (addr); i < PTRS_PER_PTE; i++, addr += PAGE_SIZE, pte++) {
        if (addr >= end) {
            if (!after_bootmem) {
                for (; i < PTRS_PER_PTE; i++, pte++)
                    set_pte (pte, __pte (0));
            }
            break;
        }
        if (pte_val (*pte))
            continue;
        if (0)
            printk ("   pte=%p addr=%lx pte=%016lx\n", pte, addr, pfn_pte (addr >> PAGE_SHIFT, PAGE_KERNEL).pte);
        set_pte (pte, pfn_pte (addr >> PAGE_SHIFT, PAGE_KERNEL));
        last_map_addr = (addr & PAGE_MASK) + PAGE_SIZE;
        pages++;
    }
    update_page_count (PG_LEVEL_4K, pages);
    return last_map_addr;
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/init_64.c.ifdefed" startline="282" endline="301">
{
    if (addr >= end) {
        if (!after_bootmem) {
            for (; i < PTRS_PER_PTE; i++, pte++)
                set_pte (pte, __pte (0));
        }
        break;
    }
    if (pte_val (*pte))
        continue;
    if (0)
        printk ("   pte=%p addr=%lx pte=%016lx\n", pte, addr, pfn_pte (addr >> PAGE_SHIFT, PAGE_KERNEL).pte);
    set_pte (pte, pfn_pte (addr >> PAGE_SHIFT, PAGE_KERNEL));
    last_map_addr = (addr & PAGE_MASK) + PAGE_SIZE;
    pages++;
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/init_64.c.ifdefed" startline="284" endline="290">
{
    if (!after_bootmem) {
        for (; i < PTRS_PER_PTE; i++, pte++)
            set_pte (pte, __pte (0));
    }
    break;
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/init_64.c.ifdefed" startline="285" endline="288">
{
    for (; i < PTRS_PER_PTE; i++, pte++)
        set_pte (pte, __pte (0));
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/init_64.c.ifdefed" startline="309" endline="313">
{
    pte_t *pte = (pte_t *) pmd_page_vaddr (*pmd);
    return phys_pte_init (pte, address, end);
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/init_64.c.ifdefed" startline="318" endline="371">
{
    unsigned long pages = 0;
    unsigned long last_map_addr = end;
    unsigned long start = address;
    int i = pmd_index (address);
    for (; i < PTRS_PER_PMD; i++, address += PMD_SIZE) {
        unsigned long pte_phys;
        pmd_t *pmd = pmd_page + pmd_index (address);
        pte_t *pte;
        if (address >= end) {
            if (!after_bootmem) {
                for (; i < PTRS_PER_PMD; i++, pmd++)
                    set_pmd (pmd, __pmd (0));
            }
            break;
        }
        if (pmd_val (*pmd)) {
            if (!pmd_large (*pmd)) {
                spin_lock (& init_mm.page_table_lock);
                last_map_addr = phys_pte_update (pmd, address, end);
                spin_unlock (& init_mm.page_table_lock);
            }
            if (start == 0)
                pages++;
            continue;
        }
        if (page_size_mask & (1 << PG_LEVEL_2M)) {
            pages++;
            spin_lock (& init_mm.page_table_lock);
            set_pte ((pte_t *) pmd, pfn_pte (address >> PAGE_SHIFT, PAGE_KERNEL_LARGE));
            spin_unlock (& init_mm.page_table_lock);
            last_map_addr = (address & PMD_MASK) + PMD_SIZE;
            continue;
        }
        pte = alloc_low_page (&pte_phys);
        last_map_addr = phys_pte_init (pte, address, end);
        unmap_low_page (pte);
        spin_lock (& init_mm.page_table_lock);
        pmd_populate_kernel (& init_mm, pmd, __va (pte_phys));
        spin_unlock (& init_mm.page_table_lock);
    }
    update_page_count (PG_LEVEL_2M, pages);
    return last_map_addr;
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/init_64.c.ifdefed" startline="325" endline="368">
{
    unsigned long pte_phys;
    pmd_t *pmd = pmd_page + pmd_index (address);
    pte_t *pte;
    if (address >= end) {
        if (!after_bootmem) {
            for (; i < PTRS_PER_PMD; i++, pmd++)
                set_pmd (pmd, __pmd (0));
        }
        break;
    }
    if (pmd_val (*pmd)) {
        if (!pmd_large (*pmd)) {
            spin_lock (& init_mm.page_table_lock);
            last_map_addr = phys_pte_update (pmd, address, end);
            spin_unlock (& init_mm.page_table_lock);
        }
        if (start == 0)
            pages++;
        continue;
    }
    if (page_size_mask & (1 << PG_LEVEL_2M)) {
        pages++;
        spin_lock (& init_mm.page_table_lock);
        set_pte ((pte_t *) pmd, pfn_pte (address >> PAGE_SHIFT, PAGE_KERNEL_LARGE));
        spin_unlock (& init_mm.page_table_lock);
        last_map_addr = (address & PMD_MASK) + PMD_SIZE;
        continue;
    }
    pte = alloc_low_page (&pte_phys);
    last_map_addr = phys_pte_init (pte, address, end);
    unmap_low_page (pte);
    spin_lock (& init_mm.page_table_lock);
    pmd_populate_kernel (& init_mm, pmd, __va (pte_phys));
    spin_unlock (& init_mm.page_table_lock);
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/init_64.c.ifdefed" startline="330" endline="336">
{
    if (!after_bootmem) {
        for (; i < PTRS_PER_PMD; i++, pmd++)
            set_pmd (pmd, __pmd (0));
    }
    break;
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/init_64.c.ifdefed" startline="331" endline="334">
{
    for (; i < PTRS_PER_PMD; i++, pmd++)
        set_pmd (pmd, __pmd (0));
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/init_64.c.ifdefed" startline="338" endline="349">
{
    if (!pmd_large (*pmd)) {
        spin_lock (& init_mm.page_table_lock);
        last_map_addr = phys_pte_update (pmd, address, end);
        spin_unlock (& init_mm.page_table_lock);
    }
    if (start == 0)
        pages++;
    continue;
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/init_64.c.ifdefed" startline="339" endline="344">
{
    spin_lock (& init_mm.page_table_lock);
    last_map_addr = phys_pte_update (pmd, address, end);
    spin_unlock (& init_mm.page_table_lock);
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/init_64.c.ifdefed" startline="351" endline="359">
{
    pages++;
    spin_lock (& init_mm.page_table_lock);
    set_pte ((pte_t *) pmd, pfn_pte (address >> PAGE_SHIFT, PAGE_KERNEL_LARGE));
    spin_unlock (& init_mm.page_table_lock);
    last_map_addr = (address & PMD_MASK) + PMD_SIZE;
    continue;
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/init_64.c.ifdefed" startline="376" endline="383">
{
    pmd_t *pmd = pmd_offset (pud, 0);
    unsigned long last_map_addr;
    last_map_addr = phys_pmd_init (pmd, address, end, page_size_mask);
    __flush_tlb_all ();
    return last_map_addr;
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/init_64.c.ifdefed" startline="388" endline="436">
{
    unsigned long pages = 0;
    unsigned long last_map_addr = end;
    int i = pud_index (addr);
    for (; i < PTRS_PER_PUD; i++, addr = (addr & PUD_MASK) + PUD_SIZE) {
        unsigned long pmd_phys;
        pud_t *pud = pud_page + pud_index (addr);
        pmd_t *pmd;
        if (addr >= end)
            break;
        if (!after_bootmem && !e820_any_mapped (addr, addr +PUD_SIZE, 0)) {
            set_pud (pud, __pud (0));
            continue;
        }
        if (pud_val (*pud)) {
            if (!pud_large (*pud))
                last_map_addr = phys_pmd_update (pud, addr, end, page_size_mask);
            continue;
        }
        if (page_size_mask & (1 << PG_LEVEL_1G)) {
            pages++;
            spin_lock (& init_mm.page_table_lock);
            set_pte ((pte_t *) pud, pfn_pte (addr >> PAGE_SHIFT, PAGE_KERNEL_LARGE));
            spin_unlock (& init_mm.page_table_lock);
            last_map_addr = (addr & PUD_MASK) + PUD_SIZE;
            continue;
        }
        pmd = alloc_low_page (&pmd_phys);
        last_map_addr = phys_pmd_init (pmd, addr, end, page_size_mask);
        unmap_low_page (pmd);
        spin_lock (& init_mm.page_table_lock);
        pud_populate (& init_mm, pud, __va (pmd_phys));
        spin_unlock (& init_mm.page_table_lock);
    }
    __flush_tlb_all ();
    update_page_count (PG_LEVEL_1G, pages);
    return last_map_addr;
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/init_64.c.ifdefed" startline="393" endline="431">
{
    unsigned long pmd_phys;
    pud_t *pud = pud_page + pud_index (addr);
    pmd_t *pmd;
    if (addr >= end)
        break;
    if (!after_bootmem && !e820_any_mapped (addr, addr +PUD_SIZE, 0)) {
        set_pud (pud, __pud (0));
        continue;
    }
    if (pud_val (*pud)) {
        if (!pud_large (*pud))
            last_map_addr = phys_pmd_update (pud, addr, end, page_size_mask);
        continue;
    }
    if (page_size_mask & (1 << PG_LEVEL_1G)) {
        pages++;
        spin_lock (& init_mm.page_table_lock);
        set_pte ((pte_t *) pud, pfn_pte (addr >> PAGE_SHIFT, PAGE_KERNEL_LARGE));
        spin_unlock (& init_mm.page_table_lock);
        last_map_addr = (addr & PUD_MASK) + PUD_SIZE;
        continue;
    }
    pmd = alloc_low_page (&pmd_phys);
    last_map_addr = phys_pmd_init (pmd, addr, end, page_size_mask);
    unmap_low_page (pmd);
    spin_lock (& init_mm.page_table_lock);
    pud_populate (& init_mm, pud, __va (pmd_phys));
    spin_unlock (& init_mm.page_table_lock);
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/init_64.c.ifdefed" startline="402" endline="405">
{
    set_pud (pud, __pud (0));
    continue;
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/init_64.c.ifdefed" startline="407" endline="412">
{
    if (!pud_large (*pud))
        last_map_addr = phys_pmd_update (pud, addr, end, page_size_mask);
    continue;
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/init_64.c.ifdefed" startline="414" endline="422">
{
    pages++;
    spin_lock (& init_mm.page_table_lock);
    set_pte ((pte_t *) pud, pfn_pte (addr >> PAGE_SHIFT, PAGE_KERNEL_LARGE));
    spin_unlock (& init_mm.page_table_lock);
    last_map_addr = (addr & PUD_MASK) + PUD_SIZE;
    continue;
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/init_64.c.ifdefed" startline="441" endline="447">
{
    pud_t *pud;
    pud = (pud_t *) pgd_page_vaddr (*pgd);
    return phys_pud_init (pud, addr, end, page_size_mask);
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/init_64.c.ifdefed" startline="450" endline="487">
{
    unsigned long puds, pmds, ptes, tables, start;
    puds = (end + PUD_SIZE - 1) >> PUD_SHIFT;
    tables = round_up (puds * sizeof (pud_t), PAGE_SIZE);
    if (direct_gbpages) {
        unsigned long extra;
        extra = end - ((end >> PUD_SHIFT) << PUD_SHIFT);
        pmds = (extra + PMD_SIZE - 1) >> PMD_SHIFT;
    }
    else
        pmds = (end + PMD_SIZE - 1) >> PMD_SHIFT;
    tables += round_up (pmds * sizeof (pmd_t), PAGE_SIZE);
    if (cpu_has_pse) {
        unsigned long extra;
        extra = end - ((end >> PMD_SHIFT) << PMD_SHIFT);
        ptes = (extra + PAGE_SIZE - 1) >> PAGE_SHIFT;
    }
    else
        ptes = (end + PAGE_SIZE - 1) >> PAGE_SHIFT;
    tables += round_up (ptes * sizeof (pte_t), PAGE_SIZE);
    start = 0x8000;
    table_start = find_e820_area (start, end, tables, PAGE_SIZE);
    if (table_start == -1UL)
        panic ("Cannot find space for the kernel page tables");
    table_start >>= PAGE_SHIFT;
    table_end = table_start;
    table_top = table_start + (tables >> PAGE_SHIFT);
    printk (KERN_DEBUG "kernel direct mapping tables up to %lx @ %lx-%lx\n", end, table_start << PAGE_SHIFT, table_top << PAGE_SHIFT);
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/init_64.c.ifdefed" startline="455" endline="459">
{
    unsigned long extra;
    extra = end - ((end >> PUD_SHIFT) << PUD_SHIFT);
    pmds = (extra + PMD_SIZE - 1) >> PMD_SHIFT;
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/init_64.c.ifdefed" startline="463" endline="467">
{
    unsigned long extra;
    extra = end - ((end >> PMD_SHIFT) << PMD_SHIFT);
    ptes = (extra + PAGE_SIZE - 1) >> PAGE_SHIFT;
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/init_64.c.ifdefed" startline="490" endline="495">
{
    if (direct_gbpages && cpu_has_gbpages)
        printk (KERN_INFO "Using GB pages for direct mapping\n");
    else
        direct_gbpages = 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/init_64.c.ifdefed" startline="500" endline="533">
{
    unsigned long next, last_map_addr = end;
    start = (unsigned long) __va (start);
    end = (unsigned long) __va (end);
    for (; start < end; start = next) {
        pgd_t *pgd = pgd_offset_k (start);
        unsigned long pud_phys;
        pud_t *pud;
        next = (start + PGDIR_SIZE) & PGDIR_MASK;
        if (next > end)
            next = end;
        if (pgd_val (*pgd)) {
            last_map_addr = phys_pud_update (pgd, __pa (start), __pa (end), page_size_mask);
            continue;
        }
        pud = alloc_low_page (&pud_phys);
        last_map_addr = phys_pud_init (pud, __pa (start), __pa (next), page_size_mask);
        unmap_low_page (pud);
        spin_lock (& init_mm.page_table_lock);
        pgd_populate (& init_mm, pgd, __va (pud_phys));
        spin_unlock (& init_mm.page_table_lock);
    }
    return last_map_addr;
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/init_64.c.ifdefed" startline="507" endline="530">
{
    pgd_t *pgd = pgd_offset_k (start);
    unsigned long pud_phys;
    pud_t *pud;
    next = (start + PGDIR_SIZE) & PGDIR_MASK;
    if (next > end)
        next = end;
    if (pgd_val (*pgd)) {
        last_map_addr = phys_pud_update (pgd, __pa (start), __pa (end), page_size_mask);
        continue;
    }
    pud = alloc_low_page (&pud_phys);
    last_map_addr = phys_pud_init (pud, __pa (start), __pa (next), page_size_mask);
    unmap_low_page (pud);
    spin_lock (& init_mm.page_table_lock);
    pgd_populate (& init_mm, pgd, __va (pud_phys));
    spin_unlock (& init_mm.page_table_lock);
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/init_64.c.ifdefed" startline="516" endline="520">
{
    last_map_addr = phys_pud_update (pgd, __pa (start), __pa (end), page_size_mask);
    continue;
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/init_64.c.ifdefed" startline="546" endline="558">
{
    if (start_pfn < end_pfn) {
        if (nr_range >= NR_RANGE_MR)
            panic ("run out of range for init_memory_mapping\n");
        mr[nr_range].start = start_pfn << PAGE_SHIFT;
        mr[nr_range].end = end_pfn << PAGE_SHIFT;
        mr[nr_range].page_size_mask = page_size_mask;
        nr_range++;
    }
    return nr_range;
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/init_64.c.ifdefed" startline="548" endline="555">
{
    if (nr_range >= NR_RANGE_MR)
        panic ("run out of range for init_memory_mapping\n");
    mr[nr_range].start = start_pfn << PAGE_SHIFT;
    mr[nr_range].end = end_pfn << PAGE_SHIFT;
    mr[nr_range].page_size_mask = page_size_mask;
    nr_range++;
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/init_64.c.ifdefed" startline="567" endline="672">
{
    unsigned long last_map_addr = 0;
    unsigned long page_size_mask = 0;
    unsigned long start_pfn, end_pfn;
    struct map_range mr [NR_RANGE_MR];
    int nr_range, i;
    printk (KERN_INFO "init_memory_mapping\n");
    if (!after_bootmem)
        init_gbpages ();
    if (direct_gbpages)
        page_size_mask |= 1 << PG_LEVEL_1G;
    if (cpu_has_pse)
        page_size_mask |= 1 << PG_LEVEL_2M;
    memset (mr, 0, sizeof (mr));
    nr_range = 0;
    start_pfn = start >> PAGE_SHIFT;
    end_pfn = ((start + (PMD_SIZE - 1)) >> PMD_SHIFT) << (PMD_SHIFT - PAGE_SHIFT);
    nr_range = save_mr (mr, nr_range, start_pfn, end_pfn, 0);
    start_pfn = ((start + (PMD_SIZE - 1)) >> PMD_SHIFT) << (PMD_SHIFT - PAGE_SHIFT);
    end_pfn = ((start + (PUD_SIZE - 1)) >> PUD_SHIFT) << (PUD_SHIFT - PAGE_SHIFT);
    if (end_pfn > ((end >> PUD_SHIFT) << (PUD_SHIFT - PAGE_SHIFT)))
        end_pfn = ((end >> PUD_SHIFT) << (PUD_SHIFT - PAGE_SHIFT));
    nr_range = save_mr (mr, nr_range, start_pfn, end_pfn, page_size_mask &(1 << PG_LEVEL_2M));
    start_pfn = end_pfn;
    end_pfn = (end >> PUD_SHIFT) << (PUD_SHIFT - PAGE_SHIFT);
    nr_range = save_mr (mr, nr_range, start_pfn, end_pfn, page_size_mask &((1 << PG_LEVEL_2M) | (1 << PG_LEVEL_1G)));
    start_pfn = end_pfn;
    end_pfn = (end >> PMD_SHIFT) << (PMD_SHIFT - PAGE_SHIFT);
    nr_range = save_mr (mr, nr_range, start_pfn, end_pfn, page_size_mask &(1 << PG_LEVEL_2M));
    start_pfn = end_pfn;
    end_pfn = end >> PAGE_SHIFT;
    nr_range = save_mr (mr, nr_range, start_pfn, end_pfn, 0);
    for (i = 0; nr_range > 1 && i < nr_range - 1; i++) {
        unsigned long old_start;
        if (mr[i].end != mr[i + 1].start || mr[i].page_size_mask != mr[i + 1].page_size_mask)
            continue;
        old_start = mr[i].start;
        memmove (& mr [i], & mr [i + 1], (nr_range - 1 - i) * sizeof (struct map_range));
        mr[i].start = old_start;
        nr_range--;
    }
    for (i = 0; i < nr_range; i++)
        printk (KERN_DEBUG " %010lx - %010lx page %s\n", mr[i].start, mr[i].end, (mr[i].page_size_mask & (1 << PG_LEVEL_1G)) ? "1G" : ((mr[i].page_size_mask & (1 << PG_LEVEL_2M)) ? "2M" : "4k"));
    if (!after_bootmem)
        find_early_table_space (end);
    for (i = 0; i < nr_range; i++)
        last_map_addr = kernel_physical_mapping_init (mr[i].start, mr[i].end, mr[i].page_size_mask);
    if (!after_bootmem)
        mmu_cr4_features = read_cr4 ();
    __flush_tlb_all ();
    if (!after_bootmem && table_end > table_start)
        reserve_early (table_start << PAGE_SHIFT, table_end << PAGE_SHIFT, "PGTABLE");
    printk (KERN_INFO "last_map_addr: %lx end: %lx\n", last_map_addr, end);
    if (!after_bootmem)
        early_memtest (start, end);
    return last_map_addr >> PAGE_SHIFT;
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/init_64.c.ifdefed" startline="630" endline="641">
{
    unsigned long old_start;
    if (mr[i].end != mr[i + 1].start || mr[i].page_size_mask != mr[i + 1].page_size_mask)
        continue;
    old_start = mr[i].start;
    memmove (& mr [i], & mr [i + 1], (nr_range - 1 - i) * sizeof (struct map_range));
    mr[i].start = old_start;
    nr_range--;
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/init_64.c.ifdefed" startline="676" endline="691">
{
    unsigned long bootmap_size, bootmap;
    bootmap_size = bootmem_bootmap_pages (end_pfn) << PAGE_SHIFT;
    bootmap = find_e820_area (0, end_pfn << PAGE_SHIFT, bootmap_size, PAGE_SIZE);
    if (bootmap == -1L)
        panic ("Cannot find bootmem map of size %ld\n", bootmap_size);
    bootmap_size = init_bootmem_node (NODE_DATA (0), bootmap >> PAGE_SHIFT, 0, end_pfn);
    e820_register_active_regions (0, start_pfn, end_pfn);
    free_bootmem_with_active_regions (0, end_pfn);
    early_res_to_bootmem (0, end_pfn << PAGE_SHIFT);
    reserve_bootmem (bootmap, bootmap_size, BOOTMEM_DEFAULT);
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/init_64.c.ifdefed" startline="694" endline="705">
{
    unsigned long max_zone_pfns [MAX_NR_ZONES];
    memset (max_zone_pfns, 0, sizeof (max_zone_pfns));
    max_zone_pfns[ZONE_DMA] = MAX_DMA_PFN;
    max_zone_pfns[ZONE_DMA32] = MAX_DMA32_PFN;
    max_zone_pfns[ZONE_NORMAL] = max_pfn;
    memory_present (0, 0, max_pfn);
    sparse_init ();
    free_area_init_nodes (max_zone_pfns);
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/init_64.c.ifdefed" startline="756" endline="762">
{
    if (pagenr <= 256)
        return 1;
    if (!page_is_ram (pagenr))
        return 1;
    return 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/init_64.c.ifdefed" startline="769" endline="811">
{
    long codesize, reservedpages, datasize, initsize;
    pci_iommu_alloc ();
    reservedpages = 0;
    totalram_pages = free_all_bootmem ();
    reservedpages = max_pfn - totalram_pages - absent_pages_in_range (0, max_pfn);
    after_bootmem = 1;
    codesize = (unsigned long) &_etext - (unsigned long) &_text;
    datasize = (unsigned long) &_edata - (unsigned long) &_etext;
    initsize = (unsigned long) &__init_end - (unsigned long) &__init_begin;
    kclist_add (& kcore_mem, __va (0), max_low_pfn << PAGE_SHIFT);
    kclist_add (& kcore_vmalloc, (void *) VMALLOC_START, VMALLOC_END - VMALLOC_START);
    kclist_add (& kcore_kernel, & _stext, _end - _stext);
    kclist_add (& kcore_modules, (void *) MODULES_VADDR, MODULES_LEN);
    kclist_add (& kcore_vsyscall, (void *) VSYSCALL_START, VSYSCALL_END - VSYSCALL_START);
    printk (KERN_INFO "Memory: %luk/%luk available (%ldk kernel code, " "%ldk reserved, %ldk data, %ldk init)\n", (unsigned long) nr_free_pages () << (PAGE_SHIFT - 10), max_pfn << (PAGE_SHIFT - 10), codesize >> 10, reservedpages << (PAGE_SHIFT - 10), datasize >> 10, initsize >> 10);
    cpa_init ();
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/init_64.c.ifdefed" startline="814" endline="841">
{
    unsigned long addr = begin;
    if (addr >= end)
        return;
    printk (KERN_INFO "Freeing %s: %luk freed\n", what, (end - begin) >> 10);
    for (; addr < end; addr += PAGE_SIZE) {
        ClearPageReserved (virt_to_page (addr));
        init_page_count (virt_to_page (addr));
        memset ((void *) (addr & ~ (PAGE_SIZE - 1)), POISON_FREE_INITMEM, PAGE_SIZE);
        free_page (addr);
        totalram_pages++;
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/init_64.c.ifdefed" startline="832" endline="839">
{
    ClearPageReserved (virt_to_page (addr));
    init_page_count (virt_to_page (addr));
    memset ((void *) (addr & ~ (PAGE_SIZE - 1)), POISON_FREE_INITMEM, PAGE_SIZE);
    free_page (addr);
    totalram_pages++;
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/init_64.c.ifdefed" startline="844" endline="848">
{
    free_init_pages ("unused kernel memory", (unsigned long) (& __init_begin), (unsigned long) (& __init_end));
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/init_64.c.ifdefed" startline="897" endline="939">
{
    unsigned long pfn = phys >> PAGE_SHIFT;
    if (pfn >= max_pfn) {
        if (pfn < max_pfn_mapped)
            return -EFAULT;
        printk (KERN_ERR "reserve_bootmem: illegal reserve %lx %lu\n", phys, len);
        return -EFAULT;
    }
    reserve_bootmem (phys, len, BOOTMEM_DEFAULT);
    if (phys + len <= MAX_DMA_PFN * PAGE_SIZE) {
        dma_reserve += len / PAGE_SIZE;
        set_dma_reserve (dma_reserve);
    }
    return 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/init_64.c.ifdefed" startline="904" endline="915">
{
    if (pfn < max_pfn_mapped)
        return -EFAULT;
    printk (KERN_ERR "reserve_bootmem: illegal reserve %lx %lu\n", phys, len);
    return -EFAULT;
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/init_64.c.ifdefed" startline="933" endline="936">
{
    dma_reserve += len / PAGE_SIZE;
    set_dma_reserve (dma_reserve);
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/init_64.c.ifdefed" startline="942" endline="972">
{
    unsigned long above = ((long) addr) >> __VIRTUAL_MASK_SHIFT;
    pgd_t *pgd;
    pud_t *pud;
    pmd_t *pmd;
    pte_t *pte;
    if (above != 0 && above != -1UL)
        return 0;
    pgd = pgd_offset_k (addr);
    if (pgd_none (*pgd))
        return 0;
    pud = pud_offset (pgd, addr);
    if (pud_none (*pud))
        return 0;
    pmd = pmd_offset (pud, addr);
    if (pmd_none (*pmd))
        return 0;
    if (pmd_large (*pmd))
        return pfn_valid (pmd_pfn (*pmd));
    pte = pte_offset_kernel (pmd, addr);
    if (pte_none (*pte))
        return 0;
    return pfn_valid (pte_pfn (*pte));
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/init_64.c.ifdefed" startline="987" endline="993">
{
    return &gate_vma;
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/init_64.c.ifdefed" startline="996" endline="1003">
{
    struct vm_area_struct *vma = get_gate_vma (task);
    if (!vma)
        return 0;
    return (addr >= vma->vm_start) && (addr < vma->vm_end);
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/init_64.c.ifdefed" startline="1011" endline="1013">
{
    return (addr >= VSYSCALL_START) && (addr < VSYSCALL_END);
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/init_64.c.ifdefed" startline="1016" endline="1022">
{
    if (vma->vm_mm && vma->vm_start == (long) vma->vm_mm->context.vdso)
        return "[vdso]";
    if (vma == &gate_vma)
        return "[vsyscall]";
    return NULL;
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/ioremap.c.ifdefed" startline="43" endline="45">
{
    return 1;
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/ioremap.c.ifdefed" startline="50" endline="84">
{
    resource_size_t addr, end;
    int i;
    if (pagenr == 0)
        return 0;
    if (pagenr >= (BIOS_BEGIN >> PAGE_SHIFT) && pagenr < (BIOS_END >> PAGE_SHIFT))
        return 0;
    for (i = 0; i < e820.nr_map; i++) {
        if (e820.map[i].type != E820_RAM)
            continue;
        addr = (e820.map[i].addr + PAGE_SIZE - 1) >> PAGE_SHIFT;
        end = (e820.map[i].addr + e820.map[i].size) >> PAGE_SHIFT;
        if ((pagenr >= addr) && (pagenr < end))
            return 1;
    }
    return 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/ioremap.c.ifdefed" startline="70" endline="82">
{
    if (e820.map[i].type != E820_RAM)
        continue;
    addr = (e820.map[i].addr + PAGE_SIZE - 1) >> PAGE_SHIFT;
    end = (e820.map[i].addr + e820.map[i].size) >> PAGE_SHIFT;
    if ((pagenr >= addr) && (pagenr < end))
        return 1;
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/ioremap.c.ifdefed" startline="92" endline="110">
{
    unsigned long nrpages = size >> PAGE_SHIFT;
    int err;
    switch (prot_val) {
    case _PAGE_CACHE_UC :
    default :
        err = _set_memory_uc (vaddr, nrpages);
        break;
    case _PAGE_CACHE_WC :
        err = _set_memory_wc (vaddr, nrpages);
        break;
    case _PAGE_CACHE_WB :
        err = _set_memory_wb (vaddr, nrpages);
        break;
    }
    return err;
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/ioremap.c.ifdefed" startline="96" endline="107">
{
case _PAGE_CACHE_UC :
default :
    err = _set_memory_uc (vaddr, nrpages);
    break;
case _PAGE_CACHE_WC :
    err = _set_memory_wc (vaddr, nrpages);
    break;
case _PAGE_CACHE_WB :
    err = _set_memory_wb (vaddr, nrpages);
    break;
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/ioremap.c.ifdefed" startline="123" endline="244">
{
    unsigned long pfn, offset, vaddr;
    resource_size_t last_addr;
    const resource_size_t unaligned_phys_addr = phys_addr;
    const unsigned long unaligned_size = size;
    struct vm_struct *area;
    unsigned long new_prot_val;
    pgprot_t prot;
    int retval;
    void __iomem *ret_addr;
    last_addr = phys_addr + size - 1;
    if (!size || last_addr < phys_addr)
        return NULL;
    if (!phys_addr_valid (phys_addr)) {
        printk (KERN_WARNING "ioremap: invalid physical address %llx\n", (unsigned long long) phys_addr);
        WARN_ON_ONCE (1);
        return NULL;
    }
    if (is_ISA_range (phys_addr, last_addr))
        return (__force void __iomem *) phys_to_virt (phys_addr);
    for (pfn = phys_addr >> PAGE_SHIFT; (pfn << PAGE_SHIFT) < (last_addr & PAGE_MASK); pfn++) {
        int is_ram = page_is_ram (pfn);
        if (is_ram && pfn_valid (pfn) && !PageReserved (pfn_to_page (pfn)))
            return NULL;
        WARN_ON_ONCE (is_ram);
    }
    offset = phys_addr & ~PAGE_MASK;
    phys_addr &= PAGE_MASK;
    size = PAGE_ALIGN (last_addr +1) - phys_addr;
    retval = reserve_memtype (phys_addr, (u64) phys_addr + size, prot_val, &new_prot_val);
    if (retval) {
        pr_debug ("Warning: reserve_memtype returned %d\n", retval);
        return NULL;
    }
    if (prot_val != new_prot_val) {
        if ((prot_val == _PAGE_CACHE_UC_MINUS && (new_prot_val == _PAGE_CACHE_WB || new_prot_val == _PAGE_CACHE_WC)) || (prot_val == _PAGE_CACHE_WC && new_prot_val == _PAGE_CACHE_WB)) {
            pr_debug ("ioremap error for 0x%llx-0x%llx, requested 0x%lx, got 0x%lx\n", (unsigned long long) phys_addr, (unsigned long long) (phys_addr + size), prot_val, new_prot_val);
            free_memtype (phys_addr, phys_addr + size);
            return NULL;
        }
        prot_val = new_prot_val;
    }
    switch (prot_val) {
    case _PAGE_CACHE_UC :
    default :
        prot = PAGE_KERNEL_NOCACHE;
        break;
    case _PAGE_CACHE_UC_MINUS :
        prot = PAGE_KERNEL_UC_MINUS;
        break;
    case _PAGE_CACHE_WC :
        prot = PAGE_KERNEL_WC;
        break;
    case _PAGE_CACHE_WB :
        prot = PAGE_KERNEL;
        break;
    }
    area = get_vm_area_caller (size, VM_IOREMAP, caller);
    if (!area)
        return NULL;
    area->phys_addr = phys_addr;
    vaddr = (unsigned long) area->addr;
    if (ioremap_page_range (vaddr, vaddr +size, phys_addr, prot)) {
        free_memtype (phys_addr, phys_addr + size);
        free_vm_area (area);
        return NULL;
    }
    if (ioremap_change_attr (vaddr, size, prot_val) < 0) {
        free_memtype (phys_addr, phys_addr + size);
        vunmap (area -> addr);
        return NULL;
    }
    ret_addr = (void __iomem *) (vaddr + offset);
    mmiotrace_ioremap (unaligned_phys_addr, unaligned_size, ret_addr);
    return ret_addr;
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/ioremap.c.ifdefed" startline="139" endline="144">
{
    printk (KERN_WARNING "ioremap: invalid physical address %llx\n", (unsigned long long) phys_addr);
    WARN_ON_ONCE (1);
    return NULL;
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/ioremap.c.ifdefed" startline="157" endline="164">
{
    int is_ram = page_is_ram (pfn);
    if (is_ram && pfn_valid (pfn) && !PageReserved (pfn_to_page (pfn)))
        return NULL;
    WARN_ON_ONCE (is_ram);
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/ioremap.c.ifdefed" startline="175" endline="178">
{
    pr_debug ("Warning: reserve_memtype returned %d\n", retval);
    return NULL;
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/ioremap.c.ifdefed" startline="180" endline="202">
{
    if ((prot_val == _PAGE_CACHE_UC_MINUS && (new_prot_val == _PAGE_CACHE_WB || new_prot_val == _PAGE_CACHE_WC)) || (prot_val == _PAGE_CACHE_WC && new_prot_val == _PAGE_CACHE_WB)) {
        pr_debug ("ioremap error for 0x%llx-0x%llx, requested 0x%lx, got 0x%lx\n", (unsigned long long) phys_addr, (unsigned long long) (phys_addr + size), prot_val, new_prot_val);
        free_memtype (phys_addr, phys_addr + size);
        return NULL;
    }
    prot_val = new_prot_val;
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/ioremap.c.ifdefed" startline="192" endline="200">
{
    pr_debug ("ioremap error for 0x%llx-0x%llx, requested 0x%lx, got 0x%lx\n", (unsigned long long) phys_addr, (unsigned long long) (phys_addr + size), prot_val, new_prot_val);
    free_memtype (phys_addr, phys_addr + size);
    return NULL;
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/ioremap.c.ifdefed" startline="204" endline="218">
{
case _PAGE_CACHE_UC :
default :
    prot = PAGE_KERNEL_NOCACHE;
    break;
case _PAGE_CACHE_UC_MINUS :
    prot = PAGE_KERNEL_UC_MINUS;
    break;
case _PAGE_CACHE_WC :
    prot = PAGE_KERNEL_WC;
    break;
case _PAGE_CACHE_WB :
    prot = PAGE_KERNEL;
    break;
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/ioremap.c.ifdefed" startline="228" endline="232">
{
    free_memtype (phys_addr, phys_addr + size);
    free_vm_area (area);
    return NULL;
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/ioremap.c.ifdefed" startline="234" endline="238">
{
    free_memtype (phys_addr, phys_addr + size);
    vunmap (area -> addr);
    return NULL;
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/ioremap.c.ifdefed" startline="268" endline="280">
{
    unsigned long val = _PAGE_CACHE_UC_MINUS;
    return __ioremap_caller (phys_addr, size, val, __builtin_return_address (0));
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/ioremap.c.ifdefed" startline="294" endline="300">
{
    if (pat_enabled)
        return __ioremap_caller (phys_addr, size, _PAGE_CACHE_WC, __builtin_return_address (0));
    else
        return ioremap_nocache (phys_addr, size);
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/ioremap.c.ifdefed" startline="304" endline="307">
{
    return __ioremap_caller (phys_addr, size, _PAGE_CACHE_WB, __builtin_return_address (0));
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/ioremap.c.ifdefed" startline="312" endline="331">
{
    unsigned long flags;
    void *ret;
    int err;
    err = reserve_memtype (phys_addr, phys_addr +size, -1, &flags);
    if (err < 0)
        return NULL;
    ret = (void *) __ioremap_caller (phys_addr, size, flags, __builtin_return_address (0));
    free_memtype (phys_addr, phys_addr + size);
    return (void __iomem *) ret;
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/ioremap.c.ifdefed" startline="335" endline="338">
{
    return __ioremap_caller (phys_addr, size, (prot_val & _PAGE_CACHE_MASK), __builtin_return_address (0));
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/ioremap.c.ifdefed" startline="348" endline="392">
{
    struct vm_struct *p, *o;
    if ((void __force *) addr <= high_memory)
        return;
    if ((void __force *) addr >= phys_to_virt (ISA_START_ADDRESS) && (void __force *) addr < phys_to_virt (ISA_END_ADDRESS))
        return;
    addr = (volatile void __iomem *) (PAGE_MASK & (unsigned long __force) addr);
    mmiotrace_iounmap (addr);
    read_lock (& vmlist_lock);
    for (p = vmlist; p; p = p->next) {
        if (p->addr == (void __force *) addr)
            break;
    }
    read_unlock (& vmlist_lock);
    if (!p) {
        printk (KERN_ERR "iounmap: bad address %p\n", addr);
        dump_stack ();
        return;
    }
    free_memtype (p -> phys_addr, p -> phys_addr + get_vm_area_size (p));
    o = remove_vm_area ((void __force *) addr);
    BUG_ON (p != o || o == NULL);
    kfree (p);
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/ioremap.c.ifdefed" startline="374" endline="377">
{
    if (p->addr == (void __force *) addr)
        break;
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/ioremap.c.ifdefed" startline="380" endline="384">
{
    printk (KERN_ERR "iounmap: bad address %p\n", addr);
    dump_stack ();
    return;
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/ioremap.c.ifdefed" startline="400" endline="413">
{
    void *addr;
    unsigned long start = phys & PAGE_MASK;
    if (page_is_ram (start >> PAGE_SHIFT))
        return __va (phys);
    addr = (void __force *) ioremap_default (start, PAGE_SIZE);
    if (addr)
        addr = (void *) ((unsigned long) addr | (phys & ~PAGE_MASK));
    return addr;
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/ioremap.c.ifdefed" startline="416" endline="422">
{
    if (page_is_ram (phys >> PAGE_SHIFT))
        return;
    iounmap ((void __iomem *) ((unsigned long) addr & PAGE_MASK));
    return;
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/ioremap.c.ifdefed" startline="427" endline="431">
{
    early_ioremap_debug = 1;
    return 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/ioremap.c.ifdefed" startline="438" endline="446">
{
    pgd_t *base = __va (read_cr3 ());
    pgd_t *pgd = &base[pgd_index (addr)];
    pud_t *pud = pud_offset (pgd, addr);
    pmd_t *pmd = pmd_offset (pud, addr);
    return pmd;
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/ioremap.c.ifdefed" startline="449" endline="451">
{
    return &bm_pte[pte_index (addr)];
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/ioremap.c.ifdefed" startline="454" endline="481">
{
    pmd_t *pmd;
    if (early_ioremap_debug)
        printk (KERN_INFO "early_ioremap_init()\n");
    pmd = early_ioremap_pmd (fix_to_virt (FIX_BTMAP_BEGIN));
    memset (bm_pte, 0, sizeof (bm_pte));
    pmd_populate_kernel (& init_mm, pmd, bm_pte);
    if (pmd != early_ioremap_pmd (fix_to_virt (FIX_BTMAP_END))) {
        WARN_ON (1);
        printk (KERN_WARNING "pmd %p != %p\n", pmd, early_ioremap_pmd (fix_to_virt (FIX_BTMAP_END)));
        printk (KERN_WARNING "fix_to_virt(FIX_BTMAP_BEGIN): %08lx\n", fix_to_virt (FIX_BTMAP_BEGIN));
        printk (KERN_WARNING "fix_to_virt(FIX_BTMAP_END):   %08lx\n", fix_to_virt (FIX_BTMAP_END));
        printk (KERN_WARNING "FIX_BTMAP_END:       %d\n", FIX_BTMAP_END);
        printk (KERN_WARNING "FIX_BTMAP_BEGIN:     %d\n", FIX_BTMAP_BEGIN);
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/ioremap.c.ifdefed" startline="468" endline="480">
{
    WARN_ON (1);
    printk (KERN_WARNING "pmd %p != %p\n", pmd, early_ioremap_pmd (fix_to_virt (FIX_BTMAP_END)));
    printk (KERN_WARNING "fix_to_virt(FIX_BTMAP_BEGIN): %08lx\n", fix_to_virt (FIX_BTMAP_BEGIN));
    printk (KERN_WARNING "fix_to_virt(FIX_BTMAP_END):   %08lx\n", fix_to_virt (FIX_BTMAP_END));
    printk (KERN_WARNING "FIX_BTMAP_END:       %d\n", FIX_BTMAP_END);
    printk (KERN_WARNING "FIX_BTMAP_BEGIN:     %d\n", FIX_BTMAP_BEGIN);
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/ioremap.c.ifdefed" startline="484" endline="494">
{
    pmd_t *pmd;
    if (early_ioremap_debug)
        printk (KERN_INFO "early_ioremap_clear()\n");
    pmd = early_ioremap_pmd (fix_to_virt (FIX_BTMAP_BEGIN));
    pmd_clear (pmd);
    paravirt_release_pte (__pa (bm_pte) >> PAGE_SHIFT);
    __flush_tlb_all ();
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/ioremap.c.ifdefed" startline="497" endline="511">
{
    enum fixed_addresses idx;
    unsigned long addr, phys;
    pte_t *pte;
    after_paging_init = 1;
    for (idx = FIX_BTMAP_BEGIN; idx >= FIX_BTMAP_END; idx--) {
        addr = fix_to_virt (idx);
        pte = early_ioremap_pte (addr);
        if (pte_present (*pte)) {
            phys = pte_val (*pte) & PAGE_MASK;
            set_fixmap (idx, phys);
        }
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/ioremap.c.ifdefed" startline="503" endline="510">
{
    addr = fix_to_virt (idx);
    pte = early_ioremap_pte (addr);
    if (pte_present (*pte)) {
        phys = pte_val (*pte) & PAGE_MASK;
        set_fixmap (idx, phys);
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/ioremap.c.ifdefed" startline="506" endline="509">
{
    phys = pte_val (*pte) & PAGE_MASK;
    set_fixmap (idx, phys);
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/ioremap.c.ifdefed" startline="515" endline="530">
{
    unsigned long addr = __fix_to_virt (idx);
    pte_t *pte;
    if (idx >= __end_of_fixed_addresses) {
        BUG ();
        return;
    }
    pte = early_ioremap_pte (addr);
    if (pgprot_val (flags))
        set_pte (pte, pfn_pte (phys >> PAGE_SHIFT, flags));
    else
        pte_clear (&init_mm, addr, pte);
    __flush_tlb_one (addr);
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/ioremap.c.ifdefed" startline="519" endline="522">
{
    BUG ();
    return;
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/ioremap.c.ifdefed" startline="534" endline="539">
{
    if (after_paging_init)
        set_fixmap (idx, phys);
    else
        __early_set_fixmap (idx, phys, PAGE_KERNEL);
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/ioremap.c.ifdefed" startline="542" endline="547">
{
    if (after_paging_init)
        clear_fixmap (idx);
    else
        __early_set_fixmap (idx, 0, __pgprot (0));
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/ioremap.c.ifdefed" startline="553" endline="563">
{
    if (!early_ioremap_nested)
        return 0;
    WARN (1, KERN_WARNING "Debug warning: early ioremap leak of %d areas detected.\n", early_ioremap_nested);
    printk (KERN_WARNING "please boot with early_ioremap_debug and report the dmesg.\n");
    return 1;
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/ioremap.c.ifdefed" startline="567" endline="624">
{
    unsigned long offset, last_addr;
    unsigned int nrpages, nesting;
    enum fixed_addresses idx0, idx;
    WARN_ON (system_state != SYSTEM_BOOTING);
    nesting = early_ioremap_nested;
    if (early_ioremap_debug) {
        printk (KERN_INFO "early_ioremap(%08lx, %08lx) [%d] => ", phys_addr, size, nesting);
        dump_stack ();
    }
    last_addr = phys_addr + size - 1;
    if (!size || last_addr < phys_addr) {
        WARN_ON (1);
        return NULL;
    }
    if (nesting >= FIX_BTMAPS_NESTING) {
        WARN_ON (1);
        return NULL;
    }
    early_ioremap_nested++;
    offset = phys_addr & ~PAGE_MASK;
    phys_addr &= PAGE_MASK;
    size = PAGE_ALIGN (last_addr) - phys_addr;
    nrpages = size >> PAGE_SHIFT;
    if (nrpages > NR_FIX_BTMAPS) {
        WARN_ON (1);
        return NULL;
    }
    idx0 = FIX_BTMAP_BEGIN - NR_FIX_BTMAPS * nesting;
    idx = idx0;
    while (nrpages > 0) {
        early_set_fixmap (idx, phys_addr);
        phys_addr += PAGE_SIZE;
        --idx;
        --nrpages;
    }
    if (early_ioremap_debug)
        printk (KERN_CONT "%08lx + %08lx\n", offset, fix_to_virt (idx0));
    return (void *) (offset + fix_to_virt (idx0));
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/ioremap.c.ifdefed" startline="575" endline="579">
{
    printk (KERN_INFO "early_ioremap(%08lx, %08lx) [%d] => ", phys_addr, size, nesting);
    dump_stack ();
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/ioremap.c.ifdefed" startline="583" endline="586">
{
    WARN_ON (1);
    return NULL;
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/ioremap.c.ifdefed" startline="588" endline="591">
{
    WARN_ON (1);
    return NULL;
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/ioremap.c.ifdefed" startline="604" endline="607">
{
    WARN_ON (1);
    return NULL;
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/ioremap.c.ifdefed" startline="614" endline="619">
{
    early_set_fixmap (idx, phys_addr);
    phys_addr += PAGE_SIZE;
    --idx;
    --nrpages;
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/ioremap.c.ifdefed" startline="627" endline="658">
{
    unsigned long virt_addr;
    unsigned long offset;
    unsigned int nrpages;
    enum fixed_addresses idx;
    int nesting;
    nesting = --early_ioremap_nested;
    if (WARN_ON (nesting < 0))
        return;
    if (early_ioremap_debug) {
        printk (KERN_INFO "early_iounmap(%p, %08lx) [%d]\n", addr, size, nesting);
        dump_stack ();
    }
    virt_addr = (unsigned long) addr;
    if (virt_addr < fix_to_virt (FIX_BTMAP_BEGIN)) {
        WARN_ON (1);
        return;
    }
    offset = virt_addr & ~PAGE_MASK;
    nrpages = PAGE_ALIGN (offset +size - 1) >> PAGE_SHIFT;
    idx = FIX_BTMAP_BEGIN - NR_FIX_BTMAPS * nesting;
    while (nrpages > 0) {
        early_clear_fixmap (idx);
        --idx;
        --nrpages;
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/ioremap.c.ifdefed" startline="638" endline="642">
{
    printk (KERN_INFO "early_iounmap(%p, %08lx) [%d]\n", addr, size, nesting);
    dump_stack ();
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/ioremap.c.ifdefed" startline="645" endline="648">
{
    WARN_ON (1);
    return;
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/ioremap.c.ifdefed" startline="653" endline="657">
{
    early_clear_fixmap (idx);
    --idx;
    --nrpages;
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/ioremap.c.ifdefed" startline="661" endline="663">
{
    WARN_ON (1);
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/fault.c.ifdefed" startline="54" endline="61">
{
    return 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/fault.c.ifdefed" startline="64" endline="80">
{
    return 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/fault.c.ifdefed" startline="95" endline="172">
{
    unsigned char *instr;
    int scan_more = 1;
    int prefetch = 0;
    unsigned char *max_instr;
    if (error_code & PF_INSTR)
        return 0;
    instr = (unsigned char *) convert_ip_to_linear (current, regs);
    max_instr = instr + 15;
    if (user_mode (regs) && instr >= (unsigned char *) TASK_SIZE)
        return 0;
    while (scan_more && instr < max_instr) {
        unsigned char opcode;
        unsigned char instr_hi;
        unsigned char instr_lo;
        if (probe_kernel_address (instr, opcode))
            break;
        instr_hi = opcode & 0xf0;
        instr_lo = opcode & 0x0f;
        instr++;
        switch (instr_hi) {
        case 0x20 :
        case 0x30 :
            scan_more = ((instr_lo & 7) == 0x6);
            break;
        case 0x60 :
            scan_more = (instr_lo & 0xC) == 0x4;
            break;
        case 0xF0 :
            scan_more = !instr_lo || (instr_lo >> 1) == 1;
            break;
        case 0x00 :
            scan_more = 0;
            if (probe_kernel_address (instr, opcode))
                break;
            prefetch = (instr_lo == 0xF) && (opcode == 0x0D || opcode == 0x18);
            break;
        default :
            scan_more = 0;
            break;
        }
    }
    return prefetch;
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/fault.c.ifdefed" startline="114" endline="170">
{
    unsigned char opcode;
    unsigned char instr_hi;
    unsigned char instr_lo;
    if (probe_kernel_address (instr, opcode))
        break;
    instr_hi = opcode & 0xf0;
    instr_lo = opcode & 0x0f;
    instr++;
    switch (instr_hi) {
    case 0x20 :
    case 0x30 :
        scan_more = ((instr_lo & 7) == 0x6);
        break;
    case 0x60 :
        scan_more = (instr_lo & 0xC) == 0x4;
        break;
    case 0xF0 :
        scan_more = !instr_lo || (instr_lo >> 1) == 1;
        break;
    case 0x00 :
        scan_more = 0;
        if (probe_kernel_address (instr, opcode))
            break;
        prefetch = (instr_lo == 0xF) && (opcode == 0x0D || opcode == 0x18);
        break;
    default :
        scan_more = 0;
        break;
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/fault.c.ifdefed" startline="126" endline="169">
{
case 0x20 :
case 0x30 :
    scan_more = ((instr_lo & 7) == 0x6);
    break;
case 0x60 :
    scan_more = (instr_lo & 0xC) == 0x4;
    break;
case 0xF0 :
    scan_more = !instr_lo || (instr_lo >> 1) == 1;
    break;
case 0x00 :
    scan_more = 0;
    if (probe_kernel_address (instr, opcode))
        break;
    prefetch = (instr_lo == 0xF) && (opcode == 0x0D || opcode == 0x18);
    break;
default :
    scan_more = 0;
    break;
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/fault.c.ifdefed" startline="176" endline="184">
{
    siginfo_t info;
    info.si_signo = si_signo;
    info.si_errno = 0;
    info.si_code = si_code;
    info.si_addr = (void __user *) address;
    force_sig_info (si_signo, & info, tsk);
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/fault.c.ifdefed" startline="195" endline="265">
{
    pgd_t *pgd;
    pud_t *pud;
    pmd_t *pmd;
    pte_t *pte;
    pgd = (pgd_t *) read_cr3 ();
    pgd = __va ((unsigned long) pgd & PHYSICAL_PAGE_MASK);
    pgd += pgd_index (address);
    if (bad_address (pgd))
        goto bad;
    printk ("PGD %lx ", pgd_val (* pgd));
    if (!pgd_present (*pgd))
        goto ret;
    pud = pud_offset (pgd, address);
    if (bad_address (pud))
        goto bad;
    printk ("PUD %lx ", pud_val (* pud));
    if (!pud_present (*pud) || pud_large (*pud))
        goto ret;
    pmd = pmd_offset (pud, address);
    if (bad_address (pmd))
        goto bad;
    printk ("PMD %lx ", pmd_val (* pmd));
    if (!pmd_present (*pmd) || pmd_large (*pmd))
        goto ret;
    pte = pte_offset_kernel (pmd, address);
    if (bad_address (pte))
        goto bad;
    printk ("PTE %lx", pte_val (* pte));
ret :
    printk ("\n");
    return;
bad :
    printk ("BAD\n");
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/fault.c.ifdefed" startline="323" endline="342">
{
    return 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/fault.c.ifdefed" startline="351" endline="358">
{
    return 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/fault.c.ifdefed" startline="363" endline="379">
{
    return 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/fault.c.ifdefed" startline="383" endline="410">
{
    printk (KERN_ALERT "BUG: unable to handle kernel ");
    if (address < PAGE_SIZE)
        printk (KERN_CONT "NULL pointer dereference");
    else
        printk (KERN_CONT "paging request");
    printk (KERN_CONT " at %p\n", (void *) address);
    printk (KERN_ALERT "IP:");
    printk_address (regs -> ip, 1);
    dump_pagetable (address);
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/fault.c.ifdefed" startline="433" endline="440">
{
    if ((error_code & PF_WRITE) && !pte_write (*pte))
        return 0;
    if ((error_code & PF_INSTR) && !pte_exec (*pte))
        return 0;
    return 1;
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/fault.c.ifdefed" startline="453" endline="486">
{
    pgd_t *pgd;
    pud_t *pud;
    pmd_t *pmd;
    pte_t *pte;
    if (error_code & (PF_USER | PF_RSVD))
        return 0;
    pgd = init_mm.pgd + pgd_index (address);
    if (!pgd_present (*pgd))
        return 0;
    pud = pud_offset (pgd, address);
    if (!pud_present (*pud))
        return 0;
    if (pud_large (*pud))
        return spurious_fault_check (error_code, (pte_t *) pud);
    pmd = pmd_offset (pud, address);
    if (!pmd_present (*pmd))
        return 0;
    if (pmd_large (*pmd))
        return spurious_fault_check (error_code, (pte_t *) pmd);
    pte = pte_offset_kernel (pmd, address);
    if (!pte_present (*pte))
        return 0;
    return spurious_fault_check (error_code, pte);
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/fault.c.ifdefed" startline="498" endline="572">
{
    pgd_t *pgd, *pgd_ref;
    pud_t *pud, *pud_ref;
    pmd_t *pmd, *pmd_ref;
    pte_t *pte, *pte_ref;
    if (!(address >= VMALLOC_START && address < VMALLOC_END))
        return -1;
    pgd = pgd_offset (current->mm ? : &init_mm, address);
    pgd_ref = pgd_offset_k (address);
    if (pgd_none (*pgd_ref))
        return -1;
    if (pgd_none (*pgd))
        set_pgd (pgd, *pgd_ref);
    else
        BUG_ON (pgd_page_vaddr (*pgd) != pgd_page_vaddr (*pgd_ref));
    pud = pud_offset (pgd, address);
    pud_ref = pud_offset (pgd_ref, address);
    if (pud_none (*pud_ref))
        return -1;
    if (pud_none (*pud) || pud_page_vaddr (*pud) != pud_page_vaddr (*pud_ref))
        BUG ();
    pmd = pmd_offset (pud, address);
    pmd_ref = pmd_offset (pud_ref, address);
    if (pmd_none (*pmd_ref))
        return -1;
    if (pmd_none (*pmd) || pmd_page (*pmd) != pmd_page (*pmd_ref))
        BUG ();
    pte_ref = pte_offset_kernel (pmd_ref, address);
    if (!pte_present (*pte_ref))
        return -1;
    pte = pte_offset_kernel (pmd, address);
    if (!pte_present (*pte) || pte_pfn (*pte) != pte_pfn (*pte_ref))
        BUG ();
    return 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/fault.c.ifdefed" startline="585" endline="911">
{
    struct task_struct *tsk;
    struct mm_struct *mm;
    struct vm_area_struct *vma;
    unsigned long address;
    int write, si_code;
    int fault;
    trace_hardirqs_fixup ();
    tsk = current;
    mm = tsk->mm;
    prefetchw (& mm -> mmap_sem);
    address = read_cr2 ();
    si_code = SEGV_MAPERR;
    if (notify_page_fault (regs))
        return;
    if (unlikely (kmmio_fault (regs, address)))
        return;
    if (unlikely (address >= TASK_SIZE64)) {
        if (!(error_code & (PF_RSVD | PF_USER | PF_PROT)) && vmalloc_fault (address) >= 0)
            return;
        if (spurious_fault (address, error_code))
            return;
        goto bad_area_nosemaphore;
    }
    if (likely (regs->flags & X86_EFLAGS_IF))
        local_irq_enable ();
    if (unlikely (error_code &PF_RSVD))
        pgtable_bad (address, regs, error_code);
    if (unlikely (in_atomic () || !mm))
        goto bad_area_nosemaphore;
    if (user_mode_vm (regs))
        error_code |= PF_USER;
again :
    if (!down_read_trylock (&mm->mmap_sem)) {
        if ((error_code & PF_USER) == 0 && !search_exception_tables (regs->ip))
            goto bad_area_nosemaphore;
        down_read (& mm -> mmap_sem);
    }
    vma = find_vma (mm, address);
    if (!vma)
        goto bad_area;
    if (vma->vm_start <= address)
        goto good_area;
    if (!(vma->vm_flags & VM_GROWSDOWN))
        goto bad_area;
    if (error_code & PF_USER) {
        if (address + 65536 + 32 * sizeof (unsigned long) < regs->sp)
            goto bad_area;
    }
    if (expand_stack (vma, address))
        goto bad_area;
good_area :
    si_code = SEGV_ACCERR;
    write = 0;
    switch (error_code & (PF_PROT | PF_WRITE)) {
    default :
    case PF_WRITE :
        if (!(vma->vm_flags & VM_WRITE))
            goto bad_area;
        write++;
        break;
    case PF_PROT :
        goto bad_area;
    case 0 :
        if (!(vma->vm_flags & (VM_READ | VM_EXEC | VM_WRITE)))
            goto bad_area;
    }
    fault = handle_mm_fault (mm, vma, address, write);
    if (unlikely (fault &VM_FAULT_ERROR)) {
        if (fault & VM_FAULT_OOM)
            goto out_of_memory;
        else if (fault & VM_FAULT_SIGBUS)
            goto do_sigbus;
        BUG ();
    }
    if (fault & VM_FAULT_MAJOR)
        tsk->maj_flt++;
    else
        tsk->min_flt++;
    up_read (& mm -> mmap_sem);
    return;
bad_area :
    up_read (&mm->mmap_sem);
bad_area_nosemaphore :
    if (error_code & PF_USER) {
        local_irq_enable ();
        if (is_prefetch (regs, address, error_code))
            return;
        if (is_errata100 (regs, address))
            return;
        if (show_unhandled_signals && unhandled_signal (tsk, SIGSEGV) && printk_ratelimit ()) {
            printk ("%s%s[%d]: segfault at %lx ip %p sp %p error %lx", task_pid_nr (tsk) > 1 ? KERN_INFO : KERN_EMERG, tsk -> comm, task_pid_nr (tsk), address, (void *) regs -> ip, (void *) regs -> sp, error_code);
            print_vma_addr (" in ", regs -> ip);
            printk ("\n");
        }
        tsk->thread.cr2 = address;
        tsk->thread.error_code = error_code | (address >= TASK_SIZE);
        tsk->thread.trap_no = 14;
        force_sig_info_fault (SIGSEGV, si_code, address, tsk);
        return;
    }
    if (is_f00f_bug (regs, address))
        return;
no_context :
    if (fixup_exception (regs))
        return;
    if (is_prefetch (regs, address, error_code))
        return;
    if (is_errata93 (regs, address))
        return;
    flags = oops_begin ();
    show_fault_oops (regs, error_code, address);
    tsk->thread.cr2 = address;
    tsk->thread.trap_no = 14;
    tsk->thread.error_code = error_code;
    if (__die ("Oops", regs, error_code))
        regs = NULL;
    printk (KERN_EMERG "CR2: %016lx\n", address);
    oops_end (flags, regs, SIGKILL);
out_of_memory :
    up_read (&mm->mmap_sem);
    if (is_global_init (tsk)) {
        yield ();
        goto again;
    }
    printk ("VM: killing process %s\n", tsk -> comm);
    if (error_code & PF_USER)
        do_group_exit (SIGKILL);
    goto no_context;
do_sigbus :
    up_read (&mm->mmap_sem);
    if (!(error_code & PF_USER))
        goto no_context;
    tsk->thread.cr2 = address;
    tsk->thread.error_code = error_code;
    tsk->thread.trap_no = 14;
    force_sig_info_fault (SIGBUS, BUS_ADRERR, address, tsk);
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/fault.c.ifdefed" startline="631" endline="646">
{
    if (!(error_code & (PF_RSVD | PF_USER | PF_PROT)) && vmalloc_fault (address) >= 0)
        return;
    if (spurious_fault (address, error_code))
        return;
    goto bad_area_nosemaphore;
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/fault.c.ifdefed" startline="698" endline="703">
{
    if ((error_code & PF_USER) == 0 && !search_exception_tables (regs->ip))
        goto bad_area_nosemaphore;
    down_read (& mm -> mmap_sem);
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/fault.c.ifdefed" startline="712" endline="721">
{
    if (address + 65536 + 32 * sizeof (unsigned long) < regs->sp)
        goto bad_area;
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/fault.c.ifdefed" startline="731" endline="744">
{
default :
case PF_WRITE :
    if (!(vma->vm_flags & VM_WRITE))
        goto bad_area;
    write++;
    break;
case PF_PROT :
    goto bad_area;
case 0 :
    if (!(vma->vm_flags & (VM_READ | VM_EXEC | VM_WRITE)))
        goto bad_area;
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/fault.c.ifdefed" startline="755" endline="761">
{
    if (fault & VM_FAULT_OOM)
        goto out_of_memory;
    else if (fault & VM_FAULT_SIGBUS)
        goto do_sigbus;
    BUG ();
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/fault.c.ifdefed" startline="789" endline="822">
{
    local_irq_enable ();
    if (is_prefetch (regs, address, error_code))
        return;
    if (is_errata100 (regs, address))
        return;
    if (show_unhandled_signals && unhandled_signal (tsk, SIGSEGV) && printk_ratelimit ()) {
        printk ("%s%s[%d]: segfault at %lx ip %p sp %p error %lx", task_pid_nr (tsk) > 1 ? KERN_INFO : KERN_EMERG, tsk -> comm, task_pid_nr (tsk), address, (void *) regs -> ip, (void *) regs -> sp, error_code);
        print_vma_addr (" in ", regs -> ip);
        printk ("\n");
    }
    tsk->thread.cr2 = address;
    tsk->thread.error_code = error_code | (address >= TASK_SIZE);
    tsk->thread.trap_no = 14;
    force_sig_info_fault (SIGSEGV, si_code, address, tsk);
    return;
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/fault.c.ifdefed" startline="806" endline="814">
{
    printk ("%s%s[%d]: segfault at %lx ip %p sp %p error %lx", task_pid_nr (tsk) > 1 ? KERN_INFO : KERN_EMERG, tsk -> comm, task_pid_nr (tsk), address, (void *) regs -> ip, (void *) regs -> sp, error_code);
    print_vma_addr (" in ", regs -> ip);
    printk ("\n");
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/fault.c.ifdefed" startline="881" endline="889">
{
    yield ();
    goto again;
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/fault.c.ifdefed" startline="917" endline="961">
{
    unsigned long start = VMALLOC_START & PGDIR_MASK;
    unsigned long address;
    for (address = start; address <= VMALLOC_END; address += PGDIR_SIZE) {
        const pgd_t *pgd_ref = pgd_offset_k (address);
        unsigned long flags;
        struct page *page;
        if (pgd_none (*pgd_ref))
            continue;
        spin_lock_irqsave (& pgd_lock, flags);
        list_for_each_entry (page, &pgd_list, lru) {
            pgd_t *pgd;
            pgd = (pgd_t *) page_address (page) + pgd_index (address);
            if (pgd_none (*pgd))
                set_pgd (pgd, *pgd_ref);
            else
                BUG_ON (pgd_page_vaddr (*pgd) != pgd_page_vaddr (*pgd_ref));
        }
        spin_unlock_irqrestore (& pgd_lock, flags);
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/fault.c.ifdefed" startline="942" endline="959">
{
    const pgd_t *pgd_ref = pgd_offset_k (address);
    unsigned long flags;
    struct page *page;
    if (pgd_none (*pgd_ref))
        continue;
    spin_lock_irqsave (& pgd_lock, flags);
    list_for_each_entry (page, &pgd_list, lru) {
        pgd_t *pgd;
        pgd = (pgd_t *) page_address (page) + pgd_index (address);
        if (pgd_none (*pgd))
            set_pgd (pgd, *pgd_ref);
        else
            BUG_ON (pgd_page_vaddr (*pgd) != pgd_page_vaddr (*pgd_ref));
    }
    spin_unlock_irqrestore (& pgd_lock, flags);
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/fault.c.ifdefed" startline="950" endline="957">
{
    pgd_t *pgd;
    pgd = (pgd_t *) page_address (page) + pgd_index (address);
    if (pgd_none (*pgd))
        set_pgd (pgd, *pgd_ref);
    else
        BUG_ON (pgd_page_vaddr (*pgd) != pgd_page_vaddr (*pgd_ref));
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/pgtable.c.ifdefed" startline="8" endline="10">
{
    return (pte_t *) __get_free_page (GFP_KERNEL | __GFP_REPEAT | __GFP_ZERO);
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/pgtable.c.ifdefed" startline="13" endline="24">
{
    struct page *pte;
    pte = alloc_pages (GFP_KERNEL | __GFP_REPEAT | __GFP_ZERO, 0);
    if (pte)
        pgtable_page_ctor (pte);
    return pte;
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/pgtable.c.ifdefed" startline="27" endline="31">
{
    pgtable_page_dtor (pte);
    paravirt_release_pte (page_to_pfn (pte));
    tlb_remove_page (tlb, pte);
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/pgtable.c.ifdefed" startline="50" endline="54">
{
    struct page *page = virt_to_page (pgd);
    list_add (& page -> lru, & pgd_list);
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/pgtable.c.ifdefed" startline="57" endline="61">
{
    struct page *page = virt_to_page (pgd);
    list_del (& page -> lru);
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/pgtable.c.ifdefed" startline="67" endline="88">
{
    pgd_t *pgd = p;
    if (PAGETABLE_LEVELS == 2 || (PAGETABLE_LEVELS == 3 && SHARED_KERNEL_PMD) || PAGETABLE_LEVELS == 4) {
        clone_pgd_range (pgd + KERNEL_PGD_BOUNDARY, swapper_pg_dir + KERNEL_PGD_BOUNDARY, KERNEL_PGD_PTRS);
        paravirt_alloc_pmd_clone (__pa (pgd) >> PAGE_SHIFT, __pa (swapper_pg_dir) >> PAGE_SHIFT, KERNEL_PGD_BOUNDARY, KERNEL_PGD_PTRS);
    }
    if (!SHARED_KERNEL_PMD)
        pgd_list_add (pgd);
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/pgtable.c.ifdefed" startline="75" endline="83">
{
    clone_pgd_range (pgd + KERNEL_PGD_BOUNDARY, swapper_pg_dir + KERNEL_PGD_BOUNDARY, KERNEL_PGD_PTRS);
    paravirt_alloc_pmd_clone (__pa (pgd) >> PAGE_SHIFT, __pa (swapper_pg_dir) >> PAGE_SHIFT, KERNEL_PGD_BOUNDARY, KERNEL_PGD_PTRS);
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/pgtable.c.ifdefed" startline="91" endline="100">
{
    unsigned long flags;
    if (SHARED_KERNEL_PMD)
        return;
    spin_lock_irqsave (& pgd_lock, flags);
    pgd_list_del (pgd);
    spin_unlock_irqrestore (& pgd_lock, flags);
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/pgtable.c.ifdefed" startline="152" endline="158">
{
    int i;
    for (i = 0; i < PREALLOCATED_PMDS; i++)
        if (pmds[i])
            free_page ((unsigned long) pmds[i]);
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/pgtable.c.ifdefed" startline="161" endline="178">
{
    int i;
    bool failed = false;
    for (i = 0; i < PREALLOCATED_PMDS; i++) {
        pmd_t *pmd = (pmd_t *) get_zeroed_page (GFP_KERNEL | __GFP_REPEAT);
        if (pmd == NULL)
            failed = true;
        pmds[i] = pmd;
    }
    if (failed) {
        free_pmds (pmds);
        return -ENOMEM;
    }
    return 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/pgtable.c.ifdefed" startline="165" endline="170">
{
    pmd_t *pmd = (pmd_t *) get_zeroed_page (GFP_KERNEL | __GFP_REPEAT);
    if (pmd == NULL)
        failed = true;
    pmds[i] = pmd;
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/pgtable.c.ifdefed" startline="172" endline="175">
{
    free_pmds (pmds);
    return -ENOMEM;
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/pgtable.c.ifdefed" startline="187" endline="202">
{
    int i;
    for (i = 0; i < PREALLOCATED_PMDS; i++) {
        pgd_t pgd = pgdp[i];
        if (pgd_val (pgd) != 0) {
            pmd_t *pmd = (pmd_t *) pgd_page_vaddr (pgd);
            pgdp[i] = native_make_pgd (0);
            paravirt_release_pmd (pgd_val (pgd) >> PAGE_SHIFT);
            pmd_free (mm, pmd);
        }
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/pgtable.c.ifdefed" startline="190" endline="201">
{
    pgd_t pgd = pgdp[i];
    if (pgd_val (pgd) != 0) {
        pmd_t *pmd = (pmd_t *) pgd_page_vaddr (pgd);
        pgdp[i] = native_make_pgd (0);
        paravirt_release_pmd (pgd_val (pgd) >> PAGE_SHIFT);
        pmd_free (mm, pmd);
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/pgtable.c.ifdefed" startline="193" endline="200">
{
    pmd_t *pmd = (pmd_t *) pgd_page_vaddr (pgd);
    pgdp[i] = native_make_pgd (0);
    paravirt_release_pmd (pgd_val (pgd) >> PAGE_SHIFT);
    pmd_free (mm, pmd);
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/pgtable.c.ifdefed" startline="205" endline="225">
{
    pud_t *pud;
    unsigned long addr;
    int i;
    if (PREALLOCATED_PMDS == 0)
        return;
    pud = pud_offset (pgd, 0);
    for (addr = i = 0; i < PREALLOCATED_PMDS; i++, pud++, addr += PUD_SIZE) {
        pmd_t *pmd = pmds[i];
        if (i >= KERNEL_PGD_BOUNDARY)
            memcpy (pmd, (pmd_t *) pgd_page_vaddr (swapper_pg_dir[i]), sizeof (pmd_t) * PTRS_PER_PMD);
        pud_populate (mm, pud, pmd);
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/pgtable.c.ifdefed" startline="216" endline="224">
{
    pmd_t *pmd = pmds[i];
    if (i >= KERNEL_PGD_BOUNDARY)
        memcpy (pmd, (pmd_t *) pgd_page_vaddr (swapper_pg_dir[i]), sizeof (pmd_t) * PTRS_PER_PMD);
    pud_populate (mm, pud, pmd);
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/pgtable.c.ifdefed" startline="228" endline="266">
{
    pgd_t *pgd;
    pmd_t *pmds [PREALLOCATED_PMDS];
    unsigned long flags;
    pgd = (pgd_t *) __get_free_page (GFP_KERNEL | __GFP_ZERO);
    if (pgd == NULL)
        goto out;
    mm->pgd = pgd;
    if (preallocate_pmds (pmds) != 0)
        goto out_free_pgd;
    if (paravirt_pgd_alloc (mm) != 0)
        goto out_free_pmds;
    spin_lock_irqsave (& pgd_lock, flags);
    pgd_ctor (pgd);
    pgd_prepopulate_pmd (mm, pgd, pmds);
    spin_unlock_irqrestore (& pgd_lock, flags);
    return pgd;
out_free_pmds :
    free_pmds (pmds);
out_free_pgd :
    free_page ((unsigned long) pgd);
out :
    return NULL;
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/pgtable.c.ifdefed" startline="269" endline="274">
{
    pgd_mop_up_pmds (mm, pgd);
    pgd_dtor (pgd);
    paravirt_pgd_free (mm, pgd);
    free_page ((unsigned long) pgd);
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/pgtable.c.ifdefed" startline="279" endline="289">
{
    int changed = !pte_same (*ptep, entry);
    if (changed && dirty) {
        *ptep = entry;
        pte_update_defer (vma -> vm_mm, address, ptep);
        flush_tlb_page (vma, address);
    }
    return changed;
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/pgtable.c.ifdefed" startline="282" endline="286">
{
    *ptep = entry;
    pte_update_defer (vma -> vm_mm, address, ptep);
    flush_tlb_page (vma, address);
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/pgtable.c.ifdefed" startline="293" endline="304">
{
    int ret = 0;
    if (pte_young (*ptep))
        ret = test_and_clear_bit (_PAGE_BIT_ACCESSED, (unsigned long *) &ptep->pte);
    if (ret)
        pte_update (vma->vm_mm, addr, ptep);
    return ret;
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/pgtable.c.ifdefed" startline="308" endline="316">
{
    int young;
    young = ptep_test_and_clear_young (vma, address, ptep);
    if (young)
        flush_tlb_page (vma, address);
    return young;
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/pgtable.c.ifdefed" startline="321" endline="330">
{
    unsigned long address = __fix_to_virt (idx);
    if (idx >= __end_of_fixed_addresses) {
        BUG ();
        return;
    }
    set_pte_vaddr (address, pte);
    fixmaps_set++;
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/pgtable.c.ifdefed" startline="324" endline="327">
{
    BUG ();
    return;
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/pgtable.c.ifdefed" startline="333" endline="335">
{
    __native_set_fixmap (idx, pfn_pte (phys >> PAGE_SHIFT, flags));
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/pageattr.c.ifdefed" startline="75" endline="75">
{
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/pageattr.c.ifdefed" startline="100" endline="102">
{
    return addr >= start && addr < end;
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/pageattr.c.ifdefed" startline="117" endline="130">
{
    void *vend = vaddr + size - 1;
    mb ();
    for (; vaddr < vend; vaddr += boot_cpu_data.x86_clflush_size)
        clflush (vaddr);
    clflush (vend);
    mb ();
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/pageattr.c.ifdefed" startline="133" endline="144">
{
    unsigned long cache = (unsigned long) arg;
    __flush_tlb_all ();
    if (cache && boot_cpu_data.x86_model >= 4)
        wbinvd ();
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/pageattr.c.ifdefed" startline="147" endline="151">
{
    BUG_ON (irqs_disabled ());
    on_each_cpu (__cpa_flush_all, (void *) cache, 1);
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/pageattr.c.ifdefed" startline="154" endline="161">
{
    __flush_tlb_all ();
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/pageattr.c.ifdefed" startline="164" endline="191">
{
    unsigned int i, level;
    unsigned long addr;
    BUG_ON (irqs_disabled ());
    WARN_ON (PAGE_ALIGN (start) != start);
    on_each_cpu (__cpa_flush_range, NULL, 1);
    if (!cache)
        return;
    for (i = 0, addr = start; i < numpages; i++, addr += PAGE_SIZE) {
        pte_t *pte = lookup_address (addr, &level);
        if (pte && (pte_val (*pte) & _PAGE_PRESENT))
            clflush_cache_range ((void *) addr, PAGE_SIZE);
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/pageattr.c.ifdefed" startline="182" endline="190">
{
    pte_t *pte = lookup_address (addr, &level);
    if (pte && (pte_val (*pte) & _PAGE_PRESENT))
        clflush_cache_range ((void *) addr, PAGE_SIZE);
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/pageattr.c.ifdefed" startline="201" endline="230">
{
    pgprot_t forbidden = __pgprot (0);
    if (within (pfn, BIOS_BEGIN >> PAGE_SHIFT, BIOS_END >> PAGE_SHIFT))
        pgprot_val (forbidden) |= _PAGE_NX;
    if (within (address, (unsigned long) _text, (unsigned long) _etext))
        pgprot_val (forbidden) |= _PAGE_NX;
    if (within (pfn, __pa ((unsigned long) __start_rodata) >> PAGE_SHIFT, __pa ((unsigned long) __end_rodata) >> PAGE_SHIFT))
        pgprot_val (forbidden) |= _PAGE_RW;
    prot = __pgprot (pgprot_val (prot) &~pgprot_val (forbidden));
    return prot;
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/pageattr.c.ifdefed" startline="241" endline="270">
{
    pgd_t *pgd = pgd_offset_k (address);
    pud_t *pud;
    pmd_t *pmd;
    *level = PG_LEVEL_NONE;
    if (pgd_none (*pgd))
        return NULL;
    pud = pud_offset (pgd, address);
    if (pud_none (*pud))
        return NULL;
    *level = PG_LEVEL_1G;
    if (pud_large (*pud) || !pud_present (*pud))
        return (pte_t *) pud;
    pmd = pmd_offset (pud, address);
    if (pmd_none (*pmd))
        return NULL;
    *level = PG_LEVEL_2M;
    if (pmd_large (*pmd) || !pmd_present (*pmd))
        return (pte_t *) pmd;
    *level = PG_LEVEL_4K;
    return pte_offset_kernel (pmd, address);
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/pageattr.c.ifdefed" startline="277" endline="296">
{
    set_pte_atomic (kpte, pte);
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/pageattr.c.ifdefed" startline="301" endline="409">
{
    unsigned long nextpage_addr, numpages, pmask, psize, flags, addr, pfn;
    pte_t new_pte, old_pte, *tmp;
    pgprot_t old_prot, new_prot;
    int i, do_split = 1;
    unsigned int level;
    if (cpa->force_split)
        return 1;
    spin_lock_irqsave (& pgd_lock, flags);
    tmp = lookup_address (address, &level);
    if (tmp != kpte)
        goto out_unlock;
    switch (level) {
    case PG_LEVEL_2M :
        psize = PMD_PAGE_SIZE;
        pmask = PMD_PAGE_MASK;
        break;
    default :
        do_split = -EINVAL;
        goto out_unlock;
    }
    nextpage_addr = (address + psize) & pmask;
    numpages = (nextpage_addr - address) >> PAGE_SHIFT;
    if (numpages < cpa->numpages)
        cpa->numpages = numpages;
    old_pte = *kpte;
    old_prot = new_prot = pte_pgprot (old_pte);
    pgprot_val (new_prot) &= ~pgprot_val (cpa->mask_clr);
    pgprot_val (new_prot) |= pgprot_val (cpa->mask_set);
    pfn = pte_pfn (old_pte) + ((address & (psize - 1)) >> PAGE_SHIFT);
    cpa->pfn = pfn;
    new_prot = static_protections (new_prot, address, pfn);
    addr = address + PAGE_SIZE;
    pfn++;
    for (i = 1; i < cpa->numpages; i++, addr += PAGE_SIZE, pfn++) {
        pgprot_t chk_prot = static_protections (new_prot, addr, pfn);
        if (pgprot_val (chk_prot) != pgprot_val (new_prot))
            goto out_unlock;
    }
    if (pgprot_val (new_prot) == pgprot_val (old_prot)) {
        do_split = 0;
        goto out_unlock;
    }
    if (address == (nextpage_addr - psize) && cpa->numpages == numpages) {
        new_pte = pfn_pte (pte_pfn (old_pte), canon_pgprot (new_prot));
        __set_pmd_pte (kpte, address, new_pte);
        cpa->flushtlb = 1;
        do_split = 0;
    }
out_unlock :
    spin_unlock_irqrestore (&pgd_lock, flags);
    return do_split;
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/pageattr.c.ifdefed" startline="320" endline="334">
{
case PG_LEVEL_2M :
    psize = PMD_PAGE_SIZE;
    pmask = PMD_PAGE_MASK;
    break;
default :
    do_split = -EINVAL;
    goto out_unlock;
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/pageattr.c.ifdefed" startline="370" endline="375">
{
    pgprot_t chk_prot = static_protections (new_prot, addr, pfn);
    if (pgprot_val (chk_prot) != pgprot_val (new_prot))
        goto out_unlock;
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/pageattr.c.ifdefed" startline="381" endline="384">
{
    do_split = 0;
    goto out_unlock;
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/pageattr.c.ifdefed" startline="394" endline="403">
{
    new_pte = pfn_pte (pte_pfn (old_pte), canon_pgprot (new_prot));
    __set_pmd_pte (kpte, address, new_pte);
    cpa->flushtlb = 1;
    do_split = 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/pageattr.c.ifdefed" startline="416" endline="455">
{
    gfp_t gfp = GFP_KERNEL;
    unsigned long flags;
    struct page *p;
    if (current->flags & PF_MEMALLOC)
        return;
    current->flags |= PF_MEMALLOC;
    if (in_atomic () || irqs_disabled () || debug_pagealloc)
        gfp = GFP_ATOMIC | __GFP_NORETRY | __GFP_NOWARN;
    while (pool_pages < pool_size || (ret && !*ret)) {
        p = alloc_pages (gfp, 0);
        if (!p) {
            pool_failed++;
            break;
        }
        if (ret && !*ret) {
            *ret = p;
            continue;
        }
        spin_lock_irqsave (& pgd_lock, flags);
        list_add (& p -> lru, & page_pool);
        pool_pages++;
        spin_unlock_irqrestore (& pgd_lock, flags);
    }
    current->flags &= ~PF_MEMALLOC;
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/pageattr.c.ifdefed" startline="435" endline="452">
{
    p = alloc_pages (gfp, 0);
    if (!p) {
        pool_failed++;
        break;
    }
    if (ret && !*ret) {
        *ret = p;
        continue;
    }
    spin_lock_irqsave (& pgd_lock, flags);
    list_add (& p -> lru, & page_pool);
    pool_pages++;
    spin_unlock_irqrestore (& pgd_lock, flags);
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/pageattr.c.ifdefed" startline="437" endline="440">
{
    pool_failed++;
    break;
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/pageattr.c.ifdefed" startline="444" endline="447">
{
    *ret = p;
    continue;
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/pageattr.c.ifdefed" startline="463" endline="487">
{
    struct sysinfo si;
    unsigned long gb;
    si_meminfo (& si);
    if (debug_pagealloc) {
        gb = ((si.totalram >> SHIFT_MB) + ROUND_MB_GB) >> SHIFT_MB_GB;
        pool_size = POOL_PAGES_PER_GB * gb;
    }
    else {
        pool_size = 1;
    }
    pool_low = pool_size;
    cpa_fill_pool (NULL);
    printk (KERN_DEBUG "CPA: page pool initialized %lu of %lu pages preallocated\n", pool_pages, pool_size);
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/pageattr.c.ifdefed" startline="475" endline="478">
{
    gb = ((si.totalram >> SHIFT_MB) + ROUND_MB_GB) >> SHIFT_MB_GB;
    pool_size = POOL_PAGES_PER_GB * gb;
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/pageattr.c.ifdefed" startline="478" endline="480">
{
    pool_size = 1;
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/pageattr.c.ifdefed" startline="490" endline="583">
{
    unsigned long flags, pfn, pfninc = 1;
    unsigned int i, level;
    pte_t *pbase, *tmp;
    pgprot_t ref_prot;
    struct page *base;
    spin_lock_irqsave (& pgd_lock, flags);
    if (list_empty (&page_pool)) {
        spin_unlock_irqrestore (& pgd_lock, flags);
        base = NULL;
        cpa_fill_pool (& base);
        if (!base)
            return -ENOMEM;
        spin_lock_irqsave (& pgd_lock, flags);
    }
    else {
        base = list_first_entry (&page_pool, struct page, lru);
        list_del (& base -> lru);
        pool_pages--;
        if (pool_pages < pool_low)
            pool_low = pool_pages;
    }
    tmp = lookup_address (address, &level);
    if (tmp != kpte)
        goto out_unlock;
    pbase = (pte_t *) page_address (base);
    paravirt_alloc_pte (& init_mm, page_to_pfn (base));
    ref_prot = pte_pgprot (pte_clrhuge (*kpte));
    pfn = pte_pfn (*kpte);
    for (i = 0; i < PTRS_PER_PTE; i++, pfn += pfninc)
        set_pte (&pbase[i], pfn_pte (pfn, ref_prot));
    if (address >= (unsigned long) __va (0) && address < (unsigned long) __va (max_low_pfn_mapped << PAGE_SHIFT))
        split_page_count (level);
    ref_prot = pte_pgprot (pte_mkexec (pte_clrhuge (*kpte)));
    pgprot_val (ref_prot) |= _PAGE_PRESENT;
    __set_pmd_pte (kpte, address, mk_pte (base, ref_prot));
    base = NULL;
out_unlock :
    if (base) {
        list_add (& base -> lru, & page_pool);
        pool_pages++;
    }
    else
        pool_used++;
    spin_unlock_irqrestore (& pgd_lock, flags);
    return 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/pageattr.c.ifdefed" startline="503" endline="510">
{
    spin_unlock_irqrestore (& pgd_lock, flags);
    base = NULL;
    cpa_fill_pool (& base);
    if (!base)
        return -ENOMEM;
    spin_lock_irqsave (& pgd_lock, flags);
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/pageattr.c.ifdefed" startline="510" endline="517">
{
    base = list_first_entry (&page_pool, struct page, lru);
    list_del (& base -> lru);
    pool_pages--;
    if (pool_pages < pool_low)
        pool_low = pool_pages;
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/pageattr.c.ifdefed" startline="575" endline="578">
{
    list_add (& base -> lru, & page_pool);
    pool_pages++;
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/pageattr.c.ifdefed" startline="586" endline="658">
{
    unsigned long address = cpa->vaddr;
    int do_split, err;
    unsigned int level;
    pte_t *kpte, old_pte;
repeat :
    kpte = lookup_address (address, &level);
    if (!kpte)
        return 0;
    old_pte = *kpte;
    if (!pte_val (old_pte)) {
        if (!primary)
            return 0;
        WARN (1, KERN_WARNING "CPA: called for zero pte. " "vaddr = %lx cpa->vaddr = %lx\n", address, cpa -> vaddr);
        return -EINVAL;
    }
    if (level == PG_LEVEL_4K) {
        pte_t new_pte;
        pgprot_t new_prot = pte_pgprot (old_pte);
        unsigned long pfn = pte_pfn (old_pte);
        pgprot_val (new_prot) &= ~pgprot_val (cpa->mask_clr);
        pgprot_val (new_prot) |= pgprot_val (cpa->mask_set);
        new_prot = static_protections (new_prot, address, pfn);
        new_pte = pfn_pte (pfn, canon_pgprot (new_prot));
        cpa->pfn = pfn;
        if (pte_val (old_pte) != pte_val (new_pte)) {
            set_pte_atomic (kpte, new_pte);
            cpa->flushtlb = 1;
        }
        cpa->numpages = 1;
        return 0;
    }
    do_split = try_preserve_large_page (kpte, address, cpa);
    if (do_split <= 0)
        return do_split;
    err = split_large_page (kpte, address);
    if (!err) {
        cpa->flushtlb = 1;
        goto repeat;
    }
    return err;
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/pageattr.c.ifdefed" startline="598" endline="605">
{
    if (!primary)
        return 0;
    WARN (1, KERN_WARNING "CPA: called for zero pte. " "vaddr = %lx cpa->vaddr = %lx\n", address, cpa -> vaddr);
    return -EINVAL;
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/pageattr.c.ifdefed" startline="607" endline="633">
{
    pte_t new_pte;
    pgprot_t new_prot = pte_pgprot (old_pte);
    unsigned long pfn = pte_pfn (old_pte);
    pgprot_val (new_prot) &= ~pgprot_val (cpa->mask_clr);
    pgprot_val (new_prot) |= pgprot_val (cpa->mask_set);
    new_prot = static_protections (new_prot, address, pfn);
    new_pte = pfn_pte (pfn, canon_pgprot (new_prot));
    cpa->pfn = pfn;
    if (pte_val (old_pte) != pte_val (new_pte)) {
        set_pte_atomic (kpte, new_pte);
        cpa->flushtlb = 1;
    }
    cpa->numpages = 1;
    return 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/pageattr.c.ifdefed" startline="627" endline="630">
{
    set_pte_atomic (kpte, new_pte);
    cpa->flushtlb = 1;
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/pageattr.c.ifdefed" startline="652" endline="655">
{
    cpa->flushtlb = 1;
    goto repeat;
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/pageattr.c.ifdefed" startline="663" endline="719">
{
    struct cpa_data alias_cpa;
    int ret = 0;
    if (cpa->pfn >= max_pfn_mapped)
        return 0;
    if (!(within (cpa->vaddr, PAGE_OFFSET, PAGE_OFFSET +(max_low_pfn_mapped << PAGE_SHIFT)))) {
        alias_cpa = *cpa;
        alias_cpa.vaddr = (unsigned long) __va (cpa->pfn << PAGE_SHIFT);
        ret = __change_page_attr_set_clr (&alias_cpa, 0);
    }
    return ret;
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/pageattr.c.ifdefed" startline="684" endline="690">
{
    alias_cpa = *cpa;
    alias_cpa.vaddr = (unsigned long) __va (cpa->pfn << PAGE_SHIFT);
    ret = __change_page_attr_set_clr (&alias_cpa, 0);
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/pageattr.c.ifdefed" startline="722" endline="752">
{
    int ret, numpages = cpa->numpages;
    while (numpages) {
        cpa->numpages = numpages;
        ret = __change_page_attr (cpa, checkalias);
        if (ret)
            return ret;
        if (checkalias) {
            ret = cpa_process_alias (cpa);
            if (ret)
                return ret;
        }
        BUG_ON (cpa -> numpages > numpages);
        numpages -= cpa->numpages;
        cpa->vaddr += cpa->numpages * PAGE_SIZE;
    }
    return 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/pageattr.c.ifdefed" startline="725" endline="750">
{
    cpa->numpages = numpages;
    ret = __change_page_attr (cpa, checkalias);
    if (ret)
        return ret;
    if (checkalias) {
        ret = cpa_process_alias (cpa);
        if (ret)
            return ret;
    }
    BUG_ON (cpa -> numpages > numpages);
    numpages -= cpa->numpages;
    cpa->vaddr += cpa->numpages * PAGE_SIZE;
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/pageattr.c.ifdefed" startline="736" endline="740">
{
    ret = cpa_process_alias (cpa);
    if (ret)
        return ret;
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/pageattr.c.ifdefed" startline="755" endline="758">
{
    return pgprot_val (attr) & (_PAGE_PAT | _PAGE_PAT_LARGE | _PAGE_PWT | _PAGE_PCD);
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/pageattr.c.ifdefed" startline="763" endline="824">
{
    struct cpa_data cpa;
    int ret, cache, checkalias;
    mask_set = canon_pgprot (mask_set);
    mask_clr = canon_pgprot (mask_clr);
    if (!pgprot_val (mask_set) && !pgprot_val (mask_clr) && !force_split)
        return 0;
    if (addr & ~PAGE_MASK) {
        addr &= PAGE_MASK;
        WARN_ON_ONCE (1);
    }
    cpa.vaddr = addr;
    cpa.numpages = numpages;
    cpa.mask_set = mask_set;
    cpa.mask_clr = mask_clr;
    cpa.flushtlb = 0;
    cpa.force_split = force_split;
    checkalias = (pgprot_val (mask_set) | pgprot_val (mask_clr)) != _PAGE_NX;
    ret = __change_page_attr_set_clr (&cpa, checkalias);
    if (!cpa.flushtlb)
        goto out;
    cache = cache_attr (mask_set);
    if (!ret && cpu_has_clflush)
        cpa_flush_range (addr, numpages, cache);
    else
        cpa_flush_all (cache);
out :
    cpa_fill_pool (NULL);
    return ret;
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/pageattr.c.ifdefed" startline="777" endline="783">
{
    addr &= PAGE_MASK;
    WARN_ON_ONCE (1);
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/pageattr.c.ifdefed" startline="828" endline="830">
{
    return change_page_attr_set_clr (addr, numpages, mask, __pgprot (0), 0);
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/pageattr.c.ifdefed" startline="834" endline="836">
{
    return change_page_attr_set_clr (addr, numpages, __pgprot (0), mask, 0);
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/pageattr.c.ifdefed" startline="839" endline="845">
{
    return change_page_attr_set (addr, numpages, __pgprot (_PAGE_CACHE_UC_MINUS));
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/pageattr.c.ifdefed" startline="848" endline="857">
{
    if (reserve_memtype (__pa (addr), __pa (addr) +numpages * PAGE_SIZE, _PAGE_CACHE_UC_MINUS, NULL))
        return -EINVAL;
    return _set_memory_uc (addr, numpages);
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/pageattr.c.ifdefed" startline="861" endline="864">
{
    return change_page_attr_set (addr, numpages, __pgprot (_PAGE_CACHE_WC));
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/pageattr.c.ifdefed" startline="867" endline="876">
{
    if (!pat_enabled)
        return set_memory_uc (addr, numpages);
    if (reserve_memtype (__pa (addr), __pa (addr) +numpages * PAGE_SIZE, _PAGE_CACHE_WC, NULL))
        return -EINVAL;
    return _set_memory_wc (addr, numpages);
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/pageattr.c.ifdefed" startline="880" endline="883">
{
    return change_page_attr_clear (addr, numpages, __pgprot (_PAGE_CACHE_MASK));
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/pageattr.c.ifdefed" startline="886" endline="890">
{
    free_memtype (__pa (addr), __pa (addr) + numpages * PAGE_SIZE);
    return _set_memory_wb (addr, numpages);
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/pageattr.c.ifdefed" startline="894" endline="896">
{
    return change_page_attr_clear (addr, numpages, __pgprot (_PAGE_NX));
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/pageattr.c.ifdefed" startline="900" endline="902">
{
    return change_page_attr_set (addr, numpages, __pgprot (_PAGE_NX));
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/pageattr.c.ifdefed" startline="906" endline="908">
{
    return change_page_attr_clear (addr, numpages, __pgprot (_PAGE_RW));
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/pageattr.c.ifdefed" startline="911" endline="913">
{
    return change_page_attr_set (addr, numpages, __pgprot (_PAGE_RW));
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/pageattr.c.ifdefed" startline="916" endline="918">
{
    return change_page_attr_clear (addr, numpages, __pgprot (_PAGE_PRESENT));
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/pageattr.c.ifdefed" startline="921" endline="924">
{
    return change_page_attr_set_clr (addr, numpages, __pgprot (0), __pgprot (0), 1);
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/pageattr.c.ifdefed" startline="927" endline="931">
{
    unsigned long addr = (unsigned long) page_address (page);
    return set_memory_uc (addr, numpages);
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/pageattr.c.ifdefed" startline="935" endline="939">
{
    unsigned long addr = (unsigned long) page_address (page);
    return set_memory_wb (addr, numpages);
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/pageattr.c.ifdefed" startline="943" endline="947">
{
    unsigned long addr = (unsigned long) page_address (page);
    return set_memory_x (addr, numpages);
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/pageattr.c.ifdefed" startline="951" endline="955">
{
    unsigned long addr = (unsigned long) page_address (page);
    return set_memory_nx (addr, numpages);
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/pageattr.c.ifdefed" startline="959" endline="963">
{
    unsigned long addr = (unsigned long) page_address (page);
    return set_memory_ro (addr, numpages);
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/pageattr.c.ifdefed" startline="966" endline="970">
{
    unsigned long addr = (unsigned long) page_address (page);
    return set_memory_rw (addr, numpages);
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/hugetlbpage.c.ifdefed" startline="23" endline="39">
{
    unsigned long saddr = ((idx - svma->vm_pgoff) << PAGE_SHIFT) + svma->vm_start;
    unsigned long sbase = saddr & PUD_MASK;
    unsigned long s_end = sbase + PUD_SIZE;
    if (pmd_index (addr) != pmd_index (saddr) || vma->vm_flags != svma->vm_flags || sbase < svma->vm_start || svma->vm_end < s_end)
        return 0;
    return saddr;
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/hugetlbpage.c.ifdefed" startline="42" endline="53">
{
    unsigned long base = addr & PUD_MASK;
    unsigned long end = base + PUD_SIZE;
    if (vma->vm_flags & VM_MAYSHARE && vma->vm_start <= base && end <= vma->vm_end)
        return 1;
    return 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/hugetlbpage.c.ifdefed" startline="59" endline="98">
{
    struct vm_area_struct *vma = find_vma (mm, addr);
    struct address_space *mapping = vma->vm_file->f_mapping;
    pgoff_t idx = ((addr - vma->vm_start) >> PAGE_SHIFT) + vma->vm_pgoff;
    struct prio_tree_iter iter;
    struct vm_area_struct *svma;
    unsigned long saddr;
    pte_t *spte = NULL;
    if (!vma_shareable (vma, addr))
        return;
    spin_lock (& mapping -> i_mmap_lock);
    vma_prio_tree_foreach (svma, & iter, & mapping -> i_mmap, idx, idx)
    {
        if (svma == vma)
            continue;
        saddr = page_table_shareable (svma, vma, addr, idx);
        if (saddr) {
            spte = huge_pte_offset (svma->vm_mm, saddr);
            if (spte) {
                get_page (virt_to_page (spte));
                break;
            }
        }
    }
    if (!spte)
        goto out;
    spin_lock (& mm -> page_table_lock);
    if (pud_none (*pud))
        pud_populate (mm, pud, (pmd_t *) ((unsigned long) spte & PAGE_MASK));
    else
        put_page (virt_to_page (spte));
    spin_unlock (& mm -> page_table_lock);
out :
    spin_unlock (&mapping->i_mmap_lock);
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/hugetlbpage.c.ifdefed" startline="73" endline="85">
{
    if (svma == vma)
        continue;
    saddr = page_table_shareable (svma, vma, addr, idx);
    if (saddr) {
        spte = huge_pte_offset (svma->vm_mm, saddr);
        if (spte) {
            get_page (virt_to_page (spte));
            break;
        }
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/hugetlbpage.c.ifdefed" startline="78" endline="84">
{
    spte = huge_pte_offset (svma->vm_mm, saddr);
    if (spte) {
        get_page (virt_to_page (spte));
        break;
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/hugetlbpage.c.ifdefed" startline="80" endline="83">
{
    get_page (virt_to_page (spte));
    break;
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/hugetlbpage.c.ifdefed" startline="113" endline="125">
{
    pgd_t *pgd = pgd_offset (mm, *addr);
    pud_t *pud = pud_offset (pgd, *addr);
    BUG_ON (page_count (virt_to_page (ptep)) == 0);
    if (page_count (virt_to_page (ptep)) == 1)
        return 0;
    pud_clear (pud);
    put_page (virt_to_page (ptep));
    *addr = ALIGN (*addr, HPAGE_SIZE *PTRS_PER_PTE) - HPAGE_SIZE;
    return 1;
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/hugetlbpage.c.ifdefed" startline="129" endline="149">
{
    pgd_t *pgd;
    pud_t *pud;
    pte_t *pte = NULL;
    pgd = pgd_offset (mm, addr);
    pud = pud_alloc (mm, pgd, addr);
    if (pud) {
        if (sz == PUD_SIZE) {
            pte = (pte_t *) pud;
        }
        else {
            BUG_ON (sz != PMD_SIZE);
            if (pud_none (*pud))
                huge_pmd_share (mm, addr, pud);
            pte = (pte_t *) pmd_alloc (mm, pud, addr);
        }
    }
    BUG_ON (pte && ! pte_none (* pte) && ! pte_huge (* pte));
    return pte;
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/hugetlbpage.c.ifdefed" startline="136" endline="145">
{
    if (sz == PUD_SIZE) {
        pte = (pte_t *) pud;
    }
    else {
        BUG_ON (sz != PMD_SIZE);
        if (pud_none (*pud))
            huge_pmd_share (mm, addr, pud);
        pte = (pte_t *) pmd_alloc (mm, pud, addr);
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/hugetlbpage.c.ifdefed" startline="137" endline="139">
{
    pte = (pte_t *) pud;
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/hugetlbpage.c.ifdefed" startline="139" endline="144">
{
    BUG_ON (sz != PMD_SIZE);
    if (pud_none (*pud))
        huge_pmd_share (mm, addr, pud);
    pte = (pte_t *) pmd_alloc (mm, pud, addr);
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/hugetlbpage.c.ifdefed" startline="152" endline="167">
{
    pgd_t *pgd;
    pud_t *pud;
    pmd_t *pmd = NULL;
    pgd = pgd_offset (mm, addr);
    if (pgd_present (*pgd)) {
        pud = pud_offset (pgd, addr);
        if (pud_present (*pud)) {
            if (pud_large (*pud))
                return (pte_t *) pud;
            pmd = pmd_offset (pud, addr);
        }
    }
    return (pte_t *) pmd;
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/hugetlbpage.c.ifdefed" startline="158" endline="165">
{
    pud = pud_offset (pgd, addr);
    if (pud_present (*pud)) {
        if (pud_large (*pud))
            return (pte_t *) pud;
        pmd = pmd_offset (pud, addr);
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/hugetlbpage.c.ifdefed" startline="160" endline="164">
{
    if (pud_large (*pud))
        return (pte_t *) pud;
    pmd = pmd_offset (pud, addr);
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/hugetlbpage.c.ifdefed" startline="216" endline="218">
{
    return ERR_PTR (-EINVAL);
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/hugetlbpage.c.ifdefed" startline="221" endline="223">
{
    return !!(pmd_val (pmd) & _PAGE_PSE);
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/hugetlbpage.c.ifdefed" startline="226" endline="228">
{
    return !!(pud_val (pud) & _PAGE_PSE);
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/hugetlbpage.c.ifdefed" startline="233" endline="240">
{
    struct page *page;
    page = pte_page (*(pte_t*) pmd);
    if (page)
        page += ((address & ~PMD_MASK) >> PAGE_SHIFT);
    return page;
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/hugetlbpage.c.ifdefed" startline="245" endline="252">
{
    struct page *page;
    page = pte_page (*(pte_t*) pud);
    if (page)
        page += ((address & ~PUD_MASK) >> PAGE_SHIFT);
    return page;
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/mmap.c.ifdefed" startline="45" endline="54">
{
    return 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/mmap.c.ifdefed" startline="57" endline="65">
{
    if (current->personality & ADDR_COMPAT_LAYOUT)
        return 1;
    if (current->signal->rlim[RLIMIT_STACK].rlim_cur == RLIM_INFINITY)
        return 1;
    return sysctl_legacy_va_layout;
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/mmap.c.ifdefed" startline="68" endline="82">
{
    unsigned long rnd = 0;
    if (current->flags & PF_RANDOMIZE) {
        if (mmap_is_ia32 ())
            rnd = (long) get_random_int () % (1 << 8);
        else
            rnd = (long) (get_random_int () % (1 << 28));
    }
    return rnd << PAGE_SHIFT;
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/mmap.c.ifdefed" startline="75" endline="80">
{
    if (mmap_is_ia32 ())
        rnd = (long) get_random_int () % (1 << 8);
    else
        rnd = (long) (get_random_int () % (1 << 28));
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/mmap.c.ifdefed" startline="85" endline="94">
{
    unsigned long gap = current->signal->rlim[RLIMIT_STACK].rlim_cur;
    if (gap < MIN_GAP)
        gap = MIN_GAP;
    else if (gap > MAX_GAP)
        gap = MAX_GAP;
    return PAGE_ALIGN (TASK_SIZE -gap - mmap_rnd ());
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/mmap.c.ifdefed" startline="101" endline="106">
{
    if (mmap_is_ia32 ())
        return TASK_UNMAPPED_BASE;
    else
        return TASK_UNMAPPED_BASE + mmap_rnd ();
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/mmap.c.ifdefed" startline="113" endline="123">
{
    if (mmap_is_legacy ()) {
        mm->mmap_base = mmap_legacy_base ();
        mm->get_unmapped_area = arch_get_unmapped_area;
        mm->unmap_area = arch_unmap_area;
    }
    else {
        mm->mmap_base = mmap_base ();
        mm->get_unmapped_area = arch_get_unmapped_area_topdown;
        mm->unmap_area = arch_unmap_area_topdown;
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/mmap.c.ifdefed" startline="114" endline="118">
{
    mm->mmap_base = mmap_legacy_base ();
    mm->get_unmapped_area = arch_get_unmapped_area;
    mm->unmap_area = arch_unmap_area;
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/mmap.c.ifdefed" startline="118" endline="122">
{
    mm->mmap_base = mmap_base ();
    mm->get_unmapped_area = arch_get_unmapped_area_topdown;
    mm->unmap_area = arch_unmap_area_topdown;
}
</source>
