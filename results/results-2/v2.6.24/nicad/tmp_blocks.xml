<source file="/cmpt816/tmp/init/do_mounts_initrd.c.ifdefed" startline="20" endline="23">
{
    mount_initrd = 0;
    return 1;
}
</source>
<source file="/cmpt816/tmp/init/do_mounts_initrd.c.ifdefed" startline="28" endline="39">
{
    static char *argv [] = {"linuxrc", NULL,};
    extern char *envp_init [];
    sys_close (old_fd);
    sys_close (root_fd);
    sys_close (0);
    sys_close (1);
    sys_close (2);
    sys_setsid ();
    (void) sys_open ("/dev/console", O_RDWR, 0);
    (void) sys_dup (0);
    (void) sys_dup (0);
    return kernel_execve (shell, argv, envp_init);
}
</source>
<source file="/cmpt816/tmp/init/do_mounts_initrd.c.ifdefed" startline="42" endline="109">
{
    int error;
    int pid;
    real_root_dev = new_encode_dev (ROOT_DEV);
    create_dev ("/dev/root.old", Root_RAM0);
    mount_block_root ("/dev/root.old", root_mountflags & ~ MS_RDONLY);
    sys_mkdir ("/old", 0700);
    root_fd = sys_open ("/", 0, 0);
    old_fd = sys_open ("/old", 0, 0);
    sys_chdir ("/root");
    sys_mount (".", "/", NULL, MS_MOVE, NULL);
    sys_chroot (".");
    current->flags |= PF_FREEZER_SKIP;
    pid = kernel_thread (do_linuxrc, "/linuxrc", SIGCHLD);
    if (pid > 0)
        while (pid != sys_wait4 (-1, NULL, 0, NULL))
            yield ();
    current->flags &= ~PF_FREEZER_SKIP;
    sys_fchdir (old_fd);
    sys_mount ("/", ".", NULL, MS_MOVE, NULL);
    sys_fchdir (root_fd);
    sys_chroot (".");
    sys_close (old_fd);
    sys_close (root_fd);
    if (new_decode_dev (real_root_dev) == Root_RAM0) {
        sys_chdir ("/old");
        return;
    }
    ROOT_DEV = new_decode_dev (real_root_dev);
    mount_root ();
    printk (KERN_NOTICE "Trying to move old root to /initrd ... ");
    error = sys_mount ("/old", "/root/initrd", NULL, MS_MOVE, NULL);
    if (!error)
        printk ("okay\n");
    else {
        int fd = sys_open ("/dev/root.old", O_RDWR, 0);
        if (error == -ENOENT)
            printk ("/initrd does not exist. Ignored.\n");
        else
            printk ("failed\n");
        printk (KERN_NOTICE "Unmounting old root\n");
        sys_umount ("/old", MNT_DETACH);
        printk (KERN_NOTICE "Trying to free ramdisk memory ... ");
        if (fd < 0) {
            error = fd;
        }
        else {
            error = sys_ioctl (fd, BLKFLSBUF, 0);
            sys_close (fd);
        }
        printk (! error ? "okay\n" : "failed\n");
    }
}
</source>
<source file="/cmpt816/tmp/init/do_mounts_initrd.c.ifdefed" startline="80" endline="83">
{
    sys_chdir ("/old");
    return;
}
</source>
<source file="/cmpt816/tmp/init/do_mounts_initrd.c.ifdefed" startline="92" endline="108">
{
    int fd = sys_open ("/dev/root.old", O_RDWR, 0);
    if (error == -ENOENT)
        printk ("/initrd does not exist. Ignored.\n");
    else
        printk ("failed\n");
    printk (KERN_NOTICE "Unmounting old root\n");
    sys_umount ("/old", MNT_DETACH);
    printk (KERN_NOTICE "Trying to free ramdisk memory ... ");
    if (fd < 0) {
        error = fd;
    }
    else {
        error = sys_ioctl (fd, BLKFLSBUF, 0);
        sys_close (fd);
    }
    printk (! error ? "okay\n" : "failed\n");
}
</source>
<source file="/cmpt816/tmp/init/do_mounts_initrd.c.ifdefed" startline="101" endline="103">
{
    error = fd;
}
</source>
<source file="/cmpt816/tmp/init/do_mounts_initrd.c.ifdefed" startline="103" endline="106">
{
    error = sys_ioctl (fd, BLKFLSBUF, 0);
    sys_close (fd);
}
</source>
<source file="/cmpt816/tmp/init/do_mounts_initrd.c.ifdefed" startline="112" endline="129">
{
    if (mount_initrd) {
        create_dev ("/dev/ram", Root_RAM0);
        if (rd_load_image ("/initrd.image") && ROOT_DEV != Root_RAM0) {
            sys_unlink ("/initrd.image");
            handle_initrd ();
            return 1;
        }
    }
    sys_unlink ("/initrd.image");
    return 0;
}
</source>
<source file="/cmpt816/tmp/init/do_mounts_initrd.c.ifdefed" startline="113" endline="126">
{
    create_dev ("/dev/ram", Root_RAM0);
    if (rd_load_image ("/initrd.image") && ROOT_DEV != Root_RAM0) {
        sys_unlink ("/initrd.image");
        handle_initrd ();
        return 1;
    }
}
</source>
<source file="/cmpt816/tmp/init/do_mounts_initrd.c.ifdefed" startline="121" endline="125">
{
    sys_unlink ("/initrd.image");
    handle_initrd ();
    return 1;
}
</source>
<source file="/cmpt816/tmp/init/do_mounts_rd.c.ifdefed" startline="18" endline="21">
{
    rd_prompt = simple_strtol (str, NULL, 0) & 1;
    return 1;
}
</source>
<source file="/cmpt816/tmp/init/do_mounts_rd.c.ifdefed" startline="27" endline="30">
{
    rd_image_start = simple_strtol (str, NULL, 0);
    return 1;
}
</source>
<source file="/cmpt816/tmp/init/do_mounts_rd.c.ifdefed" startline="50" endline="138">
{
    const int size = 512;
    struct minix_super_block *minixsb;
    struct ext2_super_block *ext2sb;
    struct romfs_super_block *romfsb;
    struct cramfs_super *cramfsb;
    int nblocks = -1;
    unsigned char *buf;
    buf = kmalloc (size, GFP_KERNEL);
    if (!buf)
        return -1;
    minixsb = (struct minix_super_block *) buf;
    ext2sb = (struct ext2_super_block *) buf;
    romfsb = (struct romfs_super_block *) buf;
    cramfsb = (struct cramfs_super *) buf;
    memset (buf, 0xe5, size);
    sys_lseek (fd, start_block * BLOCK_SIZE, 0);
    sys_read (fd, buf, size);
    if (buf[0] == 037 && ((buf[1] == 0213) || (buf[1] == 0236))) {
        printk (KERN_NOTICE "RAMDISK: Compressed image found at block %d\n", start_block);
        nblocks = 0;
        goto done;
    }
    if (romfsb->word0 == ROMSB_WORD0 && romfsb->word1 == ROMSB_WORD1) {
        printk (KERN_NOTICE "RAMDISK: romfs filesystem found at block %d\n", start_block);
        nblocks = (ntohl (romfsb->size) + BLOCK_SIZE - 1) >> BLOCK_SIZE_BITS;
        goto done;
    }
    if (cramfsb->magic == CRAMFS_MAGIC) {
        printk (KERN_NOTICE "RAMDISK: cramfs filesystem found at block %d\n", start_block);
        nblocks = (cramfsb->size + BLOCK_SIZE - 1) >> BLOCK_SIZE_BITS;
        goto done;
    }
    sys_lseek (fd, (start_block + 1) * BLOCK_SIZE, 0);
    sys_read (fd, buf, size);
    if (minixsb->s_magic == MINIX_SUPER_MAGIC || minixsb->s_magic == MINIX_SUPER_MAGIC2) {
        printk (KERN_NOTICE "RAMDISK: Minix filesystem found at block %d\n", start_block);
        nblocks = minixsb->s_nzones << minixsb->s_log_zone_size;
        goto done;
    }
    if (ext2sb->s_magic == cpu_to_le16 (EXT2_SUPER_MAGIC)) {
        printk (KERN_NOTICE "RAMDISK: ext2 filesystem found at block %d\n", start_block);
        nblocks = le32_to_cpu (ext2sb->s_blocks_count) << le32_to_cpu (ext2sb->s_log_block_size);
        goto done;
    }
    printk (KERN_NOTICE "RAMDISK: Couldn't find valid RAM disk image starting at %d.\n", start_block);
done :
    sys_lseek (fd, start_block *BLOCK_SIZE, 0);
    kfree (buf);
    return nblocks;
}
</source>
<source file="/cmpt816/tmp/init/do_mounts_rd.c.ifdefed" startline="78" endline="84">
{
    printk (KERN_NOTICE "RAMDISK: Compressed image found at block %d\n", start_block);
    nblocks = 0;
    goto done;
}
</source>
<source file="/cmpt816/tmp/init/do_mounts_rd.c.ifdefed" startline="88" endline="94">
{
    printk (KERN_NOTICE "RAMDISK: romfs filesystem found at block %d\n", start_block);
    nblocks = (ntohl (romfsb->size) + BLOCK_SIZE - 1) >> BLOCK_SIZE_BITS;
    goto done;
}
</source>
<source file="/cmpt816/tmp/init/do_mounts_rd.c.ifdefed" startline="96" endline="102">
{
    printk (KERN_NOTICE "RAMDISK: cramfs filesystem found at block %d\n", start_block);
    nblocks = (cramfsb->size + BLOCK_SIZE - 1) >> BLOCK_SIZE_BITS;
    goto done;
}
</source>
<source file="/cmpt816/tmp/init/do_mounts_rd.c.ifdefed" startline="112" endline="118">
{
    printk (KERN_NOTICE "RAMDISK: Minix filesystem found at block %d\n", start_block);
    nblocks = minixsb->s_nzones << minixsb->s_log_zone_size;
    goto done;
}
</source>
<source file="/cmpt816/tmp/init/do_mounts_rd.c.ifdefed" startline="121" endline="128">
{
    printk (KERN_NOTICE "RAMDISK: ext2 filesystem found at block %d\n", start_block);
    nblocks = le32_to_cpu (ext2sb->s_blocks_count) << le32_to_cpu (ext2sb->s_log_block_size);
    goto done;
}
</source>
<source file="/cmpt816/tmp/init/do_mounts_rd.c.ifdefed" startline="141" endline="259">
{
    int res = 0;
    int in_fd, out_fd;
    unsigned long rd_blocks, devblocks;
    int nblocks, i, disk;
    char *buf = NULL;
    unsigned short rotate = 0;
    out_fd = sys_open ("/dev/ram", O_RDWR, 0);
    if (out_fd < 0)
        goto out;
    in_fd = sys_open (from, O_RDONLY, 0);
    if (in_fd < 0)
        goto noclose_input;
    nblocks = identify_ramdisk_image (in_fd, rd_image_start);
    if (nblocks < 0)
        goto done;
    if (nblocks == 0) {
        printk (KERN_NOTICE "RAMDISK: Kernel does not support compressed " "RAM disk images\n");
        goto done;
    }
    if (sys_ioctl (out_fd, BLKGETSIZE, (unsigned long) &rd_blocks) < 0)
        rd_blocks = 0;
    else
        rd_blocks >>= 1;
    if (nblocks > rd_blocks) {
        printk ("RAMDISK: image too big! (%dKiB/%ldKiB)\n", nblocks, rd_blocks);
        goto done;
    }
    if (sys_ioctl (in_fd, BLKGETSIZE, (unsigned long) &devblocks) < 0)
        devblocks = 0;
    else
        devblocks >>= 1;
    if (strcmp (from, "/initrd.image") == 0)
        devblocks = nblocks;
    if (devblocks == 0) {
        printk (KERN_ERR "RAMDISK: could not determine device size\n");
        goto done;
    }
    buf = kmalloc (BLOCK_SIZE, GFP_KERNEL);
    if (buf == 0) {
        printk (KERN_ERR "RAMDISK: could not allocate buffer\n");
        goto done;
    }
    printk (KERN_NOTICE "RAMDISK: Loading %dKiB [%ld disk%s] into ram disk... ", nblocks, ((nblocks - 1) / devblocks) + 1, nblocks > devblocks ? "s" : "");
    for (i = 0, disk = 1; i < nblocks; i++) {
        if (i && (i % devblocks == 0)) {
            printk ("done disk #%d.\n", disk ++);
            rotate = 0;
            if (sys_close (in_fd)) {
                printk ("Error closing the disk.\n");
                goto noclose_input;
            }
            change_floppy ("disk #%d", disk);
            in_fd = sys_open (from, O_RDONLY, 0);
            if (in_fd < 0) {
                printk ("Error opening disk.\n");
                goto noclose_input;
            }
            printk ("Loading disk #%d... ", disk);
        }
        sys_read (in_fd, buf, BLOCK_SIZE);
        sys_write (out_fd, buf, BLOCK_SIZE);
    }
    printk ("done.\n");
successful_load :
    res = 1;
done :
    sys_close (in_fd);
noclose_input :
    sys_close (out_fd);
out :
    kfree (buf);
    sys_unlink ("/dev/ram");
    return res;
}
</source>
<source file="/cmpt816/tmp/init/do_mounts_rd.c.ifdefed" startline="164" endline="174">
{
    printk (KERN_NOTICE "RAMDISK: Kernel does not support compressed " "RAM disk images\n");
    goto done;
}
</source>
<source file="/cmpt816/tmp/init/do_mounts_rd.c.ifdefed" startline="192" endline="196">
{
    printk ("RAMDISK: image too big! (%dKiB/%ldKiB)\n", nblocks, rd_blocks);
    goto done;
}
</source>
<source file="/cmpt816/tmp/init/do_mounts_rd.c.ifdefed" startline="209" endline="212">
{
    printk (KERN_ERR "RAMDISK: could not determine device size\n");
    goto done;
}
</source>
<source file="/cmpt816/tmp/init/do_mounts_rd.c.ifdefed" startline="215" endline="218">
{
    printk (KERN_ERR "RAMDISK: could not allocate buffer\n");
    goto done;
}
</source>
<source file="/cmpt816/tmp/init/do_mounts_rd.c.ifdefed" startline="222" endline="246">
{
    if (i && (i % devblocks == 0)) {
        printk ("done disk #%d.\n", disk ++);
        rotate = 0;
        if (sys_close (in_fd)) {
            printk ("Error closing the disk.\n");
            goto noclose_input;
        }
        change_floppy ("disk #%d", disk);
        in_fd = sys_open (from, O_RDONLY, 0);
        if (in_fd < 0) {
            printk ("Error opening disk.\n");
            goto noclose_input;
        }
        printk ("Loading disk #%d... ", disk);
    }
    sys_read (in_fd, buf, BLOCK_SIZE);
    sys_write (out_fd, buf, BLOCK_SIZE);
}
</source>
<source file="/cmpt816/tmp/init/do_mounts_rd.c.ifdefed" startline="223" endline="237">
{
    printk ("done disk #%d.\n", disk ++);
    rotate = 0;
    if (sys_close (in_fd)) {
        printk ("Error closing the disk.\n");
        goto noclose_input;
    }
    change_floppy ("disk #%d", disk);
    in_fd = sys_open (from, O_RDONLY, 0);
    if (in_fd < 0) {
        printk ("Error opening disk.\n");
        goto noclose_input;
    }
    printk ("Loading disk #%d... ", disk);
}
</source>
<source file="/cmpt816/tmp/init/do_mounts_rd.c.ifdefed" startline="226" endline="229">
{
    printk ("Error closing the disk.\n");
    goto noclose_input;
}
</source>
<source file="/cmpt816/tmp/init/do_mounts_rd.c.ifdefed" startline="232" endline="235">
{
    printk ("Error opening disk.\n");
    goto noclose_input;
}
</source>
<source file="/cmpt816/tmp/init/do_mounts_rd.c.ifdefed" startline="262" endline="268">
{
    if (rd_prompt)
        change_floppy ("root floppy disk to be loaded into RAM disk");
    create_dev ("/dev/root", ROOT_DEV);
    create_dev ("/dev/ram", MKDEV (RAMDISK_MAJOR, n));
    return rd_load_image ("/dev/root");
}
</source>
<source file="/cmpt816/tmp/init/initramfs.c.ifdefed" startline="12" endline="15">
{
    if (!message)
        message = x;
}
</source>
<source file="/cmpt816/tmp/init/initramfs.c.ifdefed" startline="18" endline="20">
{
    return kmalloc (size, GFP_KERNEL);
}
</source>
<source file="/cmpt816/tmp/init/initramfs.c.ifdefed" startline="23" endline="25">
{
    kfree (where);
}
</source>
<source file="/cmpt816/tmp/init/initramfs.c.ifdefed" startline="39" endline="43">
{
    unsigned long tmp = ino + minor + (major << 3);
    tmp += tmp >> 5;
    return tmp & 31;
}
</source>
<source file="/cmpt816/tmp/init/initramfs.c.ifdefed" startline="47" endline="71">
{
    struct hash **p, *q;
    for (p = head + hash (major, minor, ino); *p; p = &(*p)->next) {
        if ((*p)->ino != ino)
            continue;
        if ((*p)->minor != minor)
            continue;
        if ((*p)->major != major)
            continue;
        if (((*p)->mode ^ mode) & S_IFMT)
            continue;
        return (*p)->name;
    }
    q = (struct hash *) malloc (sizeof (struct hash));
    if (!q)
        panic ("can't allocate link hash entry");
    q->major = major;
    q->minor = minor;
    q->ino = ino;
    q->mode = mode;
    strcpy (q -> name, name);
    q->next = NULL;
    *p = q;
    return NULL;
}
</source>
<source file="/cmpt816/tmp/init/initramfs.c.ifdefed" startline="49" endline="59">
{
    if ((*p)->ino != ino)
        continue;
    if ((*p)->minor != minor)
        continue;
    if ((*p)->major != major)
        continue;
    if (((*p)->mode ^ mode) & S_IFMT)
        continue;
    return (*p)->name;
}
</source>
<source file="/cmpt816/tmp/init/initramfs.c.ifdefed" startline="74" endline="83">
{
    struct hash **p, *q;
    for (p = head; p < head + 32; p++) {
        while (*p) {
            q = *p;
            *p = q->next;
            free (q);
        }
    }
}
</source>
<source file="/cmpt816/tmp/init/initramfs.c.ifdefed" startline="76" endline="82">
{
    while (*p) {
        q = *p;
        *p = q->next;
        free (q);
    }
}
</source>
<source file="/cmpt816/tmp/init/initramfs.c.ifdefed" startline="77" endline="81">
{
    q = *p;
    *p = q->next;
    free (q);
}
</source>
<source file="/cmpt816/tmp/init/initramfs.c.ifdefed" startline="95" endline="115">
{
    unsigned long parsed [12];
    char buf [9];
    int i;
    buf[8] = '\0';
    for (i = 0, s += 6; i < 12; i++, s += 8) {
        memcpy (buf, s, 8);
        parsed[i] = simple_strtoul (buf, NULL, 16);
    }
    ino = parsed[0];
    mode = parsed[1];
    uid = parsed[2];
    gid = parsed[3];
    nlink = parsed[4];
    body_len = parsed[6];
    major = parsed[7];
    minor = parsed[8];
    rdev = new_encode_dev (MKDEV (parsed[9], parsed[10]));
    name_len = parsed[11];
}
</source>
<source file="/cmpt816/tmp/init/initramfs.c.ifdefed" startline="101" endline="104">
{
    memcpy (buf, s, 8);
    parsed[i] = simple_strtoul (buf, NULL, 16);
}
</source>
<source file="/cmpt816/tmp/init/initramfs.c.ifdefed" startline="137" endline="141">
{
    victim += n;
    this_header += n;
    count -= n;
}
</source>
<source file="/cmpt816/tmp/init/initramfs.c.ifdefed" startline="148" endline="159">
{
    if (count >= size) {
        collected = victim;
        eat (size);
        state = next;
    }
    else {
        collect = collected = buf;
        remains = size;
        next_state = next;
        state = Collect;
    }
}
</source>
<source file="/cmpt816/tmp/init/initramfs.c.ifdefed" startline="149" endline="153">
{
    collected = victim;
    eat (size);
    state = next;
}
</source>
<source file="/cmpt816/tmp/init/initramfs.c.ifdefed" startline="153" endline="158">
{
    collect = collected = buf;
    remains = size;
    next_state = next;
    state = Collect;
}
</source>
<source file="/cmpt816/tmp/init/initramfs.c.ifdefed" startline="164" endline="167">
{
    read_into (header_buf, 110, GotHeader);
    return 0;
}
</source>
<source file="/cmpt816/tmp/init/initramfs.c.ifdefed" startline="170" endline="181">
{
    unsigned n = remains;
    if (count < n)
        n = count;
    memcpy (collect, victim, n);
    eat (n);
    collect += n;
    if ((remains -= n) != 0)
        return 1;
    state = next_state;
    return 0;
}
</source>
<source file="/cmpt816/tmp/init/initramfs.c.ifdefed" startline="184" endline="215">
{
    if (memcmp (collected, "070707", 6) == 0) {
        error ("incorrect cpio method used: use -H newc option");
        return 1;
    }
    if (memcmp (collected, "070701", 6)) {
        error ("no cpio magic");
        return 1;
    }
    parse_header (collected);
    next_header = this_header + N_ALIGN (name_len) + body_len;
    next_header = (next_header + 3) & ~3;
    if (dry_run) {
        read_into (name_buf, N_ALIGN (name_len), GotName);
        return 0;
    }
    state = SkipIt;
    if (name_len <= 0 || name_len > PATH_MAX)
        return 0;
    if (S_ISLNK (mode)) {
        if (body_len > PATH_MAX)
            return 0;
        collect = collected = symlink_buf;
        remains = N_ALIGN (name_len) + body_len;
        next_state = GotSymlink;
        state = Collect;
        return 0;
    }
    if (S_ISREG (mode) || !body_len)
        read_into (name_buf, N_ALIGN (name_len), GotName);
    return 0;
}
</source>
<source file="/cmpt816/tmp/init/initramfs.c.ifdefed" startline="185" endline="188">
{
    error ("incorrect cpio method used: use -H newc option");
    return 1;
}
</source>
<source file="/cmpt816/tmp/init/initramfs.c.ifdefed" startline="189" endline="192">
{
    error ("no cpio magic");
    return 1;
}
</source>
<source file="/cmpt816/tmp/init/initramfs.c.ifdefed" startline="196" endline="199">
{
    read_into (name_buf, N_ALIGN (name_len), GotName);
    return 0;
}
</source>
<source file="/cmpt816/tmp/init/initramfs.c.ifdefed" startline="203" endline="211">
{
    if (body_len > PATH_MAX)
        return 0;
    collect = collected = symlink_buf;
    remains = N_ALIGN (name_len) + body_len;
    next_state = GotSymlink;
    state = Collect;
    return 0;
}
</source>
<source file="/cmpt816/tmp/init/initramfs.c.ifdefed" startline="218" endline="227">
{
    if (this_header + count < next_header) {
        eat (count);
        return 1;
    }
    else {
        eat (next_header - this_header);
        state = next_state;
        return 0;
    }
}
</source>
<source file="/cmpt816/tmp/init/initramfs.c.ifdefed" startline="219" endline="222">
{
    eat (count);
    return 1;
}
</source>
<source file="/cmpt816/tmp/init/initramfs.c.ifdefed" startline="222" endline="226">
{
    eat (next_header - this_header);
    state = next_state;
    return 0;
}
</source>
<source file="/cmpt816/tmp/init/initramfs.c.ifdefed" startline="230" endline="236">
{
    while (count && *victim == '\0')
        eat (1);
    if (count && (this_header & 3))
        error ("broken padding");
    return 1;
}
</source>
<source file="/cmpt816/tmp/init/initramfs.c.ifdefed" startline="239" endline="246">
{
    if (nlink >= 2) {
        char *old = find_link (major, minor, ino, mode, collected);
        if (old)
            return (sys_link (old, collected) < 0) ? -1 : 1;
    }
    return 0;
}
</source>
<source file="/cmpt816/tmp/init/initramfs.c.ifdefed" startline="240" endline="244">
{
    char *old = find_link (major, minor, ino, mode, collected);
    if (old)
        return (sys_link (old, collected) < 0) ? -1 : 1;
}
</source>
<source file="/cmpt816/tmp/init/initramfs.c.ifdefed" startline="249" endline="258">
{
    struct stat st;
    if (!sys_newlstat (path, &st) && (st.st_mode ^ mode) & S_IFMT) {
        if (S_ISDIR (st.st_mode))
            sys_rmdir (path);
        else
            sys_unlink (path);
    }
}
</source>
<source file="/cmpt816/tmp/init/initramfs.c.ifdefed" startline="252" endline="257">
{
    if (S_ISDIR (st.st_mode))
        sys_rmdir (path);
    else
        sys_unlink (path);
}
</source>
<source file="/cmpt816/tmp/init/initramfs.c.ifdefed" startline="263" endline="300">
{
    state = SkipIt;
    next_state = Reset;
    if (strcmp (collected, "TRAILER!!!") == 0) {
        free_hash ();
        return 0;
    }
    if (dry_run)
        return 0;
    clean_path (collected, mode);
    if (S_ISREG (mode)) {
        int ml = maybe_link ();
        if (ml >= 0) {
            int openflags = O_WRONLY | O_CREAT;
            if (ml != 1)
                openflags |= O_TRUNC;
            wfd = sys_open (collected, openflags, mode);
            if (wfd >= 0) {
                sys_fchown (wfd, uid, gid);
                sys_fchmod (wfd, mode);
                state = CopyFile;
            }
        }
    }
    else if (S_ISDIR (mode)) {
        sys_mkdir (collected, mode);
        sys_chown (collected, uid, gid);
        sys_chmod (collected, mode);
    }
    else if (S_ISBLK (mode) || S_ISCHR (mode) || S_ISFIFO (mode) || S_ISSOCK (mode)) {
        if (maybe_link () == 0) {
            sys_mknod (collected, mode, rdev);
            sys_chown (collected, uid, gid);
            sys_chmod (collected, mode);
        }
    }
    return 0;
}
</source>
<source file="/cmpt816/tmp/init/initramfs.c.ifdefed" startline="266" endline="269">
{
    free_hash ();
    return 0;
}
</source>
<source file="/cmpt816/tmp/init/initramfs.c.ifdefed" startline="273" endline="287">
{
    int ml = maybe_link ();
    if (ml >= 0) {
        int openflags = O_WRONLY | O_CREAT;
        if (ml != 1)
            openflags |= O_TRUNC;
        wfd = sys_open (collected, openflags, mode);
        if (wfd >= 0) {
            sys_fchown (wfd, uid, gid);
            sys_fchmod (wfd, mode);
            state = CopyFile;
        }
    }
}
</source>
<source file="/cmpt816/tmp/init/initramfs.c.ifdefed" startline="275" endline="286">
{
    int openflags = O_WRONLY | O_CREAT;
    if (ml != 1)
        openflags |= O_TRUNC;
    wfd = sys_open (collected, openflags, mode);
    if (wfd >= 0) {
        sys_fchown (wfd, uid, gid);
        sys_fchmod (wfd, mode);
        state = CopyFile;
    }
}
</source>
<source file="/cmpt816/tmp/init/initramfs.c.ifdefed" startline="281" endline="285">
{
    sys_fchown (wfd, uid, gid);
    sys_fchmod (wfd, mode);
    state = CopyFile;
}
</source>
<source file="/cmpt816/tmp/init/initramfs.c.ifdefed" startline="287" endline="291">
{
    sys_mkdir (collected, mode);
    sys_chown (collected, uid, gid);
    sys_chmod (collected, mode);
}
</source>
<source file="/cmpt816/tmp/init/initramfs.c.ifdefed" startline="292" endline="298">
{
    if (maybe_link () == 0) {
        sys_mknod (collected, mode, rdev);
        sys_chown (collected, uid, gid);
        sys_chmod (collected, mode);
    }
}
</source>
<source file="/cmpt816/tmp/init/initramfs.c.ifdefed" startline="293" endline="297">
{
    sys_mknod (collected, mode, rdev);
    sys_chown (collected, uid, gid);
    sys_chmod (collected, mode);
}
</source>
<source file="/cmpt816/tmp/init/initramfs.c.ifdefed" startline="303" endline="316">
{
    if (count >= body_len) {
        sys_write (wfd, victim, body_len);
        sys_close (wfd);
        eat (body_len);
        state = SkipIt;
        return 0;
    }
    else {
        sys_write (wfd, victim, count);
        body_len -= count;
        eat (count);
        return 1;
    }
}
</source>
<source file="/cmpt816/tmp/init/initramfs.c.ifdefed" startline="304" endline="310">
{
    sys_write (wfd, victim, body_len);
    sys_close (wfd);
    eat (body_len);
    state = SkipIt;
    return 0;
}
</source>
<source file="/cmpt816/tmp/init/initramfs.c.ifdefed" startline="310" endline="315">
{
    sys_write (wfd, victim, count);
    body_len -= count;
    eat (count);
    return 1;
}
</source>
<source file="/cmpt816/tmp/init/initramfs.c.ifdefed" startline="319" endline="327">
{
    collected[N_ALIGN (name_len) + body_len] = '\0';
    clean_path (collected, 0);
    sys_symlink (collected + N_ALIGN (name_len), collected);
    sys_lchown (collected, uid, gid);
    state = SkipIt;
    next_state = Reset;
    return 0;
}
</source>
<source file="/cmpt816/tmp/init/initramfs.c.ifdefed" startline="341" endline="348">
{
    count = len;
    victim = buf;
    while (!actions[state] ())
        ;
    return len - count;
}
</source>
<source file="/cmpt816/tmp/init/initramfs.c.ifdefed" startline="351" endline="368">
{
    int written;
    if (message)
        return;
    while ((written = write_buffer (buf, len)) < len && !message) {
        char c = buf[written];
        if (c == '0') {
            buf += written;
            len -= written;
            state = Start;
        }
        else if (c == 0) {
            buf += written;
            len -= written;
            state = Reset;
        }
        else
            error ("junk in compressed archive");
    }
}
</source>
<source file="/cmpt816/tmp/init/initramfs.c.ifdefed" startline="355" endline="367">
{
    char c = buf[written];
    if (c == '0') {
        buf += written;
        len -= written;
        state = Start;
    }
    else if (c == 0) {
        buf += written;
        len -= written;
        state = Reset;
    }
    else
        error ("junk in compressed archive");
}
</source>
<source file="/cmpt816/tmp/init/initramfs.c.ifdefed" startline="357" endline="361">
{
    buf += written;
    len -= written;
    state = Start;
}
</source>
<source file="/cmpt816/tmp/init/initramfs.c.ifdefed" startline="361" endline="365">
{
    buf += written;
    len -= written;
    state = Reset;
}
</source>
<source file="/cmpt816/tmp/init/initramfs.c.ifdefed" startline="416" endline="417">
{
}
</source>
<source file="/cmpt816/tmp/init/initramfs.c.ifdefed" startline="420" endline="421">
{
}
</source>
<source file="/cmpt816/tmp/init/initramfs.c.ifdefed" startline="428" endline="442">
{
    ulg c = crc;
    unsigned n;
    uch *in, ch;
    flush_buffer (window, outcnt);
    in = window;
    for (n = 0; n < outcnt; n++) {
        ch = *in++;
        c = crc_32_tab[((int) c ^ ch) & 0xff] ^ (c >> 8);
    }
    crc = c;
    bytes_out += (ulg) outcnt;
    outcnt = 0;
}
</source>
<source file="/cmpt816/tmp/init/initramfs.c.ifdefed" startline="435" endline="438">
{
    ch = *in++;
    c = crc_32_tab[((int) c ^ ch) & 0xff] ^ (c >> 8);
}
</source>
<source file="/cmpt816/tmp/init/initramfs.c.ifdefed" startline="445" endline="492">
{
    int written;
    dry_run = check_only;
    header_buf = malloc (110);
    symlink_buf = malloc (PATH_MAX +N_ALIGN (PATH_MAX) + 1);
    name_buf = malloc (N_ALIGN (PATH_MAX));
    window = malloc (WSIZE);
    if (!window || !header_buf || !symlink_buf || !name_buf)
        panic ("can't allocate buffers");
    state = Start;
    this_header = 0;
    message = NULL;
    while (!message && len) {
        loff_t saved_offset = this_header;
        if (*buf == '0' && !(this_header & 3)) {
            state = Start;
            written = write_buffer (buf, len);
            buf += written;
            len -= written;
            continue;
        }
        if (!*buf) {
            buf++;
            len--;
            this_header++;
            continue;
        }
        this_header = 0;
        insize = len;
        inbuf = buf;
        inptr = 0;
        outcnt = 0;
        bytes_out = 0;
        crc = (ulg) 0xffffffffL;
        makecrc ();
        gunzip ();
        if (state != Reset)
            error ("junk in gzipped archive");
        this_header = saved_offset + inptr;
        buf += inptr;
        len -= inptr;
    }
    free (window);
    free (name_buf);
    free (symlink_buf);
    free (header_buf);
    return message;
}
</source>
<source file="/cmpt816/tmp/init/initramfs.c.ifdefed" startline="457" endline="486">
{
    loff_t saved_offset = this_header;
    if (*buf == '0' && !(this_header & 3)) {
        state = Start;
        written = write_buffer (buf, len);
        buf += written;
        len -= written;
        continue;
    }
    if (!*buf) {
        buf++;
        len--;
        this_header++;
        continue;
    }
    this_header = 0;
    insize = len;
    inbuf = buf;
    inptr = 0;
    outcnt = 0;
    bytes_out = 0;
    crc = (ulg) 0xffffffffL;
    makecrc ();
    gunzip ();
    if (state != Reset)
        error ("junk in gzipped archive");
    this_header = saved_offset + inptr;
    buf += inptr;
    len -= inptr;
}
</source>
<source file="/cmpt816/tmp/init/initramfs.c.ifdefed" startline="459" endline="465">
{
    state = Start;
    written = write_buffer (buf, len);
    buf += written;
    len -= written;
    continue;
}
</source>
<source file="/cmpt816/tmp/init/initramfs.c.ifdefed" startline="466" endline="471">
{
    buf++;
    len--;
    this_header++;
    continue;
}
</source>
<source file="/cmpt816/tmp/init/initramfs.c.ifdefed" startline="497" endline="502">
{
    if (*str)
        return 0;
    do_retain_initrd = 1;
    return 1;
}
</source>
<source file="/cmpt816/tmp/init/initramfs.c.ifdefed" startline="545" endline="584">
{
    char *err = unpack_to_rootfs (__initramfs_start, __initramfs_end -__initramfs_start, 0);
    if (err)
        panic (err);
    return 0;
}
</source>
<source file="/cmpt816/tmp/init/do_mounts.c.ifdefed" startline="33" endline="36">
{
    rd_doload = simple_strtol (str, NULL, 0) & 3;
    return 1;
}
</source>
<source file="/cmpt816/tmp/init/do_mounts.c.ifdefed" startline="40" endline="45">
{
    if (*str)
        return 0;
    root_mountflags |= MS_RDONLY;
    return 1;
}
</source>
<source file="/cmpt816/tmp/init/do_mounts.c.ifdefed" startline="48" endline="53">
{
    if (*str)
        return 0;
    root_mountflags &= ~MS_RDONLY;
    return 1;
}
</source>
<source file="/cmpt816/tmp/init/do_mounts.c.ifdefed" startline="59" endline="119">
{
    char path [64];
    char buf [32];
    int range;
    dev_t res;
    char *s;
    int len;
    int fd;
    unsigned int maj, min;
    sprintf (path, "/sys/block/%s/dev", name);
    fd = sys_open (path, 0, 0);
    if (fd < 0)
        goto fail;
    len = sys_read (fd, buf, 32);
    sys_close (fd);
    if (len <= 0 || len == 32 || buf[len - 1] != '\n')
        goto fail;
    buf[len - 1] = '\0';
    if (sscanf (buf, "%u:%u", &maj, &min) == 2) {
        res = MKDEV (maj, min);
        if (maj != MAJOR (res) || min != MINOR (res))
            goto fail;
    }
    else {
        res = new_decode_dev (simple_strtoul (buf, &s, 16));
        if (*s)
            goto fail;
    }
    if (!part)
        return res;
    sprintf (path, "/sys/block/%s/range", name);
    fd = sys_open (path, 0, 0);
    if (fd < 0)
        goto fail;
    len = sys_read (fd, buf, 32);
    sys_close (fd);
    if (len <= 0 || len == 32 || buf[len - 1] != '\n')
        goto fail;
    buf[len - 1] = '\0';
    range = simple_strtoul (buf, &s, 10);
    if (*s)
        goto fail;
    if (part < range)
        return res + part;
fail :
    return 0;
}
</source>
<source file="/cmpt816/tmp/init/do_mounts.c.ifdefed" startline="80" endline="87">
{
    res = MKDEV (maj, min);
    if (maj != MAJOR (res) || min != MINOR (res))
        goto fail;
}
</source>
<source file="/cmpt816/tmp/init/do_mounts.c.ifdefed" startline="87" endline="94">
{
    res = new_decode_dev (simple_strtoul (buf, &s, 16));
    if (*s)
        goto fail;
}
</source>
<source file="/cmpt816/tmp/init/do_mounts.c.ifdefed" startline="141" endline="210">
{
    char s [32];
    char *p;
    dev_t res = 0;
    int part;
    if (strncmp (name, "/dev/", 5) != 0) {
        unsigned maj, min;
        if (sscanf (name, "%u:%u", &maj, &min) == 2) {
            res = MKDEV (maj, min);
            if (maj != MAJOR (res) || min != MINOR (res))
                goto fail;
        }
        else {
            res = new_decode_dev (simple_strtoul (name, &p, 16));
            if (*p)
                goto fail;
        }
        goto done;
    }
    name += 5;
    res = Root_NFS;
    if (strcmp (name, "nfs") == 0)
        goto done;
    res = Root_RAM0;
    if (strcmp (name, "ram") == 0)
        goto done;
    if (strlen (name) > 31)
        goto fail;
    strcpy (s, name);
    for (p = s; *p; p++)
        if (*p == '/')
            *p = '!';
    res = try_name (s, 0);
    if (res)
        goto done;
    while (p > s && isdigit (p[-1]))
        p--;
    if (p == s || !*p || *p == '0')
        goto fail;
    part = simple_strtoul (p, NULL, 10);
    *p = '\0';
    res = try_name (s, part);
    if (res)
        goto done;
    if (p < s + 2 || !isdigit (p[-2]) || p[-1] != 'p')
        goto fail;
    p[-1] = '\0';
    res = try_name (s, part);
done :
    return res;
fail :
    res = 0;
    goto done;
}
</source>
<source file="/cmpt816/tmp/init/do_mounts.c.ifdefed" startline="153" endline="166">
{
    unsigned maj, min;
    if (sscanf (name, "%u:%u", &maj, &min) == 2) {
        res = MKDEV (maj, min);
        if (maj != MAJOR (res) || min != MINOR (res))
            goto fail;
    }
    else {
        res = new_decode_dev (simple_strtoul (name, &p, 16));
        if (*p)
            goto fail;
    }
    goto done;
}
</source>
<source file="/cmpt816/tmp/init/do_mounts.c.ifdefed" startline="156" endline="160">
{
    res = MKDEV (maj, min);
    if (maj != MAJOR (res) || min != MINOR (res))
        goto fail;
}
</source>
<source file="/cmpt816/tmp/init/do_mounts.c.ifdefed" startline="160" endline="164">
{
    res = new_decode_dev (simple_strtoul (name, &p, 16));
    if (*p)
        goto fail;
}
</source>
<source file="/cmpt816/tmp/init/do_mounts.c.ifdefed" startline="213" endline="216">
{
    strlcpy (saved_root_name, line, sizeof (saved_root_name));
    return 1;
}
</source>
<source file="/cmpt816/tmp/init/do_mounts.c.ifdefed" startline="221" endline="226">
{
    if (*str)
        return 0;
    root_wait = 1;
    return 1;
}
</source>
<source file="/cmpt816/tmp/init/do_mounts.c.ifdefed" startline="232" endline="235">
{
    root_mount_data = str;
    return 1;
}
</source>
<source file="/cmpt816/tmp/init/do_mounts.c.ifdefed" startline="239" endline="242">
{
    root_fs_names = str;
    return 1;
}
</source>
<source file="/cmpt816/tmp/init/do_mounts.c.ifdefed" startline="246" endline="249">
{
    root_delay = simple_strtoul (str, NULL, 0);
    return 1;
}
</source>
<source file="/cmpt816/tmp/init/do_mounts.c.ifdefed" startline="256" endline="280">
{
    char *s = page;
    if (root_fs_names) {
        strcpy (page, root_fs_names);
        while (*s++) {
            if (s[-1] == ',')
                s[-1] = '\0';
        }
    }
    else {
        int len = get_filesystem_list (page);
        char *p, *next;
        page[len] = '\0';
        for (p = page - 1; p; p = next) {
            next = strchr (++p, '\n');
            if (*p++ != '\t')
                continue;
            while ((*s++ = *p++) != '\n')
                ;
            s[-1] = '\0';
        }
    }
    *s = '\0';
}
</source>
<source file="/cmpt816/tmp/init/do_mounts.c.ifdefed" startline="259" endline="265">
{
    strcpy (page, root_fs_names);
    while (*s++) {
        if (s[-1] == ',')
            s[-1] = '\0';
    }
}
</source>
<source file="/cmpt816/tmp/init/do_mounts.c.ifdefed" startline="261" endline="264">
{
    if (s[-1] == ',')
        s[-1] = '\0';
}
</source>
<source file="/cmpt816/tmp/init/do_mounts.c.ifdefed" startline="265" endline="278">
{
    int len = get_filesystem_list (page);
    char *p, *next;
    page[len] = '\0';
    for (p = page - 1; p; p = next) {
        next = strchr (++p, '\n');
        if (*p++ != '\t')
            continue;
        while ((*s++ = *p++) != '\n')
            ;
        s[-1] = '\0';
    }
}
</source>
<source file="/cmpt816/tmp/init/do_mounts.c.ifdefed" startline="270" endline="277">
{
    next = strchr (++p, '\n');
    if (*p++ != '\t')
        continue;
    while ((*s++ = *p++) != '\n')
        ;
    s[-1] = '\0';
}
</source>
<source file="/cmpt816/tmp/init/do_mounts.c.ifdefed" startline="283" endline="295">
{
    int err = sys_mount (name, "/root", fs, flags, data);
    if (err)
        return err;
    sys_chdir ("/root");
    ROOT_DEV = current->fs->pwdmnt->mnt_sb->s_dev;
    printk ("VFS: Mounted root (%s filesystem)%s.\n", current -> fs -> pwdmnt -> mnt_sb -> s_type -> name, current -> fs -> pwdmnt -> mnt_sb -> s_flags & MS_RDONLY ? " readonly" : "");
    return 0;
}
</source>
<source file="/cmpt816/tmp/init/do_mounts.c.ifdefed" startline="298" endline="348">
{
    char *fs_names = __getname ();
    char *p;
    const char *b = name;
    get_fs_names (fs_names);
retry :
    for (p = fs_names; *p; p += strlen (p) + 1) {
        int err = do_mount_root (name, p, flags, root_mount_data);
        switch (err) {
        case 0 :
            goto out;
        case -EACCES :
            flags |= MS_RDONLY;
            goto retry;
        case -EINVAL :
            continue;
        }
        printk ("VFS: Cannot open root device \"%s\" or %s\n", root_device_name, b);
        printk ("Please append a correct \"root=\" boot option; here are the available partitions:\n");
        printk_all_partitions ();
        panic ("VFS: Unable to mount root fs on %s", b);
    }
    printk ("List of all partitions:\n");
    printk_all_partitions ();
    printk ("No filesystem could mount root, tried: ");
    for (p = fs_names; *p; p += strlen (p) + 1)
        printk (" %s", p);
    printk ("\n");
    panic ("VFS: Unable to mount root fs on %s", b);
out :
    putname (fs_names);
}
</source>
<source file="/cmpt816/tmp/init/do_mounts.c.ifdefed" startline="309" endline="334">
{
    int err = do_mount_root (name, p, flags, root_mount_data);
    switch (err) {
    case 0 :
        goto out;
    case -EACCES :
        flags |= MS_RDONLY;
        goto retry;
    case -EINVAL :
        continue;
    }
    printk ("VFS: Cannot open root device \"%s\" or %s\n", root_device_name, b);
    printk ("Please append a correct \"root=\" boot option; here are the available partitions:\n");
    printk_all_partitions ();
    panic ("VFS: Unable to mount root fs on %s", b);
}
</source>
<source file="/cmpt816/tmp/init/do_mounts.c.ifdefed" startline="311" endline="319">
{
case 0 :
    goto out;
case -EACCES :
    flags |= MS_RDONLY;
    goto retry;
case -EINVAL :
    continue;
}
</source>
<source file="/cmpt816/tmp/init/do_mounts.c.ifdefed" startline="394" endline="420">
{
}
</source>
<source file="/cmpt816/tmp/init/do_mounts.c.ifdefed" startline="426" endline="474">
{
    int is_floppy;
    if (root_delay) {
        printk (KERN_INFO "Waiting %dsec before mounting root device...\n", root_delay);
        ssleep (root_delay);
    }
    while (driver_probe_done () != 0)
        msleep (100);
    md_run_setup ();
    if (saved_root_name[0]) {
        root_device_name = saved_root_name;
        if (!strncmp (root_device_name, "mtd", 3)) {
            mount_block_root (root_device_name, root_mountflags);
            goto out;
        }
        ROOT_DEV = name_to_dev_t (root_device_name);
        if (strncmp (root_device_name, "/dev/", 5) == 0)
            root_device_name += 5;
    }
    if (initrd_load ())
        goto out;
    if ((ROOT_DEV == 0) && root_wait) {
        printk (KERN_INFO "Waiting for root device %s...\n", saved_root_name);
        while (driver_probe_done () != 0 || (ROOT_DEV = name_to_dev_t (saved_root_name)) == 0)
            msleep (100);
    }
    is_floppy = MAJOR (ROOT_DEV) == FLOPPY_MAJOR;
    if (is_floppy && rd_doload && rd_load_disk (0))
        ROOT_DEV = Root_RAM0;
    mount_root ();
out :
    sys_mount (".", "/", NULL, MS_MOVE, NULL);
    sys_chroot (".");
    security_sb_post_mountroot ();
}
</source>
<source file="/cmpt816/tmp/init/do_mounts.c.ifdefed" startline="429" endline="433">
{
    printk (KERN_INFO "Waiting %dsec before mounting root device...\n", root_delay);
    ssleep (root_delay);
}
</source>
<source file="/cmpt816/tmp/init/do_mounts.c.ifdefed" startline="441" endline="450">
{
    root_device_name = saved_root_name;
    if (!strncmp (root_device_name, "mtd", 3)) {
        mount_block_root (root_device_name, root_mountflags);
        goto out;
    }
    ROOT_DEV = name_to_dev_t (root_device_name);
    if (strncmp (root_device_name, "/dev/", 5) == 0)
        root_device_name += 5;
}
</source>
<source file="/cmpt816/tmp/init/do_mounts.c.ifdefed" startline="443" endline="446">
{
    mount_block_root (root_device_name, root_mountflags);
    goto out;
}
</source>
<source file="/cmpt816/tmp/init/do_mounts.c.ifdefed" startline="456" endline="462">
{
    printk (KERN_INFO "Waiting for root device %s...\n", saved_root_name);
    while (driver_probe_done () != 0 || (ROOT_DEV = name_to_dev_t (saved_root_name)) == 0)
        msleep (100);
}
</source>
<source file="/cmpt816/tmp/init/calibrate.c.ifdefed" startline="15" endline="18">
{
    preset_lpj = simple_strtoul (str, NULL, 0);
    return 1;
}
</source>
<source file="/cmpt816/tmp/init/calibrate.c.ifdefed" startline="105" endline="105">
{
    return 0;
}
</source>
<source file="/cmpt816/tmp/init/calibrate.c.ifdefed" startline="116" endline="173">
{
    unsigned long ticks, loopbit;
    int lps_precision = LPS_PREC;
    if (preset_lpj) {
        loops_per_jiffy = preset_lpj;
        printk ("Calibrating delay loop (skipped)... " "%lu.%02lu BogoMIPS preset\n", loops_per_jiffy / (500000 / HZ), (loops_per_jiffy / (5000 / HZ)) % 100);
    }
    else if ((loops_per_jiffy = calibrate_delay_direct ()) != 0) {
        printk ("Calibrating delay using timer specific routine.. ");
        printk ("%lu.%02lu BogoMIPS (lpj=%lu)\n", loops_per_jiffy / (500000 / HZ), (loops_per_jiffy / (5000 / HZ)) % 100, loops_per_jiffy);
    }
    else {
        loops_per_jiffy = (1 << 12);
        printk (KERN_DEBUG "Calibrating delay loop... ");
        while ((loops_per_jiffy <<= 1) != 0) {
            ticks = jiffies;
            while (ticks == jiffies)
                ;
            ticks = jiffies;
            __delay (loops_per_jiffy);
            ticks = jiffies - ticks;
            if (ticks)
                break;
        }
        loops_per_jiffy >>= 1;
        loopbit = loops_per_jiffy;
        while (lps_precision-- && (loopbit >>= 1)) {
            loops_per_jiffy |= loopbit;
            ticks = jiffies;
            while (ticks == jiffies)
                ;
            ticks = jiffies;
            __delay (loops_per_jiffy);
            if (jiffies != ticks)
                loops_per_jiffy &= ~loopbit;
        }
        printk ("%lu.%02lu BogoMIPS (lpj=%lu)\n", loops_per_jiffy / (500000 / HZ), (loops_per_jiffy / (5000 / HZ)) % 100, loops_per_jiffy);
    }
}
</source>
<source file="/cmpt816/tmp/init/calibrate.c.ifdefed" startline="120" endline="126">
{
    loops_per_jiffy = preset_lpj;
    printk ("Calibrating delay loop (skipped)... " "%lu.%02lu BogoMIPS preset\n", loops_per_jiffy / (500000 / HZ), (loops_per_jiffy / (5000 / HZ)) % 100);
}
</source>
<source file="/cmpt816/tmp/init/calibrate.c.ifdefed" startline="126" endline="132">
{
    printk ("Calibrating delay using timer specific routine.. ");
    printk ("%lu.%02lu BogoMIPS (lpj=%lu)\n", loops_per_jiffy / (500000 / HZ), (loops_per_jiffy / (5000 / HZ)) % 100, loops_per_jiffy);
}
</source>
<source file="/cmpt816/tmp/init/calibrate.c.ifdefed" startline="132" endline="171">
{
    loops_per_jiffy = (1 << 12);
    printk (KERN_DEBUG "Calibrating delay loop... ");
    while ((loops_per_jiffy <<= 1) != 0) {
        ticks = jiffies;
        while (ticks == jiffies)
            ;
        ticks = jiffies;
        __delay (loops_per_jiffy);
        ticks = jiffies - ticks;
        if (ticks)
            break;
    }
    loops_per_jiffy >>= 1;
    loopbit = loops_per_jiffy;
    while (lps_precision-- && (loopbit >>= 1)) {
        loops_per_jiffy |= loopbit;
        ticks = jiffies;
        while (ticks == jiffies)
            ;
        ticks = jiffies;
        __delay (loops_per_jiffy);
        if (jiffies != ticks)
            loops_per_jiffy &= ~loopbit;
    }
    printk ("%lu.%02lu BogoMIPS (lpj=%lu)\n", loops_per_jiffy / (500000 / HZ), (loops_per_jiffy / (5000 / HZ)) % 100, loops_per_jiffy);
}
</source>
<source file="/cmpt816/tmp/init/calibrate.c.ifdefed" startline="136" endline="147">
{
    ticks = jiffies;
    while (ticks == jiffies)
        ;
    ticks = jiffies;
    __delay (loops_per_jiffy);
    ticks = jiffies - ticks;
    if (ticks)
        break;
}
</source>
<source file="/cmpt816/tmp/init/calibrate.c.ifdefed" startline="155" endline="164">
{
    loops_per_jiffy |= loopbit;
    ticks = jiffies;
    while (ticks == jiffies)
        ;
    ticks = jiffies;
    __delay (loops_per_jiffy);
    if (jiffies != ticks)
        loops_per_jiffy &= ~loopbit;
}
</source>
<source file="/cmpt816/tmp/init/main.c.ifdefed" startline="95" endline="95">
{
}
</source>
<source file="/cmpt816/tmp/init/main.c.ifdefed" startline="98" endline="98">
{
}
</source>
<source file="/cmpt816/tmp/init/main.c.ifdefed" startline="183" endline="186">
{
    reset_devices = 1;
    return 1;
}
</source>
<source file="/cmpt816/tmp/init/main.c.ifdefed" startline="197" endline="223">
{
    struct obs_kernel_param *p;
    int had_early_param = 0;
    p = __setup_start;
    do {
        int n = strlen (p->str);
        if (!strncmp (line, p->str, n)) {
            if (p->early) {
                if (line[n] == '\0' || line[n] == '=')
                    had_early_param = 1;
            }
            else if (!p->setup_func) {
                printk (KERN_WARNING "Parameter %s is obsolete," " ignored\n", p -> str);
                return 1;
            }
            else if (p->setup_func (line +n))
                return 1;
        }
        p++;
    }
    while (p < __setup_end);
    return had_early_param;
}
</source>
<source file="/cmpt816/tmp/init/main.c.ifdefed" startline="202" endline="220">
{
    int n = strlen (p->str);
    if (!strncmp (line, p->str, n)) {
        if (p->early) {
            if (line[n] == '\0' || line[n] == '=')
                had_early_param = 1;
        }
        else if (!p->setup_func) {
            printk (KERN_WARNING "Parameter %s is obsolete," " ignored\n", p -> str);
            return 1;
        }
        else if (p->setup_func (line +n))
            return 1;
    }
    p++;
}
</source>
<source file="/cmpt816/tmp/init/main.c.ifdefed" startline="204" endline="218">
{
    if (p->early) {
        if (line[n] == '\0' || line[n] == '=')
            had_early_param = 1;
    }
    else if (!p->setup_func) {
        printk (KERN_WARNING "Parameter %s is obsolete," " ignored\n", p -> str);
        return 1;
    }
    else if (p->setup_func (line +n))
        return 1;
}
</source>
<source file="/cmpt816/tmp/init/main.c.ifdefed" startline="205" endline="212">
{
    if (line[n] == '\0' || line[n] == '=')
        had_early_param = 1;
}
</source>
<source file="/cmpt816/tmp/init/main.c.ifdefed" startline="212" endline="216">
{
    printk (KERN_WARNING "Parameter %s is obsolete," " ignored\n", p -> str);
    return 1;
}
</source>
<source file="/cmpt816/tmp/init/main.c.ifdefed" startline="234" endline="239">
{
    if (*str)
        return 0;
    console_loglevel = 10;
    return 1;
}
</source>
<source file="/cmpt816/tmp/init/main.c.ifdefed" startline="242" endline="247">
{
    if (*str)
        return 0;
    console_loglevel = 4;
    return 1;
}
</source>
<source file="/cmpt816/tmp/init/main.c.ifdefed" startline="253" endline="256">
{
    get_option (& str, & console_loglevel);
    return 1;
}
</source>
<source file="/cmpt816/tmp/init/main.c.ifdefed" startline="265" endline="319">
{
    if (val) {
        if (val == param + strlen (param) + 1)
            val[-1] = '=';
        else if (val == param + strlen (param) + 2) {
            val[-2] = '=';
            memmove (val - 1, val, strlen (val) + 1);
            val--;
        }
        else
            BUG ();
    }
    if (obsolete_checksetup (param))
        return 0;
    if (strchr (param, '.') && (!val || strchr (param, '.') < val)) {
        printk (KERN_ERR "Unknown boot option `%s': ignoring\n", param);
        return 0;
    }
    if (panic_later)
        return 0;
    if (val) {
        unsigned int i;
        for (i = 0; envp_init[i]; i++) {
            if (i == MAX_INIT_ENVS) {
                panic_later = "Too many boot env vars at `%s'";
                panic_param = param;
            }
            if (!strncmp (param, envp_init[i], val -param))
                break;
        }
        envp_init[i] = param;
    }
    else {
        unsigned int i;
        for (i = 0; argv_init[i]; i++) {
            if (i == MAX_INIT_ARGS) {
                panic_later = "Too many boot init vars at `%s'";
                panic_param = param;
            }
        }
        argv_init[i] = param;
    }
    return 0;
}
</source>
<source file="/cmpt816/tmp/init/main.c.ifdefed" startline="267" endline="277">
{
    if (val == param + strlen (param) + 1)
        val[-1] = '=';
    else if (val == param + strlen (param) + 2) {
        val[-2] = '=';
        memmove (val - 1, val, strlen (val) + 1);
        val--;
    }
    else
        BUG ();
}
</source>
<source file="/cmpt816/tmp/init/main.c.ifdefed" startline="271" endline="275">
{
    val[-2] = '=';
    memmove (val - 1, val, strlen (val) + 1);
    val--;
}
</source>
<source file="/cmpt816/tmp/init/main.c.ifdefed" startline="287" endline="290">
{
    printk (KERN_ERR "Unknown boot option `%s': ignoring\n", param);
    return 0;
}
</source>
<source file="/cmpt816/tmp/init/main.c.ifdefed" startline="295" endline="307">
{
    unsigned int i;
    for (i = 0; envp_init[i]; i++) {
        if (i == MAX_INIT_ENVS) {
            panic_later = "Too many boot env vars at `%s'";
            panic_param = param;
        }
        if (!strncmp (param, envp_init[i], val -param))
            break;
    }
    envp_init[i] = param;
}
</source>
<source file="/cmpt816/tmp/init/main.c.ifdefed" startline="298" endline="305">
{
    if (i == MAX_INIT_ENVS) {
        panic_later = "Too many boot env vars at `%s'";
        panic_param = param;
    }
    if (!strncmp (param, envp_init[i], val -param))
        break;
}
</source>
<source file="/cmpt816/tmp/init/main.c.ifdefed" startline="299" endline="302">
{
    panic_later = "Too many boot env vars at `%s'";
    panic_param = param;
}
</source>
<source file="/cmpt816/tmp/init/main.c.ifdefed" startline="307" endline="317">
{
    unsigned int i;
    for (i = 0; argv_init[i]; i++) {
        if (i == MAX_INIT_ARGS) {
            panic_later = "Too many boot init vars at `%s'";
            panic_param = param;
        }
    }
    argv_init[i] = param;
}
</source>
<source file="/cmpt816/tmp/init/main.c.ifdefed" startline="310" endline="315">
{
    if (i == MAX_INIT_ARGS) {
        panic_later = "Too many boot init vars at `%s'";
        panic_param = param;
    }
}
</source>
<source file="/cmpt816/tmp/init/main.c.ifdefed" startline="311" endline="314">
{
    panic_later = "Too many boot init vars at `%s'";
    panic_param = param;
}
</source>
<source file="/cmpt816/tmp/init/main.c.ifdefed" startline="322" endline="335">
{
    unsigned int i;
    execute_command = str;
    for (i = 1; i < MAX_INIT_ARGS; i++)
        argv_init[i] = NULL;
    return 1;
}
</source>
<source file="/cmpt816/tmp/init/main.c.ifdefed" startline="339" endline="347">
{
    unsigned int i;
    ramdisk_execute_command = str;
    for (i = 1; i < MAX_INIT_ARGS; i++)
        argv_init[i] = NULL;
    return 1;
}
</source>
<source file="/cmpt816/tmp/init/main.c.ifdefed" startline="361" endline="361">
{
}
</source>
<source file="/cmpt816/tmp/init/main.c.ifdefed" startline="362" endline="362">
{
}
</source>
<source file="/cmpt816/tmp/init/main.c.ifdefed" startline="416" endline="421">
{
    saved_command_line = alloc_bootmem (strlen (boot_command_line) +1);
    static_command_line = alloc_bootmem (strlen (command_line) +1);
    strcpy (saved_command_line, boot_command_line);
    strcpy (static_command_line, command_line);
}
</source>
<source file="/cmpt816/tmp/init/main.c.ifdefed" startline="434" endline="454">
{
    int pid;
    kernel_thread (kernel_init, NULL, CLONE_FS | CLONE_SIGHAND);
    numa_default_policy ();
    pid = kernel_thread (kthreadd, NULL, CLONE_FS | CLONE_FILES);
    kthreadd_task = find_task_by_pid (pid);
    unlock_kernel ();
    init_idle_bootup_task (current);
    preempt_enable_no_resched ();
    schedule ();
    preempt_disable ();
    cpu_idle ();
}
</source>
<source file="/cmpt816/tmp/init/main.c.ifdefed" startline="458" endline="473">
{
    struct obs_kernel_param *p;
    for (p = __setup_start; p < __setup_end; p++) {
        if ((p->early && strcmp (param, p->str) == 0) || (strcmp (param, "console") == 0 && strcmp (p->str, "earlycon") == 0)) {
            if (p->setup_func (val) != 0)
                printk (KERN_WARNING "Malformed early option '%s'\n", param);
        }
    }
    return 0;
}
</source>
<source file="/cmpt816/tmp/init/main.c.ifdefed" startline="461" endline="470">
{
    if ((p->early && strcmp (param, p->str) == 0) || (strcmp (param, "console") == 0 && strcmp (p->str, "earlycon") == 0)) {
        if (p->setup_func (val) != 0)
            printk (KERN_WARNING "Malformed early option '%s'\n", param);
    }
}
</source>
<source file="/cmpt816/tmp/init/main.c.ifdefed" startline="465" endline="469">
{
    if (p->setup_func (val) != 0)
        printk (KERN_WARNING "Malformed early option '%s'\n", param);
}
</source>
<source file="/cmpt816/tmp/init/main.c.ifdefed" startline="477" endline="488">
{
    static __initdata int done = 0;
    static __initdata char tmp_cmdline [COMMAND_LINE_SIZE];
    if (done)
        return;
    strlcpy (tmp_cmdline, boot_command_line, COMMAND_LINE_SIZE);
    parse_args ("early options", tmp_cmdline, NULL, 0, do_early_param);
    done = 1;
}
</source>
<source file="/cmpt816/tmp/init/main.c.ifdefed" startline="495" endline="501">
{
    int cpu = smp_processor_id ();
    cpu_set (cpu, cpu_online_map);
    cpu_set (cpu, cpu_present_map);
    cpu_set (cpu, cpu_possible_map);
}
</source>
<source file="/cmpt816/tmp/init/main.c.ifdefed" startline="504" endline="505">
{
}
</source>
<source file="/cmpt816/tmp/init/main.c.ifdefed" startline="508" endline="649">
{
    char *command_line;
    extern struct kernel_param __start___param [], __stop___param [];
    smp_setup_processor_id ();
    unwind_init ();
    lockdep_init ();
    cgroup_init_early ();
    local_irq_disable ();
    early_boot_irqs_off ();
    early_init_irq_lock_class ();
    lock_kernel ();
    tick_init ();
    boot_cpu_init ();
    page_address_init ();
    printk (KERN_NOTICE);
    printk (linux_banner);
    setup_arch (& command_line);
    setup_command_line (command_line);
    unwind_setup ();
    setup_per_cpu_areas ();
    smp_prepare_boot_cpu ();
    sched_init ();
    preempt_disable ();
    build_all_zonelists ();
    page_alloc_init ();
    printk (KERN_NOTICE "Kernel command line: %s\n", boot_command_line);
    parse_early_param ();
    parse_args ("Booting kernel", static_command_line, __start___param, __stop___param - __start___param, & unknown_bootoption);
    if (!irqs_disabled ()) {
        printk (KERN_WARNING "start_kernel(): bug: interrupts were " "enabled *very* early, fixing it\n");
        local_irq_disable ();
    }
    sort_main_extable ();
    trap_init ();
    rcu_init ();
    init_IRQ ();
    pidhash_init ();
    init_timers ();
    hrtimers_init ();
    softirq_init ();
    timekeeping_init ();
    time_init ();
    profile_init ();
    if (!irqs_disabled ())
        printk ("start_kernel(): bug: interrupts were enabled early\n");
    early_boot_irqs_on ();
    local_irq_enable ();
    console_init ();
    if (panic_later)
        panic (panic_later, panic_param);
    lockdep_info ();
    locking_selftest ();
    vfs_caches_init_early ();
    cpuset_init_early ();
    mem_init ();
    kmem_cache_init ();
    setup_per_cpu_pageset ();
    numa_policy_init ();
    if (late_time_init)
        late_time_init ();
    calibrate_delay ();
    pidmap_init ();
    pgtable_cache_init ();
    prio_tree_init ();
    anon_vma_init ();
    fork_init (num_physpages);
    proc_caches_init ();
    buffer_init ();
    unnamed_dev_init ();
    key_init ();
    security_init ();
    vfs_caches_init (num_physpages);
    radix_tree_init ();
    signals_init ();
    page_writeback_init ();
    cgroup_init ();
    cpuset_init ();
    taskstats_init_early ();
    delayacct_init ();
    check_bugs ();
    acpi_early_init ();
    rest_init ();
}
</source>
<source file="/cmpt816/tmp/init/main.c.ifdefed" startline="560" endline="564">
{
    printk (KERN_WARNING "start_kernel(): bug: interrupts were " "enabled *very* early, fixing it\n");
    local_irq_disable ();
}
</source>
<source file="/cmpt816/tmp/init/main.c.ifdefed" startline="654" endline="657">
{
    initcall_debug = 1;
    return 1;
}
</source>
<source file="/cmpt816/tmp/init/main.c.ifdefed" startline="663" endline="720">
{
    initcall_t *call;
    int count = preempt_count ();
    for (call = __initcall_start; call < __initcall_end; call++) {
        ktime_t t0, t1, delta;
        char *msg = NULL;
        char msgbuf [40];
        int result;
        if (initcall_debug) {
            printk ("Calling initcall 0x%p", * call);
            print_fn_descriptor_symbol (": %s()", (unsigned long) * call);
            printk ("\n");
            t0 = ktime_get ();
        }
        result = (*call) ();
        if (initcall_debug) {
            t1 = ktime_get ();
            delta = ktime_sub (t1, t0);
            printk ("initcall 0x%p", * call);
            print_fn_descriptor_symbol (": %s()", (unsigned long) * call);
            printk (" returned %d.\n", result);
            printk ("initcall 0x%p ran for %Ld msecs: ", * call, (unsigned long long) delta.tv64 >> 20);
            print_fn_descriptor_symbol ("%s()\n", (unsigned long) * call);
        }
        if (result && result != -ENODEV && initcall_debug) {
            sprintf (msgbuf, "error code %d", result);
            msg = msgbuf;
        }
        if (preempt_count () != count) {
            msg = "preemption imbalance";
            preempt_count () = count;
        }
        if (irqs_disabled ()) {
            msg = "disabled interrupts";
            local_irq_enable ();
        }
        if (msg) {
            printk (KERN_WARNING "initcall at 0x%p", * call);
            print_fn_descriptor_symbol (": %s()", (unsigned long) * call);
            printk (": returned with %s\n", msg);
        }
    }
    flush_scheduled_work ();
}
</source>
<source file="/cmpt816/tmp/init/main.c.ifdefed" startline="667" endline="716">
{
    ktime_t t0, t1, delta;
    char *msg = NULL;
    char msgbuf [40];
    int result;
    if (initcall_debug) {
        printk ("Calling initcall 0x%p", * call);
        print_fn_descriptor_symbol (": %s()", (unsigned long) * call);
        printk ("\n");
        t0 = ktime_get ();
    }
    result = (*call) ();
    if (initcall_debug) {
        t1 = ktime_get ();
        delta = ktime_sub (t1, t0);
        printk ("initcall 0x%p", * call);
        print_fn_descriptor_symbol (": %s()", (unsigned long) * call);
        printk (" returned %d.\n", result);
        printk ("initcall 0x%p ran for %Ld msecs: ", * call, (unsigned long long) delta.tv64 >> 20);
        print_fn_descriptor_symbol ("%s()\n", (unsigned long) * call);
    }
    if (result && result != -ENODEV && initcall_debug) {
        sprintf (msgbuf, "error code %d", result);
        msg = msgbuf;
    }
    if (preempt_count () != count) {
        msg = "preemption imbalance";
        preempt_count () = count;
    }
    if (irqs_disabled ()) {
        msg = "disabled interrupts";
        local_irq_enable ();
    }
    if (msg) {
        printk (KERN_WARNING "initcall at 0x%p", * call);
        print_fn_descriptor_symbol (": %s()", (unsigned long) * call);
        printk (": returned with %s\n", msg);
    }
}
</source>
<source file="/cmpt816/tmp/init/main.c.ifdefed" startline="673" endline="679">
{
    printk ("Calling initcall 0x%p", * call);
    print_fn_descriptor_symbol (": %s()", (unsigned long) * call);
    printk ("\n");
    t0 = ktime_get ();
}
</source>
<source file="/cmpt816/tmp/init/main.c.ifdefed" startline="683" endline="696">
{
    t1 = ktime_get ();
    delta = ktime_sub (t1, t0);
    printk ("initcall 0x%p", * call);
    print_fn_descriptor_symbol (": %s()", (unsigned long) * call);
    printk (" returned %d.\n", result);
    printk ("initcall 0x%p ran for %Ld msecs: ", * call, (unsigned long long) delta.tv64 >> 20);
    print_fn_descriptor_symbol ("%s()\n", (unsigned long) * call);
}
</source>
<source file="/cmpt816/tmp/init/main.c.ifdefed" startline="698" endline="701">
{
    sprintf (msgbuf, "error code %d", result);
    msg = msgbuf;
}
</source>
<source file="/cmpt816/tmp/init/main.c.ifdefed" startline="702" endline="705">
{
    msg = "preemption imbalance";
    preempt_count () = count;
}
</source>
<source file="/cmpt816/tmp/init/main.c.ifdefed" startline="706" endline="709">
{
    msg = "disabled interrupts";
    local_irq_enable ();
}
</source>
<source file="/cmpt816/tmp/init/main.c.ifdefed" startline="710" endline="715">
{
    printk (KERN_WARNING "initcall at 0x%p", * call);
    print_fn_descriptor_symbol (": %s()", (unsigned long) * call);
    printk (": returned with %s\n", msg);
}
</source>
<source file="/cmpt816/tmp/init/main.c.ifdefed" startline="730" endline="737">
{
    init_workqueues ();
    usermodehelper_init ();
    driver_init ();
    init_irq_proc ();
    do_initcalls ();
}
</source>
<source file="/cmpt816/tmp/init/main.c.ifdefed" startline="742" endline="745">
{
    nosoftlockup = 1;
    return 1;
}
</source>
<source file="/cmpt816/tmp/init/main.c.ifdefed" startline="749" endline="756">
{
    extern int spawn_ksoftirqd (void);
    migration_init ();
    spawn_ksoftirqd ();
    if (!nosoftlockup)
        spawn_softlockup_task ();
}
</source>
<source file="/cmpt816/tmp/init/main.c.ifdefed" startline="759" endline="762">
{
    argv_init[0] = init_filename;
    kernel_execve (init_filename, argv_init, envp_init);
}
</source>
<source file="/cmpt816/tmp/init/main.c.ifdefed" startline="768" endline="804">
{
    free_initmem ();
    unlock_kernel ();
    mark_rodata_ro ();
    system_state = SYSTEM_RUNNING;
    numa_default_policy ();
    if (sys_open ((const char __user *) "/dev/console", O_RDWR, 0) < 0)
        printk (KERN_WARNING "Warning: unable to open an initial console.\n");
    (void) sys_dup (0);
    (void) sys_dup (0);
    if (ramdisk_execute_command) {
        run_init_process (ramdisk_execute_command);
        printk (KERN_WARNING "Failed to execute %s\n", ramdisk_execute_command);
    }
    if (execute_command) {
        run_init_process (execute_command);
        printk (KERN_WARNING "Failed to execute %s.  Attempting " "defaults...\n", execute_command);
    }
    run_init_process ("/sbin/init");
    run_init_process ("/etc/init");
    run_init_process ("/bin/init");
    run_init_process ("/bin/sh");
    panic ("No init found.  Try passing init= option to kernel.");
}
</source>
<source file="/cmpt816/tmp/init/main.c.ifdefed" startline="781" endline="785">
{
    run_init_process (ramdisk_execute_command);
    printk (KERN_WARNING "Failed to execute %s\n", ramdisk_execute_command);
}
</source>
<source file="/cmpt816/tmp/init/main.c.ifdefed" startline="793" endline="797">
{
    run_init_process (execute_command);
    printk (KERN_WARNING "Failed to execute %s.  Attempting " "defaults...\n", execute_command);
}
</source>
<source file="/cmpt816/tmp/init/main.c.ifdefed" startline="807" endline="857">
{
    lock_kernel ();
    set_cpus_allowed (current, CPU_MASK_ALL);
    init_pid_ns.child_reaper = current;
    __set_special_pids (1, 1);
    cad_pid = task_pid (current);
    smp_prepare_cpus (max_cpus);
    do_pre_smp_initcalls ();
    smp_init ();
    sched_init_smp ();
    cpuset_init_smp ();
    do_basic_setup ();
    if (!ramdisk_execute_command)
        ramdisk_execute_command = "/init";
    if (sys_access ((const char __user *) ramdisk_execute_command, 0) != 0) {
        ramdisk_execute_command = NULL;
        prepare_namespace ();
    }
    init_post ();
    return 0;
}
</source>
<source file="/cmpt816/tmp/init/main.c.ifdefed" startline="845" endline="848">
{
    ramdisk_execute_command = NULL;
    prepare_namespace ();
}
</source>
<source file="/cmpt816/tmp/arch/x86/vdso/vgetcpu.c.ifdefed" startline="17" endline="32">
{
    unsigned int dummy, p;
    if (*vdso_vgetcpu_mode == VGETCPU_RDTSCP) {
        rdtscp (dummy, dummy, p);
    }
    else {
        asm ("lsl %1,%0"
            : "=r" (p)
            : "r" (__PER_CPU_SEG)
        )}
    if (cpu)
        *cpu = p & 0xfff;
    if (node)
        *node = p >> 12;
    return 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/vdso/vgetcpu.c.ifdefed" startline="20" endline="23">
{
    rdtscp (dummy, dummy, p);
}
</source>
<source file="/cmpt816/tmp/arch/x86/vdso/vgetcpu.c.ifdefed" startline="23" endline="26">
{
    asm ("lsl %1,%0"
        : "=r" (p)
        : "r" (__PER_CPU_SEG)
    )}
</source>
<source file="/cmpt816/tmp/arch/x86/vdso/vma.c.ifdefed" startline="28" endline="36">
{
    unsigned offset = var - &vdso_kernel_start[0] + VDSO_TEXT_OFFSET;
    void *p = vbase + offset;
    if (*(void**) p != (void *) VMAGIC) {
        printk ("VDSO: variable %s broken\n", name);
        vdso_enabled = 0;
    }
    return p;
}
</source>
<source file="/cmpt816/tmp/arch/x86/vdso/vma.c.ifdefed" startline="31" endline="34">
{
    printk ("VDSO: variable %s broken\n", name);
    vdso_enabled = 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/vdso/vma.c.ifdefed" startline="39" endline="76">
{
    int npages = (vdso_end - vdso_start + PAGE_SIZE - 1) / PAGE_SIZE;
    int i;
    char *vbase;
    vdso_pages = kmalloc (sizeof (struct page *) * npages, GFP_KERNEL);
    if (!vdso_pages)
        goto oom;
    for (i = 0; i < npages; i++) {
        struct page *p;
        p = alloc_page (GFP_KERNEL);
        if (!p)
            goto oom;
        vdso_pages[i] = p;
        copy_page (page_address (p), vdso_start + i * PAGE_SIZE);
    }
    vbase = vmap (vdso_pages, npages, 0, PAGE_KERNEL);
    if (!vbase)
        goto oom;
    if (memcmp (vbase, "\177ELF", 4)) {
        printk ("VDSO: I'm broken; not ELF\n");
        vdso_enabled = 0;
    }
    return 0;
oom :
    printk ("Cannot allocate vdso\n");
    vdso_enabled = 0;
    return -ENOMEM;
}
</source>
<source file="/cmpt816/tmp/arch/x86/vdso/vma.c.ifdefed" startline="47" endline="54">
{
    struct page *p;
    p = alloc_page (GFP_KERNEL);
    if (!p)
        goto oom;
    vdso_pages[i] = p;
    copy_page (page_address (p), vdso_start + i * PAGE_SIZE);
}
</source>
<source file="/cmpt816/tmp/arch/x86/vdso/vma.c.ifdefed" startline="60" endline="63">
{
    printk ("VDSO: I'm broken; not ELF\n");
    vdso_enabled = 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/vdso/vma.c.ifdefed" startline="86" endline="99">
{
    unsigned long addr, end;
    unsigned offset;
    end = (start + PMD_SIZE - 1) & PMD_MASK;
    if (end >= TASK_SIZE64)
        end = TASK_SIZE64;
    end -= len;
    offset = get_random_int () & (PTRS_PER_PTE - 1);
    addr = start + (offset << PAGE_SHIFT);
    if (addr >= end)
        addr = end;
    return addr;
}
</source>
<source file="/cmpt816/tmp/arch/x86/vdso/vma.c.ifdefed" startline="104" endline="133">
{
    struct mm_struct *mm = current->mm;
    unsigned long addr;
    int ret;
    unsigned len = round_up (vdso_end -vdso_start, PAGE_SIZE);
    if (!vdso_enabled)
        return 0;
    down_write (& mm -> mmap_sem);
    addr = vdso_addr (mm->start_stack, len);
    addr = get_unmapped_area (NULL, addr, len, 0, 0);
    if (IS_ERR_VALUE (addr)) {
        ret = addr;
        goto up_fail;
    }
    ret = install_special_mapping (mm, addr, len, VM_READ | VM_EXEC | VM_MAYREAD | VM_MAYWRITE | VM_MAYEXEC | VM_ALWAYSDUMP, vdso_pages);
    if (ret)
        goto up_fail;
    current->mm->context.vdso = (void *) addr;
up_fail :
    up_write (&mm->mmap_sem);
    return ret;
}
</source>
<source file="/cmpt816/tmp/arch/x86/vdso/vma.c.ifdefed" startline="116" endline="119">
{
    ret = addr;
    goto up_fail;
}
</source>
<source file="/cmpt816/tmp/arch/x86/vdso/vma.c.ifdefed" startline="136" endline="139">
{
    vdso_enabled = simple_strtoul (s, NULL, 0);
    return 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/vdso/vclock_gettime.c.ifdefed" startline="28" endline="33">
{
    long ret;
    asm ("syscall"
        : "=a" (ret)
        : "0" (__NR_clock_gettime), "D" (clock), "S" (ts)
        : "memory"
    ) return ret;
}
</source>
<source file="/cmpt816/tmp/arch/x86/vdso/vclock_gettime.c.ifdefed" startline="36" endline="42">
{
    long v;
    cycles_t (*vread) (void);
    vread = gtod->clock.vread;
    v = (vread () - gtod->clock.cycle_last) & gtod->clock.mask;
    return (v * gtod->clock.mult) >> gtod->clock.shift;
}
</source>
<source file="/cmpt816/tmp/arch/x86/vdso/vclock_gettime.c.ifdefed" startline="45" endline="55">
{
    unsigned long seq, ns;
    do {
        seq = read_seqbegin (&gtod->lock);
        ts->tv_sec = gtod->wall_time_sec;
        ts->tv_nsec = gtod->wall_time_nsec;
        ns = vgetns ();
    }
    while (unlikely (read_seqretry (&gtod->lock, seq)));
    timespec_add_ns (ts, ns);
    return 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/vdso/vclock_gettime.c.ifdefed" startline="47" endline="52">
{
    seq = read_seqbegin (&gtod->lock);
    ts->tv_sec = gtod->wall_time_sec;
    ts->tv_nsec = gtod->wall_time_nsec;
    ns = vgetns ();
}
</source>
<source file="/cmpt816/tmp/arch/x86/vdso/vclock_gettime.c.ifdefed" startline="59" endline="70">
{
    while (nsec >= NSEC_PER_SEC) {
        nsec -= NSEC_PER_SEC;
        ++sec;
    }
    while (nsec < 0) {
        nsec += NSEC_PER_SEC;
        --sec;
    }
    ts->tv_sec = sec;
    ts->tv_nsec = nsec;
}
</source>
<source file="/cmpt816/tmp/arch/x86/vdso/vclock_gettime.c.ifdefed" startline="60" endline="63">
{
    nsec -= NSEC_PER_SEC;
    ++sec;
}
</source>
<source file="/cmpt816/tmp/arch/x86/vdso/vclock_gettime.c.ifdefed" startline="64" endline="67">
{
    nsec += NSEC_PER_SEC;
    --sec;
}
</source>
<source file="/cmpt816/tmp/arch/x86/vdso/vclock_gettime.c.ifdefed" startline="73" endline="84">
{
    unsigned long seq, ns, secs;
    do {
        seq = read_seqbegin (&gtod->lock);
        secs = gtod->wall_time_sec;
        ns = gtod->wall_time_nsec + vgetns ();
        secs += gtod->wall_to_monotonic.tv_sec;
        ns += gtod->wall_to_monotonic.tv_nsec;
    }
    while (unlikely (read_seqretry (&gtod->lock, seq)));
    vset_normalized_timespec (ts, secs, ns);
    return 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/vdso/vclock_gettime.c.ifdefed" startline="75" endline="81">
{
    seq = read_seqbegin (&gtod->lock);
    secs = gtod->wall_time_sec;
    ns = gtod->wall_time_nsec + vgetns ();
    secs += gtod->wall_to_monotonic.tv_sec;
    ns += gtod->wall_to_monotonic.tv_nsec;
}
</source>
<source file="/cmpt816/tmp/arch/x86/vdso/vclock_gettime.c.ifdefed" startline="87" endline="96">
{
    if (likely (gtod->sysctl_enabled && gtod->clock.vread))
        switch (clock) {
        case CLOCK_REALTIME :
            return do_realtime (ts);
        case CLOCK_MONOTONIC :
            return do_monotonic (ts);
        }
    return vdso_fallback_gettime (clock, ts);
}
</source>
<source file="/cmpt816/tmp/arch/x86/vdso/vclock_gettime.c.ifdefed" startline="89" endline="94">
{
case CLOCK_REALTIME :
    return do_realtime (ts);
case CLOCK_MONOTONIC :
    return do_monotonic (ts);
}
</source>
<source file="/cmpt816/tmp/arch/x86/vdso/vclock_gettime.c.ifdefed" startline="101" endline="119">
{
    long ret;
    if (likely (gtod->sysctl_enabled && gtod->clock.vread)) {
        BUILD_BUG_ON (offsetof (struct timeval, tv_usec) != offsetof (struct timespec, tv_nsec) || sizeof (* tv) != sizeof (struct timespec));
        do_realtime ((struct timespec *) tv);
        tv->tv_usec /= 1000;
        if (unlikely (tz != NULL)) {
            memcpy (tz, & gtod -> sys_tz, sizeof (struct timezone));
        }
        return 0;
    }
    asm ("syscall"
        : "=a" (ret)
        : "0" (__NR_gettimeofday), "D" (tv), "S" (tz)
        : "memory"
    ) return ret;
}
</source>
<source file="/cmpt816/tmp/arch/x86/vdso/vclock_gettime.c.ifdefed" startline="103" endline="115">
{
    BUILD_BUG_ON (offsetof (struct timeval, tv_usec) != offsetof (struct timespec, tv_nsec) || sizeof (* tv) != sizeof (struct timespec));
    do_realtime ((struct timespec *) tv);
    tv->tv_usec /= 1000;
    if (unlikely (tz != NULL)) {
        memcpy (tz, & gtod -> sys_tz, sizeof (struct timezone));
    }
    return 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/vdso/vclock_gettime.c.ifdefed" startline="109" endline="113">
{
    memcpy (tz, & gtod -> sys_tz, sizeof (struct timezone));
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/smpboot_64.c.ifdefed" startline="128" endline="132">
{
    void *tramp = __va (SMP_TRAMPOLINE_BASE);
    memcpy (tramp, trampoline_data, trampoline_end - trampoline_data);
    return virt_to_phys (tramp);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/smpboot_64.c.ifdefed" startline="140" endline="147">
{
    struct cpuinfo_x86 *c = &cpu_data (id);
    *c = boot_cpu_data;
    c->cpu_index = id;
    identify_cpu (c);
    print_cpu_info (c);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/smpboot_64.c.ifdefed" startline="156" endline="236">
{
    int cpuid, phys_id;
    unsigned long timeout;
    while (!atomic_read (&init_deasserted))
        cpu_relax ();
    phys_id = GET_APIC_ID (apic_read (APIC_ID));
    cpuid = smp_processor_id ();
    if (cpu_isset (cpuid, cpu_callin_map)) {
        panic ("smp_callin: phys CPU#%d, CPU#%d already present??\n", phys_id, cpuid);
    }
    Dprintk ("CPU#%d (phys ID: %d) waiting for CALLOUT\n", cpuid, phys_id);
    timeout = jiffies + 2 * HZ;
    while (time_before (jiffies, timeout)) {
        if (cpu_isset (cpuid, cpu_callout_map))
            break;
        cpu_relax ();
    }
    if (!time_before (jiffies, timeout)) {
        panic ("smp_callin: CPU%d started up but did not get a callout!\n", cpuid);
    }
    Dprintk ("CALLIN, before setup_local_APIC().\n");
    setup_local_APIC ();
    local_irq_enable ();
    calibrate_delay ();
    local_irq_disable ();
    Dprintk ("Stack at about %p\n", & cpuid);
    smp_store_cpu_info (cpuid);
    cpu_set (cpuid, cpu_callin_map);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/smpboot_64.c.ifdefed" startline="174" endline="177">
{
    panic ("smp_callin: phys CPU#%d, CPU#%d already present??\n", phys_id, cpuid);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/smpboot_64.c.ifdefed" startline="192" endline="199">
{
    if (cpu_isset (cpuid, cpu_callout_map))
        break;
    cpu_relax ();
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/smpboot_64.c.ifdefed" startline="201" endline="204">
{
    panic ("smp_callin: CPU%d started up but did not get a callout!\n", cpuid);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/smpboot_64.c.ifdefed" startline="240" endline="250">
{
    struct cpuinfo_x86 *c = &cpu_data (cpu);
    if (sched_mc_power_savings || sched_smt_power_savings)
        return per_cpu (cpu_core_map, cpu);
    else
        return c->llc_shared_map;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/smpboot_64.c.ifdefed" startline="256" endline="315">
{
    int i;
    struct cpuinfo_x86 *c = &cpu_data (cpu);
    cpu_set (cpu, cpu_sibling_setup_map);
    if (smp_num_siblings > 1) {

        for_each_cpu_mask (i, cpu_sibling_setup_map) {
            if (c->phys_proc_id == cpu_data (i).phys_proc_id && c->cpu_core_id == cpu_data (i).cpu_core_id) {
                cpu_set (i, per_cpu (cpu_sibling_map, cpu));
                cpu_set (cpu, per_cpu (cpu_sibling_map, i));
                cpu_set (i, per_cpu (cpu_core_map, cpu));
                cpu_set (cpu, per_cpu (cpu_core_map, i));
                cpu_set (i, c -> llc_shared_map);
                cpu_set (cpu, cpu_data (i).llc_shared_map);
            }
        }

    }
    else {
        cpu_set (cpu, per_cpu (cpu_sibling_map, cpu));
    }
    cpu_set (cpu, c -> llc_shared_map);
    if (current_cpu_data.x86_max_cores == 1) {
        per_cpu (cpu_core_map, cpu) = per_cpu (cpu_sibling_map, cpu);
        c->booted_cores = 1;
        return;
    }

    for_each_cpu_mask (i, cpu_sibling_setup_map) {
        if (per_cpu (cpu_llc_id, cpu) != BAD_APICID && per_cpu (cpu_llc_id, cpu) == per_cpu (cpu_llc_id, i)) {
            cpu_set (i, c -> llc_shared_map);
            cpu_set (cpu, cpu_data (i).llc_shared_map);
        }
        if (c->phys_proc_id == cpu_data (i).phys_proc_id) {
            cpu_set (i, per_cpu (cpu_core_map, cpu));
            cpu_set (cpu, per_cpu (cpu_core_map, i));
            if (cpus_weight (per_cpu (cpu_sibling_map, cpu)) == 1) {
                if (first_cpu (per_cpu (cpu_sibling_map, i)) == i)
                    c->booted_cores++;
                if (i != cpu)
                    cpu_data (i).booted_cores++;
            }
            else if (i != cpu && !c->booted_cores)
                c->booted_cores = cpu_data (i).booted_cores;
        }
    }

}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/smpboot_64.c.ifdefed" startline="262" endline="274">
{

    for_each_cpu_mask (i, cpu_sibling_setup_map) {
        if (c->phys_proc_id == cpu_data (i).phys_proc_id && c->cpu_core_id == cpu_data (i).cpu_core_id) {
            cpu_set (i, per_cpu (cpu_sibling_map, cpu));
            cpu_set (cpu, per_cpu (cpu_sibling_map, i));
            cpu_set (i, per_cpu (cpu_core_map, cpu));
            cpu_set (cpu, per_cpu (cpu_core_map, i));
            cpu_set (i, c -> llc_shared_map);
            cpu_set (cpu, cpu_data (i).llc_shared_map);
        }
    }

}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/smpboot_64.c.ifdefed" startline="263" endline="273">
{
    if (c->phys_proc_id == cpu_data (i).phys_proc_id && c->cpu_core_id == cpu_data (i).cpu_core_id) {
        cpu_set (i, per_cpu (cpu_sibling_map, cpu));
        cpu_set (cpu, per_cpu (cpu_sibling_map, i));
        cpu_set (i, per_cpu (cpu_core_map, cpu));
        cpu_set (cpu, per_cpu (cpu_core_map, i));
        cpu_set (i, c -> llc_shared_map);
        cpu_set (cpu, cpu_data (i).llc_shared_map);
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/smpboot_64.c.ifdefed" startline="265" endline="272">
{
    cpu_set (i, per_cpu (cpu_sibling_map, cpu));
    cpu_set (cpu, per_cpu (cpu_sibling_map, i));
    cpu_set (i, per_cpu (cpu_core_map, cpu));
    cpu_set (cpu, per_cpu (cpu_core_map, i));
    cpu_set (i, c -> llc_shared_map);
    cpu_set (cpu, cpu_data (i).llc_shared_map);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/smpboot_64.c.ifdefed" startline="274" endline="276">
{
    cpu_set (cpu, per_cpu (cpu_sibling_map, cpu));
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/smpboot_64.c.ifdefed" startline="280" endline="284">
{
    per_cpu (cpu_core_map, cpu) = per_cpu (cpu_sibling_map, cpu);
    c->booted_cores = 1;
    return;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/smpboot_64.c.ifdefed" startline="286" endline="314">
{
    if (per_cpu (cpu_llc_id, cpu) != BAD_APICID && per_cpu (cpu_llc_id, cpu) == per_cpu (cpu_llc_id, i)) {
        cpu_set (i, c -> llc_shared_map);
        cpu_set (cpu, cpu_data (i).llc_shared_map);
    }
    if (c->phys_proc_id == cpu_data (i).phys_proc_id) {
        cpu_set (i, per_cpu (cpu_core_map, cpu));
        cpu_set (cpu, per_cpu (cpu_core_map, i));
        if (cpus_weight (per_cpu (cpu_sibling_map, cpu)) == 1) {
            if (first_cpu (per_cpu (cpu_sibling_map, i)) == i)
                c->booted_cores++;
            if (i != cpu)
                cpu_data (i).booted_cores++;
        }
        else if (i != cpu && !c->booted_cores)
            c->booted_cores = cpu_data (i).booted_cores;
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/smpboot_64.c.ifdefed" startline="288" endline="291">
{
    cpu_set (i, c -> llc_shared_map);
    cpu_set (cpu, cpu_data (i).llc_shared_map);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/smpboot_64.c.ifdefed" startline="292" endline="313">
{
    cpu_set (i, per_cpu (cpu_core_map, cpu));
    cpu_set (cpu, per_cpu (cpu_core_map, i));
    if (cpus_weight (per_cpu (cpu_sibling_map, cpu)) == 1) {
        if (first_cpu (per_cpu (cpu_sibling_map, i)) == i)
            c->booted_cores++;
        if (i != cpu)
            cpu_data (i).booted_cores++;
    }
    else if (i != cpu && !c->booted_cores)
        c->booted_cores = cpu_data (i).booted_cores;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/smpboot_64.c.ifdefed" startline="298" endline="311">
{
    if (first_cpu (per_cpu (cpu_sibling_map, i)) == i)
        c->booted_cores++;
    if (i != cpu)
        cpu_data (i).booted_cores++;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/smpboot_64.c.ifdefed" startline="321" endline="376">
{
    cpu_init ();
    preempt_disable ();
    smp_callin ();
    barrier ();
    check_tsc_sync_target ();
    if (nmi_watchdog == NMI_IO_APIC) {
        disable_8259A_irq (0);
        enable_NMI_through_LVT0 (NULL);
        enable_8259A_irq (0);
    }
    set_cpu_sibling_map (smp_processor_id ());
    lock_ipi_call_lock ();
    spin_lock (& vector_lock);
    __setup_vector_irq (smp_processor_id ());
    cpu_set (smp_processor_id (), cpu_online_map);
    per_cpu (cpu_state, smp_processor_id ()) = CPU_ONLINE;
    spin_unlock (& vector_lock);
    unlock_ipi_call_lock ();
    setup_secondary_APIC_clock ();
    cpu_idle ();
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/smpboot_64.c.ifdefed" startline="339" endline="343">
{
    disable_8259A_irq (0);
    enable_NMI_through_LVT0 (NULL);
    enable_8259A_irq (0);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/smpboot_64.c.ifdefed" startline="426" endline="520">
{
    unsigned long send_status, accept_status = 0;
    int maxlvt, num_starts, j;
    Dprintk ("Asserting INIT.\n");
    apic_write (APIC_ICR2, SET_APIC_DEST_FIELD (phys_apicid));
    apic_write (APIC_ICR, APIC_INT_LEVELTRIG | APIC_INT_ASSERT | APIC_DM_INIT);
    Dprintk ("Waiting for send to finish...\n");
    send_status = safe_apic_wait_icr_idle ();
    mdelay (10);
    Dprintk ("Deasserting INIT.\n");
    apic_write (APIC_ICR2, SET_APIC_DEST_FIELD (phys_apicid));
    apic_write (APIC_ICR, APIC_INT_LEVELTRIG | APIC_DM_INIT);
    Dprintk ("Waiting for send to finish...\n");
    send_status = safe_apic_wait_icr_idle ();
    mb ();
    atomic_set (& init_deasserted, 1);
    num_starts = 2;
    Dprintk ("#startup loops: %d.\n", num_starts);
    maxlvt = get_maxlvt ();
    for (j = 1; j <= num_starts; j++) {
        Dprintk ("Sending STARTUP #%d.\n", j);
        apic_write (APIC_ESR, 0);
        apic_read (APIC_ESR);
        Dprintk ("After apic_write.\n");
        apic_write (APIC_ICR2, SET_APIC_DEST_FIELD (phys_apicid));
        apic_write (APIC_ICR, APIC_DM_STARTUP | (start_rip >> 12));
        udelay (300);
        Dprintk ("Startup point 1.\n");
        Dprintk ("Waiting for send to finish...\n");
        send_status = safe_apic_wait_icr_idle ();
        udelay (200);
        if (maxlvt > 3) {
            apic_write (APIC_ESR, 0);
        }
        accept_status = (apic_read (APIC_ESR) & 0xEF);
        if (send_status || accept_status)
            break;
    }
    Dprintk ("After Startup.\n");
    if (send_status)
        printk (KERN_ERR "APIC never delivered???\n");
    if (accept_status)
        printk (KERN_ERR "APIC delivery error (%lx).\n", accept_status);
    return (send_status | accept_status);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/smpboot_64.c.ifdefed" startline="471" endline="511">
{
    Dprintk ("Sending STARTUP #%d.\n", j);
    apic_write (APIC_ESR, 0);
    apic_read (APIC_ESR);
    Dprintk ("After apic_write.\n");
    apic_write (APIC_ICR2, SET_APIC_DEST_FIELD (phys_apicid));
    apic_write (APIC_ICR, APIC_DM_STARTUP | (start_rip >> 12));
    udelay (300);
    Dprintk ("Startup point 1.\n");
    Dprintk ("Waiting for send to finish...\n");
    send_status = safe_apic_wait_icr_idle ();
    udelay (200);
    if (maxlvt > 3) {
        apic_write (APIC_ESR, 0);
    }
    accept_status = (apic_read (APIC_ESR) & 0xEF);
    if (send_status || accept_status)
        break;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/smpboot_64.c.ifdefed" startline="505" endline="507">
{
    apic_write (APIC_ESR, 0);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/smpboot_64.c.ifdefed" startline="530" endline="536">
{
    struct create_idle *c_idle = container_of (work, struct create_idle, work);
    c_idle->idle = fork_idle (c_idle->cpu);
    complete (& c_idle -> done);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/smpboot_64.c.ifdefed" startline="542" endline="703">
{
    unsigned long boot_error;
    int timeout;
    unsigned long start_rip;
    struct create_idle c_idle = {
        .work = __WORK_INITIALIZER (c_idle.work, do_fork_idle),
        .cpu = cpu,
        .done = COMPLETION_INITIALIZER_ONSTACK (c_idle.done),
    };
    if (!cpu_gdt_descr[cpu].address && !(cpu_gdt_descr[cpu].address = get_zeroed_page (GFP_KERNEL))) {
        printk (KERN_ERR "Failed to allocate GDT for CPU %d\n", cpu);
        return -1;
    }
    if (cpu_pda (cpu) == &boot_cpu_pda[cpu]) {
        struct x8664_pda *newpda, *pda;
        int node = cpu_to_node (cpu);
        pda = cpu_pda (cpu);
        newpda = kmalloc_node (sizeof (struct x8664_pda), GFP_ATOMIC, node);
        if (newpda) {
            memcpy (newpda, pda, sizeof (struct x8664_pda));
            cpu_pda (cpu) = newpda;
        }
        else
            printk (KERN_ERR "Could not allocate node local PDA for CPU %d on node %d\n", cpu, node);
    }
    alternatives_smp_switch (1);
    c_idle.idle = get_idle_for_cpu (cpu);
    if (c_idle.idle) {
        c_idle.idle->thread.rsp = (unsigned long) (((struct pt_regs *) (THREAD_SIZE + task_stack_page (c_idle.idle))) - 1);
        init_idle (c_idle.idle, cpu);
        goto do_rest;
    }
    if (!keventd_up () || current_is_keventd ())
        c_idle.work.func (&c_idle.work);
    else {
        schedule_work (& c_idle.work);
        wait_for_completion (& c_idle.done);
    }
    if (IS_ERR (c_idle.idle)) {
        printk ("failed fork for CPU %d\n", cpu);
        return PTR_ERR (c_idle.idle);
    }
    set_idle_for_cpu (cpu, c_idle.idle);
do_rest :
    cpu_pda (cpu)->pcurrent = c_idle.idle;
    start_rip = setup_trampoline ();
    init_rsp = c_idle.idle->thread.rsp;
    per_cpu (init_tss, cpu).rsp0 = init_rsp;
    initial_code = start_secondary;
    clear_tsk_thread_flag (c_idle.idle, TIF_FORK);
    printk (KERN_INFO "Booting processor %d/%d APIC 0x%x\n", cpu, cpus_weight (cpu_present_map), apicid);
    atomic_set (& init_deasserted, 0);
    Dprintk ("Setting warm reset code and vector.\n");
    CMOS_WRITE (0xa, 0xf);
    local_flush_tlb ();
    Dprintk ("1.\n");
    *((volatile unsigned short *) phys_to_virt (0x469)) = start_rip >> 4;
    Dprintk ("2.\n");
    *((volatile unsigned short *) phys_to_virt (0x467)) = start_rip & 0xf;
    Dprintk ("3.\n");
    apic_write (APIC_ESR, 0);
    apic_read (APIC_ESR);
    boot_error = 0;
    boot_error = wakeup_secondary_via_INIT (apicid, start_rip);
    if (!boot_error) {
        Dprintk ("Before Callout %d.\n", cpu);
        cpu_set (cpu, cpu_callout_map);
        Dprintk ("After Callout %d.\n", cpu);
        for (timeout = 0; timeout < 50000; timeout++) {
            if (cpu_isset (cpu, cpu_callin_map))
                break;
            udelay (100);
        }
        if (cpu_isset (cpu, cpu_callin_map)) {
            Dprintk ("CPU has booted.\n");
        }
        else {
            boot_error = 1;
            if (*((volatile unsigned char *) phys_to_virt (SMP_TRAMPOLINE_BASE)) == 0xA5)
                printk ("Stuck ??\n");
            else
                printk ("Not responding.\n");
        }
    }
    if (boot_error) {
        cpu_clear (cpu, cpu_callout_map);
        clear_bit (cpu, & cpu_initialized);
        clear_node_cpumask (cpu);
        cpu_clear (cpu, cpu_present_map);
        cpu_clear (cpu, cpu_possible_map);
        per_cpu (x86_cpu_to_apicid, cpu) = BAD_APICID;
        return -EIO;
    }
    return 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/smpboot_64.c.ifdefed" startline="554" endline="557">
{
    printk (KERN_ERR "Failed to allocate GDT for CPU %d\n", cpu);
    return -1;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/smpboot_64.c.ifdefed" startline="560" endline="573">
{
    struct x8664_pda *newpda, *pda;
    int node = cpu_to_node (cpu);
    pda = cpu_pda (cpu);
    newpda = kmalloc_node (sizeof (struct x8664_pda), GFP_ATOMIC, node);
    if (newpda) {
        memcpy (newpda, pda, sizeof (struct x8664_pda));
        cpu_pda (cpu) = newpda;
    }
    else
        printk (KERN_ERR "Could not allocate node local PDA for CPU %d on node %d\n", cpu, node);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/smpboot_64.c.ifdefed" startline="566" endline="569">
{
    memcpy (newpda, pda, sizeof (struct x8664_pda));
    cpu_pda (cpu) = newpda;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/smpboot_64.c.ifdefed" startline="579" endline="584">
{
    c_idle.idle->thread.rsp = (unsigned long) (((struct pt_regs *) (THREAD_SIZE + task_stack_page (c_idle.idle))) - 1);
    init_idle (c_idle.idle, cpu);
    goto do_rest;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/smpboot_64.c.ifdefed" startline="598" endline="601">
{
    schedule_work (& c_idle.work);
    wait_for_completion (& c_idle.done);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/smpboot_64.c.ifdefed" startline="603" endline="606">
{
    printk ("failed fork for CPU %d\n", cpu);
    return PTR_ERR (c_idle.idle);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/smpboot_64.c.ifdefed" startline="658" endline="691">
{
    Dprintk ("Before Callout %d.\n", cpu);
    cpu_set (cpu, cpu_callout_map);
    Dprintk ("After Callout %d.\n", cpu);
    for (timeout = 0; timeout < 50000; timeout++) {
        if (cpu_isset (cpu, cpu_callin_map))
            break;
        udelay (100);
    }
    if (cpu_isset (cpu, cpu_callin_map)) {
        Dprintk ("CPU has booted.\n");
    }
    else {
        boot_error = 1;
        if (*((volatile unsigned char *) phys_to_virt (SMP_TRAMPOLINE_BASE)) == 0xA5)
            printk ("Stuck ??\n");
        else
            printk ("Not responding.\n");
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/smpboot_64.c.ifdefed" startline="669" endline="673">
{
    if (cpu_isset (cpu, cpu_callin_map))
        break;
    udelay (100);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/smpboot_64.c.ifdefed" startline="675" endline="678">
{
    Dprintk ("CPU has booted.\n");
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/smpboot_64.c.ifdefed" startline="678" endline="690">
{
    boot_error = 1;
    if (*((volatile unsigned char *) phys_to_virt (SMP_TRAMPOLINE_BASE)) == 0xA5)
        printk ("Stuck ??\n");
    else
        printk ("Not responding.\n");
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/smpboot_64.c.ifdefed" startline="692" endline="700">
{
    cpu_clear (cpu, cpu_callout_map);
    clear_bit (cpu, & cpu_initialized);
    clear_node_cpumask (cpu);
    cpu_clear (cpu, cpu_present_map);
    cpu_clear (cpu, cpu_possible_map);
    per_cpu (x86_cpu_to_apicid, cpu) = BAD_APICID;
    return -EIO;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/smpboot_64.c.ifdefed" startline="712" endline="723">
{
    CMOS_WRITE (0, 0xf);
    *((volatile int *) phys_to_virt (0x467)) = 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/smpboot_64.c.ifdefed" startline="731" endline="740">
{
    cpu_present_map = cpumask_of_cpu (0);
    cpu_possible_map = cpumask_of_cpu (0);
    if (smp_found_config)
        phys_cpu_present_map = physid_mask_of_physid (boot_cpu_id);
    else
        phys_cpu_present_map = physid_mask_of_physid (0);
    cpu_set (0, per_cpu (cpu_sibling_map, 0));
    cpu_set (0, per_cpu (cpu_core_map, 0));
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/smpboot_64.c.ifdefed" startline="791" endline="842">
{
    if (!physid_isset (hard_smp_processor_id (), phys_cpu_present_map)) {
        printk ("weird, boot CPU (#%d) not listed by the BIOS.\n", hard_smp_processor_id ());
        physid_set (hard_smp_processor_id (), phys_cpu_present_map);
    }
    if (!smp_found_config) {
        printk (KERN_NOTICE "SMP motherboard not detected.\n");
        disable_smp ();
        if (APIC_init_uniprocessor ())
            printk (KERN_NOTICE "Local APIC not detected." " Using dummy APIC emulation.\n");
        return -1;
    }
    if (!physid_isset (boot_cpu_id, phys_cpu_present_map)) {
        printk (KERN_NOTICE "weird, boot CPU (#%d) not listed by the BIOS.\n", boot_cpu_id);
        physid_set (hard_smp_processor_id (), phys_cpu_present_map);
    }
    if (!cpu_has_apic) {
        printk (KERN_ERR "BIOS bug, local APIC #%d not detected!...\n", boot_cpu_id);
        printk (KERN_ERR "... forcing use of dummy APIC emulation. (tell your hw vendor)\n");
        nr_ioapics = 0;
        return -1;
    }
    if (!max_cpus) {
        printk (KERN_INFO "SMP mode deactivated, forcing use of dummy APIC emulation.\n");
        nr_ioapics = 0;
        return -1;
    }
    return 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/smpboot_64.c.ifdefed" startline="792" endline="796">
{
    printk ("weird, boot CPU (#%d) not listed by the BIOS.\n", hard_smp_processor_id ());
    physid_set (hard_smp_processor_id (), phys_cpu_present_map);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/smpboot_64.c.ifdefed" startline="802" endline="809">
{
    printk (KERN_NOTICE "SMP motherboard not detected.\n");
    disable_smp ();
    if (APIC_init_uniprocessor ())
        printk (KERN_NOTICE "Local APIC not detected." " Using dummy APIC emulation.\n");
    return -1;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/smpboot_64.c.ifdefed" startline="815" endline="819">
{
    printk (KERN_NOTICE "weird, boot CPU (#%d) not listed by the BIOS.\n", boot_cpu_id);
    physid_set (hard_smp_processor_id (), phys_cpu_present_map);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/smpboot_64.c.ifdefed" startline="824" endline="830">
{
    printk (KERN_ERR "BIOS bug, local APIC #%d not detected!...\n", boot_cpu_id);
    printk (KERN_ERR "... forcing use of dummy APIC emulation. (tell your hw vendor)\n");
    nr_ioapics = 0;
    return -1;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/smpboot_64.c.ifdefed" startline="835" endline="839">
{
    printk (KERN_INFO "SMP mode deactivated, forcing use of dummy APIC emulation.\n");
    nr_ioapics = 0;
    return -1;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/smpboot_64.c.ifdefed" startline="851" endline="862">
{
    int cpu;

    for_each_cpu_mask (cpu, cpu_possible_map) {
        if (per_cpu_offset (cpu))
            per_cpu (x86_cpu_to_apicid, cpu) = x86_cpu_to_apicid_init[cpu];
    }

    x86_cpu_to_apicid_ptr = NULL;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/smpboot_64.c.ifdefed" startline="854" endline="858">
{
    if (per_cpu_offset (cpu))
        per_cpu (x86_cpu_to_apicid, cpu) = x86_cpu_to_apicid_init[cpu];
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/smpboot_64.c.ifdefed" startline="869" endline="907">
{
    nmi_watchdog_default ();
    current_cpu_data = boot_cpu_data;
    current_thread_info ()->cpu = 0;
    smp_set_apicids ();
    set_cpu_sibling_map (0);
    if (smp_sanity_check (max_cpus) < 0) {
        printk (KERN_INFO "SMP disabled\n");
        disable_smp ();
        return;
    }
    setup_local_APIC ();
    if (GET_APIC_ID (apic_read (APIC_ID)) != boot_cpu_id) {
        panic ("Boot APIC ID in local APIC unexpected (%d vs %d)", GET_APIC_ID (apic_read (APIC_ID)), boot_cpu_id);
    }
    if (!skip_ioapic_setup && nr_ioapics)
        setup_IO_APIC ();
    else
        nr_ioapics = 0;
    setup_boot_APIC_clock ();
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/smpboot_64.c.ifdefed" startline="876" endline="880">
{
    printk (KERN_INFO "SMP disabled\n");
    disable_smp ();
    return;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/smpboot_64.c.ifdefed" startline="888" endline="892">
{
    panic ("Boot APIC ID in local APIC unexpected (%d vs %d)", GET_APIC_ID (apic_read (APIC_ID)), boot_cpu_id);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/smpboot_64.c.ifdefed" startline="913" endline="918">
{
    int me = smp_processor_id ();
    cpu_set (me, cpu_online_map);
    cpu_set (me, cpu_callout_map);
    per_cpu (cpu_state, me) = CPU_ONLINE;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/smpboot_64.c.ifdefed" startline="924" endline="976">
{
    int apicid = cpu_present_to_apicid (cpu);
    unsigned long flags;
    int err;
    WARN_ON (irqs_disabled ());
    Dprintk ("++++++++++++++++++++=_---CPU UP  %u\n", cpu);
    if (apicid == BAD_APICID || apicid == boot_cpu_id || !physid_isset (apicid, phys_cpu_present_map)) {
        printk ("__cpu_up: bad cpu %d\n", cpu);
        return -EINVAL;
    }
    if (cpu_isset (cpu, cpu_callin_map)) {
        Dprintk ("do_boot_cpu %d Already started\n", cpu);
        return -ENOSYS;
    }
    mtrr_save_state ();
    per_cpu (cpu_state, cpu) = CPU_UP_PREPARE;
    err = do_boot_cpu (cpu, apicid);
    if (err < 0) {
        Dprintk ("do_boot_cpu failed %d\n", err);
        return err;
    }
    Dprintk ("waiting for cpu %d\n", cpu);
    local_irq_save (flags);
    check_tsc_sync_source (cpu);
    local_irq_restore (flags);
    while (!cpu_isset (cpu, cpu_online_map))
        cpu_relax ();
    err = 0;
    return err;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/smpboot_64.c.ifdefed" startline="934" endline="937">
{
    printk ("__cpu_up: bad cpu %d\n", cpu);
    return -EINVAL;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/smpboot_64.c.ifdefed" startline="942" endline="945">
{
    Dprintk ("do_boot_cpu %d Already started\n", cpu);
    return -ENOSYS;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/smpboot_64.c.ifdefed" startline="956" endline="959">
{
    Dprintk ("do_boot_cpu failed %d\n", err);
    return err;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/smpboot_64.c.ifdefed" startline="982" endline="986">
{
    smp_cleanup_boot ();
    setup_ioapic_dest ();
    check_nmi_watchdog ();
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/smpboot_64.c.ifdefed" startline="1090" endline="1092">
{
    return -ENOSYS;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/smpboot_64.c.ifdefed" startline="1095" endline="1098">
{
    BUG ();
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/reboot_64.c.ifdefed" startline="45" endline="71">
{
    for (;;) {
        switch (*str) {
        case 'w' :
            reboot_mode = 0x1234;
            break;
        case 'c' :
            reboot_mode = 0;
            break;
        case 't' :
        case 'b' :
        case 'k' :
            reboot_type = *str;
            break;
        case 'f' :
            reboot_force = 1;
            break;
        }
        if ((str = strchr (str, ',')) != NULL)
            str++;
        else
            break;
    }
    return 1;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/reboot_64.c.ifdefed" startline="46" endline="69">
{
    switch (*str) {
    case 'w' :
        reboot_mode = 0x1234;
        break;
    case 'c' :
        reboot_mode = 0;
        break;
    case 't' :
    case 'b' :
    case 'k' :
        reboot_type = *str;
        break;
    case 'f' :
        reboot_force = 1;
        break;
    }
    if ((str = strchr (str, ',')) != NULL)
        str++;
    else
        break;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/reboot_64.c.ifdefed" startline="47" endline="64">
{
case 'w' :
    reboot_mode = 0x1234;
    break;
case 'c' :
    reboot_mode = 0;
    break;
case 't' :
case 'b' :
case 'k' :
    reboot_type = *str;
    break;
case 'f' :
    reboot_force = 1;
    break;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/reboot_64.c.ifdefed" startline="76" endline="82">
{
    int i;
    for (i = 0; i < 0x10000; i++)
        if ((inb_p (0x64) & 0x02) == 0)
            break;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/reboot_64.c.ifdefed" startline="85" endline="123">
{
    unsigned long flags;
    local_irq_save (flags);
    disable_local_APIC ();
    disable_IO_APIC ();
    local_irq_restore (flags);
    pci_iommu_shutdown ();
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/reboot_64.c.ifdefed" startline="126" endline="151">
{
    int i;
    *((unsigned short *) __va (0x472)) = reboot_mode;
    for (;;) {
        switch (reboot_type) {
        case BOOT_KBD :
            for (i = 0; i < 10; i++) {
                kb_wait ();
                udelay (50);
                outb (0xfe, 0x64);
                udelay (50);
            }
        case BOOT_TRIPLE :
            load_idt ((const struct desc_ptr *) &no_idt);
            __asm__ __volatile__ ("int3");
            reboot_type = BOOT_KBD;
            break;
        }
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/reboot_64.c.ifdefed" startline="132" endline="150">
{
    switch (reboot_type) {
    case BOOT_KBD :
        for (i = 0; i < 10; i++) {
            kb_wait ();
            udelay (50);
            outb (0xfe, 0x64);
            udelay (50);
        }
    case BOOT_TRIPLE :
        load_idt ((const struct desc_ptr *) &no_idt);
        __asm__ __volatile__ ("int3");
        reboot_type = BOOT_KBD;
        break;
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/reboot_64.c.ifdefed" startline="134" endline="149">
{
case BOOT_KBD :
    for (i = 0; i < 10; i++) {
        kb_wait ();
        udelay (50);
        outb (0xfe, 0x64);
        udelay (50);
    }
case BOOT_TRIPLE :
    load_idt ((const struct desc_ptr *) &no_idt);
    __asm__ __volatile__ ("int3");
    reboot_type = BOOT_KBD;
    break;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/reboot_64.c.ifdefed" startline="136" endline="141">
{
    kb_wait ();
    udelay (50);
    outb (0xfe, 0x64);
    udelay (50);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/reboot_64.c.ifdefed" startline="154" endline="161">
{
    printk ("machine restart\n");
    if (!reboot_force) {
        machine_shutdown ();
    }
    machine_emergency_restart ();
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/reboot_64.c.ifdefed" startline="157" endline="159">
{
    machine_shutdown ();
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/reboot_64.c.ifdefed" startline="164" endline="165">
{
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/reboot_64.c.ifdefed" startline="168" endline="175">
{
    if (pm_power_off) {
        if (!reboot_force) {
            machine_shutdown ();
        }
        pm_power_off ();
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/reboot_64.c.ifdefed" startline="169" endline="174">
{
    if (!reboot_force) {
        machine_shutdown ();
    }
    pm_power_off ();
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/reboot_64.c.ifdefed" startline="170" endline="172">
{
    machine_shutdown ();
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/pci-nommu_64.c.ifdefed" startline="16" endline="26">
{
    if (hwdev && bus + size > *hwdev->dma_mask) {
        if (*hwdev->dma_mask >= DMA_32BIT_MASK)
            printk (KERN_ERR "nommu_%s: overflow %Lx+%zu of device mask %Lx\n", name, (long long) bus, size, (long long) *hwdev->dma_mask);
        return 0;
    }
    return 1;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/pci-nommu_64.c.ifdefed" startline="17" endline="24">
{
    if (*hwdev->dma_mask >= DMA_32BIT_MASK)
        printk (KERN_ERR "nommu_%s: overflow %Lx+%zu of device mask %Lx\n", name, (long long) bus, size, (long long) *hwdev->dma_mask);
    return 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/pci-nommu_64.c.ifdefed" startline="31" endline="36">
{
    dma_addr_t bus = virt_to_bus (ptr);
    if (!check_addr ("map_single", hwdev, bus, size))
        return bad_dma_address;
    return bus;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/pci-nommu_64.c.ifdefed" startline="40" endline="41">
{
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/pci-nommu_64.c.ifdefed" startline="60" endline="72">
{
    struct scatterlist *s;
    int i;

    for_each_sg (sg, s, nents, i) {
        BUG_ON (! sg_page (s));
        s->dma_address = virt_to_bus (sg_virt (s));
        if (!check_addr ("map_sg", hwdev, s->dma_address, s->length))
            return 0;
        s->dma_length = s->length;
    }

    return nents;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/pci-nommu_64.c.ifdefed" startline="64" endline="70">
{
    BUG_ON (! sg_page (s));
    s->dma_address = virt_to_bus (sg_virt (s));
    if (!check_addr ("map_sg", hwdev, s->dma_address, s->length))
        return 0;
    s->dma_length = s->length;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/pci-nommu_64.c.ifdefed" startline="80" endline="81">
{
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/pci-nommu_64.c.ifdefed" startline="92" endline="98">
{
    if (dma_ops)
        return;
    force_iommu = 0;
    dma_ops = &nommu_dma_ops;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpuid.c.ifdefed" startline="52" endline="57">
{
    struct cpuid_command *cmd = (struct cpuid_command *) cmd_block;
    cpuid (cmd -> reg, & cmd -> data [0], & cmd -> data [1], & cmd -> data [2], & cmd -> data [3]);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpuid.c.ifdefed" startline="60" endline="67">
{
    struct cpuid_command cmd;
    cmd.reg = reg;
    cmd.data = data;
    smp_call_function_single (cpu, cpuid_smp_cpuid, & cmd, 1, 1);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpuid.c.ifdefed" startline="70" endline="90">
{
    loff_t ret;
    lock_kernel ();
    switch (orig) {
    case 0 :
        file->f_pos = offset;
        ret = file->f_pos;
        break;
    case 1 :
        file->f_pos += offset;
        ret = file->f_pos;
        break;
    default :
        ret = -EINVAL;
    }
    unlock_kernel ();
    return ret;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpuid.c.ifdefed" startline="75" endline="86">
{
case 0 :
    file->f_pos = offset;
    ret = file->f_pos;
    break;
case 1 :
    file->f_pos += offset;
    ret = file->f_pos;
    break;
default :
    ret = -EINVAL;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpuid.c.ifdefed" startline="94" endline="112">
{
    char __user *tmp = buf;
    u32 data [4];
    u32 reg = *ppos;
    int cpu = iminor (file->f_path.dentry->d_inode);
    if (count % 16)
        return -EINVAL;
    for (; count; count -= 16) {
        do_cpuid (cpu, reg, data);
        if (copy_to_user (tmp, &data, 16))
            return -EFAULT;
        tmp += 16;
        *ppos = reg++;
    }
    return tmp - buf;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpuid.c.ifdefed" startline="103" endline="109">
{
    do_cpuid (cpu, reg, data);
    if (copy_to_user (tmp, &data, 16))
        return -EFAULT;
    tmp += 16;
    *ppos = reg++;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpuid.c.ifdefed" startline="115" endline="125">
{
    unsigned int cpu = iminor (file->f_path.dentry->d_inode);
    struct cpuinfo_x86 *c = &cpu_data (cpu);
    if (cpu >= NR_CPUS || !cpu_online (cpu))
        return -ENXIO;
    if (c->cpuid_level < 0)
        return -EIO;
    return 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpuid.c.ifdefed" startline="138" endline="144">
{
    struct device *dev;
    dev = device_create (cpuid_class, NULL, MKDEV (CPUID_MAJOR, cpu), "cpu%d", cpu);
    return IS_ERR (dev) ? PTR_ERR (dev) : 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpuid.c.ifdefed" startline="147" endline="149">
{
    device_destroy (cpuid_class, MKDEV (CPUID_MAJOR, cpu));
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpuid.c.ifdefed" startline="154" endline="171">
{
    unsigned int cpu = (unsigned long) hcpu;
    int err = 0;
    switch (action) {
    case CPU_UP_PREPARE :
    case CPU_UP_PREPARE_FROZEN :
        err = cpuid_device_create (cpu);
        break;
    case CPU_UP_CANCELED :
    case CPU_UP_CANCELED_FROZEN :
    case CPU_DEAD :
    case CPU_DEAD_FROZEN :
        cpuid_device_destroy (cpu);
        break;
    }
    return err ? NOTIFY_BAD : NOTIFY_OK;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpuid.c.ifdefed" startline="158" endline="169">
{
case CPU_UP_PREPARE :
case CPU_UP_PREPARE_FROZEN :
    err = cpuid_device_create (cpu);
    break;
case CPU_UP_CANCELED :
case CPU_UP_CANCELED_FROZEN :
case CPU_DEAD :
case CPU_DEAD_FROZEN :
    cpuid_device_destroy (cpu);
    break;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpuid.c.ifdefed" startline="179" endline="214">
{
    int i, err = 0;
    i = 0;
    if (register_chrdev (CPUID_MAJOR, "cpu/cpuid", &cpuid_fops)) {
        printk (KERN_ERR "cpuid: unable to get major %d for cpuid\n", CPUID_MAJOR);
        err = -EBUSY;
        goto out;
    }
    cpuid_class = class_create (THIS_MODULE, "cpuid");
    if (IS_ERR (cpuid_class)) {
        err = PTR_ERR (cpuid_class);
        goto out_chrdev;
    }

    for_each_online_cpu (i) {
        err = cpuid_device_create (i);
        if (err != 0)
            goto out_class;
    }

    register_hotcpu_notifier (& cpuid_class_cpu_notifier);
    err = 0;
    goto out;
out_class :
    i = 0;

    for_each_online_cpu (i) {
        cpuid_device_destroy (i);
    }

    class_destroy (cpuid_class);
out_chrdev :
    unregister_chrdev (CPUID_MAJOR, "cpu/cpuid");
out :
    return err;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpuid.c.ifdefed" startline="183" endline="188">
{
    printk (KERN_ERR "cpuid: unable to get major %d for cpuid\n", CPUID_MAJOR);
    err = -EBUSY;
    goto out;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpuid.c.ifdefed" startline="190" endline="193">
{
    err = PTR_ERR (cpuid_class);
    goto out_chrdev;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpuid.c.ifdefed" startline="194" endline="198">
{
    err = cpuid_device_create (i);
    if (err != 0)
        goto out_class;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpuid.c.ifdefed" startline="206" endline="208">
{
    cpuid_device_destroy (i);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpuid.c.ifdefed" startline="217" endline="225">
{
    int cpu = 0;
    for_each_online_cpu (cpu)
    cpuid_device_destroy (cpu);
    class_destroy (cpuid_class);
    unregister_chrdev (CPUID_MAJOR, "cpu/cpuid");
    unregister_hotcpu_notifier (& cpuid_class_cpu_notifier);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/alternative.c.ifdefed" startline="33" endline="36">
{
    debug_alternative = 1;
    return 1;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/alternative.c.ifdefed" startline="42" endline="45">
{
    noreplace_smp = 1;
    return 1;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/alternative.c.ifdefed" startline="160" endline="171">
{
    const unsigned char * const *noptable = intel_nops;
    int i;
    for (i = 0; noptypes[i].cpuid >= 0; i++) {
        if (boot_cpu_has (noptypes[i].cpuid)) {
            noptable = noptypes[i].noptable;
            break;
        }
    }
    return noptable;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/alternative.c.ifdefed" startline="164" endline="169">
{
    if (boot_cpu_has (noptypes[i].cpuid)) {
        noptable = noptypes[i].noptable;
        break;
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/alternative.c.ifdefed" startline="165" endline="168">
{
    noptable = noptypes[i].noptable;
    break;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/alternative.c.ifdefed" startline="177" endline="188">
{
    const unsigned char * const *noptable = find_nop_table ();
    while (len > 0) {
        unsigned int noplen = len;
        if (noplen > ASM_NOP_MAX)
            noplen = ASM_NOP_MAX;
        memcpy (insns, noptable [noplen], noplen);
        insns += noplen;
        len -= noplen;
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/alternative.c.ifdefed" startline="180" endline="187">
{
    unsigned int noplen = len;
    if (noplen > ASM_NOP_MAX)
        noplen = ASM_NOP_MAX;
    memcpy (insns, noptable [noplen], noplen);
    insns += noplen;
    len -= noplen;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/alternative.c.ifdefed" startline="200" endline="224">
{
    struct alt_instr *a;
    char insnbuf [MAX_PATCH_LEN];
    DPRINTK ("%s: alt table %p -> %p\n", __FUNCTION__, start, end);
    for (a = start; a < end; a++) {
        u8 *instr = a->instr;
        BUG_ON (a -> replacementlen > a -> instrlen);
        BUG_ON (a -> instrlen > sizeof (insnbuf));
        if (!boot_cpu_has (a->cpuid))
            continue;
        memcpy (insnbuf, a -> replacement, a -> replacementlen);
        add_nops (insnbuf + a -> replacementlen, a -> instrlen - a -> replacementlen);
        text_poke (instr, insnbuf, a -> instrlen);
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/alternative.c.ifdefed" startline="205" endline="223">
{
    u8 *instr = a->instr;
    BUG_ON (a -> replacementlen > a -> instrlen);
    BUG_ON (a -> instrlen > sizeof (insnbuf));
    if (!boot_cpu_has (a->cpuid))
        continue;
    memcpy (insnbuf, a -> replacement, a -> replacementlen);
    add_nops (insnbuf + a -> replacementlen, a -> instrlen - a -> replacementlen);
    text_poke (instr, insnbuf, a -> instrlen);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/alternative.c.ifdefed" startline="408" endline="458">
{
    unsigned long flags;
    stop_nmi ();
    local_irq_save (flags);
    apply_alternatives (__alt_instructions, __alt_instructions_end);
    apply_paravirt (__parainstructions, __parainstructions_end);
    local_irq_restore (flags);
    if (smp_alt_once)
        free_init_pages ("SMP alternatives", (unsigned long) __smp_locks, (unsigned long) __smp_locks_end);
    restart_nmi ();
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/alternative.c.ifdefed" startline="469" endline="474">
{
    memcpy (addr, opcode, len);
    sync_core ();
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/bugs_64.c.ifdefed" startline="14" endline="22">
{
    identify_cpu (& boot_cpu_data);
    mtrr_bp_init ();
    alternative_instructions ();
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/i8253.c.ifdefed" startline="33" endline="66">
{
    unsigned long flags;
    spin_lock_irqsave (& i8253_lock, flags);
    switch (mode) {
    case CLOCK_EVT_MODE_PERIODIC :
        outb_p (0x34, PIT_MODE);
        outb_p (LATCH & 0xff, PIT_CH0);
        outb (LATCH >> 8, PIT_CH0);
        break;
    case CLOCK_EVT_MODE_SHUTDOWN :
    case CLOCK_EVT_MODE_UNUSED :
        if (evt->mode == CLOCK_EVT_MODE_PERIODIC || evt->mode == CLOCK_EVT_MODE_ONESHOT) {
            outb_p (0x30, PIT_MODE);
            outb_p (0, PIT_CH0);
            outb_p (0, PIT_CH0);
        }
        break;
    case CLOCK_EVT_MODE_ONESHOT :
        outb_p (0x38, PIT_MODE);
        break;
    case CLOCK_EVT_MODE_RESUME :
        break;
    }
    spin_unlock_irqrestore (& i8253_lock, flags);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/i8253.c.ifdefed" startline="38" endline="64">
{
case CLOCK_EVT_MODE_PERIODIC :
    outb_p (0x34, PIT_MODE);
    outb_p (LATCH & 0xff, PIT_CH0);
    outb (LATCH >> 8, PIT_CH0);
    break;
case CLOCK_EVT_MODE_SHUTDOWN :
case CLOCK_EVT_MODE_UNUSED :
    if (evt->mode == CLOCK_EVT_MODE_PERIODIC || evt->mode == CLOCK_EVT_MODE_ONESHOT) {
        outb_p (0x30, PIT_MODE);
        outb_p (0, PIT_CH0);
        outb_p (0, PIT_CH0);
    }
    break;
case CLOCK_EVT_MODE_ONESHOT :
    outb_p (0x38, PIT_MODE);
    break;
case CLOCK_EVT_MODE_RESUME :
    break;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/i8253.c.ifdefed" startline="49" endline="53">
{
    outb_p (0x30, PIT_MODE);
    outb_p (0, PIT_CH0);
    outb_p (0, PIT_CH0);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/i8253.c.ifdefed" startline="74" endline="83">
{
    unsigned long flags;
    spin_lock_irqsave (& i8253_lock, flags);
    outb_p (delta & 0xff, PIT_CH0);
    outb (delta >> 8, PIT_CH0);
    spin_unlock_irqrestore (& i8253_lock, flags);
    return 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/i8253.c.ifdefed" startline="107" endline="120">
{
    pit_clockevent.cpumask = cpumask_of_cpu (smp_processor_id ());
    pit_clockevent.mult = div_sc (CLOCK_TICK_RATE, NSEC_PER_SEC, 32);
    pit_clockevent.max_delta_ns = clockevent_delta2ns (0x7FFF, &pit_clockevent);
    pit_clockevent.min_delta_ns = clockevent_delta2ns (0xF, &pit_clockevent);
    clockevents_register_device (& pit_clockevent);
    global_clock_event = &pit_clockevent;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/i8253.c.ifdefed" startline="129" endline="187">
{
    unsigned long flags;
    int count;
    u32 jifs;
    static int old_count;
    static u32 old_jifs;
    spin_lock_irqsave (& i8253_lock, flags);
    jifs = jiffies;
    outb_p (0x00, PIT_MODE);
    count = inb_p (PIT_CH0);
    count |= inb_p (PIT_CH0) << 8;
    if (count > LATCH) {
        outb_p (0x34, PIT_MODE);
        outb_p (LATCH & 0xff, PIT_CH0);
        outb (LATCH >> 8, PIT_CH0);
        count = LATCH - 1;
    }
    if (count > old_count && jifs == old_jifs) {
        count = old_count;
    }
    old_count = count;
    old_jifs = jifs;
    spin_unlock_irqrestore (& i8253_lock, flags);
    count = (LATCH - 1) - count;
    return (cycle_t) (jifs * LATCH) +count;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/i8253.c.ifdefed" startline="156" endline="161">
{
    outb_p (0x34, PIT_MODE);
    outb_p (LATCH & 0xff, PIT_CH0);
    outb (LATCH >> 8, PIT_CH0);
    count = LATCH - 1;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/i8253.c.ifdefed" startline="176" endline="178">
{
    count = old_count;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/i8253.c.ifdefed" startline="199" endline="205">
{
    if (num_possible_cpus () > 1)
        return 0;
    clocksource_pit.mult = clocksource_hz2mult (CLOCK_TICK_RATE, 20);
    return clocksource_register (&clocksource_pit);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/kprobes_64.c.ifdefed" startline="62" endline="74">
{
    switch (*insn) {
    case 0xfa :
    case 0xfb :
    case 0xcf :
    case 0x9d :
        return 1;
    }
    if (*insn >= 0x40 && *insn <= 0x4f && *++insn == 0xcf)
        return 1;
    return 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/kprobes_64.c.ifdefed" startline="63" endline="69">
{
case 0xfa :
case 0xfb :
case 0xcf :
case 0x9d :
    return 1;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/kprobes_64.c.ifdefed" startline="77" endline="85">
{
    p->ainsn.insn = get_insn_slot ();
    if (!p->ainsn.insn) {
        return -ENOMEM;
    }
    arch_copy_kprobe (p);
    return 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/kprobes_64.c.ifdefed" startline="80" endline="82">
{
    return -ENOMEM;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/kprobes_64.c.ifdefed" startline="93" endline="188">
{
    static const u64 onebyte_has_modrm [256 / 64] = {W (0x00, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0) | W (0x10, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0) | W (0x20, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0) | W (0x30, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0), W (0x40, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0) | W (0x50, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0) | W (0x60, 0, 0, 1, 1, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0) | W (0x70, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0), W (0x80, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1) | W (0x90, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0) | W (0xa0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0) | W (0xb0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0), W (0xc0, 1, 1, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0) | W (0xd0, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1) | W (0xe0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0) | W (0xf0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1)};
    static const u64 twobyte_has_modrm [256 / 64] = {W (0x00, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1) | W (0x10, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0) | W (0x20, 1, 1, 1, 1, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1) | W (0x30, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0), W (0x40, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1) | W (0x50, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1) | W (0x60, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1) | W (0x70, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 1, 1, 1, 1), W (0x80, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0) | W (0x90, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1) | W (0xa0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1, 1, 1, 1) | W (0xb0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 1, 1), W (0xc0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0) | W (0xd0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1) | W (0xe0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1) | W (0xf0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0)};
    int need_modrm;
    while (1) {
        switch (*insn) {
        case 0x66 :
        case 0x67 :
        case 0x2e :
        case 0x3e :
        case 0x26 :
        case 0x64 :
        case 0x65 :
        case 0x36 :
        case 0xf0 :
        case 0xf3 :
        case 0xf2 :
            ++insn;
            continue;
        }
        break;
    }
    if ((*insn & 0xf0) == 0x40)
        ++insn;
    if (*insn == 0x0f) {
        ++insn;
        need_modrm = test_bit (*insn, twobyte_has_modrm);
    }
    else {
        need_modrm = test_bit (*insn, onebyte_has_modrm);
    }
    if (need_modrm) {
        u8 modrm = *++insn;
        if ((modrm & 0xc7) == 0x05) {
            return (s32 *) ++insn;
        }
    }
    return NULL;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/kprobes_64.c.ifdefed" startline="148" endline="165">
{
    switch (*insn) {
    case 0x66 :
    case 0x67 :
    case 0x2e :
    case 0x3e :
    case 0x26 :
    case 0x64 :
    case 0x65 :
    case 0x36 :
    case 0xf0 :
    case 0xf3 :
    case 0xf2 :
        ++insn;
        continue;
    }
    break;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/kprobes_64.c.ifdefed" startline="149" endline="163">
{
case 0x66 :
case 0x67 :
case 0x2e :
case 0x3e :
case 0x26 :
case 0x64 :
case 0x65 :
case 0x36 :
case 0xf0 :
case 0xf3 :
case 0xf2 :
    ++insn;
    continue;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/kprobes_64.c.ifdefed" startline="171" endline="174">
{
    ++insn;
    need_modrm = test_bit (*insn, twobyte_has_modrm);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/kprobes_64.c.ifdefed" startline="174" endline="176">
{
    need_modrm = test_bit (*insn, onebyte_has_modrm);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/kprobes_64.c.ifdefed" startline="178" endline="184">
{
    u8 modrm = *++insn;
    if ((modrm & 0xc7) == 0x05) {
        return (s32 *) ++insn;
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/kprobes_64.c.ifdefed" startline="180" endline="183">
{
    return (s32 *) ++insn;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/kprobes_64.c.ifdefed" startline="191" endline="214">
{
    s32 *ripdisp;
    memcpy (p -> ainsn.insn, p -> addr, MAX_INSN_SIZE);
    ripdisp = is_riprel (p->ainsn.insn);
    if (ripdisp) {
        s64 disp = (u8 *) p->addr + *ripdisp - (u8 *) p->ainsn.insn;
        BUG_ON ((s64) (s32) disp != disp);
        *ripdisp = disp;
    }
    p->opcode = *p->addr;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/kprobes_64.c.ifdefed" startline="195" endline="212">
{
    s64 disp = (u8 *) p->addr + *ripdisp - (u8 *) p->ainsn.insn;
    BUG_ON ((s64) (s32) disp != disp);
    *ripdisp = disp;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/kprobes_64.c.ifdefed" startline="217" endline="219">
{
    text_poke (p -> addr, ((unsigned char []) {BREAKPOINT_INSTRUCTION}), 1);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/kprobes_64.c.ifdefed" startline="222" endline="224">
{
    text_poke (p -> addr, & p -> opcode, 1);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/kprobes_64.c.ifdefed" startline="227" endline="231">
{
    mutex_lock (& kprobe_mutex);
    free_insn_slot (p -> ainsn.insn, 0);
    mutex_unlock (& kprobe_mutex);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/kprobes_64.c.ifdefed" startline="234" endline="239">
{
    kcb->prev_kprobe.kp = kprobe_running ();
    kcb->prev_kprobe.status = kcb->kprobe_status;
    kcb->prev_kprobe.old_rflags = kcb->kprobe_old_rflags;
    kcb->prev_kprobe.saved_rflags = kcb->kprobe_saved_rflags;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/kprobes_64.c.ifdefed" startline="242" endline="247">
{
    __get_cpu_var (current_kprobe) = kcb->prev_kprobe.kp;
    kcb->kprobe_status = kcb->prev_kprobe.status;
    kcb->kprobe_old_rflags = kcb->prev_kprobe.old_rflags;
    kcb->kprobe_saved_rflags = kcb->prev_kprobe.saved_rflags;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/kprobes_64.c.ifdefed" startline="251" endline="257">
{
    __get_cpu_var (current_kprobe) = p;
    kcb->kprobe_saved_rflags = kcb->kprobe_old_rflags = (regs->eflags & (TF_MASK | IF_MASK));
    if (is_IF_modifier (p->ainsn.insn))
        kcb->kprobe_saved_rflags &= ~IF_MASK;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/kprobes_64.c.ifdefed" startline="260" endline="268">
{
    regs->eflags |= TF_MASK;
    regs->eflags &= ~IF_MASK;
    if (p->opcode == BREAKPOINT_INSTRUCTION)
        regs->rip = (unsigned long) p->addr;
    else
        regs->rip = (unsigned long) p->ainsn.insn;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/kprobes_64.c.ifdefed" startline="273" endline="279">
{
    unsigned long *sara = (unsigned long *) regs->rsp;
    ri->ret_addr = (kprobe_opcode_t *) *sara;
    *sara = (unsigned long) &kretprobe_trampoline;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/kprobes_64.c.ifdefed" startline="282" endline="381">
{
    struct kprobe *p;
    int ret = 0;
    kprobe_opcode_t *addr = (kprobe_opcode_t *) (regs->rip - sizeof (kprobe_opcode_t));
    struct kprobe_ctlblk *kcb;
    preempt_disable ();
    kcb = get_kprobe_ctlblk ();
    if (kprobe_running ()) {
        p = get_kprobe (addr);
        if (p) {
            if (kcb->kprobe_status == KPROBE_HIT_SS && *p->ainsn.insn == BREAKPOINT_INSTRUCTION) {
                regs->eflags &= ~TF_MASK;
                regs->eflags |= kcb->kprobe_saved_rflags;
                goto no_kprobe;
            }
            else if (kcb->kprobe_status == KPROBE_HIT_SSDONE) {
                arch_disarm_kprobe (p);
                regs->rip = (unsigned long) p->addr;
                reset_current_kprobe ();
                ret = 1;
            }
            else {
                save_previous_kprobe (kcb);
                set_current_kprobe (p, regs, kcb);
                kprobes_inc_nmissed_count (p);
                prepare_singlestep (p, regs);
                kcb->kprobe_status = KPROBE_REENTER;
                return 1;
            }
        }
        else {
            if (*addr != BREAKPOINT_INSTRUCTION) {
                regs->rip = (unsigned long) addr;
                ret = 1;
                goto no_kprobe;
            }
            p = __get_cpu_var (current_kprobe);
            if (p->break_handler && p->break_handler (p, regs)) {
                goto ss_probe;
            }
        }
        goto no_kprobe;
    }
    p = get_kprobe (addr);
    if (!p) {
        if (*addr != BREAKPOINT_INSTRUCTION) {
            regs->rip = (unsigned long) addr;
            ret = 1;
        }
        goto no_kprobe;
    }
    set_current_kprobe (p, regs, kcb);
    kcb->kprobe_status = KPROBE_HIT_ACTIVE;
    if (p->pre_handler && p->pre_handler (p, regs))
        return 1;
ss_probe :
    prepare_singlestep (p, regs);
    kcb->kprobe_status = KPROBE_HIT_SS;
    return 1;
no_kprobe :
    preempt_enable_no_resched ();
    return ret;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/kprobes_64.c.ifdefed" startline="296" endline="345">
{
    p = get_kprobe (addr);
    if (p) {
        if (kcb->kprobe_status == KPROBE_HIT_SS && *p->ainsn.insn == BREAKPOINT_INSTRUCTION) {
            regs->eflags &= ~TF_MASK;
            regs->eflags |= kcb->kprobe_saved_rflags;
            goto no_kprobe;
        }
        else if (kcb->kprobe_status == KPROBE_HIT_SSDONE) {
            arch_disarm_kprobe (p);
            regs->rip = (unsigned long) p->addr;
            reset_current_kprobe ();
            ret = 1;
        }
        else {
            save_previous_kprobe (kcb);
            set_current_kprobe (p, regs, kcb);
            kprobes_inc_nmissed_count (p);
            prepare_singlestep (p, regs);
            kcb->kprobe_status = KPROBE_REENTER;
            return 1;
        }
    }
    else {
        if (*addr != BREAKPOINT_INSTRUCTION) {
            regs->rip = (unsigned long) addr;
            ret = 1;
            goto no_kprobe;
        }
        p = __get_cpu_var (current_kprobe);
        if (p->break_handler && p->break_handler (p, regs)) {
            goto ss_probe;
        }
    }
    goto no_kprobe;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/kprobes_64.c.ifdefed" startline="298" endline="329">
{
    if (kcb->kprobe_status == KPROBE_HIT_SS && *p->ainsn.insn == BREAKPOINT_INSTRUCTION) {
        regs->eflags &= ~TF_MASK;
        regs->eflags |= kcb->kprobe_saved_rflags;
        goto no_kprobe;
    }
    else if (kcb->kprobe_status == KPROBE_HIT_SSDONE) {
        arch_disarm_kprobe (p);
        regs->rip = (unsigned long) p->addr;
        reset_current_kprobe ();
        ret = 1;
    }
    else {
        save_previous_kprobe (kcb);
        set_current_kprobe (p, regs, kcb);
        kprobes_inc_nmissed_count (p);
        prepare_singlestep (p, regs);
        kcb->kprobe_status = KPROBE_REENTER;
        return 1;
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/kprobes_64.c.ifdefed" startline="300" endline="304">
{
    regs->eflags &= ~TF_MASK;
    regs->eflags |= kcb->kprobe_saved_rflags;
    goto no_kprobe;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/kprobes_64.c.ifdefed" startline="304" endline="314">
{
    arch_disarm_kprobe (p);
    regs->rip = (unsigned long) p->addr;
    reset_current_kprobe ();
    ret = 1;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/kprobes_64.c.ifdefed" startline="314" endline="328">
{
    save_previous_kprobe (kcb);
    set_current_kprobe (p, regs, kcb);
    kprobes_inc_nmissed_count (p);
    prepare_singlestep (p, regs);
    kcb->kprobe_status = KPROBE_REENTER;
    return 1;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/kprobes_64.c.ifdefed" startline="329" endline="343">
{
    if (*addr != BREAKPOINT_INSTRUCTION) {
        regs->rip = (unsigned long) addr;
        ret = 1;
        goto no_kprobe;
    }
    p = __get_cpu_var (current_kprobe);
    if (p->break_handler && p->break_handler (p, regs)) {
        goto ss_probe;
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/kprobes_64.c.ifdefed" startline="330" endline="338">
{
    regs->rip = (unsigned long) addr;
    ret = 1;
    goto no_kprobe;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/kprobes_64.c.ifdefed" startline="340" endline="342">
{
    goto ss_probe;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/kprobes_64.c.ifdefed" startline="348" endline="364">
{
    if (*addr != BREAKPOINT_INSTRUCTION) {
        regs->rip = (unsigned long) addr;
        ret = 1;
    }
    goto no_kprobe;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/kprobes_64.c.ifdefed" startline="349" endline="361">
{
    regs->rip = (unsigned long) addr;
    ret = 1;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/kprobes_64.c.ifdefed" startline="389" endline="393">
{
    asm volatile (".global kretprobe_trampoline\n"
        "kretprobe_trampoline: \n"
        "nop\n"
    )}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/kprobes_64.c.ifdefed" startline="399" endline="460">
{
    struct kretprobe_instance *ri = NULL;
    struct hlist_head *head, empty_rp;
    struct hlist_node *node, *tmp;
    unsigned long flags, orig_ret_address = 0;
    unsigned long trampoline_address = (unsigned long) &kretprobe_trampoline;
    INIT_HLIST_HEAD (& empty_rp);
    spin_lock_irqsave (& kretprobe_lock, flags);
    head = kretprobe_inst_table_head (current);
    hlist_for_each_entry_safe (ri, node, tmp, head, hlist) {
        if (ri->task != current)
            continue;
        if (ri->rp && ri->rp->handler)
            ri->rp->handler (ri, regs);
        orig_ret_address = (unsigned long) ri->ret_addr;
        recycle_rp_inst (ri, & empty_rp);
        if (orig_ret_address != trampoline_address)
            break;
    }
    kretprobe_assert (ri, orig_ret_address, trampoline_address);
    regs->rip = orig_ret_address;
    reset_current_kprobe ();
    spin_unlock_irqrestore (& kretprobe_lock, flags);
    preempt_enable_no_resched ();
    hlist_for_each_entry_safe (ri, node, tmp, &empty_rp, hlist) {
        hlist_del (& ri -> hlist);
        kfree (ri);
    }
    return 1;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/kprobes_64.c.ifdefed" startline="423" endline="441">
{
    if (ri->task != current)
        continue;
    if (ri->rp && ri->rp->handler)
        ri->rp->handler (ri, regs);
    orig_ret_address = (unsigned long) ri->ret_addr;
    recycle_rp_inst (ri, & empty_rp);
    if (orig_ret_address != trampoline_address)
        break;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/kprobes_64.c.ifdefed" startline="450" endline="453">
{
    hlist_del (& ri -> hlist);
    kfree (ri);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/kprobes_64.c.ifdefed" startline="486" endline="532">
{
    unsigned long *tos = (unsigned long *) regs->rsp;
    unsigned long copy_rip = (unsigned long) p->ainsn.insn;
    unsigned long orig_rip = (unsigned long) p->addr;
    kprobe_opcode_t *insn = p->ainsn.insn;
    if (*insn >= 0x40 && *insn <= 0x4f)
        insn++;
    regs->eflags &= ~TF_MASK;
    switch (*insn) {
    case 0x9c :
        *tos &= ~(TF_MASK | IF_MASK);
        *tos |= kcb->kprobe_old_rflags;
        break;
    case 0xc2 :
    case 0xc3 :
    case 0xca :
    case 0xcb :
    case 0xcf :
    case 0xea :
        goto no_change;
    case 0xe8 :
        *tos = orig_rip + (*tos - copy_rip);
        break;
    case 0xff :
        if ((insn[1] & 0x30) == 0x10) {
            *tos = orig_rip + (*tos - copy_rip);
            goto no_change;
        }
        else if (((insn[1] & 0x31) == 0x20) || ((insn[1] & 0x31) == 0x21)) {
            goto no_change;
        }
    default :
        break;
    }
    regs->rip = orig_rip + (regs->rip - copy_rip);
no_change :
    return;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/kprobes_64.c.ifdefed" startline="497" endline="526">
{
case 0x9c :
    *tos &= ~(TF_MASK | IF_MASK);
    *tos |= kcb->kprobe_old_rflags;
    break;
case 0xc2 :
case 0xc3 :
case 0xca :
case 0xcb :
case 0xcf :
case 0xea :
    goto no_change;
case 0xe8 :
    *tos = orig_rip + (*tos - copy_rip);
    break;
case 0xff :
    if ((insn[1] & 0x30) == 0x10) {
        *tos = orig_rip + (*tos - copy_rip);
        goto no_change;
    }
    else if (((insn[1] & 0x31) == 0x20) || ((insn[1] & 0x31) == 0x21)) {
        goto no_change;
    }
default :
    break;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/kprobes_64.c.ifdefed" startline="514" endline="519">
{
    *tos = orig_rip + (*tos - copy_rip);
    goto no_change;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/kprobes_64.c.ifdefed" startline="520" endline="523">
{
    goto no_change;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/kprobes_64.c.ifdefed" startline="535" endline="569">
{
    struct kprobe *cur = kprobe_running ();
    struct kprobe_ctlblk *kcb = get_kprobe_ctlblk ();
    if (!cur)
        return 0;
    if ((kcb->kprobe_status != KPROBE_REENTER) && cur->post_handler) {
        kcb->kprobe_status = KPROBE_HIT_SSDONE;
        cur->post_handler (cur, regs, 0);
    }
    resume_execution (cur, regs, kcb);
    regs->eflags |= kcb->kprobe_saved_rflags;
    trace_hardirqs_fixup_flags (regs -> eflags);
    if (kcb->kprobe_status == KPROBE_REENTER) {
        restore_previous_kprobe (kcb);
        goto out;
    }
    reset_current_kprobe ();
out :
    preempt_enable_no_resched ();
    if (regs->eflags & TF_MASK)
        return 0;
    return 1;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/kprobes_64.c.ifdefed" startline="542" endline="545">
{
    kcb->kprobe_status = KPROBE_HIT_SSDONE;
    cur->post_handler (cur, regs, 0);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/kprobes_64.c.ifdefed" startline="552" endline="555">
{
    restore_previous_kprobe (kcb);
    goto out;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/kprobes_64.c.ifdefed" startline="572" endline="633">
{
    struct kprobe *cur = kprobe_running ();
    struct kprobe_ctlblk *kcb = get_kprobe_ctlblk ();
    const struct exception_table_entry *fixup;
    switch (kcb->kprobe_status) {
    case KPROBE_HIT_SS :
    case KPROBE_REENTER :
        regs->rip = (unsigned long) cur->addr;
        regs->eflags |= kcb->kprobe_old_rflags;
        if (kcb->kprobe_status == KPROBE_REENTER)
            restore_previous_kprobe (kcb);
        else
            reset_current_kprobe ();
        preempt_enable_no_resched ();
        break;
    case KPROBE_HIT_ACTIVE :
    case KPROBE_HIT_SSDONE :
        kprobes_inc_nmissed_count (cur);
        if (cur->fault_handler && cur->fault_handler (cur, regs, trapnr))
            return 1;
        fixup = search_exception_tables (regs->rip);
        if (fixup) {
            regs->rip = fixup->fixup;
            return 1;
        }
        break;
    default :
        break;
    }
    return 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/kprobes_64.c.ifdefed" startline="577" endline="631">
{
case KPROBE_HIT_SS :
case KPROBE_REENTER :
    regs->rip = (unsigned long) cur->addr;
    regs->eflags |= kcb->kprobe_old_rflags;
    if (kcb->kprobe_status == KPROBE_REENTER)
        restore_previous_kprobe (kcb);
    else
        reset_current_kprobe ();
    preempt_enable_no_resched ();
    break;
case KPROBE_HIT_ACTIVE :
case KPROBE_HIT_SSDONE :
    kprobes_inc_nmissed_count (cur);
    if (cur->fault_handler && cur->fault_handler (cur, regs, trapnr))
        return 1;
    fixup = search_exception_tables (regs->rip);
    if (fixup) {
        regs->rip = fixup->fixup;
        return 1;
    }
    break;
default :
    break;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/kprobes_64.c.ifdefed" startline="619" endline="622">
{
    regs->rip = fixup->fixup;
    return 1;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/kprobes_64.c.ifdefed" startline="640" endline="668">
{
    struct die_args *args = (struct die_args *) data;
    int ret = NOTIFY_DONE;
    if (args->regs && user_mode (args->regs))
        return ret;
    switch (val) {
    case DIE_INT3 :
        if (kprobe_handler (args->regs))
            ret = NOTIFY_STOP;
        break;
    case DIE_DEBUG :
        if (post_kprobe_handler (args->regs))
            ret = NOTIFY_STOP;
        break;
    case DIE_GPF :
        preempt_disable ();
        if (kprobe_running () && kprobe_fault_handler (args->regs, args->trapnr))
            ret = NOTIFY_STOP;
        preempt_enable ();
        break;
    default :
        break;
    }
    return ret;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/kprobes_64.c.ifdefed" startline="647" endline="666">
{
case DIE_INT3 :
    if (kprobe_handler (args->regs))
        ret = NOTIFY_STOP;
    break;
case DIE_DEBUG :
    if (post_kprobe_handler (args->regs))
        ret = NOTIFY_STOP;
    break;
case DIE_GPF :
    preempt_disable ();
    if (kprobe_running () && kprobe_fault_handler (args->regs, args->trapnr))
        ret = NOTIFY_STOP;
    preempt_enable ();
    break;
default :
    break;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/kprobes_64.c.ifdefed" startline="671" endline="692">
{
    struct jprobe *jp = container_of (p, struct jprobe, kp);
    unsigned long addr;
    struct kprobe_ctlblk *kcb = get_kprobe_ctlblk ();
    kcb->jprobe_saved_regs = *regs;
    kcb->jprobe_saved_rsp = (long *) regs->rsp;
    addr = (unsigned long) (kcb->jprobe_saved_rsp);
    memcpy (kcb -> jprobes_stack, (kprobe_opcode_t *) addr, MIN_STACK_SIZE (addr));
    regs->eflags &= ~IF_MASK;
    trace_hardirqs_off ();
    regs->rip = (unsigned long) (jp->entry);
    return 1;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/kprobes_64.c.ifdefed" startline="695" endline="704">
{
    struct kprobe_ctlblk *kcb = get_kprobe_ctlblk ();
    asm volatile ("       xchg   %%rbx,%%rsp     \n"
        "       int3			\n"
        "       .globl jprobe_return_end	\n"
        "       jprobe_return_end:	\n"
        "       nop			\n"
        :
        : "b" (kcb->jprobe_saved_rsp)
        : "memory"
    )}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/kprobes_64.c.ifdefed" startline="707" endline="731">
{
    struct kprobe_ctlblk *kcb = get_kprobe_ctlblk ();
    u8 *addr = (u8 *) (regs->rip - 1);
    unsigned long stack_addr = (unsigned long) (kcb->jprobe_saved_rsp);
    struct jprobe *jp = container_of (p, struct jprobe, kp);
    if ((addr > (u8 *) jprobe_return) && (addr < (u8 *) jprobe_return_end)) {
        if ((unsigned long *) regs->rsp != kcb->jprobe_saved_rsp) {
            struct pt_regs *saved_regs = &kcb->jprobe_saved_regs;
            printk ("current rsp %p does not match saved rsp %p\n", (long *) regs -> rsp, kcb -> jprobe_saved_rsp);
            printk ("Saved registers for jprobe %p\n", jp);
            show_registers (saved_regs);
            printk ("Current registers\n");
            show_registers (regs);
            BUG ();
        }
        *regs = kcb->jprobe_saved_regs;
        memcpy ((kprobe_opcode_t *) stack_addr, kcb -> jprobes_stack, MIN_STACK_SIZE (stack_addr));
        preempt_enable_no_resched ();
        return 1;
    }
    return 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/kprobes_64.c.ifdefed" startline="713" endline="729">
{
    if ((unsigned long *) regs->rsp != kcb->jprobe_saved_rsp) {
        struct pt_regs *saved_regs = &kcb->jprobe_saved_regs;
        printk ("current rsp %p does not match saved rsp %p\n", (long *) regs -> rsp, kcb -> jprobe_saved_rsp);
        printk ("Saved registers for jprobe %p\n", jp);
        show_registers (saved_regs);
        printk ("Current registers\n");
        show_registers (regs);
        BUG ();
    }
    *regs = kcb->jprobe_saved_regs;
    memcpy ((kprobe_opcode_t *) stack_addr, kcb -> jprobes_stack, MIN_STACK_SIZE (stack_addr));
    preempt_enable_no_resched ();
    return 1;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/kprobes_64.c.ifdefed" startline="714" endline="723">
{
    struct pt_regs *saved_regs = &kcb->jprobe_saved_regs;
    printk ("current rsp %p does not match saved rsp %p\n", (long *) regs -> rsp, kcb -> jprobe_saved_rsp);
    printk ("Saved registers for jprobe %p\n", jp);
    show_registers (saved_regs);
    printk ("Current registers\n");
    show_registers (regs);
    BUG ();
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/kprobes_64.c.ifdefed" startline="739" endline="741">
{
    return register_kprobe (&trampoline_p);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/kprobes_64.c.ifdefed" startline="744" endline="749">
{
    if (p->addr == (kprobe_opcode_t *) &kretprobe_trampoline)
        return 1;
    return 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/genapic_flat_64.c.ifdefed" startline="23" endline="25">
{
    return cpu_online_map;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/genapic_flat_64.c.ifdefed" startline="28" endline="39">
{
    cpumask_t domain = {{
            [0] = APIC_ALL_CPUS,
        }
    };
    return domain;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/genapic_flat_64.c.ifdefed" startline="49" endline="59">
{
    unsigned long val;
    unsigned long num, id;
    num = smp_processor_id ();
    id = 1UL << num;
    apic_write (APIC_DFR, APIC_DFR_FLAT);
    val = apic_read (APIC_LDR) & ~APIC_LDR_MASK;
    val |= SET_APIC_LOGICAL_ID (id);
    apic_write (APIC_LDR, val);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/genapic_flat_64.c.ifdefed" startline="62" endline="69">
{
    unsigned long mask = cpus_addr (cpumask)[0];
    unsigned long flags;
    local_irq_save (flags);
    __send_IPI_dest_field (mask, vector, APIC_DEST_LOGICAL);
    local_irq_restore (flags);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/genapic_flat_64.c.ifdefed" startline="72" endline="88">
{
    int hotplug = 0;
    if (hotplug || vector == NMI_VECTOR) {
        cpumask_t allbutme = cpu_online_map;
        cpu_clear (smp_processor_id (), allbutme);
        if (!cpus_empty (allbutme))
            flat_send_IPI_mask (allbutme, vector);
    }
    else if (num_online_cpus () > 1) {
        __send_IPI_shortcut (APIC_DEST_ALLBUT, vector, APIC_DEST_LOGICAL);
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/genapic_flat_64.c.ifdefed" startline="78" endline="85">
{
    cpumask_t allbutme = cpu_online_map;
    cpu_clear (smp_processor_id (), allbutme);
    if (!cpus_empty (allbutme))
        flat_send_IPI_mask (allbutme, vector);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/genapic_flat_64.c.ifdefed" startline="85" endline="87">
{
    __send_IPI_shortcut (APIC_DEST_ALLBUT, vector, APIC_DEST_LOGICAL);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/genapic_flat_64.c.ifdefed" startline="91" endline="96">
{
    if (vector == NMI_VECTOR)
        flat_send_IPI_mask (cpu_online_map, vector);
    else
        __send_IPI_shortcut (APIC_DEST_ALLINC, vector, APIC_DEST_LOGICAL);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/genapic_flat_64.c.ifdefed" startline="99" endline="101">
{
    return physid_isset (GET_APIC_ID (apic_read (APIC_ID)), phys_cpu_present_map);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/genapic_flat_64.c.ifdefed" startline="104" endline="106">
{
    return cpus_addr (cpumask)[0] & APIC_ALL_CPUS;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/genapic_flat_64.c.ifdefed" startline="109" endline="111">
{
    return hard_smp_processor_id () >> index_msb;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/genapic_flat_64.c.ifdefed" startline="135" endline="137">
{
    return cpu_online_map;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/genapic_flat_64.c.ifdefed" startline="140" endline="144">
{
    cpumask_t domain = CPU_MASK_NONE;
    cpu_set (cpu, domain);
    return domain;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/genapic_flat_64.c.ifdefed" startline="148" endline="150">
{
    send_IPI_mask_sequence (cpumask, vector);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/genapic_flat_64.c.ifdefed" startline="153" endline="158">
{
    cpumask_t allbutme = cpu_online_map;
    cpu_clear (smp_processor_id (), allbutme);
    physflat_send_IPI_mask (allbutme, vector);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/genapic_flat_64.c.ifdefed" startline="161" endline="163">
{
    physflat_send_IPI_mask (cpu_online_map, vector);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/genapic_flat_64.c.ifdefed" startline="166" endline="178">
{
    int cpu;
    cpu = first_cpu (cpumask);
    if ((unsigned) cpu < NR_CPUS)
        return per_cpu (x86_cpu_to_apicid, cpu);
    else
        return BAD_APICID;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/e820_64.c.ifdefed" startline="54" endline="102">
{
    unsigned long addr = *addrp, last = addr + size;
    if (addr < 0x8000) {
        *addrp = PAGE_ALIGN (0x8000);
        return 1;
    }
    if (last >= table_start << PAGE_SHIFT && addr < table_end << PAGE_SHIFT) {
        *addrp = PAGE_ALIGN (table_end << PAGE_SHIFT);
        return 1;
    }
    if (last >= __pa_symbol (&_text) && addr < __pa_symbol (&_end)) {
        *addrp = PAGE_ALIGN (__pa_symbol (&_end));
        return 1;
    }
    if (last >= ebda_addr && addr < ebda_addr + ebda_size) {
        *addrp = PAGE_ALIGN (ebda_addr +ebda_size);
        return 1;
    }
    return 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/e820_64.c.ifdefed" startline="58" endline="61">
{
    *addrp = PAGE_ALIGN (0x8000);
    return 1;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/e820_64.c.ifdefed" startline="64" endline="67">
{
    *addrp = PAGE_ALIGN (table_end << PAGE_SHIFT);
    return 1;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/e820_64.c.ifdefed" startline="83" endline="86">
{
    *addrp = PAGE_ALIGN (__pa_symbol (&_end));
    return 1;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/e820_64.c.ifdefed" startline="88" endline="91">
{
    *addrp = PAGE_ALIGN (ebda_addr +ebda_size);
    return 1;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/e820_64.c.ifdefed" startline="110" endline="121">
{
    int i;
    for (i = 0; i < e820.nr_map; i++) {
        struct e820entry *ei = &e820.map[i];
        if (type && ei->type != type)
            continue;
        if (ei->addr >= end || ei->addr + ei->size <= start)
            continue;
        return 1;
    }
    return 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/e820_64.c.ifdefed" startline="112" endline="119">
{
    struct e820entry *ei = &e820.map[i];
    if (type && ei->type != type)
        continue;
    if (ei->addr >= end || ei->addr + ei->size <= start)
        continue;
    return 1;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/e820_64.c.ifdefed" startline="131" endline="151">
{
    int i;
    for (i = 0; i < e820.nr_map; i++) {
        struct e820entry *ei = &e820.map[i];
        if (type && ei->type != type)
            continue;
        if (ei->addr >= end || ei->addr + ei->size <= start)
            continue;
        if (ei->addr <= start)
            start = ei->addr + ei->size;
        if (start >= end)
            return 1;
    }
    return 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/e820_64.c.ifdefed" startline="133" endline="149">
{
    struct e820entry *ei = &e820.map[i];
    if (type && ei->type != type)
        continue;
    if (ei->addr >= end || ei->addr + ei->size <= start)
        continue;
    if (ei->addr <= start)
        start = ei->addr + ei->size;
    if (start >= end)
        return 1;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/e820_64.c.ifdefed" startline="157" endline="178">
{
    int i;
    for (i = 0; i < e820.nr_map; i++) {
        struct e820entry *ei = &e820.map[i];
        unsigned long addr = ei->addr, last;
        if (ei->type != E820_RAM)
            continue;
        if (addr < start)
            addr = start;
        if (addr > ei->addr + ei->size)
            continue;
        while (bad_addr (&addr, size) && addr + size <= ei->addr + ei->size)
            ;
        last = PAGE_ALIGN (addr) + size;
        if (last > ei->addr + ei->size)
            continue;
        if (last > end)
            continue;
        return addr;
    }
    return -1UL;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/e820_64.c.ifdefed" startline="159" endline="176">
{
    struct e820entry *ei = &e820.map[i];
    unsigned long addr = ei->addr, last;
    if (ei->type != E820_RAM)
        continue;
    if (addr < start)
        addr = start;
    if (addr > ei->addr + ei->size)
        continue;
    while (bad_addr (&addr, size) && addr + size <= ei->addr + ei->size)
        ;
    last = PAGE_ALIGN (addr) + size;
    if (last > ei->addr + ei->size)
        continue;
    if (last > end)
        continue;
    return addr;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/e820_64.c.ifdefed" startline="184" endline="199">
{
    unsigned long end_pfn = 0;
    end_pfn = find_max_pfn_with_active_regions ();
    if (end_pfn > end_pfn_map)
        end_pfn_map = end_pfn;
    if (end_pfn_map > MAXMEM >> PAGE_SHIFT)
        end_pfn_map = MAXMEM >> PAGE_SHIFT;
    if (end_pfn > end_user_pfn)
        end_pfn = end_user_pfn;
    if (end_pfn > end_pfn_map)
        end_pfn = end_pfn_map;
    printk ("end_pfn_map = %lu\n", end_pfn_map);
    return end_pfn;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/e820_64.c.ifdefed" startline="205" endline="235">
{
    int i;
    for (i = 0; i < e820.nr_map; i++) {
        struct resource *res;
        res = alloc_bootmem_low (sizeof (struct resource));
        switch (e820.map[i].type) {
        case E820_RAM :
            res->name = "System RAM";
            break;
        case E820_ACPI :
            res->name = "ACPI Tables";
            break;
        case E820_NVS :
            res->name = "ACPI Non-volatile Storage";
            break;
        default :
            res->name = "reserved";
        }
        res->start = e820.map[i].addr;
        res->end = res->start + e820.map[i].size - 1;
        res->flags = IORESOURCE_MEM | IORESOURCE_BUSY;
        request_resource (& iomem_resource, res);
        if (e820.map[i].type == E820_RAM) {
            request_resource (res, & code_resource);
            request_resource (res, & data_resource);
            request_resource (res, & bss_resource);
        }
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/e820_64.c.ifdefed" startline="207" endline="234">
{
    struct resource *res;
    res = alloc_bootmem_low (sizeof (struct resource));
    switch (e820.map[i].type) {
    case E820_RAM :
        res->name = "System RAM";
        break;
    case E820_ACPI :
        res->name = "ACPI Tables";
        break;
    case E820_NVS :
        res->name = "ACPI Non-volatile Storage";
        break;
    default :
        res->name = "reserved";
    }
    res->start = e820.map[i].addr;
    res->end = res->start + e820.map[i].size - 1;
    res->flags = IORESOURCE_MEM | IORESOURCE_BUSY;
    request_resource (& iomem_resource, res);
    if (e820.map[i].type == E820_RAM) {
        request_resource (res, & code_resource);
        request_resource (res, & data_resource);
        request_resource (res, & bss_resource);
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/e820_64.c.ifdefed" startline="210" endline="215">
{
case E820_RAM :
    res->name = "System RAM";
    break;
case E820_ACPI :
    res->name = "ACPI Tables";
    break;
case E820_NVS :
    res->name = "ACPI Non-volatile Storage";
    break;
default :
    res->name = "reserved";
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/e820_64.c.ifdefed" startline="220" endline="233">
{
    request_resource (res, & code_resource);
    request_resource (res, & data_resource);
    request_resource (res, & bss_resource);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/e820_64.c.ifdefed" startline="246" endline="266">
{
    int i;
    unsigned long paddr;
    paddr = round_down (e820.map[0].addr + e820.map[0].size, PAGE_SIZE);
    for (i = 1; i < e820.nr_map; i++) {
        struct e820entry *ei = &e820.map[i];
        if (paddr < ei->addr)
            register_nosave_region (PFN_DOWN (paddr), PFN_UP (ei->addr));
        paddr = round_down (ei->addr + ei->size, PAGE_SIZE);
        if (ei->type != E820_RAM)
            register_nosave_region (PFN_UP (ei->addr), PFN_DOWN (paddr));
        if (paddr >= (end_pfn << PAGE_SHIFT))
            break;
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/e820_64.c.ifdefed" startline="251" endline="265">
{
    struct e820entry *ei = &e820.map[i];
    if (paddr < ei->addr)
        register_nosave_region (PFN_DOWN (paddr), PFN_UP (ei->addr));
    paddr = round_down (ei->addr + ei->size, PAGE_SIZE);
    if (ei->type != E820_RAM)
        register_nosave_region (PFN_UP (ei->addr), PFN_DOWN (paddr));
    if (paddr >= (end_pfn << PAGE_SHIFT))
        break;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/e820_64.c.ifdefed" startline="277" endline="307">
{
    *ei_startpfn = round_up (ei->addr, PAGE_SIZE) >> PAGE_SHIFT;
    *ei_endpfn = round_down (ei->addr + ei->size, PAGE_SIZE) >> PAGE_SHIFT;
    if (*ei_startpfn >= *ei_endpfn)
        return 0;
    if (ei->type != E820_RAM && *ei_endpfn > end_pfn_map)
        end_pfn_map = *ei_endpfn;
    if (ei->type != E820_RAM || *ei_endpfn <= start_pfn || *ei_startpfn >= end_pfn)
        return 0;
    if (*ei_startpfn < start_pfn)
        *ei_startpfn = start_pfn;
    if (*ei_endpfn > end_pfn)
        *ei_endpfn = end_pfn;
    if (*ei_startpfn >= end_user_pfn)
        return 0;
    if (*ei_endpfn > end_user_pfn)
        *ei_endpfn = end_user_pfn;
    return 1;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/e820_64.c.ifdefed" startline="313" endline="323">
{
    unsigned long ei_startpfn;
    unsigned long ei_endpfn;
    int i;
    for (i = 0; i < e820.nr_map; i++)
        if (e820_find_active_region (&e820.map[i], start_pfn, end_pfn, &ei_startpfn, &ei_endpfn))
            add_active_range (nid, ei_startpfn, ei_endpfn);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/e820_64.c.ifdefed" startline="329" endline="341">
{
    int x = e820.nr_map;
    if (x == E820MAX) {
        printk (KERN_ERR "Ooops! Too many entries in the memory map!\n");
        return;
    }
    e820.map[x].addr = start;
    e820.map[x].size = size;
    e820.map[x].type = type;
    e820.nr_map++;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/e820_64.c.ifdefed" startline="332" endline="335">
{
    printk (KERN_ERR "Ooops! Too many entries in the memory map!\n");
    return;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/e820_64.c.ifdefed" startline="349" endline="364">
{
    unsigned long start_pfn = start >> PAGE_SHIFT;
    unsigned long end_pfn = end >> PAGE_SHIFT;
    unsigned long ei_startpfn;
    unsigned long ei_endpfn;
    unsigned long ram = 0;
    int i;
    for (i = 0; i < e820.nr_map; i++) {
        if (e820_find_active_region (&e820.map[i], start_pfn, end_pfn, &ei_startpfn, &ei_endpfn))
            ram += ei_endpfn - ei_startpfn;
    }
    return end - start - (ram << PAGE_SHIFT);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/e820_64.c.ifdefed" startline="357" endline="362">
{
    if (e820_find_active_region (&e820.map[i], start_pfn, end_pfn, &ei_startpfn, &ei_endpfn))
        ram += ei_endpfn - ei_startpfn;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/e820_64.c.ifdefed" startline="367" endline="390">
{
    int i;
    for (i = 0; i < e820.nr_map; i++) {
        printk (KERN_INFO " %s: %016Lx - %016Lx ", who, (unsigned long long) e820.map [i].addr, (unsigned long long) (e820.map [i].addr + e820.map [i].size));
        switch (e820.map[i].type) {
        case E820_RAM :
            printk ("(usable)\n");
            break;
        case E820_RESERVED :
            printk ("(reserved)\n");
            break;
        case E820_ACPI :
            printk ("(ACPI data)\n");
            break;
        case E820_NVS :
            printk ("(ACPI NVS)\n");
            break;
        default :
            printk ("type %u\n", e820.map[i].type);
            break;
        }
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/e820_64.c.ifdefed" startline="370" endline="389">
{
    printk (KERN_INFO " %s: %016Lx - %016Lx ", who, (unsigned long long) e820.map [i].addr, (unsigned long long) (e820.map [i].addr + e820.map [i].size));
    switch (e820.map[i].type) {
    case E820_RAM :
        printk ("(usable)\n");
        break;
    case E820_RESERVED :
        printk ("(reserved)\n");
        break;
    case E820_ACPI :
        printk ("(ACPI data)\n");
        break;
    case E820_NVS :
        printk ("(ACPI NVS)\n");
        break;
    default :
        printk ("type %u\n", e820.map[i].type);
        break;
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/e820_64.c.ifdefed" startline="374" endline="388">
{
case E820_RAM :
    printk ("(usable)\n");
    break;
case E820_RESERVED :
    printk ("(reserved)\n");
    break;
case E820_ACPI :
    printk ("(ACPI data)\n");
    break;
case E820_NVS :
    printk ("(ACPI NVS)\n");
    break;
default :
    printk ("type %u\n", e820.map[i].type);
    break;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/e820_64.c.ifdefed" startline="400" endline="558">
{
    struct change_member {
        struct e820entry *pbios;
        unsigned long long addr;
    };
    static struct change_member change_point_list [2 * E820MAX] __initdata;
    static struct change_member *change_point [2 * E820MAX] __initdata;
    static struct e820entry *overlap_list [E820MAX] __initdata;
    static struct e820entry new_bios [E820MAX] __initdata;
    struct change_member *change_tmp;
    unsigned long current_type, last_type;
    unsigned long long last_addr;
    int chgidx, still_changing;
    int overlap_entries;
    int new_bios_entry;
    int old_nr, new_nr, chg_nr;
    int i;
    if (*pnr_map < 2)
        return -1;
    old_nr = *pnr_map;
    for (i = 0; i < old_nr; i++)
        if (biosmap[i].addr + biosmap[i].size < biosmap[i].addr)
            return -1;
    for (i = 0; i < 2 * old_nr; i++)
        change_point[i] = &change_point_list[i];
    chgidx = 0;
    for (i = 0; i < old_nr; i++) {
        if (biosmap[i].size != 0) {
            change_point[chgidx]->addr = biosmap[i].addr;
            change_point[chgidx++]->pbios = &biosmap[i];
            change_point[chgidx]->addr = biosmap[i].addr + biosmap[i].size;
            change_point[chgidx++]->pbios = &biosmap[i];
        }
    }
    chg_nr = chgidx;
    still_changing = 1;
    while (still_changing) {
        still_changing = 0;
        for (i = 1; i < chg_nr; i++) {
            if ((change_point[i]->addr < change_point[i - 1]->addr) || ((change_point[i]->addr == change_point[i - 1]->addr) && (change_point[i]->addr == change_point[i]->pbios->addr) && (change_point[i - 1]->addr != change_point[i - 1]->pbios->addr))) {
                change_tmp = change_point[i];
                change_point[i] = change_point[i - 1];
                change_point[i - 1] = change_tmp;
                still_changing = 1;
            }
        }
    }
    overlap_entries = 0;
    new_bios_entry = 0;
    last_type = 0;
    last_addr = 0;
    for (chgidx = 0; chgidx < chg_nr; chgidx++) {
        if (change_point[chgidx]->addr == change_point[chgidx]->pbios->addr) {
            overlap_list[overlap_entries++] = change_point[chgidx]->pbios;
        }
        else {
            for (i = 0; i < overlap_entries; i++) {
                if (overlap_list[i] == change_point[chgidx]->pbios)
                    overlap_list[i] = overlap_list[overlap_entries - 1];
            }
            overlap_entries--;
        }
        current_type = 0;
        for (i = 0; i < overlap_entries; i++)
            if (overlap_list[i]->type > current_type)
                current_type = overlap_list[i]->type;
        if (current_type != last_type) {
            if (last_type != 0) {
                new_bios[new_bios_entry].size = change_point[chgidx]->addr - last_addr;
                if (new_bios[new_bios_entry].size != 0)
                    if (++new_bios_entry >= E820MAX)
                        break;
            }
            if (current_type != 0) {
                new_bios[new_bios_entry].addr = change_point[chgidx]->addr;
                new_bios[new_bios_entry].type = current_type;
                last_addr = change_point[chgidx]->addr;
            }
            last_type = current_type;
        }
    }
    new_nr = new_bios_entry;
    memcpy (biosmap, new_bios, new_nr * sizeof (struct e820entry));
    *pnr_map = new_nr;
    return 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/e820_64.c.ifdefed" startline="472" endline="479">
{
    if (biosmap[i].size != 0) {
        change_point[chgidx]->addr = biosmap[i].addr;
        change_point[chgidx++]->pbios = &biosmap[i];
        change_point[chgidx]->addr = biosmap[i].addr + biosmap[i].size;
        change_point[chgidx++]->pbios = &biosmap[i];
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/e820_64.c.ifdefed" startline="473" endline="478">
{
    change_point[chgidx]->addr = biosmap[i].addr;
    change_point[chgidx++]->pbios = &biosmap[i];
    change_point[chgidx]->addr = biosmap[i].addr + biosmap[i].size;
    change_point[chgidx++]->pbios = &biosmap[i];
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/e820_64.c.ifdefed" startline="484" endline="501">
{
    still_changing = 0;
    for (i = 1; i < chg_nr; i++) {
        if ((change_point[i]->addr < change_point[i - 1]->addr) || ((change_point[i]->addr == change_point[i - 1]->addr) && (change_point[i]->addr == change_point[i]->pbios->addr) && (change_point[i - 1]->addr != change_point[i - 1]->pbios->addr))) {
            change_tmp = change_point[i];
            change_point[i] = change_point[i - 1];
            change_point[i - 1] = change_tmp;
            still_changing = 1;
        }
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/e820_64.c.ifdefed" startline="486" endline="500">
{
    if ((change_point[i]->addr < change_point[i - 1]->addr) || ((change_point[i]->addr == change_point[i - 1]->addr) && (change_point[i]->addr == change_point[i]->pbios->addr) && (change_point[i - 1]->addr != change_point[i - 1]->pbios->addr))) {
        change_tmp = change_point[i];
        change_point[i] = change_point[i - 1];
        change_point[i - 1] = change_tmp;
        still_changing = 1;
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/e820_64.c.ifdefed" startline="494" endline="499">
{
    change_tmp = change_point[i];
    change_point[i] = change_point[i - 1];
    change_point[i - 1] = change_tmp;
    still_changing = 1;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/e820_64.c.ifdefed" startline="510" endline="550">
{
    if (change_point[chgidx]->addr == change_point[chgidx]->pbios->addr) {
        overlap_list[overlap_entries++] = change_point[chgidx]->pbios;
    }
    else {
        for (i = 0; i < overlap_entries; i++) {
            if (overlap_list[i] == change_point[chgidx]->pbios)
                overlap_list[i] = overlap_list[overlap_entries - 1];
        }
        overlap_entries--;
    }
    current_type = 0;
    for (i = 0; i < overlap_entries; i++)
        if (overlap_list[i]->type > current_type)
            current_type = overlap_list[i]->type;
    if (current_type != last_type) {
        if (last_type != 0) {
            new_bios[new_bios_entry].size = change_point[chgidx]->addr - last_addr;
            if (new_bios[new_bios_entry].size != 0)
                if (++new_bios_entry >= E820MAX)
                    break;
        }
        if (current_type != 0) {
            new_bios[new_bios_entry].addr = change_point[chgidx]->addr;
            new_bios[new_bios_entry].type = current_type;
            last_addr = change_point[chgidx]->addr;
        }
        last_type = current_type;
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/e820_64.c.ifdefed" startline="513" endline="516">
{
    overlap_list[overlap_entries++] = change_point[chgidx]->pbios;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/e820_64.c.ifdefed" startline="518" endline="526">
{
    for (i = 0; i < overlap_entries; i++) {
        if (overlap_list[i] == change_point[chgidx]->pbios)
            overlap_list[i] = overlap_list[overlap_entries - 1];
    }
    overlap_entries--;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/e820_64.c.ifdefed" startline="521" endline="524">
{
    if (overlap_list[i] == change_point[chgidx]->pbios)
        overlap_list[i] = overlap_list[overlap_entries - 1];
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/e820_64.c.ifdefed" startline="534" endline="549">
{
    if (last_type != 0) {
        new_bios[new_bios_entry].size = change_point[chgidx]->addr - last_addr;
        if (new_bios[new_bios_entry].size != 0)
            if (++new_bios_entry >= E820MAX)
                break;
    }
    if (current_type != 0) {
        new_bios[new_bios_entry].addr = change_point[chgidx]->addr;
        new_bios[new_bios_entry].type = current_type;
        last_addr = change_point[chgidx]->addr;
    }
    last_type = current_type;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/e820_64.c.ifdefed" startline="535" endline="542">
{
    new_bios[new_bios_entry].size = change_point[chgidx]->addr - last_addr;
    if (new_bios[new_bios_entry].size != 0)
        if (++new_bios_entry >= E820MAX)
            break;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/e820_64.c.ifdefed" startline="543" endline="547">
{
    new_bios[new_bios_entry].addr = change_point[chgidx]->addr;
    new_bios[new_bios_entry].type = current_type;
    last_addr = change_point[chgidx]->addr;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/e820_64.c.ifdefed" startline="570" endline="588">
{
    if (nr_map < 2)
        return -1;
    do {
        unsigned long start = biosmap->addr;
        unsigned long size = biosmap->size;
        unsigned long end = start + size;
        unsigned long type = biosmap->type;
        if (start > end)
            return -1;
        add_memory_region (start, size, type);
    }
    while (biosmap++, --nr_map);
    return 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/e820_64.c.ifdefed" startline="575" endline="586">
{
    unsigned long start = biosmap->addr;
    unsigned long size = biosmap->size;
    unsigned long end = start + size;
    unsigned long type = biosmap->type;
    if (start > end)
        return -1;
    add_memory_region (start, size, type);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/e820_64.c.ifdefed" startline="591" endline="594">
{
    early_printk (msg);
    panic (msg);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/e820_64.c.ifdefed" startline="597" endline="609">
{
    sanitize_e820_map (boot_params.e820_map, & boot_params.e820_entries);
    if (copy_e820_map (boot_params.e820_map, boot_params.e820_entries) < 0)
        early_panic ("Cannot find a valid memory map");
    printk (KERN_INFO "BIOS-provided physical RAM map:\n");
    e820_print_map ("BIOS-e820");
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/e820_64.c.ifdefed" startline="612" endline="618">
{
    if (!p)
        return -EINVAL;
    end_user_pfn = memparse (p, &p);
    end_user_pfn >>= PAGE_SHIFT;
    return 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/e820_64.c.ifdefed" startline="624" endline="662">
{
    char *oldp;
    unsigned long long start_at, mem_size;
    if (!strcmp (p, "exactmap")) {
        end_pfn_map = 0;
        e820.nr_map = 0;
        userdef = 1;
        return 0;
    }
    oldp = p;
    mem_size = memparse (p, &p);
    if (p == oldp)
        return -EINVAL;
    if (*p == '@') {
        start_at = memparse (p +1, &p);
        add_memory_region (start_at, mem_size, E820_RAM);
    }
    else if (*p == '#') {
        start_at = memparse (p +1, &p);
        add_memory_region (start_at, mem_size, E820_ACPI);
    }
    else if (*p == '$') {
        start_at = memparse (p +1, &p);
        add_memory_region (start_at, mem_size, E820_RESERVED);
    }
    else {
        end_user_pfn = (mem_size >> PAGE_SHIFT);
    }
    return *p == '\0' ? 0 : -EINVAL;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/e820_64.c.ifdefed" startline="628" endline="643">
{
    end_pfn_map = 0;
    e820.nr_map = 0;
    userdef = 1;
    return 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/e820_64.c.ifdefed" startline="649" endline="652">
{
    start_at = memparse (p +1, &p);
    add_memory_region (start_at, mem_size, E820_RAM);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/e820_64.c.ifdefed" startline="652" endline="655">
{
    start_at = memparse (p +1, &p);
    add_memory_region (start_at, mem_size, E820_ACPI);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/e820_64.c.ifdefed" startline="655" endline="658">
{
    start_at = memparse (p +1, &p);
    add_memory_region (start_at, mem_size, E820_RESERVED);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/e820_64.c.ifdefed" startline="658" endline="660">
{
    end_user_pfn = (mem_size >> PAGE_SHIFT);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/e820_64.c.ifdefed" startline="666" endline="671">
{
    if (userdef) {
        printk (KERN_INFO "user-defined physical RAM map:\n");
        e820_print_map ("user");
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/e820_64.c.ifdefed" startline="667" endline="670">
{
    printk (KERN_INFO "user-defined physical RAM map:\n");
    e820_print_map ("user");
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/e820_64.c.ifdefed" startline="683" endline="732">
{
    unsigned long gapstart, gapsize, round;
    unsigned long last;
    int i;
    int found = 0;
    last = 0x100000000ull;
    gapstart = 0x10000000;
    gapsize = 0x400000;
    i = e820.nr_map;
    while (--i >= 0) {
        unsigned long long start = e820.map[i].addr;
        unsigned long long end = start + e820.map[i].size;
        if (last > end) {
            unsigned long gap = last - end;
            if (gap > gapsize) {
                gapsize = gap;
                gapstart = end;
                found = 1;
            }
        }
        if (start < last)
            last = start;
    }
    if (!found) {
        gapstart = (end_pfn << PAGE_SHIFT) + 1024 * 1024;
        printk (KERN_ERR "PCI: Warning: Cannot find a gap in the 32bit address range\n" KERN_ERR "PCI: Unassigned devices with 32bit resource registers may break!\n");
    }
    round = 0x100000;
    while ((gapsize >> 4) > round)
        round += round;
    pci_mem_start = (gapstart + round) & -round;
    printk (KERN_INFO "Allocating PCI resources starting at %lx (gap: %lx:%lx)\n", pci_mem_start, gapstart, gapsize);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/e820_64.c.ifdefed" startline="693" endline="712">
{
    unsigned long long start = e820.map[i].addr;
    unsigned long long end = start + e820.map[i].size;
    if (last > end) {
        unsigned long gap = last - end;
        if (gap > gapsize) {
            gapsize = gap;
            gapstart = end;
            found = 1;
        }
    }
    if (start < last)
        last = start;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/e820_64.c.ifdefed" startline="701" endline="709">
{
    unsigned long gap = last - end;
    if (gap > gapsize) {
        gapsize = gap;
        gapstart = end;
        found = 1;
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/e820_64.c.ifdefed" startline="704" endline="708">
{
    gapsize = gap;
    gapstart = end;
    found = 1;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/e820_64.c.ifdefed" startline="714" endline="718">
{
    gapstart = (end_pfn << PAGE_SHIFT) + 1024 * 1024;
    printk (KERN_ERR "PCI: Warning: Cannot find a gap in the 32bit address range\n" KERN_ERR "PCI: Unassigned devices with 32bit resource registers may break!\n");
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/e820_64.c.ifdefed" startline="735" endline="751">
{
    int i;
    if (slot < 0 || slot >= e820.nr_map)
        return -1;
    for (i = slot; i < e820.nr_map; i++) {
        if (e820.map[i].type != E820_RAM)
            continue;
        break;
    }
    if (i == e820.nr_map || e820.map[i].addr > (max_pfn << PAGE_SHIFT))
        return -1;
    *addr = e820.map[i].addr;
    *size = min_t (u64, e820.map[i].size + e820.map[i].addr, max_pfn << PAGE_SHIFT) - *addr;
    return i + 1;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/e820_64.c.ifdefed" startline="740" endline="744">
{
    if (e820.map[i].type != E820_RAM)
        continue;
    break;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/tsc_64.c.ifdefed" startline="24" endline="26">
{
    cyc2ns_scale = (NSEC_PER_MSEC << NS_SCALE) / khz;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/tsc_64.c.ifdefed" startline="29" endline="31">
{
    return (cyc * cyc2ns_scale) >> NS_SCALE;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/tsc_64.c.ifdefed" startline="34" endline="45">
{
    unsigned long a = 0;
    rdtscll (a);
    return cycles_2_ns (a);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/tsc_64.c.ifdefed" startline="50" endline="52">
{
    return tsc_unstable;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/tsc_64.c.ifdefed" startline="131" endline="146">
{
    unsigned long t1, t2;
    int i;
    for (i = 0; i < MAX_RETRIES; i++) {
        t1 = get_cycles_sync ();
        if (hpet)
            *hpet = hpet_readl (HPET_COUNTER) & 0xFFFFFFFF;
        else
            *pm = acpi_pm_read_early ();
        t2 = get_cycles_sync ();
        if ((t2 - t1) < SMI_TRESHOLD)
            return t2;
    }
    return ULONG_MAX;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/tsc_64.c.ifdefed" startline="135" endline="144">
{
    t1 = get_cycles_sync ();
    if (hpet)
        *hpet = hpet_readl (HPET_COUNTER) & 0xFFFFFFFF;
    else
        *pm = acpi_pm_read_early ();
    t2 = get_cycles_sync ();
    if ((t2 - t1) < SMI_TRESHOLD)
        return t2;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/tsc_64.c.ifdefed" startline="152" endline="210">
{
    unsigned long flags, tsc1, tsc2, tr1, tr2, pm1, pm2, hpet1, hpet2;
    int hpet = is_hpet_enabled ();
    local_irq_save (flags);
    tsc1 = tsc_read_refs (&pm1, hpet ? &hpet1 : NULL);
    outb ((inb (0x61) & ~ 0x02) | 0x01, 0x61);
    outb (0xb0, 0x43);
    outb ((CLOCK_TICK_RATE / (1000 / 50)) & 0xff, 0x42);
    outb ((CLOCK_TICK_RATE / (1000 / 50)) >> 8, 0x42);
    tr1 = get_cycles_sync ();
    while ((inb (0x61) & 0x20) == 0)
        ;
    tr2 = get_cycles_sync ();
    tsc2 = tsc_read_refs (&pm2, hpet ? &hpet2 : NULL);
    local_irq_restore (flags);
    tsc_khz = (tr2 - tr1) / 50;
    if (!hpet && !pm1 && !pm2) {
        printk (KERN_INFO "TSC calibrated against PIT\n");
        return;
    }
    if (tsc1 == ULONG_MAX || tsc2 == ULONG_MAX) {
        printk (KERN_WARNING "TSC calibration disturbed by SMI, " "using PIT calibration result\n");
        return;
    }
    tsc2 = (tsc2 - tsc1) * 1000000L;
    if (hpet) {
        printk (KERN_INFO "TSC calibrated against HPET\n");
        if (hpet2 < hpet1)
            hpet2 += 0x100000000;
        hpet2 -= hpet1;
        tsc1 = (hpet2 * hpet_readl (HPET_PERIOD)) / 1000000;
    }
    else {
        printk (KERN_INFO "TSC calibrated against PM_TIMER\n");
        if (pm2 < pm1)
            pm2 += ACPI_PM_OVRRUN;
        pm2 -= pm1;
        tsc1 = (pm2 * 1000000000) / PMTMR_TICKS_PER_SEC;
    }
    tsc_khz = tsc2 / tsc1;
    set_cyc2ns_scale (tsc_khz);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/tsc_64.c.ifdefed" startline="180" endline="183">
{
    printk (KERN_INFO "TSC calibrated against PIT\n");
    return;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/tsc_64.c.ifdefed" startline="186" endline="190">
{
    printk (KERN_WARNING "TSC calibration disturbed by SMI, " "using PIT calibration result\n");
    return;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/tsc_64.c.ifdefed" startline="194" endline="200">
{
    printk (KERN_INFO "TSC calibrated against HPET\n");
    if (hpet2 < hpet1)
        hpet2 += 0x100000000;
    hpet2 -= hpet1;
    tsc1 = (hpet2 * hpet_readl (HPET_PERIOD)) / 1000000;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/tsc_64.c.ifdefed" startline="200" endline="206">
{
    printk (KERN_INFO "TSC calibrated against PM_TIMER\n");
    if (pm2 < pm1)
        pm2 += ACPI_PM_OVRRUN;
    pm2 -= pm1;
    tsc1 = (pm2 * 1000000000) / PMTMR_TICKS_PER_SEC;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/tsc_64.c.ifdefed" startline="217" endline="239">
{
    if (tsc_unstable)
        return 1;
    if (boot_cpu_data.x86_vendor == X86_VENDOR_INTEL) {
        return 0;
    }
    return num_present_cpus () > 1;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/tsc_64.c.ifdefed" startline="227" endline="235">
{
    return 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/tsc_64.c.ifdefed" startline="242" endline="245">
{
    notsc = 1;
    return 1;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/tsc_64.c.ifdefed" startline="252" endline="255">
{
    cycle_t ret = (cycle_t) get_cycles_sync ();
    return ret;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/tsc_64.c.ifdefed" startline="258" endline="261">
{
    cycle_t ret = (cycle_t) get_cycles_sync ();
    return ret;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/tsc_64.c.ifdefed" startline="275" endline="285">
{
    if (!tsc_unstable) {
        tsc_unstable = 1;
        printk ("Marking TSC unstable due to %s\n", reason);
        if (clocksource_tsc.mult)
            clocksource_change_rating (&clocksource_tsc, 0);
        else
            clocksource_tsc.rating = 0;
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/tsc_64.c.ifdefed" startline="276" endline="284">
{
    tsc_unstable = 1;
    printk ("Marking TSC unstable due to %s\n", reason);
    if (clocksource_tsc.mult)
        clocksource_change_rating (&clocksource_tsc, 0);
    else
        clocksource_tsc.rating = 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/tsc_64.c.ifdefed" startline="289" endline="298">
{
    if (!notsc) {
        clocksource_tsc.mult = clocksource_khz2mult (tsc_khz, clocksource_tsc.shift);
        if (check_tsc_unstable ())
            clocksource_tsc.rating = 0;
        clocksource_register (& clocksource_tsc);
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/tsc_64.c.ifdefed" startline="290" endline="297">
{
    clocksource_tsc.mult = clocksource_khz2mult (tsc_khz, clocksource_tsc.shift);
    if (check_tsc_unstable ())
        clocksource_tsc.rating = 0;
    clocksource_register (& clocksource_tsc);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/pci-swiotlb_64.c.ifdefed" startline="33" endline="44">
{
    if (!iommu_detected && !no_iommu && end_pfn > MAX_DMA32_PFN)
        swiotlb = 1;
    if (swiotlb_force)
        swiotlb = 1;
    if (swiotlb) {
        printk (KERN_INFO "PCI-DMA: Using software bounce buffering for IO (SWIOTLB)\n");
        swiotlb_init ();
        dma_ops = &swiotlb_dma_ops;
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/pci-swiotlb_64.c.ifdefed" startline="39" endline="43">
{
    printk (KERN_INFO "PCI-DMA: Using software bounce buffering for IO (SWIOTLB)\n");
    swiotlb_init ();
    dma_ops = &swiotlb_dma_ops;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/sys_x86_64.c.ifdefed" startline="24" endline="34">
{
    int fd [2];
    int error;
    error = do_pipe (fd);
    if (!error) {
        if (copy_to_user (fildes, fd, 2 * sizeof (int)))
            error = -EFAULT;
    }
    return error;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/sys_x86_64.c.ifdefed" startline="29" endline="32">
{
    if (copy_to_user (fildes, fd, 2 * sizeof (int)))
        error = -EFAULT;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/sys_x86_64.c.ifdefed" startline="38" endline="62">
{
    long error;
    struct file *file;
    error = -EINVAL;
    if (off & ~PAGE_MASK)
        goto out;
    error = -EBADF;
    file = NULL;
    flags &= ~(MAP_EXECUTABLE | MAP_DENYWRITE);
    if (!(flags & MAP_ANONYMOUS)) {
        file = fget (fd);
        if (!file)
            goto out;
    }
    down_write (& current -> mm -> mmap_sem);
    error = do_mmap_pgoff (file, addr, len, prot, flags, off >> PAGE_SHIFT);
    up_write (& current -> mm -> mmap_sem);
    if (file)
        fput (file);
out :
    return error;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/sys_x86_64.c.ifdefed" startline="49" endline="53">
{
    file = fget (fd);
    if (!file)
        goto out;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/sys_x86_64.c.ifdefed" startline="66" endline="81">
{
    if (!test_thread_flag (TIF_IA32) && (flags & MAP_32BIT)) {
        *begin = 0x40000000;
        *end = 0x80000000;
    }
    else {
        *begin = TASK_UNMAPPED_BASE;
        *end = TASK_SIZE;
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/sys_x86_64.c.ifdefed" startline="67" endline="77">
{
    *begin = 0x40000000;
    *end = 0x80000000;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/sys_x86_64.c.ifdefed" startline="77" endline="80">
{
    *begin = TASK_UNMAPPED_BASE;
    *end = TASK_SIZE;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/sys_x86_64.c.ifdefed" startline="86" endline="144">
{
    struct mm_struct *mm = current->mm;
    struct vm_area_struct *vma;
    unsigned long start_addr;
    unsigned long begin, end;
    if (flags & MAP_FIXED)
        return addr;
    find_start_end (flags, & begin, & end);
    if (len > end)
        return -ENOMEM;
    if (addr) {
        addr = PAGE_ALIGN (addr);
        vma = find_vma (mm, addr);
        if (end - len >= addr && (!vma || addr + len <= vma->vm_start))
            return addr;
    }
    if (((flags & MAP_32BIT) || test_thread_flag (TIF_IA32)) && len <= mm->cached_hole_size) {
        mm->cached_hole_size = 0;
        mm->free_area_cache = begin;
    }
    addr = mm->free_area_cache;
    if (addr < begin)
        addr = begin;
    start_addr = addr;
full_search :
    for (vma = find_vma (mm, addr);; vma = vma->vm_next) {
        if (end - len < addr) {
            if (start_addr != begin) {
                start_addr = addr = begin;
                mm->cached_hole_size = 0;
                goto full_search;
            }
            return -ENOMEM;
        }
        if (!vma || addr + len <= vma->vm_start) {
            mm->free_area_cache = addr + len;
            return addr;
        }
        if (addr + mm->cached_hole_size < vma->vm_start)
            mm->cached_hole_size = vma->vm_start - addr;
        addr = vma->vm_end;
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/sys_x86_64.c.ifdefed" startline="100" endline="106">
{
    addr = PAGE_ALIGN (addr);
    vma = find_vma (mm, addr);
    if (end - len >= addr && (!vma || addr + len <= vma->vm_start))
        return addr;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/sys_x86_64.c.ifdefed" startline="108" endline="111">
{
    mm->cached_hole_size = 0;
    mm->free_area_cache = begin;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/sys_x86_64.c.ifdefed" startline="118" endline="143">
{
    if (end - len < addr) {
        if (start_addr != begin) {
            start_addr = addr = begin;
            mm->cached_hole_size = 0;
            goto full_search;
        }
        return -ENOMEM;
    }
    if (!vma || addr + len <= vma->vm_start) {
        mm->free_area_cache = addr + len;
        return addr;
    }
    if (addr + mm->cached_hole_size < vma->vm_start)
        mm->cached_hole_size = vma->vm_start - addr;
    addr = vma->vm_end;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/sys_x86_64.c.ifdefed" startline="120" endline="131">
{
    if (start_addr != begin) {
        start_addr = addr = begin;
        mm->cached_hole_size = 0;
        goto full_search;
    }
    return -ENOMEM;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/sys_x86_64.c.ifdefed" startline="125" endline="129">
{
    start_addr = addr = begin;
    mm->cached_hole_size = 0;
    goto full_search;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/sys_x86_64.c.ifdefed" startline="132" endline="138">
{
    mm->free_area_cache = addr + len;
    return addr;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/sys_x86_64.c.ifdefed" startline="147" endline="155">
{
    int err;
    down_read (& uts_sem);
    err = copy_to_user (name, utsname (), sizeof (*name));
    up_read (& uts_sem);
    if (personality (current->personality) == PER_LINUX32)
        err |= copy_to_user (&name->machine, "i686", 5);
    return err ? -EFAULT : 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/pmtimer_64.c.ifdefed" startline="30" endline="40">
{
    cycles *= 286;
    return (cycles >> 10);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/pmtimer_64.c.ifdefed" startline="43" endline="50">
{
    u32 a, b;
    for (a = b = inl (pmtmr_ioport) & ACPI_PM_MASK; a == b; b = inl (pmtmr_ioport) & ACPI_PM_MASK)
        cpu_relax ();
    return b;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/pmtimer_64.c.ifdefed" startline="54" endline="61">
{
    u32 a, b;
    a = pmtimer_wait_tick ();
    do {
        b = inl (pmtmr_ioport);
        cpu_relax ();
    }
    while (cyc2us (b -a) < us);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/pmtimer_64.c.ifdefed" startline="57" endline="60">
{
    b = inl (pmtmr_ioport);
    cpu_relax ();
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/pmtimer_64.c.ifdefed" startline="64" endline="67">
{
    pmtmr_ioport = 0;
    return 1;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/traps_64.c.ifdefed" startline="78" endline="81">
{
    if (regs->eflags & X86_EFLAGS_IF)
        local_irq_enable ();
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/traps_64.c.ifdefed" startline="84" endline="88">
{
    preempt_disable ();
    if (regs->eflags & X86_EFLAGS_IF)
        local_irq_enable ();
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/traps_64.c.ifdefed" startline="91" endline="97">
{
    if (regs->eflags & X86_EFLAGS_IF)
        local_irq_disable ();
    preempt_enable_no_resched ();
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/traps_64.c.ifdefed" startline="123" endline="125">
{
    printk (" [<%016lx>]\n", address);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/traps_64.c.ifdefed" startline="130" endline="200">
{
    static char ids [] [8] = {
        [DEBUG_STACK - 1] = "#DB",
        [NMI_STACK - 1] = "NMI",
        [DOUBLEFAULT_STACK - 1] = "#DF",
        [STACKFAULT_STACK - 1] = "#SS",
        [MCE_STACK - 1] = "#MC",
    };
    unsigned k;
    for (k = 0; k < N_EXCEPTION_STACKS; k++) {
        unsigned long end = per_cpu (orig_ist, cpu).ist[k];
        if (stack >= end)
            continue;
        if (stack >= end - EXCEPTION_STKSZ) {
            if (*usedp & (1U << k))
                break;
            *usedp |= 1U << k;
            *idp = ids[k];
            return (unsigned long *) end;
        }
    }
    return NULL;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/traps_64.c.ifdefed" startline="147" endline="198">
{
    unsigned long end = per_cpu (orig_ist, cpu).ist[k];
    if (stack >= end)
        continue;
    if (stack >= end - EXCEPTION_STKSZ) {
        if (*usedp & (1U << k))
            break;
        *usedp |= 1U << k;
        *idp = ids[k];
        return (unsigned long *) end;
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/traps_64.c.ifdefed" startline="159" endline="171">
{
    if (*usedp & (1U << k))
        break;
    *usedp |= 1U << k;
    *idp = ids[k];
    return (unsigned long *) end;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/traps_64.c.ifdefed" startline="212" endline="215">
{
    void *t = (void *) tinfo;
    return p > t && p < t + THREAD_SIZE - 3;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/traps_64.c.ifdefed" startline="220" endline="313">
{
    const unsigned cpu = get_cpu ();
    unsigned long *irqstack_end = (unsigned long *) cpu_pda (cpu)->irqstackptr;
    unsigned used = 0;
    struct thread_info *tinfo;
    if (!tsk)
        tsk = current;
    if (!stack) {
        unsigned long dummy;
        stack = &dummy;
        if (tsk && tsk != current)
            stack = (unsigned long *) tsk->thread.rsp;
    }
    for (;;) {
        char *id;
        unsigned long *estack_end;
        estack_end = in_exception_stack (cpu, (unsigned long) stack, &used, &id);
        if (estack_end) {
            if (ops->stack (data, id) < 0)
                break;
            HANDLE_STACK (stack < estack_end);
            ops->stack (data, "<EOE>");
            stack = (unsigned long *) estack_end[-2];
            continue;
        }
        if (irqstack_end) {
            unsigned long *irqstack;
            irqstack = irqstack_end - (IRQSTACKSIZE - 64) / sizeof (*irqstack);
            if (stack >= irqstack && stack < irqstack_end) {
                if (ops->stack (data, "IRQ") < 0)
                    break;
                HANDLE_STACK (stack < irqstack_end);
                stack = (unsigned long *) (irqstack_end[-1]);
                irqstack_end = NULL;
                ops->stack (data, "EOI");
                continue;
            }
        }
        break;
    }
    tinfo = task_thread_info (tsk);
    HANDLE_STACK (valid_stack_ptr (tinfo, stack));
    put_cpu ();
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/traps_64.c.ifdefed" startline="229" endline="234">
{
    unsigned long dummy;
    stack = &dummy;
    if (tsk && tsk != current)
        stack = (unsigned long *) tsk->thread.rsp;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/traps_64.c.ifdefed" startline="264" endline="304">
{
    char *id;
    unsigned long *estack_end;
    estack_end = in_exception_stack (cpu, (unsigned long) stack, &used, &id);
    if (estack_end) {
        if (ops->stack (data, id) < 0)
            break;
        HANDLE_STACK (stack < estack_end);
        ops->stack (data, "<EOE>");
        stack = (unsigned long *) estack_end[-2];
        continue;
    }
    if (irqstack_end) {
        unsigned long *irqstack;
        irqstack = irqstack_end - (IRQSTACKSIZE - 64) / sizeof (*irqstack);
        if (stack >= irqstack && stack < irqstack_end) {
            if (ops->stack (data, "IRQ") < 0)
                break;
            HANDLE_STACK (stack < irqstack_end);
            stack = (unsigned long *) (irqstack_end[-1]);
            irqstack_end = NULL;
            ops->stack (data, "EOI");
            continue;
        }
    }
    break;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/traps_64.c.ifdefed" startline="270" endline="282">
{
    if (ops->stack (data, id) < 0)
        break;
    HANDLE_STACK (stack < estack_end);
    ops->stack (data, "<EOE>");
    stack = (unsigned long *) estack_end[-2];
    continue;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/traps_64.c.ifdefed" startline="283" endline="302">
{
    unsigned long *irqstack;
    irqstack = irqstack_end - (IRQSTACKSIZE - 64) / sizeof (*irqstack);
    if (stack >= irqstack && stack < irqstack_end) {
        if (ops->stack (data, "IRQ") < 0)
            break;
        HANDLE_STACK (stack < irqstack_end);
        stack = (unsigned long *) (irqstack_end[-1]);
        irqstack_end = NULL;
        ops->stack (data, "EOI");
        continue;
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/traps_64.c.ifdefed" startline="288" endline="301">
{
    if (ops->stack (data, "IRQ") < 0)
        break;
    HANDLE_STACK (stack < irqstack_end);
    stack = (unsigned long *) (irqstack_end[-1]);
    irqstack_end = NULL;
    ops->stack (data, "EOI");
    continue;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/traps_64.c.ifdefed" startline="318" endline="321">
{
    print_symbol (msg, symbol);
    printk ("\n");
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/traps_64.c.ifdefed" startline="324" endline="326">
{
    printk ("%s\n", msg);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/traps_64.c.ifdefed" startline="329" endline="332">
{
    printk (" <%s> ", name);
    return 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/traps_64.c.ifdefed" startline="335" endline="338">
{
    touch_nmi_watchdog ();
    printk_address (addr);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/traps_64.c.ifdefed" startline="349" endline="353">
{
    printk ("\nCall Trace:\n");
    dump_trace (tsk, regs, stack, & print_trace_ops, NULL);
    printk ("\n");
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/traps_64.c.ifdefed" startline="357" endline="391">
{
    unsigned long *stack;
    int i;
    const int cpu = smp_processor_id ();
    unsigned long *irqstack_end = (unsigned long *) (cpu_pda (cpu)->irqstackptr);
    unsigned long *irqstack = (unsigned long *) (cpu_pda (cpu)->irqstackptr - IRQSTACKSIZE);
    if (rsp == NULL) {
        if (tsk)
            rsp = (unsigned long *) tsk->thread.rsp;
        else
            rsp = (unsigned long *) &rsp;
    }
    stack = rsp;
    for (i = 0; i < kstack_depth_to_print; i++) {
        if (stack >= irqstack && stack <= irqstack_end) {
            if (stack == irqstack_end) {
                stack = (unsigned long *) (irqstack_end[-1]);
                printk (" <EOI> ");
            }
        }
        else {
            if (((long) stack & (THREAD_SIZE - 1)) == 0)
                break;
        }
        if (i && ((i % 4) == 0))
            printk ("\n");
        printk (" %016lx", * stack ++);
        touch_nmi_watchdog ();
    }
    show_trace (tsk, regs, rsp);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/traps_64.c.ifdefed" startline="367" endline="372">
{
    if (tsk)
        rsp = (unsigned long *) tsk->thread.rsp;
    else
        rsp = (unsigned long *) &rsp;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/traps_64.c.ifdefed" startline="375" endline="389">
{
    if (stack >= irqstack && stack <= irqstack_end) {
        if (stack == irqstack_end) {
            stack = (unsigned long *) (irqstack_end[-1]);
            printk (" <EOI> ");
        }
    }
    else {
        if (((long) stack & (THREAD_SIZE - 1)) == 0)
            break;
    }
    if (i && ((i % 4) == 0))
        printk ("\n");
    printk (" %016lx", * stack ++);
    touch_nmi_watchdog ();
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/traps_64.c.ifdefed" startline="376" endline="381">
{
    if (stack == irqstack_end) {
        stack = (unsigned long *) (irqstack_end[-1]);
        printk (" <EOI> ");
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/traps_64.c.ifdefed" startline="377" endline="380">
{
    stack = (unsigned long *) (irqstack_end[-1]);
    printk (" <EOI> ");
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/traps_64.c.ifdefed" startline="381" endline="384">
{
    if (((long) stack & (THREAD_SIZE - 1)) == 0)
        break;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/traps_64.c.ifdefed" startline="394" endline="396">
{
    _show_stack (tsk, NULL, rsp);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/traps_64.c.ifdefed" startline="402" endline="411">
{
    unsigned long dummy;
    printk ("Pid: %d, comm: %.20s %s %s %.*s\n", current -> pid, current -> comm, print_tainted (), init_utsname () -> release, (int) strcspn (init_utsname () -> version, " "), init_utsname () -> version);
    show_trace (NULL, NULL, & dummy);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/traps_64.c.ifdefed" startline="416" endline="452">
{
    int i;
    int in_kernel = !user_mode (regs);
    unsigned long rsp;
    const int cpu = smp_processor_id ();
    struct task_struct *cur = cpu_pda (cpu)->pcurrent;
    rsp = regs->rsp;
    printk ("CPU %d ", cpu);
    __show_regs (regs);
    printk ("Process %s (pid: %d, threadinfo %p, task %p)\n", cur -> comm, cur -> pid, task_thread_info (cur), cur);
    if (in_kernel) {
        printk ("Stack: ");
        _show_stack (NULL, regs, (unsigned long *) rsp);
        printk ("\nCode: ");
        if (regs->rip < PAGE_OFFSET)
            goto bad;
        for (i = 0; i < 20; i++) {
            unsigned char c;
            if (__get_user (c, &((unsigned char *) regs->rip)[i])) {
            bad :
                printk (" Bad RIP value.");
                break;
            }
            printk ("%02x ", c);
        }
    }
    printk ("\n");
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/traps_64.c.ifdefed" startline="433" endline="450">
{
    printk ("Stack: ");
    _show_stack (NULL, regs, (unsigned long *) rsp);
    printk ("\nCode: ");
    if (regs->rip < PAGE_OFFSET)
        goto bad;
    for (i = 0; i < 20; i++) {
        unsigned char c;
        if (__get_user (c, &((unsigned char *) regs->rip)[i])) {
        bad :
            printk (" Bad RIP value.");
            break;
        }
        printk ("%02x ", c);
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/traps_64.c.ifdefed" startline="441" endline="449">
{
    unsigned char c;
    if (__get_user (c, &((unsigned char *) regs->rip)[i])) {
    bad :
        printk (" Bad RIP value.");
        break;
    }
    printk ("%02x ", c);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/traps_64.c.ifdefed" startline="443" endline="447">
{
bad :
    printk (" Bad RIP value.");
    break;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/traps_64.c.ifdefed" startline="455" endline="462">
{
    unsigned short ud2;
    if (__copy_from_user (&ud2, (const void __user *) rip, sizeof (ud2)))
        return 0;
    return ud2 == 0x0b0f;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/traps_64.c.ifdefed" startline="477" endline="497">
{
    int cpu;
    unsigned long flags;
    oops_enter ();
    raw_local_irq_save (flags);
    cpu = smp_processor_id ();
    if (!__raw_spin_trylock (&die_lock)) {
        if (cpu == die_owner)
            ;
        else
            __raw_spin_lock (&die_lock);
    }
    die_nest_count++;
    die_owner = cpu;
    console_verbose ();
    bust_spinlocks (1);
    return flags;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/traps_64.c.ifdefed" startline="486" endline="491">
{
    if (cpu == die_owner)
        ;
    else
        __raw_spin_lock (&die_lock);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/traps_64.c.ifdefed" startline="500" endline="511">
{
    die_owner = -1;
    bust_spinlocks (0);
    die_nest_count--;
    if (!die_nest_count)
        __raw_spin_unlock (&die_lock);
    raw_local_irq_restore (flags);
    if (panic_on_oops)
        panic ("Fatal exception");
    oops_exit ();
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/traps_64.c.ifdefed" startline="514" endline="536">
{
    static int die_counter;
    printk (KERN_EMERG "%s: %04lx [%u] ", str, err & 0xffff, ++ die_counter);
    printk ("\n");
    notify_die (DIE_OOPS, str, regs, err, current -> thread.trap_no, SIGSEGV);
    show_registers (regs);
    add_taint (TAINT_DIE);
    printk (KERN_ALERT "RIP ");
    printk_address (regs -> rip);
    printk (" RSP <%016lx>\n", regs -> rsp);
    if (kexec_should_crash (current))
        crash_kexec (regs);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/traps_64.c.ifdefed" startline="539" endline="548">
{
    unsigned long flags = oops_begin ();
    if (!user_mode (regs))
        report_bug (regs->rip, regs);
    __die (str, regs, err);
    oops_end (flags);
    do_exit (SIGSEGV);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/traps_64.c.ifdefed" startline="551" endline="568">
{
    unsigned long flags = oops_begin ();
    printk (str, smp_processor_id ());
    show_registers (regs);
    if (kexec_should_crash (current))
        crash_kexec (regs);
    if (do_panic || panic_on_oops)
        panic ("Non maskable interrupt");
    oops_end (flags);
    nmi_exit ();
    local_irq_enable ();
    do_exit (SIGSEGV);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/traps_64.c.ifdefed" startline="573" endline="618">
{
    struct task_struct *tsk = current;
    if (user_mode (regs)) {
        tsk->thread.error_code = error_code;
        tsk->thread.trap_no = trapnr;
        if (show_unhandled_signals && unhandled_signal (tsk, signr) && printk_ratelimit ())
            printk (KERN_INFO "%s[%d] trap %s rip:%lx rsp:%lx error:%lx\n", tsk->comm, tsk->pid, str, regs->rip, regs->rsp, error_code);
        if (info)
            force_sig_info (signr, info, tsk);
        else
            force_sig (signr, tsk);
        return;
    }
    {
        const struct exception_table_entry *fixup;
        fixup = search_exception_tables (regs->rip);
        if (fixup)
            regs->rip = fixup->fixup;
        else {
            tsk->thread.error_code = error_code;
            tsk->thread.trap_no = trapnr;
            die (str, regs, error_code);
        }
        return;
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/traps_64.c.ifdefed" startline="576" endline="602">
{
    tsk->thread.error_code = error_code;
    tsk->thread.trap_no = trapnr;
    if (show_unhandled_signals && unhandled_signal (tsk, signr) && printk_ratelimit ())
        printk (KERN_INFO "%s[%d] trap %s rip:%lx rsp:%lx error:%lx\n", tsk->comm, tsk->pid, str, regs->rip, regs->rsp, error_code);
    if (info)
        force_sig_info (signr, info, tsk);
    else
        force_sig (signr, tsk);
    return;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/traps_64.c.ifdefed" startline="606" endline="617">
{
    const struct exception_table_entry *fixup;
    fixup = search_exception_tables (regs->rip);
    if (fixup)
        regs->rip = fixup->fixup;
    else {
        tsk->thread.error_code = error_code;
        tsk->thread.trap_no = trapnr;
        die (str, regs, error_code);
    }
    return;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/traps_64.c.ifdefed" startline="611" endline="615">
{
    tsk->thread.error_code = error_code;
    tsk->thread.trap_no = trapnr;
    die (str, regs, error_code);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/traps_64.c.ifdefed" startline="659" endline="666">
{
    if (notify_die (DIE_TRAP, "stack segment", regs, error_code, 12, SIGBUS) == NOTIFY_STOP)
        return;
    preempt_conditional_sti (regs);
    do_trap (12, SIGBUS, "stack segment", regs, error_code, NULL);
    preempt_conditional_cli (regs);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/traps_64.c.ifdefed" startline="669" endline="683">
{
    static const char str [] = "double fault";
    struct task_struct *tsk = current;
    notify_die (DIE_TRAP, str, regs, error_code, 8, SIGSEGV);
    tsk->thread.error_code = error_code;
    tsk->thread.trap_no = 8;
    for (;;)
        die (str, regs, error_code);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/traps_64.c.ifdefed" startline="687" endline="723">
{
    struct task_struct *tsk = current;
    conditional_sti (regs);
    if (user_mode (regs)) {
        tsk->thread.error_code = error_code;
        tsk->thread.trap_no = 13;
        if (show_unhandled_signals && unhandled_signal (tsk, SIGSEGV) && printk_ratelimit ())
            printk (KERN_INFO "%s[%d] general protection rip:%lx rsp:%lx error:%lx\n", tsk->comm, tsk->pid, regs->rip, regs->rsp, error_code);
        force_sig (SIGSEGV, tsk);
        return;
    }
    {
        const struct exception_table_entry *fixup;
        fixup = search_exception_tables (regs->rip);
        if (fixup) {
            regs->rip = fixup->fixup;
            return;
        }
        tsk->thread.error_code = error_code;
        tsk->thread.trap_no = 13;
        if (notify_die (DIE_GPF, "general protection fault", regs, error_code, 13, SIGSEGV) == NOTIFY_STOP)
            return;
        die ("general protection fault", regs, error_code);
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/traps_64.c.ifdefed" startline="692" endline="705">
{
    tsk->thread.error_code = error_code;
    tsk->thread.trap_no = 13;
    if (show_unhandled_signals && unhandled_signal (tsk, SIGSEGV) && printk_ratelimit ())
        printk (KERN_INFO "%s[%d] general protection rip:%lx rsp:%lx error:%lx\n", tsk->comm, tsk->pid, regs->rip, regs->rsp, error_code);
    force_sig (SIGSEGV, tsk);
    return;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/traps_64.c.ifdefed" startline="708" endline="722">
{
    const struct exception_table_entry *fixup;
    fixup = search_exception_tables (regs->rip);
    if (fixup) {
        regs->rip = fixup->fixup;
        return;
    }
    tsk->thread.error_code = error_code;
    tsk->thread.trap_no = 13;
    if (notify_die (DIE_GPF, "general protection fault", regs, error_code, 13, SIGSEGV) == NOTIFY_STOP)
        return;
    die ("general protection fault", regs, error_code);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/traps_64.c.ifdefed" startline="711" endline="714">
{
    regs->rip = fixup->fixup;
    return;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/traps_64.c.ifdefed" startline="727" endline="747">
{
    printk (KERN_EMERG "Uhhuh. NMI received for unknown reason %02x.\n", reason);
    printk (KERN_EMERG "You have some hardware problem, likely on the PCI bus.\n");
    if (panic_on_unrecovered_nmi)
        panic ("NMI: Not continuing");
    printk (KERN_EMERG "Dazed and confused, but trying to continue\n");
    reason = (reason & 0xf) | 4;
    outb (reason, 0x61);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/traps_64.c.ifdefed" startline="751" endline="761">
{
    printk ("NMI: IOCK error (debug interrupt?)\n");
    show_registers (regs);
    reason = (reason & 0xf) | 8;
    outb (reason, 0x61);
    mdelay (2000);
    reason &= ~8;
    outb (reason, 0x61);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/traps_64.c.ifdefed" startline="765" endline="774">
{
    printk (KERN_EMERG "Uhhuh. NMI received for unknown reason %02x.\n", reason);
    printk (KERN_EMERG "Do you have a strange power saving mode enabled?\n");
    if (panic_on_unrecovered_nmi)
        panic ("NMI: Not continuing");
    printk (KERN_EMERG "Dazed and confused, but trying to continue\n");
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/traps_64.c.ifdefed" startline="779" endline="813">
{
    unsigned char reason = 0;
    int cpu;
    cpu = smp_processor_id ();
    if (!cpu)
        reason = get_nmi_reason ();
    if (!(reason & 0xc0)) {
        if (notify_die (DIE_NMI_IPI, "nmi_ipi", regs, reason, 2, SIGINT) == NOTIFY_STOP)
            return;
        if (nmi_watchdog_tick (regs, reason))
            return;
        if (!do_nmi_callback (regs, cpu))
            unknown_nmi_error (reason, regs);
        return;
    }
    if (notify_die (DIE_NMI, "nmi", regs, reason, 2, SIGINT) == NOTIFY_STOP)
        return;
    if (reason & 0x80)
        mem_parity_error (reason, regs);
    if (reason & 0x40)
        io_check_error (reason, regs);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/traps_64.c.ifdefed" startline="789" endline="803">
{
    if (notify_die (DIE_NMI_IPI, "nmi_ipi", regs, reason, 2, SIGINT) == NOTIFY_STOP)
        return;
    if (nmi_watchdog_tick (regs, reason))
        return;
    if (!do_nmi_callback (regs, cpu))
        unknown_nmi_error (reason, regs);
    return;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/traps_64.c.ifdefed" startline="817" endline="826">
{
    trace_hardirqs_fixup ();
    if (notify_die (DIE_INT3, "int3", regs, error_code, 3, SIGTRAP) == NOTIFY_STOP) {
        return;
    }
    preempt_conditional_sti (regs);
    do_trap (3, SIGTRAP, "int3", regs, error_code, NULL);
    preempt_conditional_cli (regs);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/traps_64.c.ifdefed" startline="820" endline="822">
{
    return;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/traps_64.c.ifdefed" startline="832" endline="847">
{
    struct pt_regs *regs = eregs;
    if (eregs == (struct pt_regs *) eregs->rsp)
        ;
    else if (user_mode (eregs))
        regs = task_pt_regs (current);
    else if (eregs->eflags & X86_EFLAGS_IF)
        regs = (struct pt_regs *) (eregs->rsp -= sizeof (struct pt_regs));
    if (eregs != regs)
        *regs = *eregs;
    return regs;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/traps_64.c.ifdefed" startline="852" endline="917">
{
    unsigned long condition;
    struct task_struct *tsk = current;
    siginfo_t info;
    trace_hardirqs_fixup ();
    get_debugreg (condition, 6);
    if (notify_die (DIE_DEBUG, "debug", regs, condition, error_code, SIGTRAP) == NOTIFY_STOP)
        return;
    preempt_conditional_sti (regs);
    if (condition & (DR_TRAP0 | DR_TRAP1 | DR_TRAP2 | DR_TRAP3)) {
        if (!tsk->thread.debugreg7) {
            goto clear_dr7;
        }
    }
    tsk->thread.debugreg6 = condition;
    if (condition & DR_STEP) {
        if (!user_mode (regs))
            goto clear_TF_reenable;
        if (tsk->ptrace & PT_DTRACE) {
            regs->eflags &= ~TF_MASK;
            tsk->ptrace &= ~PT_DTRACE;
        }
    }
    tsk->thread.trap_no = 1;
    tsk->thread.error_code = error_code;
    info.si_signo = SIGTRAP;
    info.si_errno = 0;
    info.si_code = TRAP_BRKPT;
    info.si_addr = user_mode (regs) ? (void __user *) regs->rip : NULL;
    force_sig_info (SIGTRAP, & info, tsk);
clear_dr7 :
    set_debugreg (0UL, 7);
    preempt_conditional_cli (regs);
    return;
clear_TF_reenable :
    set_tsk_thread_flag (tsk, TIF_SINGLESTEP);
    regs->eflags &= ~TF_MASK;
    preempt_conditional_cli (regs);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/traps_64.c.ifdefed" startline="868" endline="872">
{
    if (!tsk->thread.debugreg7) {
        goto clear_dr7;
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/traps_64.c.ifdefed" startline="869" endline="871">
{
    goto clear_dr7;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/traps_64.c.ifdefed" startline="877" endline="897">
{
    if (!user_mode (regs))
        goto clear_TF_reenable;
    if (tsk->ptrace & PT_DTRACE) {
        regs->eflags &= ~TF_MASK;
        tsk->ptrace &= ~PT_DTRACE;
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/traps_64.c.ifdefed" startline="893" endline="896">
{
    regs->eflags &= ~TF_MASK;
    tsk->ptrace &= ~PT_DTRACE;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/traps_64.c.ifdefed" startline="920" endline="932">
{
    const struct exception_table_entry *fixup;
    fixup = search_exception_tables (regs->rip);
    if (fixup) {
        regs->rip = fixup->fixup;
        return 1;
    }
    notify_die (DIE_GPF, str, regs, 0, trapnr, SIGFPE);
    current->thread.trap_no = trapnr;
    die (str, regs, 0);
    return 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/traps_64.c.ifdefed" startline="923" endline="926">
{
    regs->rip = fixup->fixup;
    return 1;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/traps_64.c.ifdefed" startline="940" endline="1001">
{
    void __user *rip = (void __user *) (regs->rip);
    struct task_struct *task;
    siginfo_t info;
    unsigned short cwd, swd;
    conditional_sti (regs);
    if (!user_mode (regs) && kernel_math_error (regs, "kernel x87 math error", 16))
        return;
    task = current;
    save_init_fpu (task);
    task->thread.trap_no = 16;
    task->thread.error_code = 0;
    info.si_signo = SIGFPE;
    info.si_errno = 0;
    info.si_code = __SI_FAULT;
    info.si_addr = rip;
    cwd = get_fpu_cwd (task);
    swd = get_fpu_swd (task);
    switch (swd & ~cwd & 0x3f) {
    case 0x000 :
    default :
        break;
    case 0x001 :
        info.si_code = FPE_FLTINV;
        break;
    case 0x002 :
    case 0x010 :
        info.si_code = FPE_FLTUND;
        break;
    case 0x004 :
        info.si_code = FPE_FLTDIV;
        break;
    case 0x008 :
        info.si_code = FPE_FLTOVF;
        break;
    case 0x020 :
        info.si_code = FPE_FLTRES;
        break;
    }
    force_sig_info (SIGFPE, & info, task);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/traps_64.c.ifdefed" startline="974" endline="999">
{
case 0x000 :
default :
    break;
case 0x001 :
    info.si_code = FPE_FLTINV;
    break;
case 0x002 :
case 0x010 :
    info.si_code = FPE_FLTUND;
    break;
case 0x004 :
    info.si_code = FPE_FLTDIV;
    break;
case 0x008 :
    info.si_code = FPE_FLTOVF;
    break;
case 0x020 :
    info.si_code = FPE_FLTRES;
    break;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/traps_64.c.ifdefed" startline="1004" endline="1006">
{
    printk ("bad interrupt");
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/traps_64.c.ifdefed" startline="1009" endline="1060">
{
    void __user *rip = (void __user *) (regs->rip);
    struct task_struct *task;
    siginfo_t info;
    unsigned short mxcsr;
    conditional_sti (regs);
    if (!user_mode (regs) && kernel_math_error (regs, "kernel simd math error", 19))
        return;
    task = current;
    save_init_fpu (task);
    task->thread.trap_no = 19;
    task->thread.error_code = 0;
    info.si_signo = SIGFPE;
    info.si_errno = 0;
    info.si_code = __SI_FAULT;
    info.si_addr = rip;
    mxcsr = get_fpu_mxcsr (task);
    switch (~((mxcsr & 0x1f80) >> 7) & (mxcsr & 0x3f)) {
    case 0x000 :
    default :
        break;
    case 0x001 :
        info.si_code = FPE_FLTINV;
        break;
    case 0x002 :
    case 0x010 :
        info.si_code = FPE_FLTUND;
        break;
    case 0x004 :
        info.si_code = FPE_FLTDIV;
        break;
    case 0x008 :
        info.si_code = FPE_FLTOVF;
        break;
    case 0x020 :
        info.si_code = FPE_FLTRES;
        break;
    }
    force_sig_info (SIGFPE, & info, task);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/traps_64.c.ifdefed" startline="1038" endline="1058">
{
case 0x000 :
default :
    break;
case 0x001 :
    info.si_code = FPE_FLTINV;
    break;
case 0x002 :
case 0x010 :
    info.si_code = FPE_FLTUND;
    break;
case 0x004 :
    info.si_code = FPE_FLTDIV;
    break;
case 0x008 :
    info.si_code = FPE_FLTOVF;
    break;
case 0x020 :
    info.si_code = FPE_FLTRES;
    break;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/traps_64.c.ifdefed" startline="1063" endline="1064">
{
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/traps_64.c.ifdefed" startline="1067" endline="1068">
{
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/traps_64.c.ifdefed" startline="1071" endline="1072">
{
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/traps_64.c.ifdefed" startline="1082" endline="1091">
{
    struct task_struct *me = current;
    clts ();
    if (!used_math ())
        init_fpu (me);
    restore_fpu_checking (& me -> thread.i387.fxsave);
    task_thread_info (me)->status |= TS_USEDFPU;
    me->fpu_counter++;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/traps_64.c.ifdefed" startline="1094" endline="1126">
{
    set_intr_gate (0, & divide_error);
    set_intr_gate_ist (1, & debug, DEBUG_STACK);
    set_intr_gate_ist (2, & nmi, NMI_STACK);
    set_system_gate_ist (3, & int3, DEBUG_STACK);
    set_system_gate (4, & overflow);
    set_intr_gate (5, & bounds);
    set_intr_gate (6, & invalid_op);
    set_intr_gate (7, & device_not_available);
    set_intr_gate_ist (8, & double_fault, DOUBLEFAULT_STACK);
    set_intr_gate (9, & coprocessor_segment_overrun);
    set_intr_gate (10, & invalid_TSS);
    set_intr_gate (11, & segment_not_present);
    set_intr_gate_ist (12, & stack_segment, STACKFAULT_STACK);
    set_intr_gate (13, & general_protection);
    set_intr_gate (14, & page_fault);
    set_intr_gate (15, & spurious_interrupt_bug);
    set_intr_gate (16, & coprocessor_error);
    set_intr_gate (17, & alignment_check);
    set_intr_gate (19, & simd_coprocessor_error);
    cpu_init ();
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/traps_64.c.ifdefed" startline="1130" endline="1136">
{
    if (!s)
        return -EINVAL;
    if (!strcmp (s, "panic"))
        panic_on_oops = 1;
    return 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/traps_64.c.ifdefed" startline="1140" endline="1145">
{
    if (!s)
        return -EINVAL;
    kstack_depth_to_print = simple_strtoul (s, NULL, 0);
    return 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/acpi/cstate.c.ifdefed" startline="31" endline="45">
{
    struct cpuinfo_x86 *c = &cpu_data (cpu);
    flags->bm_check = 0;
    if (num_online_cpus () == 1)
        flags->bm_check = 1;
    else if (c->x86_vendor == X86_VENDOR_INTEL) {
        flags->bm_check = 1;
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/acpi/cstate.c.ifdefed" startline="37" endline="44">
{
    flags->bm_check = 1;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/acpi/cstate.c.ifdefed" startline="73" endline="133">
{
    struct cstate_entry *percpu_entry;
    struct cpuinfo_x86 *c = &cpu_data (cpu);
    cpumask_t saved_mask;
    int retval;
    unsigned int eax, ebx, ecx, edx;
    unsigned int edx_part;
    unsigned int cstate_type;
    unsigned int num_cstate_subtype;
    if (!cpu_cstate_entry || c->cpuid_level < CPUID_MWAIT_LEAF)
        return -1;
    if (reg->bit_offset != NATIVE_CSTATE_BEYOND_HALT)
        return -1;
    percpu_entry = per_cpu_ptr (cpu_cstate_entry, cpu);
    percpu_entry->states[cx->index].eax = 0;
    percpu_entry->states[cx->index].ecx = 0;
    saved_mask = current->cpus_allowed;
    retval = set_cpus_allowed (current, cpumask_of_cpu (cpu));
    if (retval)
        return -1;
    cpuid (CPUID_MWAIT_LEAF, & eax, & ebx, & ecx, & edx);
    cstate_type = (cx->address >> MWAIT_SUBSTATE_SIZE) + 1;
    edx_part = edx >> (cstate_type * MWAIT_SUBSTATE_SIZE);
    num_cstate_subtype = edx_part & MWAIT_SUBSTATE_MASK;
    retval = 0;
    if (num_cstate_subtype < (cx->address & MWAIT_SUBSTATE_MASK)) {
        retval = -1;
        goto out;
    }
    if (!(ecx & CPUID5_ECX_EXTENSIONS_SUPPORTED) || !(ecx & CPUID5_ECX_INTERRUPT_BREAK)) {
        retval = -1;
        goto out;
    }
    percpu_entry->states[cx->index].ecx = MWAIT_ECX_INTERRUPT_BREAK;
    percpu_entry->states[cx->index].eax = cx->address;
    if (!mwait_supported[cstate_type]) {
        mwait_supported[cstate_type] = 1;
        printk (KERN_DEBUG "Monitor-Mwait will be used to enter C-%d " "state\n", cx -> type);
    }
out :
    set_cpus_allowed (current, saved_mask);
    return retval;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/acpi/cstate.c.ifdefed" startline="108" endline="111">
{
    retval = -1;
    goto out;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/acpi/cstate.c.ifdefed" startline="115" endline="118">
{
    retval = -1;
    goto out;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/acpi/cstate.c.ifdefed" startline="124" endline="128">
{
    mwait_supported[cstate_type] = 1;
    printk (KERN_DEBUG "Monitor-Mwait will be used to enter C-%d " "state\n", cx -> type);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/acpi/cstate.c.ifdefed" startline="137" endline="144">
{
    unsigned int cpu = smp_processor_id ();
    struct cstate_entry *percpu_entry;
    percpu_entry = per_cpu_ptr (cpu_cstate_entry, cpu);
    mwait_idle_with_hints (percpu_entry -> states [cx -> index].eax, percpu_entry -> states [cx -> index].ecx);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/acpi/cstate.c.ifdefed" startline="148" endline="155">
{
    struct cpuinfo_x86 *c = &boot_cpu_data;
    if (c->x86_vendor != X86_VENDOR_INTEL)
        return -1;
    cpu_cstate_entry = alloc_percpu (struct cstate_entry);
    return 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/acpi/cstate.c.ifdefed" startline="158" endline="161">
{
    free_percpu (cpu_cstate_entry);
    cpu_cstate_entry = NULL;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/acpi/processor.c.ifdefed" startline="18" endline="63">
{
    struct acpi_object_list *obj_list;
    union acpi_object *obj;
    u32 *buf;
    obj_list = kmalloc (sizeof (struct acpi_object_list), GFP_KERNEL);
    if (!obj_list) {
        printk (KERN_ERR "Memory allocation error\n");
        return;
    }
    obj = kmalloc (sizeof (union acpi_object), GFP_KERNEL);
    if (!obj) {
        printk (KERN_ERR "Memory allocation error\n");
        kfree (obj_list);
        return;
    }
    buf = kmalloc (12, GFP_KERNEL);
    if (!buf) {
        printk (KERN_ERR "Memory allocation error\n");
        kfree (obj);
        kfree (obj_list);
        return;
    }
    buf[0] = ACPI_PDC_REVISION_ID;
    buf[1] = 1;
    buf[2] = ACPI_PDC_C_CAPABILITY_SMP;
    if (cpu_has (c, X86_FEATURE_EST))
        buf[2] |= ACPI_PDC_EST_CAPABILITY_SWSMP;
    if (cpu_has (c, X86_FEATURE_ACPI))
        buf[2] |= ACPI_PDC_T_FFH;
    obj->type = ACPI_TYPE_BUFFER;
    obj->buffer.length = 12;
    obj->buffer.pointer = (u8 *) buf;
    obj_list->count = 1;
    obj_list->pointer = obj;
    pr->pdc = obj_list;
    return;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/acpi/processor.c.ifdefed" startline="25" endline="28">
{
    printk (KERN_ERR "Memory allocation error\n");
    return;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/acpi/processor.c.ifdefed" startline="31" endline="35">
{
    printk (KERN_ERR "Memory allocation error\n");
    kfree (obj_list);
    return;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/acpi/processor.c.ifdefed" startline="38" endline="43">
{
    printk (KERN_ERR "Memory allocation error\n");
    kfree (obj);
    kfree (obj_list);
    return;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/acpi/processor.c.ifdefed" startline="67" endline="75">
{
    struct cpuinfo_x86 *c = &cpu_data (pr->id);
    pr->pdc = NULL;
    if (c->x86_vendor == X86_VENDOR_INTEL)
        init_intel_pdc (pr, c);
    return;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/acpi/sleep_64.c.ifdefed" startline="68" endline="74">
{
    memcpy ((void *) acpi_wakeup_address, & wakeup_start, & wakeup_end - & wakeup_start);
    acpi_copy_wakeup_routine (acpi_wakeup_address);
    return 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/acpi/sleep_64.c.ifdefed" startline="80" endline="81">
{
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/acpi/sleep_64.c.ifdefed" startline="92" endline="98">
{
    acpi_wakeup_address = (unsigned long) alloc_bootmem_low (PAGE_SIZE *2);
    if ((&wakeup_end - &wakeup_start) > (PAGE_SIZE * 2))
        printk (KERN_CRIT "ACPI: Wakeup code way too big, will crash on attempt" " to suspend\n");
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/acpi/sleep_64.c.ifdefed" startline="101" endline="114">
{
    while ((str != NULL) && (*str != '\0')) {
        if (strncmp (str, "s3_bios", 7) == 0)
            acpi_realmode_flags |= 1;
        if (strncmp (str, "s3_mode", 7) == 0)
            acpi_realmode_flags |= 2;
        if (strncmp (str, "s3_beep", 7) == 0)
            acpi_realmode_flags |= 4;
        str = strchr (str, ',');
        if (str != NULL)
            str += strspn (str, ", \t");
    }
    return 1;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/acpi/sleep_64.c.ifdefed" startline="102" endline="112">
{
    if (strncmp (str, "s3_bios", 7) == 0)
        acpi_realmode_flags |= 1;
    if (strncmp (str, "s3_mode", 7) == 0)
        acpi_realmode_flags |= 2;
    if (strncmp (str, "s3_beep", 7) == 0)
        acpi_realmode_flags |= 4;
    str = strchr (str, ',');
    if (str != NULL)
        str += strspn (str, ", \t");
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/acpi/boot.c.ifdefed" startline="135" endline="160">
{
    unsigned long base, offset, mapped_size;
    int idx;
    if (phys + size < 8 * 1024 * 1024)
        return __va (phys);
    offset = phys & (PAGE_SIZE - 1);
    mapped_size = PAGE_SIZE - offset;
    set_fixmap (FIX_ACPI_END, phys);
    base = fix_to_virt (FIX_ACPI_END);
    idx = FIX_ACPI_END;
    while (mapped_size < size) {
        if (--idx < FIX_ACPI_BEGIN)
            return NULL;
        phys += PAGE_SIZE;
        set_fixmap (idx, phys);
        mapped_size += PAGE_SIZE;
    }
    return ((unsigned char *) base + offset);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/acpi/boot.c.ifdefed" startline="151" endline="157">
{
    if (--idx < FIX_ACPI_BEGIN)
        return NULL;
    phys += PAGE_SIZE;
    set_fixmap (idx, phys);
    mapped_size += PAGE_SIZE;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/acpi/boot.c.ifdefed" startline="422" endline="455">
{
    unsigned int mask = 1 << irq;
    unsigned int old, new;
    old = inb (0x4d0) | (inb (0x4d1) << 8);
    new = acpi_noirq ? old : 0;
    switch (trigger) {
    case 1 :
        new &= ~mask;
        break;
    case 3 :
        new |= mask;
        break;
    }
    if (old == new)
        return;
    printk (PREFIX "setting ELCR to %04x (from %04x)\n", new, old);
    outb (new, 0x4d0);
    outb (new >> 8, 0x4d1);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/acpi/boot.c.ifdefed" startline="440" endline="447">
{
case 1 :
    new &= ~mask;
    break;
case 3 :
    new |= mask;
    break;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/acpi/boot.c.ifdefed" startline="458" endline="461">
{
    *irq = gsi;
    return 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/acpi/boot.c.ifdefed" startline="468" endline="491">
{
    unsigned int irq;
    unsigned int plat_gsi = gsi;
    acpi_gsi_to_irq (plat_gsi, & irq);
    return irq;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/acpi/boot.c.ifdefed" startline="569" endline="572">
{
    return -EINVAL;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/acpi/boot.c.ifdefed" startline="577" endline="580">
{
    return -EINVAL;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/acpi/boot.c.ifdefed" startline="586" endline="601">
{
    unsigned long offset = 0;
    unsigned long sig_len = sizeof ("RSD PTR ") - 1;
    for (offset = 0; offset < length; offset += 16) {
        if (strncmp ((char *) (phys_to_virt (start) + offset), "RSD PTR ", sig_len))
            continue;
        return (start + offset);
    }
    return 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/acpi/boot.c.ifdefed" startline="594" endline="598">
{
    if (strncmp ((char *) (phys_to_virt (start) + offset), "RSD PTR ", sig_len))
        continue;
    return (start + offset);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/acpi/boot.c.ifdefed" startline="604" endline="616">
{
    struct acpi_table_boot *sb;
    sb = (struct acpi_table_boot *) table;
    if (!sb) {
        printk (KERN_WARNING PREFIX "Unable to map SBF\n");
        return -ENODEV;
    }
    sbf_port = sb->cmos_index;
    return 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/acpi/boot.c.ifdefed" startline="608" endline="611">
{
    printk (KERN_WARNING PREFIX "Unable to map SBF\n");
    return -ENODEV;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/acpi/boot.c.ifdefed" startline="716" endline="743">
{
    return 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/acpi/boot.c.ifdefed" startline="746" endline="764">
{
    unsigned long rsdp_phys = 0;
    if (efi_enabled) {
        if (efi.acpi20 != EFI_INVALID_TABLE_ADDR)
            return efi.acpi20;
        else if (efi.acpi != EFI_INVALID_TABLE_ADDR)
            return efi.acpi;
    }
    rsdp_phys = acpi_scan_rsdp (0, 0x400);
    if (!rsdp_phys)
        rsdp_phys = acpi_scan_rsdp (0xE0000, 0x20000);
    return rsdp_phys;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/acpi/boot.c.ifdefed" startline="749" endline="754">
{
    if (efi.acpi20 != EFI_INVALID_TABLE_ADDR)
        return efi.acpi20;
    else if (efi.acpi != EFI_INVALID_TABLE_ADDR)
        return efi.acpi;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/acpi/boot.c.ifdefed" startline="892" endline="894">
{
    return -1;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/acpi/boot.c.ifdefed" startline="898" endline="938">
{
    return;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/acpi/boot.c.ifdefed" startline="1187" endline="1227">
{
    int error;
    if (acpi_disabled && !acpi_ht)
        return 1;
    error = acpi_table_init ();
    if (error) {
        disable_acpi ();
        return error;
    }
    acpi_table_parse (ACPI_SIG_BOOT, acpi_parse_sbf);
    error = acpi_blacklisted ();
    if (error) {
        if (acpi_force) {
            printk (KERN_WARNING PREFIX "acpi=force override\n");
        }
        else {
            printk (KERN_WARNING PREFIX "Disabling ACPI support\n");
            disable_acpi ();
            return error;
        }
    }
    return 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/acpi/boot.c.ifdefed" startline="1205" endline="1208">
{
    disable_acpi ();
    return error;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/acpi/boot.c.ifdefed" startline="1216" endline="1224">
{
    if (acpi_force) {
        printk (KERN_WARNING PREFIX "acpi=force override\n");
    }
    else {
        printk (KERN_WARNING PREFIX "Disabling ACPI support\n");
        disable_acpi ();
        return error;
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/acpi/boot.c.ifdefed" startline="1217" endline="1219">
{
    printk (KERN_WARNING PREFIX "acpi=force override\n");
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/acpi/boot.c.ifdefed" startline="1219" endline="1223">
{
    printk (KERN_WARNING PREFIX "Disabling ACPI support\n");
    disable_acpi ();
    return error;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/acpi/boot.c.ifdefed" startline="1230" endline="1253">
{
    if (acpi_disabled && !acpi_ht)
        return 1;
    acpi_table_parse (ACPI_SIG_BOOT, acpi_parse_sbf);
    acpi_table_parse (ACPI_SIG_FADT, acpi_parse_fadt);
    acpi_process_madt ();
    acpi_table_parse (ACPI_SIG_HPET, acpi_parse_hpet);
    return 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/acpi/boot.c.ifdefed" startline="1256" endline="1288">
{
    if (!arg)
        return -EINVAL;
    if (strcmp (arg, "off") == 0) {
        disable_acpi ();
    }
    else if (strcmp (arg, "force") == 0) {
        acpi_force = 1;
        acpi_ht = 1;
        acpi_disabled = 0;
    }
    else if (strcmp (arg, "strict") == 0) {
        acpi_strict = 1;
    }
    else if (strcmp (arg, "ht") == 0) {
        if (!acpi_force)
            disable_acpi ();
        acpi_ht = 1;
    }
    else if (strcmp (arg, "noirq") == 0) {
        acpi_noirq_set ();
    }
    else {
        return -EINVAL;
    }
    return 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/acpi/boot.c.ifdefed" startline="1261" endline="1263">
{
    disable_acpi ();
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/acpi/boot.c.ifdefed" startline="1265" endline="1269">
{
    acpi_force = 1;
    acpi_ht = 1;
    acpi_disabled = 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/acpi/boot.c.ifdefed" startline="1271" endline="1273">
{
    acpi_strict = 1;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/acpi/boot.c.ifdefed" startline="1275" endline="1279">
{
    if (!acpi_force)
        disable_acpi ();
    acpi_ht = 1;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/acpi/boot.c.ifdefed" startline="1281" endline="1283">
{
    acpi_noirq_set ();
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/acpi/boot.c.ifdefed" startline="1283" endline="1286">
{
    return -EINVAL;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/acpi/boot.c.ifdefed" startline="1293" endline="1297">
{
    if (arg && strcmp (arg, "noacpi") == 0)
        acpi_disable_pci ();
    return 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/acpi/boot.c.ifdefed" startline="1317" endline="1335">
{
    if (!s)
        return -EINVAL;
    if (!strcmp (s, "edge"))
        acpi_sci_flags = ACPI_MADT_TRIGGER_EDGE | (acpi_sci_flags & ~ACPI_MADT_TRIGGER_MASK);
    else if (!strcmp (s, "level"))
        acpi_sci_flags = ACPI_MADT_TRIGGER_LEVEL | (acpi_sci_flags & ~ACPI_MADT_TRIGGER_MASK);
    else if (!strcmp (s, "high"))
        acpi_sci_flags = ACPI_MADT_POLARITY_ACTIVE_HIGH | (acpi_sci_flags & ~ACPI_MADT_POLARITY_MASK);
    else if (!strcmp (s, "low"))
        acpi_sci_flags = ACPI_MADT_POLARITY_ACTIVE_LOW | (acpi_sci_flags & ~ACPI_MADT_POLARITY_MASK);
    else
        return -EINVAL;
    return 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/acpi/boot.c.ifdefed" startline="1339" endline="1347">
{
    unsigned int old, new, val;
    do {
        old = *lock;
        new = (((old & ~0x3) + 2) + ((old >> 1) & 0x1));
        val = cmpxchg (lock, old, new);
    }
    while (unlikely (val != old));
    return (new < 3) ? -1 : 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/acpi/boot.c.ifdefed" startline="1341" endline="1345">
{
    old = *lock;
    new = (((old & ~0x3) + 2) + ((old >> 1) & 0x1));
    val = cmpxchg (lock, old, new);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/acpi/boot.c.ifdefed" startline="1350" endline="1358">
{
    unsigned int old, new, val;
    do {
        old = *lock;
        new = old & ~0x3;
        val = cmpxchg (lock, old, new);
    }
    while (unlikely (val != old));
    return old & 0x1;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/acpi/boot.c.ifdefed" startline="1352" endline="1356">
{
    old = *lock;
    new = old & ~0x3;
    val = cmpxchg (lock, old, new);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/apic_64.c.ifdefed" startline="83" endline="86">
{
    apic_write (APIC_TMICT, delta);
    return 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/apic_64.c.ifdefed" startline="90" endline="118">
{
    unsigned long flags;
    unsigned int v;
    if (evt->features & CLOCK_EVT_FEAT_DUMMY)
        return;
    local_irq_save (flags);
    switch (mode) {
    case CLOCK_EVT_MODE_PERIODIC :
    case CLOCK_EVT_MODE_ONESHOT :
        __setup_APIC_LVTT (calibration_result, mode != CLOCK_EVT_MODE_PERIODIC, 1);
        break;
    case CLOCK_EVT_MODE_UNUSED :
    case CLOCK_EVT_MODE_SHUTDOWN :
        v = apic_read (APIC_LVTT);
        v |= (APIC_LVT_MASKED | LOCAL_TIMER_VECTOR);
        apic_write (APIC_LVTT, v);
        break;
    case CLOCK_EVT_MODE_RESUME :
        break;
    }
    local_irq_restore (flags);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/apic_64.c.ifdefed" startline="100" endline="115">
{
case CLOCK_EVT_MODE_PERIODIC :
case CLOCK_EVT_MODE_ONESHOT :
    __setup_APIC_LVTT (calibration_result, mode != CLOCK_EVT_MODE_PERIODIC, 1);
    break;
case CLOCK_EVT_MODE_UNUSED :
case CLOCK_EVT_MODE_SHUTDOWN :
    v = apic_read (APIC_LVTT);
    v |= (APIC_LVT_MASKED | LOCAL_TIMER_VECTOR);
    apic_write (APIC_LVTT, v);
    break;
case CLOCK_EVT_MODE_RESUME :
    break;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/apic_64.c.ifdefed" startline="124" endline="128">
{
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/apic_64.c.ifdefed" startline="133" endline="136">
{
    while (apic_read (APIC_ICR) & APIC_ICR_BUSY)
        cpu_relax ();
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/apic_64.c.ifdefed" startline="139" endline="152">
{
    unsigned int send_status;
    int timeout;
    timeout = 0;
    do {
        send_status = apic_read (APIC_ICR) & APIC_ICR_BUSY;
        if (!send_status)
            break;
        udelay (100);
    }
    while (timeout++ < 1000);
    return send_status;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/apic_64.c.ifdefed" startline="144" endline="149">
{
    send_status = apic_read (APIC_ICR) & APIC_ICR_BUSY;
    if (!send_status)
        break;
    udelay (100);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/apic_64.c.ifdefed" startline="155" endline="161">
{
    unsigned int v;
    v = APIC_DM_NMI;
    apic_write (APIC_LVT0, v);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/apic_64.c.ifdefed" startline="164" endline="170">
{
    unsigned int v, maxlvt;
    v = apic_read (APIC_LVR);
    maxlvt = GET_APIC_MAXLVT (v);
    return maxlvt;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/apic_64.c.ifdefed" startline="177" endline="190">
{
    printk ("unexpected IRQ trap at vector %02x\n", irq);
    if (!disable_apic)
        ack_APIC_irq ();
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/apic_64.c.ifdefed" startline="193" endline="234">
{
    int maxlvt;
    unsigned int v;
    maxlvt = get_maxlvt ();
    if (maxlvt >= 3) {
        v = ERROR_APIC_VECTOR;
        apic_write (APIC_LVTERR, v | APIC_LVT_MASKED);
    }
    v = apic_read (APIC_LVTT);
    apic_write (APIC_LVTT, v | APIC_LVT_MASKED);
    v = apic_read (APIC_LVT0);
    apic_write (APIC_LVT0, v | APIC_LVT_MASKED);
    v = apic_read (APIC_LVT1);
    apic_write (APIC_LVT1, v | APIC_LVT_MASKED);
    if (maxlvt >= 4) {
        v = apic_read (APIC_LVTPC);
        apic_write (APIC_LVTPC, v | APIC_LVT_MASKED);
    }
    apic_write (APIC_LVTT, APIC_LVT_MASKED);
    apic_write (APIC_LVT0, APIC_LVT_MASKED);
    apic_write (APIC_LVT1, APIC_LVT_MASKED);
    if (maxlvt >= 3)
        apic_write (APIC_LVTERR, APIC_LVT_MASKED);
    if (maxlvt >= 4)
        apic_write (APIC_LVTPC, APIC_LVT_MASKED);
    apic_write (APIC_ESR, 0);
    apic_read (APIC_ESR);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/apic_64.c.ifdefed" startline="203" endline="206">
{
    v = ERROR_APIC_VECTOR;
    apic_write (APIC_LVTERR, v | APIC_LVT_MASKED);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/apic_64.c.ifdefed" startline="217" endline="220">
{
    v = apic_read (APIC_LVTPC);
    apic_write (APIC_LVTPC, v | APIC_LVT_MASKED);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/apic_64.c.ifdefed" startline="237" endline="273">
{
    unsigned long value;
    value = apic_read (APIC_SPIV);
    value &= ~APIC_VECTOR_MASK;
    value |= APIC_SPIV_APIC_ENABLED;
    value |= 0xf;
    apic_write (APIC_SPIV, value);
    if (!virt_wire_setup) {
        value = apic_read (APIC_LVT0);
        value &= ~(APIC_MODE_MASK | APIC_SEND_PENDING | APIC_INPUT_POLARITY | APIC_LVT_REMOTE_IRR | APIC_LVT_LEVEL_TRIGGER | APIC_LVT_MASKED);
        value |= APIC_LVT_REMOTE_IRR | APIC_SEND_PENDING;
        value = SET_APIC_DELIVERY_MODE (value, APIC_MODE_EXTINT);
        apic_write (APIC_LVT0, value);
    }
    else {
        apic_write (APIC_LVT0, APIC_LVT_MASKED);
    }
    value = apic_read (APIC_LVT1);
    value &= ~(APIC_MODE_MASK | APIC_SEND_PENDING | APIC_INPUT_POLARITY | APIC_LVT_REMOTE_IRR | APIC_LVT_LEVEL_TRIGGER | APIC_LVT_MASKED);
    value |= APIC_LVT_REMOTE_IRR | APIC_SEND_PENDING;
    value = SET_APIC_DELIVERY_MODE (value, APIC_MODE_NMI);
    apic_write (APIC_LVT1, value);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/apic_64.c.ifdefed" startline="248" endline="260">
{
    value = apic_read (APIC_LVT0);
    value &= ~(APIC_MODE_MASK | APIC_SEND_PENDING | APIC_INPUT_POLARITY | APIC_LVT_REMOTE_IRR | APIC_LVT_LEVEL_TRIGGER | APIC_LVT_MASKED);
    value |= APIC_LVT_REMOTE_IRR | APIC_SEND_PENDING;
    value = SET_APIC_DELIVERY_MODE (value, APIC_MODE_EXTINT);
    apic_write (APIC_LVT0, value);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/apic_64.c.ifdefed" startline="260" endline="263">
{
    apic_write (APIC_LVT0, APIC_LVT_MASKED);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/apic_64.c.ifdefed" startline="276" endline="288">
{
    unsigned int value;
    clear_local_APIC ();
    value = apic_read (APIC_SPIV);
    value &= ~APIC_SPIV_APIC_ENABLED;
    apic_write (APIC_SPIV, value);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/apic_64.c.ifdefed" startline="291" endline="302">
{
    unsigned long flags;
    if (!cpu_has_apic)
        return;
    local_irq_save (flags);
    disable_local_APIC ();
    local_irq_restore (flags);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/apic_64.c.ifdefed" startline="310" endline="363">
{
    unsigned int reg0, reg1;
    reg0 = apic_read (APIC_LVR);
    apic_printk (APIC_DEBUG, "Getting VERSION: %x\n", reg0);
    apic_write (APIC_LVR, reg0 ^ APIC_LVR_MASK);
    reg1 = apic_read (APIC_LVR);
    apic_printk (APIC_DEBUG, "Getting VERSION: %x\n", reg1);
    if (reg1 != reg0)
        return 0;
    reg1 = GET_APIC_VERSION (reg0);
    if (reg1 == 0x00 || reg1 == 0xff)
        return 0;
    reg1 = get_maxlvt ();
    if (reg1 < 0x02 || reg1 == 0xff)
        return 0;
    reg0 = apic_read (APIC_ID);
    apic_printk (APIC_DEBUG, "Getting ID: %x\n", reg0);
    apic_write (APIC_ID, reg0 ^ APIC_ID_MASK);
    reg1 = apic_read (APIC_ID);
    apic_printk (APIC_DEBUG, "Getting ID: %x\n", reg1);
    apic_write (APIC_ID, reg0);
    if (reg1 != (reg0 ^ APIC_ID_MASK))
        return 0;
    reg0 = apic_read (APIC_LVT0);
    apic_printk (APIC_DEBUG, "Getting LVT0: %x\n", reg0);
    reg1 = apic_read (APIC_LVT1);
    apic_printk (APIC_DEBUG, "Getting LVT1: %x\n", reg1);
    return 1;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/apic_64.c.ifdefed" startline="366" endline="380">
{
    unsigned int ver = GET_APIC_VERSION (apic_read (APIC_LVR));
    if (ver >= 0x14)
        return;
    apic_wait_icr_idle ();
    apic_printk (APIC_DEBUG, "Synchronizing Arb IDs.\n");
    apic_write (APIC_ICR, APIC_DEST_ALLINC | APIC_INT_LEVELTRIG | APIC_DM_INIT);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/apic_64.c.ifdefed" startline="386" endline="419">
{
    unsigned int value;
    if (smp_found_config || !cpu_has_apic)
        return;
    value = apic_read (APIC_LVR);
    clear_local_APIC ();
    value = apic_read (APIC_SPIV);
    value &= ~APIC_VECTOR_MASK;
    value |= APIC_SPIV_APIC_ENABLED;
    value |= APIC_SPIV_FOCUS_DISABLED;
    value |= SPURIOUS_APIC_VECTOR;
    apic_write (APIC_SPIV, value);
    apic_write (APIC_LVT0, APIC_DM_EXTINT);
    value = APIC_DM_NMI;
    apic_write (APIC_LVT1, value);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/apic_64.c.ifdefed" startline="422" endline="541">
{
    unsigned int value, maxlvt;
    int i, j;
    value = apic_read (APIC_LVR);
    BUILD_BUG_ON ((SPURIOUS_APIC_VECTOR & 0x0f) != 0x0f);
    if (!apic_id_registered ())
        BUG ();
    init_apic_ldr ();
    value = apic_read (APIC_TASKPRI);
    value &= ~APIC_TPRI_MASK;
    apic_write (APIC_TASKPRI, value);
    for (i = APIC_ISR_NR - 1; i >= 0; i--) {
        value = apic_read (APIC_ISR +i * 0x10);
        for (j = 31; j >= 0; j--) {
            if (value & (1 << j))
                ack_APIC_irq ();
        }
    }
    value = apic_read (APIC_SPIV);
    value &= ~APIC_VECTOR_MASK;
    value |= APIC_SPIV_APIC_ENABLED;
    value |= SPURIOUS_APIC_VECTOR;
    apic_write (APIC_SPIV, value);
    value = apic_read (APIC_LVT0) & APIC_LVT_MASKED;
    if (!smp_processor_id () && !value) {
        value = APIC_DM_EXTINT;
        apic_printk (APIC_VERBOSE, "enabled ExtINT on CPU#%d\n", smp_processor_id ());
    }
    else {
        value = APIC_DM_EXTINT | APIC_LVT_MASKED;
        apic_printk (APIC_VERBOSE, "masked ExtINT on CPU#%d\n", smp_processor_id ());
    }
    apic_write (APIC_LVT0, value);
    if (!smp_processor_id ())
        value = APIC_DM_NMI;
    else
        value = APIC_DM_NMI | APIC_LVT_MASKED;
    apic_write (APIC_LVT1, value);
    {
        unsigned oldvalue;
        maxlvt = get_maxlvt ();
        oldvalue = apic_read (APIC_ESR);
        value = ERROR_APIC_VECTOR;
        apic_write (APIC_LVTERR, value);
        if (maxlvt > 3)
            apic_write (APIC_ESR, 0);
        value = apic_read (APIC_ESR);
        if (value != oldvalue)
            apic_printk (APIC_VERBOSE, "ESR value after enabling vector: %08x, after %08x\n", oldvalue, value);
    }
    nmi_watchdog_default ();
    setup_apic_nmi_watchdog (NULL);
    apic_pm_activate ();
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/apic_64.c.ifdefed" startline="463" endline="469">
{
    value = apic_read (APIC_ISR +i * 0x10);
    for (j = 31; j >= 0; j--) {
        if (value & (1 << j))
            ack_APIC_irq ();
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/apic_64.c.ifdefed" startline="465" endline="468">
{
    if (value & (1 << j))
        ack_APIC_irq ();
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/apic_64.c.ifdefed" startline="500" endline="504">
{
    value = APIC_DM_EXTINT;
    apic_printk (APIC_VERBOSE, "enabled ExtINT on CPU#%d\n", smp_processor_id ());
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/apic_64.c.ifdefed" startline="504" endline="508">
{
    value = APIC_DM_EXTINT | APIC_LVT_MASKED;
    apic_printk (APIC_VERBOSE, "masked ExtINT on CPU#%d\n", smp_processor_id ());
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/apic_64.c.ifdefed" startline="520" endline="536">
{
    unsigned oldvalue;
    maxlvt = get_maxlvt ();
    oldvalue = apic_read (APIC_ESR);
    value = ERROR_APIC_VECTOR;
    apic_write (APIC_LVTERR, value);
    if (maxlvt > 3)
        apic_write (APIC_ESR, 0);
    value = apic_read (APIC_ESR);
    if (value != oldvalue)
        apic_printk (APIC_VERBOSE, "ESR value after enabling vector: %08x, after %08x\n", oldvalue, value);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/apic_64.c.ifdefed" startline="672" endline="672">
{
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/apic_64.c.ifdefed" startline="677" endline="694">
{
    if (str == NULL) {
        skip_ioapic_setup = 0;
        ioapic_force = 1;
        return 0;
    }
    if (strcmp ("debug", str) == 0)
        apic_verbosity = APIC_DEBUG;
    else if (strcmp ("verbose", str) == 0)
        apic_verbosity = APIC_VERBOSE;
    else {
        printk (KERN_WARNING "APIC Verbosity level %s not recognised" " use apic=verbose or apic=debug\n", str);
        return -EINVAL;
    }
    return 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/apic_64.c.ifdefed" startline="678" endline="682">
{
    skip_ioapic_setup = 0;
    ioapic_force = 1;
    return 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/apic_64.c.ifdefed" startline="687" endline="691">
{
    printk (KERN_WARNING "APIC Verbosity level %s not recognised" " use apic=verbose or apic=debug\n", str);
    return -EINVAL;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/apic_64.c.ifdefed" startline="705" endline="714">
{
    if (!cpu_has_apic) {
        printk (KERN_INFO "No local APIC present\n");
        return -1;
    }
    mp_lapic_addr = APIC_DEFAULT_PHYS_BASE;
    boot_cpu_id = 0;
    return 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/apic_64.c.ifdefed" startline="706" endline="709">
{
    printk (KERN_INFO "No local APIC present\n");
    return -1;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/apic_64.c.ifdefed" startline="775" endline="831">
{
    unsigned long apic_phys;
    if (!smp_found_config && detect_init_APIC ()) {
        apic_phys = (unsigned long) alloc_bootmem_pages (PAGE_SIZE);
        apic_phys = __pa (apic_phys);
    }
    else
        apic_phys = mp_lapic_addr;
    set_fixmap_nocache (FIX_APIC_BASE, apic_phys);
    apic_printk (APIC_VERBOSE, "mapped APIC to %16lx (%16lx)\n", APIC_BASE, apic_phys);
    lapic_resource.start = apic_phys;
    lapic_resource.end = lapic_resource.start + PAGE_SIZE - 1;
    insert_resource (& iomem_resource, & lapic_resource);
    boot_cpu_id = GET_APIC_ID (apic_read (APIC_ID));
    {
        unsigned long ioapic_phys, idx = FIX_IO_APIC_BASE_0;
        int i;
        struct resource *ioapic_res;
        ioapic_res = ioapic_setup_resources ();
        for (i = 0; i < nr_ioapics; i++) {
            if (smp_found_config) {
                ioapic_phys = mp_ioapics[i].mpc_apicaddr;
            }
            else {
                ioapic_phys = (unsigned long) alloc_bootmem_pages (PAGE_SIZE);
                ioapic_phys = __pa (ioapic_phys);
            }
            set_fixmap_nocache (idx, ioapic_phys);
            apic_printk (APIC_VERBOSE, "mapped IOAPIC to %016lx (%016lx)\n", __fix_to_virt (idx), ioapic_phys);
            idx++;
            if (ioapic_res != NULL) {
                ioapic_res->start = ioapic_phys;
                ioapic_res->end = ioapic_phys + (4 * 1024) - 1;
                ioapic_res++;
            }
        }
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/apic_64.c.ifdefed" startline="783" endline="786">
{
    apic_phys = (unsigned long) alloc_bootmem_pages (PAGE_SIZE);
    apic_phys = __pa (apic_phys);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/apic_64.c.ifdefed" startline="804" endline="830">
{
    unsigned long ioapic_phys, idx = FIX_IO_APIC_BASE_0;
    int i;
    struct resource *ioapic_res;
    ioapic_res = ioapic_setup_resources ();
    for (i = 0; i < nr_ioapics; i++) {
        if (smp_found_config) {
            ioapic_phys = mp_ioapics[i].mpc_apicaddr;
        }
        else {
            ioapic_phys = (unsigned long) alloc_bootmem_pages (PAGE_SIZE);
            ioapic_phys = __pa (ioapic_phys);
        }
        set_fixmap_nocache (idx, ioapic_phys);
        apic_printk (APIC_VERBOSE, "mapped IOAPIC to %016lx (%016lx)\n", __fix_to_virt (idx), ioapic_phys);
        idx++;
        if (ioapic_res != NULL) {
            ioapic_res->start = ioapic_phys;
            ioapic_res->end = ioapic_phys + (4 * 1024) - 1;
            ioapic_res++;
        }
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/apic_64.c.ifdefed" startline="810" endline="829">
{
    if (smp_found_config) {
        ioapic_phys = mp_ioapics[i].mpc_apicaddr;
    }
    else {
        ioapic_phys = (unsigned long) alloc_bootmem_pages (PAGE_SIZE);
        ioapic_phys = __pa (ioapic_phys);
    }
    set_fixmap_nocache (idx, ioapic_phys);
    apic_printk (APIC_VERBOSE, "mapped IOAPIC to %016lx (%016lx)\n", __fix_to_virt (idx), ioapic_phys);
    idx++;
    if (ioapic_res != NULL) {
        ioapic_res->start = ioapic_phys;
        ioapic_res->end = ioapic_phys + (4 * 1024) - 1;
        ioapic_res++;
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/apic_64.c.ifdefed" startline="811" endline="813">
{
    ioapic_phys = mp_ioapics[i].mpc_apicaddr;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/apic_64.c.ifdefed" startline="813" endline="817">
{
    ioapic_phys = (unsigned long) alloc_bootmem_pages (PAGE_SIZE);
    ioapic_phys = __pa (ioapic_phys);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/apic_64.c.ifdefed" startline="824" endline="828">
{
    ioapic_res->start = ioapic_phys;
    ioapic_res->end = ioapic_phys + (4 * 1024) - 1;
    ioapic_res++;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/apic_64.c.ifdefed" startline="845" endline="866">
{
    unsigned int lvtt_value, tmp_value;
    lvtt_value = LOCAL_TIMER_VECTOR;
    if (!oneshot)
        lvtt_value |= APIC_LVT_TIMER_PERIODIC;
    if (!irqen)
        lvtt_value |= APIC_LVT_MASKED;
    apic_write (APIC_LVTT, lvtt_value);
    tmp_value = apic_read (APIC_TDCR);
    apic_write (APIC_TDCR, (tmp_value & ~ (APIC_TDR_DIV_1 | APIC_TDR_DIV_TMBASE)) | APIC_TDR_DIV_16);
    if (!oneshot)
        apic_write (APIC_TMICT, clocks);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/apic_64.c.ifdefed" startline="869" endline="876">
{
    struct clock_event_device *levt = &__get_cpu_var (lapic_events);
    memcpy (levt, & lapic_clockevent, sizeof (* levt));
    levt->cpumask = cpumask_of_cpu (smp_processor_id ());
    clockevents_register_device (levt);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/apic_64.c.ifdefed" startline="894" endline="946">
{
    unsigned apic, apic_start;
    unsigned long tsc, tsc_start;
    int result;
    local_irq_disable ();
    __setup_APIC_LVTT (250000000, 0, 0);
    apic_start = apic_read (APIC_TMCCT);
    {
        rdtscll (tsc_start);
        do {
            apic = apic_read (APIC_TMCCT);
            rdtscll (tsc);
        }
        while ((tsc - tsc_start) < TICK_COUNT && (apic_start - apic) < TICK_COUNT);
        result = (apic_start - apic) * 1000L * tsc_khz / (tsc - tsc_start);
    }
    local_irq_enable ();
    printk (KERN_DEBUG "APIC timer calibration result %d\n", result);
    printk (KERN_INFO "Detected %d.%03d MHz APIC timer.\n", result / 1000 / 1000, result / 1000 % 1000);
    lapic_clockevent.mult = div_sc (result, NSEC_PER_SEC, 32);
    lapic_clockevent.max_delta_ns = clockevent_delta2ns (0x7FFFFF, &lapic_clockevent);
    lapic_clockevent.min_delta_ns = clockevent_delta2ns (0xF, &lapic_clockevent);
    calibration_result = result / HZ;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/apic_64.c.ifdefed" startline="918" endline="929">
{
    rdtscll (tsc_start);
    do {
        apic = apic_read (APIC_TMCCT);
        rdtscll (tsc);
    }
    while ((tsc - tsc_start) < TICK_COUNT && (apic_start - apic) < TICK_COUNT);
    result = (apic_start - apic) * 1000L * tsc_khz / (tsc - tsc_start);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/apic_64.c.ifdefed" startline="921" endline="924">
{
    apic = apic_read (APIC_TMCCT);
    rdtscll (tsc);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/apic_64.c.ifdefed" startline="949" endline="979">
{
    if (disable_apic_timer) {
        printk (KERN_INFO "Disabling APIC timer\n");
        if (num_possible_cpus () > 1)
            setup_APIC_timer ();
        return;
    }
    printk (KERN_INFO "Using local APIC timer interrupts.\n");
    calibrate_APIC_clock ();
    if (nmi_watchdog != NMI_IO_APIC)
        lapic_clockevent.features &= ~CLOCK_EVT_FEAT_DUMMY;
    else
        printk (KERN_WARNING "APIC timer registered as dummy," " due to nmi_watchdog=1!\n");
    setup_APIC_timer ();
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/apic_64.c.ifdefed" startline="956" endline="962">
{
    printk (KERN_INFO "Disabling APIC timer\n");
    if (num_possible_cpus () > 1)
        setup_APIC_timer ();
    return;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/apic_64.c.ifdefed" startline="990" endline="1001">
{
    if (!disable_apic_timer || (lapic_clockevent.features & CLOCK_EVT_FEAT_DUMMY))
        return;
    printk (KERN_INFO "AMD C1E detected late. Force timer broadcast.\n");
    lapic_clockevent.features |= CLOCK_EVT_FEAT_DUMMY;
    local_irq_enable ();
    clockevents_notify (CLOCK_EVT_NOTIFY_BROADCAST_FORCE, & boot_cpu_id);
    local_irq_disable ();
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/apic_64.c.ifdefed" startline="1004" endline="1007">
{
    check_boot_apic_timer_broadcast ();
    setup_APIC_timer ();
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/apic_64.c.ifdefed" startline="1010" endline="1012">
{
    return -EINVAL;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/apic_64.c.ifdefed" startline="1016" endline="1020">
{
    unsigned long reg = (lvt_off << 4) + K8_APIC_EXT_LVT_BASE;
    unsigned int v = (mask << 16) | (msg_type << 8) | vector;
    apic_write (reg, v);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/apic_64.c.ifdefed" startline="1033" endline="1062">
{
    int cpu = smp_processor_id ();
    struct clock_event_device *evt = &per_cpu (lapic_events, cpu);
    if (!evt->event_handler) {
        printk (KERN_WARNING "Spurious LAPIC timer interrupt on cpu %d\n", cpu);
        lapic_timer_setup (CLOCK_EVT_MODE_SHUTDOWN, evt);
        return;
    }
    add_pda (apic_timer_irqs, 1);
    evt->event_handler (evt);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/apic_64.c.ifdefed" startline="1048" endline="1054">
{
    printk (KERN_WARNING "Spurious LAPIC timer interrupt on cpu %d\n", cpu);
    lapic_timer_setup (CLOCK_EVT_MODE_SHUTDOWN, evt);
    return;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/apic_64.c.ifdefed" startline="1073" endline="1091">
{
    struct pt_regs *old_regs = set_irq_regs (regs);
    ack_APIC_irq ();
    exit_idle ();
    irq_enter ();
    smp_local_timer_interrupt ();
    irq_exit ();
    set_irq_regs (old_regs);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/apic_64.c.ifdefed" startline="1103" endline="1138">
{
    int i, clusters, zeros;
    unsigned id;
    DECLARE_BITMAP (clustermap, NUM_APIC_CLUSTERS);
    bitmap_zero (clustermap, NUM_APIC_CLUSTERS);
    for (i = 0; i < NR_CPUS; i++) {
        id = bios_cpu_apicid[i];
        if (id != BAD_APICID)
            __set_bit (APIC_CLUSTERID (id), clustermap);
    }
    clusters = 0;
    zeros = 0;
    for (i = 0; i < NUM_APIC_CLUSTERS; i++) {
        if (test_bit (i, clustermap)) {
            clusters += 1 + zeros;
            zeros = 0;
        }
        else
            ++zeros;
    }
    return (clusters > 2);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/apic_64.c.ifdefed" startline="1110" endline="1114">
{
    id = bios_cpu_apicid[i];
    if (id != BAD_APICID)
        __set_bit (APIC_CLUSTERID (id), clustermap);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/apic_64.c.ifdefed" startline="1124" endline="1130">
{
    if (test_bit (i, clustermap)) {
        clusters += 1 + zeros;
        zeros = 0;
    }
    else
        ++zeros;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/apic_64.c.ifdefed" startline="1125" endline="1128">
{
    clusters += 1 + zeros;
    zeros = 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/apic_64.c.ifdefed" startline="1144" endline="1159">
{
    unsigned int v;
    exit_idle ();
    irq_enter ();
    v = apic_read (APIC_ISR +((SPURIOUS_APIC_VECTOR & ~0x1f) >> 1));
    if (v & (1 << (SPURIOUS_APIC_VECTOR & 0x1f)))
        ack_APIC_irq ();
    add_pda (irq_spurious_count, 1);
    irq_exit ();
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/apic_64.c.ifdefed" startline="1166" endline="1191">
{
    unsigned int v, v1;
    exit_idle ();
    irq_enter ();
    v = apic_read (APIC_ESR);
    apic_write (APIC_ESR, 0);
    v1 = apic_read (APIC_ESR);
    ack_APIC_irq ();
    atomic_inc (& irq_err_count);
    printk (KERN_DEBUG "APIC error on CPU%d: %02x(%02x)\n", smp_processor_id (), v, v1);
    irq_exit ();
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/apic_64.c.ifdefed" startline="1200" endline="1225">
{
    if (disable_apic) {
        printk (KERN_INFO "Apic disabled\n");
        return -1;
    }
    if (!cpu_has_apic) {
        disable_apic = 1;
        printk (KERN_INFO "Apic disabled by BIOS\n");
        return -1;
    }
    verify_local_APIC ();
    phys_cpu_present_map = physid_mask_of_physid (boot_cpu_id);
    apic_write (APIC_ID, SET_APIC_ID (boot_cpu_id));
    setup_local_APIC ();
    if (smp_found_config && !skip_ioapic_setup && nr_ioapics)
        setup_IO_APIC ();
    else
        nr_ioapics = 0;
    setup_boot_APIC_clock ();
    check_nmi_watchdog ();
    return 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/apic_64.c.ifdefed" startline="1201" endline="1204">
{
    printk (KERN_INFO "Apic disabled\n");
    return -1;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/apic_64.c.ifdefed" startline="1205" endline="1209">
{
    disable_apic = 1;
    printk (KERN_INFO "Apic disabled by BIOS\n");
    return -1;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/apic_64.c.ifdefed" startline="1228" endline="1232">
{
    disable_apic = 1;
    clear_bit (X86_FEATURE_APIC, boot_cpu_data.x86_capability);
    return 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/apic_64.c.ifdefed" startline="1237" endline="1239">
{
    return setup_disableapic (str);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/apic_64.c.ifdefed" startline="1243" endline="1246">
{
    local_apic_timer_c2_ok = 1;
    return 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/apic_64.c.ifdefed" startline="1250" endline="1255">
{
    if (str[0] != ' ' && str[0] != 0)
        return 0;
    disable_apic_timer = 1;
    return 1;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/apic_64.c.ifdefed" startline="1259" endline="1263">
{
    apic_calibrate_pmtmr = 1;
    notsc_setup (NULL);
    return 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/module_64.c.ifdefed" startline="36" endline="40">
{
    vfree (module_region);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/module_64.c.ifdefed" startline="43" endline="57">
{
    struct vm_struct *area;
    if (!size)
        return NULL;
    size = PAGE_ALIGN (size);
    if (size > MODULES_LEN)
        return NULL;
    area = __get_vm_area (size, VM_ALLOC, MODULES_VADDR, MODULES_END);
    if (!area)
        return NULL;
    return __vmalloc_area (area, GFP_KERNEL, PAGE_KERNEL_EXEC);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/module_64.c.ifdefed" startline="65" endline="67">
{
    return 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/module_64.c.ifdefed" startline="74" endline="137">
{
    unsigned int i;
    Elf64_Rela *rel = (void *) sechdrs[relsec].sh_addr;
    Elf64_Sym *sym;
    void *loc;
    u64 val;
    DEBUGP ("Applying relocate section %u to %u\n", relsec, sechdrs [relsec].sh_info);
    for (i = 0; i < sechdrs[relsec].sh_size / sizeof (*rel); i++) {
        loc = (void *) sechdrs[sechdrs[relsec].sh_info].sh_addr + rel[i].r_offset;
        sym = (Elf64_Sym *) sechdrs[symindex].sh_addr + ELF64_R_SYM (rel[i].r_info);
        DEBUGP ("type %d st_value %Lx r_addend %Lx loc %Lx\n", (int) ELF64_R_TYPE (rel [i].r_info), sym -> st_value, rel [i].r_addend, (u64) loc);
        val = sym->st_value + rel[i].r_addend;
        switch (ELF64_R_TYPE (rel[i].r_info)) {
        case R_X86_64_NONE :
            break;
        case R_X86_64_64 :
            *(u64*) loc = val;
            break;
        case R_X86_64_32 :
            *(u32*) loc = val;
            if (val != *(u32*) loc)
                goto overflow;
            break;
        case R_X86_64_32S :
            *(s32*) loc = val;
            if ((s64) val != *(s32*) loc)
                goto overflow;
            break;
        case R_X86_64_PC32 :
            val -= (u64) loc;
            *(u32*) loc = val;
            break;
        default :
            printk (KERN_ERR "module %s: Unknown rela relocation: %Lu\n", me->name, ELF64_R_TYPE (rel[i].r_info));
            return -ENOEXEC;
        }
    }
    return 0;
overflow :
    printk (KERN_ERR "overflow in relocation type %d val %Lx\n", (int) ELF64_R_TYPE (rel[i].r_info), val);
    printk (KERN_ERR "`%s' likely not compiled with -mcmodel=kernel\n", me -> name);
    return -ENOEXEC;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/module_64.c.ifdefed" startline="83" endline="128">
{
    loc = (void *) sechdrs[sechdrs[relsec].sh_info].sh_addr + rel[i].r_offset;
    sym = (Elf64_Sym *) sechdrs[symindex].sh_addr + ELF64_R_SYM (rel[i].r_info);
    DEBUGP ("type %d st_value %Lx r_addend %Lx loc %Lx\n", (int) ELF64_R_TYPE (rel [i].r_info), sym -> st_value, rel [i].r_addend, (u64) loc);
    val = sym->st_value + rel[i].r_addend;
    switch (ELF64_R_TYPE (rel[i].r_info)) {
    case R_X86_64_NONE :
        break;
    case R_X86_64_64 :
        *(u64*) loc = val;
        break;
    case R_X86_64_32 :
        *(u32*) loc = val;
        if (val != *(u32*) loc)
            goto overflow;
        break;
    case R_X86_64_32S :
        *(s32*) loc = val;
        if ((s64) val != *(s32*) loc)
            goto overflow;
        break;
    case R_X86_64_PC32 :
        val -= (u64) loc;
        *(u32*) loc = val;
        break;
    default :
        printk (KERN_ERR "module %s: Unknown rela relocation: %Lu\n", me->name, ELF64_R_TYPE (rel[i].r_info));
        return -ENOEXEC;
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/module_64.c.ifdefed" startline="99" endline="127">
{
case R_X86_64_NONE :
    break;
case R_X86_64_64 :
    *(u64*) loc = val;
    break;
case R_X86_64_32 :
    *(u32*) loc = val;
    if (val != *(u32*) loc)
        goto overflow;
    break;
case R_X86_64_32S :
    *(s32*) loc = val;
    if ((s64) val != *(s32*) loc)
        goto overflow;
    break;
case R_X86_64_PC32 :
    val -= (u64) loc;
    *(u32*) loc = val;
    break;
default :
    printk (KERN_ERR "module %s: Unknown rela relocation: %Lu\n", me->name, ELF64_R_TYPE (rel[i].r_info));
    return -ENOEXEC;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/module_64.c.ifdefed" startline="144" endline="147">
{
    printk ("non add relocation not supported\n");
    return -ENOSYS;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/module_64.c.ifdefed" startline="152" endline="179">
{
    const Elf_Shdr *s, *text = NULL, *alt = NULL, *locks = NULL;
    char *secstrings = (void *) hdr + sechdrs[hdr->e_shstrndx].sh_offset;
    for (s = sechdrs; s < sechdrs + hdr->e_shnum; s++) {
        if (!strcmp (".text", secstrings +s->sh_name))
            text = s;
        if (!strcmp (".altinstructions", secstrings +s->sh_name))
            alt = s;
        if (!strcmp (".smp_locks", secstrings +s->sh_name))
            locks = s;
    }
    if (alt) {
        void *aseg = (void *) alt->sh_addr;
        apply_alternatives (aseg, aseg + alt -> sh_size);
    }
    if (locks && text) {
        void *lseg = (void *) locks->sh_addr;
        void *tseg = (void *) text->sh_addr;
        alternatives_smp_module_add (me, me -> name, lseg, lseg + locks -> sh_size, tseg, tseg + text -> sh_size);
    }
    return module_bug_finalize (hdr, sechdrs, me);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/module_64.c.ifdefed" startline="156" endline="163">
{
    if (!strcmp (".text", secstrings +s->sh_name))
        text = s;
    if (!strcmp (".altinstructions", secstrings +s->sh_name))
        alt = s;
    if (!strcmp (".smp_locks", secstrings +s->sh_name))
        locks = s;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/module_64.c.ifdefed" startline="165" endline="169">
{
    void *aseg = (void *) alt->sh_addr;
    apply_alternatives (aseg, aseg + alt -> sh_size);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/module_64.c.ifdefed" startline="170" endline="176">
{
    void *lseg = (void *) locks->sh_addr;
    void *tseg = (void *) text->sh_addr;
    alternatives_smp_module_add (me, me -> name, lseg, lseg + locks -> sh_size, tseg, tseg + text -> sh_size);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/module_64.c.ifdefed" startline="182" endline="185">
{
    alternatives_smp_module_del (mod);
    module_bug_cleanup (mod);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/head64.c.ifdefed" startline="24" endline="28">
{
    pgd_t *pgd = pgd_offset_k (0UL);
    pgd_clear (pgd);
    __flush_tlb ();
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/head64.c.ifdefed" startline="33" endline="36">
{
    memset (__bss_start, 0, (unsigned long) __bss_stop - (unsigned long) __bss_start);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/head64.c.ifdefed" startline="39" endline="47">
{
    char *command_line;
    memcpy (& boot_params, real_mode_data, sizeof boot_params);
    if (boot_params.hdr.cmd_line_ptr) {
        command_line = __va (boot_params.hdr.cmd_line_ptr);
        memcpy (boot_command_line, command_line, COMMAND_LINE_SIZE);
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/head64.c.ifdefed" startline="43" endline="46">
{
    command_line = __va (boot_params.hdr.cmd_line_ptr);
    memcpy (boot_command_line, command_line, COMMAND_LINE_SIZE);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/head64.c.ifdefed" startline="50" endline="74">
{
    int i;
    clear_bss ();
    zap_identity_mappings ();
    for (i = 0; i < IDT_ENTRIES; i++)
        set_intr_gate (i, early_idt_handler);
    load_idt ((const struct desc_ptr *) & idt_descr);
    early_printk ("Kernel alive\n");
    for (i = 0; i < NR_CPUS; i++)
        cpu_pda (i) = &boot_cpu_pda[i];
    pda_init (0);
    copy_bootdata (__va (real_mode_data));
    start_kernel ();
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/genapic_64.c.ifdefed" startline="47" endline="66">
{
    if (cpus_weight (cpu_possible_map) <= 8)
        genapic = &apic_flat;
    else
        genapic = &apic_physflat;
    printk (KERN_INFO "Setting APIC routing to %s\n", genapic -> name);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/genapic_64.c.ifdefed" startline="71" endline="73">
{
    __send_IPI_shortcut (APIC_DEST_SELF, vector, APIC_DEST_PHYSICAL);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/smp_64.c.ifdefed" startline="74" endline="79">
{
    if (read_pda (mmu_state) == TLBSTATE_OK)
        BUG ();
    cpu_clear (cpu, read_pda (active_mm) -> cpu_vm_mask);
    load_cr3 (swapper_pg_dir);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/smp_64.c.ifdefed" startline="130" endline="167">
{
    int cpu;
    int sender;
    union smp_flush_state *f;
    cpu = smp_processor_id ();
    sender = ~regs->orig_rax - INVALIDATE_TLB_VECTOR_START;
    f = &per_cpu (flush_state, sender);
    if (!cpu_isset (cpu, f->flush_cpumask))
        goto out;
    if (f->flush_mm == read_pda (active_mm)) {
        if (read_pda (mmu_state) == TLBSTATE_OK) {
            if (f->flush_va == FLUSH_ALL)
                local_flush_tlb ();
            else
                __flush_tlb_one (f->flush_va);
        }
        else
            leave_mm (cpu);
    }
out :
    ack_APIC_irq ();
    cpu_clear (cpu, f -> flush_cpumask);
    add_pda (irq_tlb_count, 1);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/smp_64.c.ifdefed" startline="154" endline="162">
{
    if (read_pda (mmu_state) == TLBSTATE_OK) {
        if (f->flush_va == FLUSH_ALL)
            local_flush_tlb ();
        else
            __flush_tlb_one (f->flush_va);
    }
    else
        leave_mm (cpu);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/smp_64.c.ifdefed" startline="155" endline="160">
{
    if (f->flush_va == FLUSH_ALL)
        local_flush_tlb ();
    else
        __flush_tlb_one (f->flush_va);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/smp_64.c.ifdefed" startline="171" endline="200">
{
    int sender;
    union smp_flush_state *f;
    sender = smp_processor_id () % NUM_INVALIDATE_TLB_VECTORS;
    f = &per_cpu (flush_state, sender);
    spin_lock (& f -> tlbstate_lock);
    f->flush_mm = mm;
    f->flush_va = va;
    cpus_or (f -> flush_cpumask, cpumask, f -> flush_cpumask);
    send_IPI_mask (cpumask, INVALIDATE_TLB_VECTOR_START + sender);
    while (!cpus_empty (f->flush_cpumask))
        cpu_relax ();
    f->flush_mm = NULL;
    f->flush_va = 0;
    spin_unlock (& f -> tlbstate_lock);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/smp_64.c.ifdefed" startline="203" endline="209">
{
    int i;

    for_each_cpu_mask (i, cpu_possible_map) {
        spin_lock_init (& per_cpu (flush_state, i).tlbstate_lock);
    }

    return 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/smp_64.c.ifdefed" startline="205" endline="207">
{
    spin_lock_init (& per_cpu (flush_state, i).tlbstate_lock);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/smp_64.c.ifdefed" startline="214" endline="226">
{
    struct mm_struct *mm = current->mm;
    cpumask_t cpu_mask;
    preempt_disable ();
    cpu_mask = mm->cpu_vm_mask;
    cpu_clear (smp_processor_id (), cpu_mask);
    local_flush_tlb ();
    if (!cpus_empty (cpu_mask))
        flush_tlb_others (cpu_mask, mm, FLUSH_ALL);
    preempt_enable ();
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/smp_64.c.ifdefed" startline="230" endline="247">
{
    cpumask_t cpu_mask;
    preempt_disable ();
    cpu_mask = mm->cpu_vm_mask;
    cpu_clear (smp_processor_id (), cpu_mask);
    if (current->active_mm == mm) {
        if (current->mm)
            local_flush_tlb ();
        else
            leave_mm (smp_processor_id ());
    }
    if (!cpus_empty (cpu_mask))
        flush_tlb_others (cpu_mask, mm, FLUSH_ALL);
    preempt_enable ();
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/smp_64.c.ifdefed" startline="237" endline="242">
{
    if (current->mm)
        local_flush_tlb ();
    else
        leave_mm (smp_processor_id ());
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/smp_64.c.ifdefed" startline="251" endline="270">
{
    struct mm_struct *mm = vma->vm_mm;
    cpumask_t cpu_mask;
    preempt_disable ();
    cpu_mask = mm->cpu_vm_mask;
    cpu_clear (smp_processor_id (), cpu_mask);
    if (current->active_mm == mm) {
        if (current->mm)
            __flush_tlb_one (va);
        else
            leave_mm (smp_processor_id ());
    }
    if (!cpus_empty (cpu_mask))
        flush_tlb_others (cpu_mask, mm, va);
    preempt_enable ();
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/smp_64.c.ifdefed" startline="259" endline="264">
{
    if (current->mm)
        __flush_tlb_one (va);
    else
        leave_mm (smp_processor_id ());
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/smp_64.c.ifdefed" startline="274" endline="280">
{
    unsigned long cpu = smp_processor_id ();
    __flush_tlb_all ();
    if (read_pda (mmu_state) == TLBSTATE_LAZY)
        leave_mm (cpu);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/smp_64.c.ifdefed" startline="283" endline="285">
{
    on_each_cpu (do_flush_tlb_all, NULL, 1, 1);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/smp_64.c.ifdefed" startline="294" endline="296">
{
    send_IPI_mask (cpumask_of_cpu (cpu), RESCHEDULE_VECTOR);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/smp_64.c.ifdefed" startline="315" endline="317">
{
    spin_lock_irq (& call_lock);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/smp_64.c.ifdefed" startline="320" endline="322">
{
    spin_unlock_irq (& call_lock);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/smp_64.c.ifdefed" startline="333" endline="374">
{
    struct call_data_struct data;
    cpumask_t allbutself;
    int cpus;
    allbutself = cpu_online_map;
    cpu_clear (smp_processor_id (), allbutself);
    cpus_and (mask, mask, allbutself);
    cpus = cpus_weight (mask);
    if (!cpus)
        return 0;
    data.func = func;
    data.info = info;
    atomic_set (& data.started, 0);
    data.wait = wait;
    if (wait)
        atomic_set (&data.finished, 0);
    call_data = &data;
    wmb ();
    if (cpus_equal (mask, allbutself))
        send_IPI_allbutself (CALL_FUNCTION_VECTOR);
    else
        send_IPI_mask (mask, CALL_FUNCTION_VECTOR);
    while (atomic_read (&data.started) != cpus)
        cpu_relax ();
    if (!wait)
        return 0;
    while (atomic_read (&data.finished) != cpus)
        cpu_relax ();
    return 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/smp_64.c.ifdefed" startline="393" endline="403">
{
    int ret;
    WARN_ON (irqs_disabled ());
    spin_lock (& call_lock);
    ret = __smp_call_function_mask (mask, func, info, wait);
    spin_unlock (& call_lock);
    return ret;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/smp_64.c.ifdefed" startline="421" endline="441">
{
    int ret;
    int me = get_cpu ();
    WARN_ON (irqs_disabled ());
    if (cpu == me) {
        local_irq_disable ();
        func (info);
        local_irq_enable ();
        put_cpu ();
        return 0;
    }
    ret = smp_call_function_mask (cpumask_of_cpu (cpu), func, info, wait);
    put_cpu ();
    return ret;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/smp_64.c.ifdefed" startline="429" endline="435">
{
    local_irq_disable ();
    func (info);
    local_irq_enable ();
    put_cpu ();
    return 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/smp_64.c.ifdefed" startline="461" endline="463">
{
    return smp_call_function_mask (cpu_online_map, func, info, wait);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/smp_64.c.ifdefed" startline="467" endline="476">
{
    local_irq_disable ();
    cpu_clear (smp_processor_id (), cpu_online_map);
    disable_local_APIC ();
    for (;;)
        halt ();
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/smp_64.c.ifdefed" startline="479" endline="494">
{
    int nolock;
    unsigned long flags;
    if (reboot_force)
        return;
    nolock = !spin_trylock (&call_lock);
    local_irq_save (flags);
    __smp_call_function_mask (cpu_online_map, stop_this_cpu, NULL, 0);
    if (!nolock)
        spin_unlock (&call_lock);
    disable_local_APIC ();
    local_irq_restore (flags);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/smp_64.c.ifdefed" startline="502" endline="505">
{
    ack_APIC_irq ();
    add_pda (irq_resched_count, 1);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/smp_64.c.ifdefed" startline="508" endline="532">
{
    void (*func) (void *info) = call_data->func;
    void *info = call_data->info;
    int wait = call_data->wait;
    ack_APIC_irq ();
    mb ();
    atomic_inc (& call_data -> started);
    exit_idle ();
    irq_enter ();
    (*func) (info);
    add_pda (irq_call_count, 1);
    irq_exit ();
    if (wait) {
        mb ();
        atomic_inc (& call_data -> finished);
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/smp_64.c.ifdefed" startline="528" endline="531">
{
    mb ();
    atomic_inc (& call_data -> finished);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/irq_64.c.ifdefed" startline="52" endline="133">
{
    int i = *(loff_t*) v, j;
    struct irqaction *action;
    unsigned long flags;
    if (i == 0) {
        seq_printf (p, "           ");
        for_each_online_cpu (j)
        seq_printf (p, "CPU%-8d", j);
        seq_putc (p, '\n');
    }
    if (i < NR_IRQS) {
        unsigned any_count = 0;
        spin_lock_irqsave (& irq_desc [i].lock, flags);
        any_count = kstat_irqs (i);
        action = irq_desc[i].action;
        if (!action && !any_count)
            goto skip;
        seq_printf (p, "%3d: ", i);
        seq_printf (p, "%10u ", kstat_irqs (i));
        seq_printf (p, " %8s", irq_desc [i].chip -> name);
        seq_printf (p, "-%-8s", irq_desc [i].name);
        if (action) {
            seq_printf (p, "  %s", action -> name);
            while ((action = action->next) != NULL)
                seq_printf (p, ", %s", action->name);
        }
        seq_putc (p, '\n');
    skip :
        spin_unlock_irqrestore (&irq_desc[i].lock, flags);
    }
    else if (i == NR_IRQS) {
        seq_printf (p, "NMI: ");
        for_each_online_cpu (j)
        seq_printf (p, "%10u ", cpu_pda (j) -> __nmi_count);
        seq_printf (p, "  Non-maskable interrupts\n");
        seq_printf (p, "LOC: ");
        for_each_online_cpu (j)
        seq_printf (p, "%10u ", cpu_pda (j) -> apic_timer_irqs);
        seq_printf (p, "  Local timer interrupts\n");
        seq_printf (p, "TRM: ");
        for_each_online_cpu (j)
        seq_printf (p, "%10u ", cpu_pda (j) -> irq_thermal_count);
        seq_printf (p, "  Thermal event interrupts\n");
        seq_printf (p, "THR: ");
        for_each_online_cpu (j)
        seq_printf (p, "%10u ", cpu_pda (j) -> irq_threshold_count);
        seq_printf (p, "  Threshold APIC interrupts\n");
        seq_printf (p, "SPU: ");
        for_each_online_cpu (j)
        seq_printf (p, "%10u ", cpu_pda (j) -> irq_spurious_count);
        seq_printf (p, "  Spurious interrupts\n");
        seq_printf (p, "ERR: %10u\n", atomic_read (& irq_err_count));
    }
    return 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/irq_64.c.ifdefed" startline="57" endline="62">
{
    seq_printf (p, "           ");
    for_each_online_cpu (j)
    seq_printf (p, "CPU%-8d", j);
    seq_putc (p, '\n');
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/irq_64.c.ifdefed" startline="64" endline="95">
{
    unsigned any_count = 0;
    spin_lock_irqsave (& irq_desc [i].lock, flags);
    any_count = kstat_irqs (i);
    action = irq_desc[i].action;
    if (!action && !any_count)
        goto skip;
    seq_printf (p, "%3d: ", i);
    seq_printf (p, "%10u ", kstat_irqs (i));
    seq_printf (p, " %8s", irq_desc [i].chip -> name);
    seq_printf (p, "-%-8s", irq_desc [i].name);
    if (action) {
        seq_printf (p, "  %s", action -> name);
        while ((action = action->next) != NULL)
            seq_printf (p, ", %s", action->name);
    }
    seq_putc (p, '\n');
skip :
    spin_unlock_irqrestore (&irq_desc[i].lock, flags);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/irq_64.c.ifdefed" startline="87" endline="91">
{
    seq_printf (p, "  %s", action -> name);
    while ((action = action->next) != NULL)
        seq_printf (p, ", %s", action->name);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/irq_64.c.ifdefed" startline="95" endline="131">
{
    seq_printf (p, "NMI: ");
    for_each_online_cpu (j)
    seq_printf (p, "%10u ", cpu_pda (j) -> __nmi_count);
    seq_printf (p, "  Non-maskable interrupts\n");
    seq_printf (p, "LOC: ");
    for_each_online_cpu (j)
    seq_printf (p, "%10u ", cpu_pda (j) -> apic_timer_irqs);
    seq_printf (p, "  Local timer interrupts\n");
    seq_printf (p, "TRM: ");
    for_each_online_cpu (j)
    seq_printf (p, "%10u ", cpu_pda (j) -> irq_thermal_count);
    seq_printf (p, "  Thermal event interrupts\n");
    seq_printf (p, "THR: ");
    for_each_online_cpu (j)
    seq_printf (p, "%10u ", cpu_pda (j) -> irq_threshold_count);
    seq_printf (p, "  Threshold APIC interrupts\n");
    seq_printf (p, "SPU: ");
    for_each_online_cpu (j)
    seq_printf (p, "%10u ", cpu_pda (j) -> irq_spurious_count);
    seq_printf (p, "  Spurious interrupts\n");
    seq_printf (p, "ERR: %10u\n", atomic_read (& irq_err_count));
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/irq_64.c.ifdefed" startline="141" endline="171">
{
    struct pt_regs *old_regs = set_irq_regs (regs);
    unsigned vector = ~regs->orig_rax;
    unsigned irq;
    exit_idle ();
    irq_enter ();
    irq = __get_cpu_var (vector_irq)[vector];
    if (likely (irq < NR_IRQS))
        generic_handle_irq (irq);
    else {
        if (!disable_apic)
            ack_APIC_irq ();
        if (printk_ratelimit ())
            printk (KERN_EMERG "%s: %d.%d No irq handler for vector\n", __func__, smp_processor_id (), vector);
    }
    irq_exit ();
    set_irq_regs (old_regs);
    return 1;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/irq_64.c.ifdefed" startline="158" endline="165">
{
    if (!disable_apic)
        ack_APIC_irq ();
    if (printk_ratelimit ())
        printk (KERN_EMERG "%s: %d.%d No irq handler for vector\n", __func__, smp_processor_id (), vector);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/irq_64.c.ifdefed" startline="231" endline="246">
{
    __u32 pending;
    unsigned long flags;
    if (in_interrupt ())
        return;
    local_irq_save (flags);
    pending = local_softirq_pending ();
    if (pending) {
        call_softirq ();
        WARN_ON_ONCE (softirq_count ());
    }
    local_irq_restore (flags);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/irq_64.c.ifdefed" startline="241" endline="244">
{
    call_softirq ();
    WARN_ON_ONCE (softirq_count ());
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/pci-dma_64.c.ifdefed" startline="52" endline="65">
{
    struct page *page;
    int node;
    node = dev_to_node (dev);
    if (node == -1)
        node = numa_node_id ();
    if (node < first_node (node_online_map))
        node = first_node (node_online_map);
    page = alloc_pages_node (node, gfp, order);
    return page ? page_address (page) : NULL;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/pci-dma_64.c.ifdefed" startline="73" endline="159">
{
    void *memory;
    unsigned long dma_mask = 0;
    u64 bus;
    if (!dev)
        dev = &fallback_dev;
    dma_mask = dev->coherent_dma_mask;
    if (dma_mask == 0)
        dma_mask = DMA_32BIT_MASK;
    if (dev->dma_mask == NULL)
        return NULL;
    gfp |= __GFP_NORETRY;
    dma_mask &= *dev->dma_mask;
    if (dma_mask <= DMA_32BIT_MASK)
        gfp |= GFP_DMA32;
again :
    memory = dma_alloc_pages (dev, gfp, get_order (size));
    if (memory == NULL)
        return NULL;
    {
        int high, mmu;
        bus = virt_to_bus (memory);
        high = (bus + size) >= dma_mask;
        mmu = high;
        if (force_iommu && !(gfp & GFP_DMA))
            mmu = 1;
        else if (high) {
            free_pages ((unsigned long) memory, get_order (size));
            if (dma_mask < DMA_32BIT_MASK && !(gfp & GFP_DMA)) {
                gfp = (gfp & ~GFP_DMA32) | GFP_DMA;
                goto again;
            }
            gfp &= ~(GFP_DMA32 | GFP_DMA);
            if (dma_ops->alloc_coherent)
                return dma_ops->alloc_coherent (dev, size, dma_handle, gfp);
            return NULL;
        }
        memset (memory, 0, size);
        if (!mmu) {
            *dma_handle = virt_to_bus (memory);
            return memory;
        }
    }
    if (dma_ops->alloc_coherent) {
        free_pages ((unsigned long) memory, get_order (size));
        gfp &= ~(GFP_DMA | GFP_DMA32);
        return dma_ops->alloc_coherent (dev, size, dma_handle, gfp);
    }
    if (dma_ops->map_simple) {
        *dma_handle = dma_ops->map_simple (dev, memory, size, PCI_DMA_BIDIRECTIONAL);
        if (*dma_handle != bad_dma_address)
            return memory;
    }
    if (panic_on_overflow)
        panic ("dma_alloc_coherent: IOMMU overflow by %lu bytes\n", size);
    free_pages ((unsigned long) memory, get_order (size));
    return NULL;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/pci-dma_64.c.ifdefed" startline="107" endline="139">
{
    int high, mmu;
    bus = virt_to_bus (memory);
    high = (bus + size) >= dma_mask;
    mmu = high;
    if (force_iommu && !(gfp & GFP_DMA))
        mmu = 1;
    else if (high) {
        free_pages ((unsigned long) memory, get_order (size));
        if (dma_mask < DMA_32BIT_MASK && !(gfp & GFP_DMA)) {
            gfp = (gfp & ~GFP_DMA32) | GFP_DMA;
            goto again;
        }
        gfp &= ~(GFP_DMA32 | GFP_DMA);
        if (dma_ops->alloc_coherent)
            return dma_ops->alloc_coherent (dev, size, dma_handle, gfp);
        return NULL;
    }
    memset (memory, 0, size);
    if (!mmu) {
        *dma_handle = virt_to_bus (memory);
        return memory;
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/pci-dma_64.c.ifdefed" startline="114" endline="132">
{
    free_pages ((unsigned long) memory, get_order (size));
    if (dma_mask < DMA_32BIT_MASK && !(gfp & GFP_DMA)) {
        gfp = (gfp & ~GFP_DMA32) | GFP_DMA;
        goto again;
    }
    gfp &= ~(GFP_DMA32 | GFP_DMA);
    if (dma_ops->alloc_coherent)
        return dma_ops->alloc_coherent (dev, size, dma_handle, gfp);
    return NULL;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/pci-dma_64.c.ifdefed" startline="120" endline="123">
{
    gfp = (gfp & ~GFP_DMA32) | GFP_DMA;
    goto again;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/pci-dma_64.c.ifdefed" startline="135" endline="138">
{
    *dma_handle = virt_to_bus (memory);
    return memory;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/pci-dma_64.c.ifdefed" startline="141" endline="145">
{
    free_pages ((unsigned long) memory, get_order (size));
    gfp &= ~(GFP_DMA | GFP_DMA32);
    return dma_ops->alloc_coherent (dev, size, dma_handle, gfp);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/pci-dma_64.c.ifdefed" startline="147" endline="153">
{
    *dma_handle = dma_ops->map_simple (dev, memory, size, PCI_DMA_BIDIRECTIONAL);
    if (*dma_handle != bad_dma_address)
        return memory;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/pci-dma_64.c.ifdefed" startline="168" endline="173">
{
    WARN_ON (irqs_disabled ());
    if (dma_ops->unmap_single)
        dma_ops->unmap_single (dev, bus, size, 0);
    free_pages ((unsigned long) vaddr, get_order (size));
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/pci-dma_64.c.ifdefed" startline="179" endline="217">
{
    if (dma_ops->dma_supported)
        return dma_ops->dma_supported (dev, mask);
    if (mask < DMA_24BIT_MASK)
        return 0;
    if (iommu_sac_force && (mask >= DMA_40BIT_MASK)) {
        printk (KERN_INFO "%s: Force SAC with mask %Lx\n", dev -> bus_id, mask);
        return 0;
    }
    return 1;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/pci-dma_64.c.ifdefed" startline="211" endline="214">
{
    printk (KERN_INFO "%s: Force SAC with mask %Lx\n", dev -> bus_id, mask);
    return 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/pci-dma_64.c.ifdefed" startline="221" endline="226">
{
    if (!dev->dma_mask || !dma_supported (dev, mask))
        return -EIO;
    *dev->dma_mask = mask;
    return 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/pci-dma_64.c.ifdefed" startline="234" endline="292">
{
    iommu_merge = 1;
    if (!p)
        return -EINVAL;
    while (*p) {
        if (!strncmp (p, "off", 3))
            no_iommu = 1;
        if (!strncmp (p, "force", 5))
            force_iommu = 1;
        if (!strncmp (p, "noforce", 7)) {
            iommu_merge = 0;
            force_iommu = 0;
        }
        if (!strncmp (p, "biomerge", 8)) {
            iommu_bio_merge = 4096;
            iommu_merge = 1;
            force_iommu = 1;
        }
        if (!strncmp (p, "panic", 5))
            panic_on_overflow = 1;
        if (!strncmp (p, "nopanic", 7))
            panic_on_overflow = 0;
        if (!strncmp (p, "merge", 5)) {
            iommu_merge = 1;
            force_iommu = 1;
        }
        if (!strncmp (p, "nomerge", 7))
            iommu_merge = 0;
        if (!strncmp (p, "forcesac", 8))
            iommu_sac_force = 1;
        if (!strncmp (p, "allowdac", 8))
            forbid_dac = 0;
        if (!strncmp (p, "nodac", 5))
            forbid_dac = -1;
        p += strcspn (p, ",");
        if (*p == ',')
            ++p;
    }
    return 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/pci-dma_64.c.ifdefed" startline="240" endline="290">
{
    if (!strncmp (p, "off", 3))
        no_iommu = 1;
    if (!strncmp (p, "force", 5))
        force_iommu = 1;
    if (!strncmp (p, "noforce", 7)) {
        iommu_merge = 0;
        force_iommu = 0;
    }
    if (!strncmp (p, "biomerge", 8)) {
        iommu_bio_merge = 4096;
        iommu_merge = 1;
        force_iommu = 1;
    }
    if (!strncmp (p, "panic", 5))
        panic_on_overflow = 1;
    if (!strncmp (p, "nopanic", 7))
        panic_on_overflow = 0;
    if (!strncmp (p, "merge", 5)) {
        iommu_merge = 1;
        force_iommu = 1;
    }
    if (!strncmp (p, "nomerge", 7))
        iommu_merge = 0;
    if (!strncmp (p, "forcesac", 8))
        iommu_sac_force = 1;
    if (!strncmp (p, "allowdac", 8))
        forbid_dac = 0;
    if (!strncmp (p, "nodac", 5))
        forbid_dac = -1;
    p += strcspn (p, ",");
    if (*p == ',')
        ++p;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/pci-dma_64.c.ifdefed" startline="246" endline="249">
{
    iommu_merge = 0;
    force_iommu = 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/pci-dma_64.c.ifdefed" startline="251" endline="255">
{
    iommu_bio_merge = 4096;
    iommu_merge = 1;
    force_iommu = 1;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/pci-dma_64.c.ifdefed" startline="260" endline="263">
{
    iommu_merge = 1;
    force_iommu = 1;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/pci-dma_64.c.ifdefed" startline="296" endline="314">
{
    detect_intel_iommu ();
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/pci-dma_64.c.ifdefed" startline="317" endline="330">
{
    intel_iommu_init ();
    no_iommu_init ();
    return 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/pci-dma_64.c.ifdefed" startline="333" endline="335">
{
    gart_iommu_shutdown ();
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/ptrace_64.c.ifdefed" startline="60" endline="66">
{
    unsigned char *stack;
    stack = (unsigned char *) task->thread.rsp0;
    stack += offset;
    return (*((unsigned long *) stack));
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/ptrace_64.c.ifdefed" startline="76" endline="83">
{
    unsigned char *stack;
    stack = (unsigned char *) task->thread.rsp0;
    stack += offset;
    *(unsignedlong*) stack = data;
    return 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/ptrace_64.c.ifdefed" startline="88" endline="124">
{
    unsigned long addr, seg;
    addr = regs->rip;
    seg = regs->cs & 0xffff;
    if (seg & LDT_SEGMENT) {
        u32 *desc;
        unsigned long base;
        seg &= ~7UL;
        mutex_lock (& child -> mm -> context.lock);
        if (unlikely ((seg >> 3) >= child->mm->context.size))
            addr = -1L;
        else {
            desc = child->mm->context.ldt + seg;
            base = ((desc[0] >> 16) | ((desc[1] & 0xff) << 16) | (desc[1] & 0xff000000));
            if (!((desc[1] >> 22) & 1))
                addr &= 0xffff;
            addr += base;
        }
        mutex_unlock (& child -> mm -> context.lock);
    }
    return addr;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/ptrace_64.c.ifdefed" startline="100" endline="121">
{
    u32 *desc;
    unsigned long base;
    seg &= ~7UL;
    mutex_lock (& child -> mm -> context.lock);
    if (unlikely ((seg >> 3) >= child->mm->context.size))
        addr = -1L;
    else {
        desc = child->mm->context.ldt + seg;
        base = ((desc[0] >> 16) | ((desc[1] & 0xff) << 16) | (desc[1] & 0xff000000));
        if (!((desc[1] >> 22) & 1))
            addr &= 0xffff;
        addr += base;
    }
    mutex_unlock (& child -> mm -> context.lock);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/ptrace_64.c.ifdefed" startline="109" endline="119">
{
    desc = child->mm->context.ldt + seg;
    base = ((desc[0] >> 16) | ((desc[1] & 0xff) << 16) | (desc[1] & 0xff000000));
    if (!((desc[1] >> 22) & 1))
        addr &= 0xffff;
    addr += base;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/ptrace_64.c.ifdefed" startline="127" endline="173">
{
    int i, copied;
    unsigned char opcode [15];
    unsigned long addr = convert_rip_to_linear (child, regs);
    copied = access_process_vm (child, addr, opcode, sizeof (opcode), 0);
    for (i = 0; i < copied; i++) {
        switch (opcode[i]) {
        case 0x9d :
        case 0xcf :
            return 1;
        case 0x66 :
        case 0x67 :
            continue;
        case 0x26 :
        case 0x2e :
        case 0x36 :
        case 0x3e :
        case 0x64 :
        case 0x65 :
        case 0xf2 :
        case 0xf3 :
            continue;
        case 0x40 ... 0x4f :
            if (regs->cs != __USER_CS)
                return 0;
            continue;
        case 0x9c :
        default :
            return 0;
        }
    }
    return 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/ptrace_64.c.ifdefed" startline="133" endline="171">
{
    switch (opcode[i]) {
    case 0x9d :
    case 0xcf :
        return 1;
    case 0x66 :
    case 0x67 :
        continue;
    case 0x26 :
    case 0x2e :
    case 0x36 :
    case 0x3e :
    case 0x64 :
    case 0x65 :
    case 0xf2 :
    case 0xf3 :
        continue;
    case 0x40 ... 0x4f :
        if (regs->cs != __USER_CS)
            return 0;
        continue;
    case 0x9c :
    default :
        return 0;
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/ptrace_64.c.ifdefed" startline="134" endline="170">
{
case 0x9d :
case 0xcf :
    return 1;
case 0x66 :
case 0x67 :
    continue;
case 0x26 :
case 0x2e :
case 0x36 :
case 0x3e :
case 0x64 :
case 0x65 :
case 0xf2 :
case 0xf3 :
    continue;
case 0x40 ... 0x4f :
    if (regs->cs != __USER_CS)
        return 0;
    continue;
case 0x9c :
default :
    return 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/ptrace_64.c.ifdefed" startline="176" endline="204">
{
    struct pt_regs *regs = task_pt_regs (child);
    set_tsk_thread_flag (child, TIF_SINGLESTEP);
    if (regs->eflags & TRAP_FLAG)
        return;
    regs->eflags |= TRAP_FLAG;
    if (is_setting_trap_flag (child, regs))
        return;
    child->ptrace |= PT_DTRACE;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/ptrace_64.c.ifdefed" startline="207" endline="217">
{
    clear_tsk_thread_flag (child, TIF_SINGLESTEP);
    if (child->ptrace & PT_DTRACE) {
        struct pt_regs *regs = task_pt_regs (child);
        regs->eflags &= ~TRAP_FLAG;
        child->ptrace &= ~PT_DTRACE;
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/ptrace_64.c.ifdefed" startline="212" endline="216">
{
    struct pt_regs *regs = task_pt_regs (child);
    regs->eflags &= ~TRAP_FLAG;
    child->ptrace &= ~PT_DTRACE;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/ptrace_64.c.ifdefed" startline="225" endline="227">
{
    clear_singlestep (child);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/ptrace_64.c.ifdefed" startline="231" endline="284">
{
    unsigned long tmp;
    switch (regno) {
    case offsetof (struct user_regs_struct, fs) :
        if (value && (value & 3) != 3)
            return -EIO;
        child->thread.fsindex = value & 0xffff;
        return 0;
    case offsetof (struct user_regs_struct, gs) :
        if (value && (value & 3) != 3)
            return -EIO;
        child->thread.gsindex = value & 0xffff;
        return 0;
    case offsetof (struct user_regs_struct, ds) :
        if (value && (value & 3) != 3)
            return -EIO;
        child->thread.ds = value & 0xffff;
        return 0;
    case offsetof (struct user_regs_struct, es) :
        if (value && (value & 3) != 3)
            return -EIO;
        child->thread.es = value & 0xffff;
        return 0;
    case offsetof (struct user_regs_struct, ss) :
        if ((value & 3) != 3)
            return -EIO;
        value &= 0xffff;
        return 0;
    case offsetof (struct user_regs_struct, fs_base) :
        if (value >= TASK_SIZE_OF (child))
            return -EIO;
        child->thread.fs = value;
        return 0;
    case offsetof (struct user_regs_struct, gs_base) :
        if (value >= TASK_SIZE_OF (child))
            return -EIO;
        child->thread.gs = value;
        return 0;
    case offsetof (struct user_regs_struct, eflags) :
        value &= FLAG_MASK;
        tmp = get_stack_long (child, EFL_OFFSET);
        tmp &= ~FLAG_MASK;
        value |= tmp;
        break;
    case offsetof (struct user_regs_struct, cs) :
        if ((value & 3) != 3)
            return -EIO;
        value &= 0xffff;
        break;
    }
    put_stack_long (child, regno - sizeof (struct pt_regs), value);
    return 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/ptrace_64.c.ifdefed" startline="234" endline="281">
{
case offsetof (struct user_regs_struct, fs) :
    if (value && (value & 3) != 3)
        return -EIO;
    child->thread.fsindex = value & 0xffff;
    return 0;
case offsetof (struct user_regs_struct, gs) :
    if (value && (value & 3) != 3)
        return -EIO;
    child->thread.gsindex = value & 0xffff;
    return 0;
case offsetof (struct user_regs_struct, ds) :
    if (value && (value & 3) != 3)
        return -EIO;
    child->thread.ds = value & 0xffff;
    return 0;
case offsetof (struct user_regs_struct, es) :
    if (value && (value & 3) != 3)
        return -EIO;
    child->thread.es = value & 0xffff;
    return 0;
case offsetof (struct user_regs_struct, ss) :
    if ((value & 3) != 3)
        return -EIO;
    value &= 0xffff;
    return 0;
case offsetof (struct user_regs_struct, fs_base) :
    if (value >= TASK_SIZE_OF (child))
        return -EIO;
    child->thread.fs = value;
    return 0;
case offsetof (struct user_regs_struct, gs_base) :
    if (value >= TASK_SIZE_OF (child))
        return -EIO;
    child->thread.gs = value;
    return 0;
case offsetof (struct user_regs_struct, eflags) :
    value &= FLAG_MASK;
    tmp = get_stack_long (child, EFL_OFFSET);
    tmp &= ~FLAG_MASK;
    value |= tmp;
    break;
case offsetof (struct user_regs_struct, cs) :
    if ((value & 3) != 3)
        return -EIO;
    value &= 0xffff;
    break;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/ptrace_64.c.ifdefed" startline="287" endline="310">
{
    unsigned long val;
    switch (regno) {
    case offsetof (struct user_regs_struct, fs) :
        return child->thread.fsindex;
    case offsetof (struct user_regs_struct, gs) :
        return child->thread.gsindex;
    case offsetof (struct user_regs_struct, ds) :
        return child->thread.ds;
    case offsetof (struct user_regs_struct, es) :
        return child->thread.es;
    case offsetof (struct user_regs_struct, fs_base) :
        return child->thread.fs;
    case offsetof (struct user_regs_struct, gs_base) :
        return child->thread.gs;
    default :
        regno = regno - sizeof (struct pt_regs);
        val = get_stack_long (child, regno);
        if (test_tsk_thread_flag (child, TIF_IA32))
            val &= 0xffffffff;
        return val;
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/ptrace_64.c.ifdefed" startline="289" endline="308">
{
case offsetof (struct user_regs_struct, fs) :
    return child->thread.fsindex;
case offsetof (struct user_regs_struct, gs) :
    return child->thread.gsindex;
case offsetof (struct user_regs_struct, ds) :
    return child->thread.ds;
case offsetof (struct user_regs_struct, es) :
    return child->thread.es;
case offsetof (struct user_regs_struct, fs_base) :
    return child->thread.fs;
case offsetof (struct user_regs_struct, gs_base) :
    return child->thread.gs;
default :
    regno = regno - sizeof (struct pt_regs);
    val = get_stack_long (child, regno);
    if (test_tsk_thread_flag (child, TIF_IA32))
        val &= 0xffffffff;
    return val;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/ptrace_64.c.ifdefed" startline="313" endline="563">
{
    long i, ret;
    unsigned ui;
    switch (request) {
    case PTRACE_PEEKTEXT :
    case PTRACE_PEEKDATA :
        ret = generic_ptrace_peekdata (child, addr, data);
        break;
    case PTRACE_PEEKUSR :
        {
            unsigned long tmp;
            ret = -EIO;
            if ((addr & 7) || addr > sizeof (struct user) - 7)
                break;
            switch (addr) {
            case 0 ... sizeof (struct user_regs_struct) - sizeof (long) :
                tmp = getreg (child, addr);
                break;
            case offsetof (struct user, u_debugreg[0]) :
                tmp = child->thread.debugreg0;
                break;
            case offsetof (struct user, u_debugreg[1]) :
                tmp = child->thread.debugreg1;
                break;
            case offsetof (struct user, u_debugreg[2]) :
                tmp = child->thread.debugreg2;
                break;
            case offsetof (struct user, u_debugreg[3]) :
                tmp = child->thread.debugreg3;
                break;
            case offsetof (struct user, u_debugreg[6]) :
                tmp = child->thread.debugreg6;
                break;
            case offsetof (struct user, u_debugreg[7]) :
                tmp = child->thread.debugreg7;
                break;
            default :
                tmp = 0;
                break;
            }
            ret = put_user (tmp, (unsigned long __user *) data);
            break;
        }
    case PTRACE_POKETEXT :
    case PTRACE_POKEDATA :
        ret = generic_ptrace_pokedata (child, addr, data);
        break;
    case PTRACE_POKEUSR :
        {
            int dsize = test_tsk_thread_flag (child, TIF_IA32) ? 3 : 7;
            ret = -EIO;
            if ((addr & 7) || addr > sizeof (struct user) - 7)
                break;
            switch (addr) {
            case 0 ... sizeof (struct user_regs_struct) - sizeof (long) :
                ret = putreg (child, addr, data);
                break;
            case offsetof (struct user, u_debugreg[0]) :
                if (data >= TASK_SIZE_OF (child) - dsize)
                    break;
                child->thread.debugreg0 = data;
                ret = 0;
                break;
            case offsetof (struct user, u_debugreg[1]) :
                if (data >= TASK_SIZE_OF (child) - dsize)
                    break;
                child->thread.debugreg1 = data;
                ret = 0;
                break;
            case offsetof (struct user, u_debugreg[2]) :
                if (data >= TASK_SIZE_OF (child) - dsize)
                    break;
                child->thread.debugreg2 = data;
                ret = 0;
                break;
            case offsetof (struct user, u_debugreg[3]) :
                if (data >= TASK_SIZE_OF (child) - dsize)
                    break;
                child->thread.debugreg3 = data;
                ret = 0;
                break;
            case offsetof (struct user, u_debugreg[6]) :
                if (data >> 32)
                    break;
                child->thread.debugreg6 = data;
                ret = 0;
                break;
            case offsetof (struct user, u_debugreg[7]) :
                data &= ~DR_CONTROL_RESERVED;
                for (i = 0; i < 4; i++)
                    if ((0x5554 >> ((data >> (16 + 4 * i)) & 0xf)) & 1)
                        break;
                if (i == 4) {
                    child->thread.debugreg7 = data;
                    if (data)
                        set_tsk_thread_flag (child, TIF_DEBUG);
                    else
                        clear_tsk_thread_flag (child, TIF_DEBUG);
                    ret = 0;
                }
                break;
            }
            break;
        }
    case PTRACE_SYSCALL :
    case PTRACE_CONT :
        ret = -EIO;
        if (!valid_signal (data))
            break;
        if (request == PTRACE_SYSCALL)
            set_tsk_thread_flag (child, TIF_SYSCALL_TRACE);
        else
            clear_tsk_thread_flag (child, TIF_SYSCALL_TRACE);
        clear_tsk_thread_flag (child, TIF_SINGLESTEP);
        child->exit_code = data;
        clear_singlestep (child);
        wake_up_process (child);
        ret = 0;
        break;
    case PTRACE_ARCH_PRCTL :
        ret = do_arch_prctl (child, data, addr);
        break;
    case PTRACE_KILL :
        ret = 0;
        if (child->exit_state == EXIT_ZOMBIE)
            break;
        clear_tsk_thread_flag (child, TIF_SINGLESTEP);
        child->exit_code = SIGKILL;
        clear_singlestep (child);
        wake_up_process (child);
        break;
    case PTRACE_SINGLESTEP :
        ret = -EIO;
        if (!valid_signal (data))
            break;
        clear_tsk_thread_flag (child, TIF_SYSCALL_TRACE);
        set_singlestep (child);
        child->exit_code = data;
        wake_up_process (child);
        ret = 0;
        break;
    case PTRACE_GETREGS :
        {
            if (!access_ok (VERIFY_WRITE, (unsigned __user *) data, sizeof (struct user_regs_struct))) {
                ret = -EIO;
                break;
            }
            ret = 0;
            for (ui = 0; ui < sizeof (struct user_regs_struct); ui += sizeof (long)) {
                ret |= __put_user (getreg (child, ui), (unsigned long __user *) data);
                data += sizeof (long);
            }
            break;
        }
    case PTRACE_SETREGS :
        {
            unsigned long tmp;
            if (!access_ok (VERIFY_READ, (unsigned __user *) data, sizeof (struct user_regs_struct))) {
                ret = -EIO;
                break;
            }
            ret = 0;
            for (ui = 0; ui < sizeof (struct user_regs_struct); ui += sizeof (long)) {
                ret = __get_user (tmp, (unsigned long __user *) data);
                if (ret)
                    break;
                ret = putreg (child, ui, tmp);
                if (ret)
                    break;
                data += sizeof (long);
            }
            break;
        }
    case PTRACE_GETFPREGS :
        {
            if (!access_ok (VERIFY_WRITE, (unsigned __user *) data, sizeof (struct user_i387_struct))) {
                ret = -EIO;
                break;
            }
            ret = get_fpregs ((struct user_i387_struct __user *) data, child);
            break;
        }
    case PTRACE_SETFPREGS :
        {
            if (!access_ok (VERIFY_READ, (unsigned __user *) data, sizeof (struct user_i387_struct))) {
                ret = -EIO;
                break;
            }
            set_stopped_child_used_math (child);
            ret = set_fpregs (child, (struct user_i387_struct __user *) data);
            break;
        }
    default :
        ret = ptrace_request (child, request, addr, data);
        break;
    }
    return ret;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/ptrace_64.c.ifdefed" startline="317" endline="561">
{
case PTRACE_PEEKTEXT :
case PTRACE_PEEKDATA :
    ret = generic_ptrace_peekdata (child, addr, data);
    break;
case PTRACE_PEEKUSR :
    {
        unsigned long tmp;
        ret = -EIO;
        if ((addr & 7) || addr > sizeof (struct user) - 7)
            break;
        switch (addr) {
        case 0 ... sizeof (struct user_regs_struct) - sizeof (long) :
            tmp = getreg (child, addr);
            break;
        case offsetof (struct user, u_debugreg[0]) :
            tmp = child->thread.debugreg0;
            break;
        case offsetof (struct user, u_debugreg[1]) :
            tmp = child->thread.debugreg1;
            break;
        case offsetof (struct user, u_debugreg[2]) :
            tmp = child->thread.debugreg2;
            break;
        case offsetof (struct user, u_debugreg[3]) :
            tmp = child->thread.debugreg3;
            break;
        case offsetof (struct user, u_debugreg[6]) :
            tmp = child->thread.debugreg6;
            break;
        case offsetof (struct user, u_debugreg[7]) :
            tmp = child->thread.debugreg7;
            break;
        default :
            tmp = 0;
            break;
        }
        ret = put_user (tmp, (unsigned long __user *) data);
        break;
    }
case PTRACE_POKETEXT :
case PTRACE_POKEDATA :
    ret = generic_ptrace_pokedata (child, addr, data);
    break;
case PTRACE_POKEUSR :
    {
        int dsize = test_tsk_thread_flag (child, TIF_IA32) ? 3 : 7;
        ret = -EIO;
        if ((addr & 7) || addr > sizeof (struct user) - 7)
            break;
        switch (addr) {
        case 0 ... sizeof (struct user_regs_struct) - sizeof (long) :
            ret = putreg (child, addr, data);
            break;
        case offsetof (struct user, u_debugreg[0]) :
            if (data >= TASK_SIZE_OF (child) - dsize)
                break;
            child->thread.debugreg0 = data;
            ret = 0;
            break;
        case offsetof (struct user, u_debugreg[1]) :
            if (data >= TASK_SIZE_OF (child) - dsize)
                break;
            child->thread.debugreg1 = data;
            ret = 0;
            break;
        case offsetof (struct user, u_debugreg[2]) :
            if (data >= TASK_SIZE_OF (child) - dsize)
                break;
            child->thread.debugreg2 = data;
            ret = 0;
            break;
        case offsetof (struct user, u_debugreg[3]) :
            if (data >= TASK_SIZE_OF (child) - dsize)
                break;
            child->thread.debugreg3 = data;
            ret = 0;
            break;
        case offsetof (struct user, u_debugreg[6]) :
            if (data >> 32)
                break;
            child->thread.debugreg6 = data;
            ret = 0;
            break;
        case offsetof (struct user, u_debugreg[7]) :
            data &= ~DR_CONTROL_RESERVED;
            for (i = 0; i < 4; i++)
                if ((0x5554 >> ((data >> (16 + 4 * i)) & 0xf)) & 1)
                    break;
            if (i == 4) {
                child->thread.debugreg7 = data;
                if (data)
                    set_tsk_thread_flag (child, TIF_DEBUG);
                else
                    clear_tsk_thread_flag (child, TIF_DEBUG);
                ret = 0;
            }
            break;
        }
        break;
    }
case PTRACE_SYSCALL :
case PTRACE_CONT :
    ret = -EIO;
    if (!valid_signal (data))
        break;
    if (request == PTRACE_SYSCALL)
        set_tsk_thread_flag (child, TIF_SYSCALL_TRACE);
    else
        clear_tsk_thread_flag (child, TIF_SYSCALL_TRACE);
    clear_tsk_thread_flag (child, TIF_SINGLESTEP);
    child->exit_code = data;
    clear_singlestep (child);
    wake_up_process (child);
    ret = 0;
    break;
case PTRACE_ARCH_PRCTL :
    ret = do_arch_prctl (child, data, addr);
    break;
case PTRACE_KILL :
    ret = 0;
    if (child->exit_state == EXIT_ZOMBIE)
        break;
    clear_tsk_thread_flag (child, TIF_SINGLESTEP);
    child->exit_code = SIGKILL;
    clear_singlestep (child);
    wake_up_process (child);
    break;
case PTRACE_SINGLESTEP :
    ret = -EIO;
    if (!valid_signal (data))
        break;
    clear_tsk_thread_flag (child, TIF_SYSCALL_TRACE);
    set_singlestep (child);
    child->exit_code = data;
    wake_up_process (child);
    ret = 0;
    break;
case PTRACE_GETREGS :
    {
        if (!access_ok (VERIFY_WRITE, (unsigned __user *) data, sizeof (struct user_regs_struct))) {
            ret = -EIO;
            break;
        }
        ret = 0;
        for (ui = 0; ui < sizeof (struct user_regs_struct); ui += sizeof (long)) {
            ret |= __put_user (getreg (child, ui), (unsigned long __user *) data);
            data += sizeof (long);
        }
        break;
    }
case PTRACE_SETREGS :
    {
        unsigned long tmp;
        if (!access_ok (VERIFY_READ, (unsigned __user *) data, sizeof (struct user_regs_struct))) {
            ret = -EIO;
            break;
        }
        ret = 0;
        for (ui = 0; ui < sizeof (struct user_regs_struct); ui += sizeof (long)) {
            ret = __get_user (tmp, (unsigned long __user *) data);
            if (ret)
                break;
            ret = putreg (child, ui, tmp);
            if (ret)
                break;
            data += sizeof (long);
        }
        break;
    }
case PTRACE_GETFPREGS :
    {
        if (!access_ok (VERIFY_WRITE, (unsigned __user *) data, sizeof (struct user_i387_struct))) {
            ret = -EIO;
            break;
        }
        ret = get_fpregs ((struct user_i387_struct __user *) data, child);
        break;
    }
case PTRACE_SETFPREGS :
    {
        if (!access_ok (VERIFY_READ, (unsigned __user *) data, sizeof (struct user_i387_struct))) {
            ret = -EIO;
            break;
        }
        set_stopped_child_used_math (child);
        ret = set_fpregs (child, (struct user_i387_struct __user *) data);
        break;
    }
default :
    ret = ptrace_request (child, request, addr, data);
    break;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/ptrace_64.c.ifdefed" startline="325" endline="361">
{
    unsigned long tmp;
    ret = -EIO;
    if ((addr & 7) || addr > sizeof (struct user) - 7)
        break;
    switch (addr) {
    case 0 ... sizeof (struct user_regs_struct) - sizeof (long) :
        tmp = getreg (child, addr);
        break;
    case offsetof (struct user, u_debugreg[0]) :
        tmp = child->thread.debugreg0;
        break;
    case offsetof (struct user, u_debugreg[1]) :
        tmp = child->thread.debugreg1;
        break;
    case offsetof (struct user, u_debugreg[2]) :
        tmp = child->thread.debugreg2;
        break;
    case offsetof (struct user, u_debugreg[3]) :
        tmp = child->thread.debugreg3;
        break;
    case offsetof (struct user, u_debugreg[6]) :
        tmp = child->thread.debugreg6;
        break;
    case offsetof (struct user, u_debugreg[7]) :
        tmp = child->thread.debugreg7;
        break;
    default :
        tmp = 0;
        break;
    }
    ret = put_user (tmp, (unsigned long __user *) data);
    break;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/ptrace_64.c.ifdefed" startline="333" endline="358">
{
case 0 ... sizeof (struct user_regs_struct) - sizeof (long) :
    tmp = getreg (child, addr);
    break;
case offsetof (struct user, u_debugreg[0]) :
    tmp = child->thread.debugreg0;
    break;
case offsetof (struct user, u_debugreg[1]) :
    tmp = child->thread.debugreg1;
    break;
case offsetof (struct user, u_debugreg[2]) :
    tmp = child->thread.debugreg2;
    break;
case offsetof (struct user, u_debugreg[3]) :
    tmp = child->thread.debugreg3;
    break;
case offsetof (struct user, u_debugreg[6]) :
    tmp = child->thread.debugreg6;
    break;
case offsetof (struct user, u_debugreg[7]) :
    tmp = child->thread.debugreg7;
    break;
default :
    tmp = 0;
    break;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/ptrace_64.c.ifdefed" startline="370" endline="426">
{
    int dsize = test_tsk_thread_flag (child, TIF_IA32) ? 3 : 7;
    ret = -EIO;
    if ((addr & 7) || addr > sizeof (struct user) - 7)
        break;
    switch (addr) {
    case 0 ... sizeof (struct user_regs_struct) - sizeof (long) :
        ret = putreg (child, addr, data);
        break;
    case offsetof (struct user, u_debugreg[0]) :
        if (data >= TASK_SIZE_OF (child) - dsize)
            break;
        child->thread.debugreg0 = data;
        ret = 0;
        break;
    case offsetof (struct user, u_debugreg[1]) :
        if (data >= TASK_SIZE_OF (child) - dsize)
            break;
        child->thread.debugreg1 = data;
        ret = 0;
        break;
    case offsetof (struct user, u_debugreg[2]) :
        if (data >= TASK_SIZE_OF (child) - dsize)
            break;
        child->thread.debugreg2 = data;
        ret = 0;
        break;
    case offsetof (struct user, u_debugreg[3]) :
        if (data >= TASK_SIZE_OF (child) - dsize)
            break;
        child->thread.debugreg3 = data;
        ret = 0;
        break;
    case offsetof (struct user, u_debugreg[6]) :
        if (data >> 32)
            break;
        child->thread.debugreg6 = data;
        ret = 0;
        break;
    case offsetof (struct user, u_debugreg[7]) :
        data &= ~DR_CONTROL_RESERVED;
        for (i = 0; i < 4; i++)
            if ((0x5554 >> ((data >> (16 + 4 * i)) & 0xf)) & 1)
                break;
        if (i == 4) {
            child->thread.debugreg7 = data;
            if (data)
                set_tsk_thread_flag (child, TIF_DEBUG);
            else
                clear_tsk_thread_flag (child, TIF_DEBUG);
            ret = 0;
        }
        break;
    }
    break;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/ptrace_64.c.ifdefed" startline="377" endline="424">
{
case 0 ... sizeof (struct user_regs_struct) - sizeof (long) :
    ret = putreg (child, addr, data);
    break;
case offsetof (struct user, u_debugreg[0]) :
    if (data >= TASK_SIZE_OF (child) - dsize)
        break;
    child->thread.debugreg0 = data;
    ret = 0;
    break;
case offsetof (struct user, u_debugreg[1]) :
    if (data >= TASK_SIZE_OF (child) - dsize)
        break;
    child->thread.debugreg1 = data;
    ret = 0;
    break;
case offsetof (struct user, u_debugreg[2]) :
    if (data >= TASK_SIZE_OF (child) - dsize)
        break;
    child->thread.debugreg2 = data;
    ret = 0;
    break;
case offsetof (struct user, u_debugreg[3]) :
    if (data >= TASK_SIZE_OF (child) - dsize)
        break;
    child->thread.debugreg3 = data;
    ret = 0;
    break;
case offsetof (struct user, u_debugreg[6]) :
    if (data >> 32)
        break;
    child->thread.debugreg6 = data;
    ret = 0;
    break;
case offsetof (struct user, u_debugreg[7]) :
    data &= ~DR_CONTROL_RESERVED;
    for (i = 0; i < 4; i++)
        if ((0x5554 >> ((data >> (16 + 4 * i)) & 0xf)) & 1)
            break;
    if (i == 4) {
        child->thread.debugreg7 = data;
        if (data)
            set_tsk_thread_flag (child, TIF_DEBUG);
        else
            clear_tsk_thread_flag (child, TIF_DEBUG);
        ret = 0;
    }
    break;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/ptrace_64.c.ifdefed" startline="415" endline="422">
{
    child->thread.debugreg7 = data;
    if (data)
        set_tsk_thread_flag (child, TIF_DEBUG);
    else
        clear_tsk_thread_flag (child, TIF_DEBUG);
    ret = 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/ptrace_64.c.ifdefed" startline="503" endline="515">
{
    if (!access_ok (VERIFY_WRITE, (unsigned __user *) data, sizeof (struct user_regs_struct))) {
        ret = -EIO;
        break;
    }
    ret = 0;
    for (ui = 0; ui < sizeof (struct user_regs_struct); ui += sizeof (long)) {
        ret |= __put_user (getreg (child, ui), (unsigned long __user *) data);
        data += sizeof (long);
    }
    break;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/ptrace_64.c.ifdefed" startline="505" endline="508">
{
    ret = -EIO;
    break;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/ptrace_64.c.ifdefed" startline="510" endline="513">
{
    ret |= __put_user (getreg (child, ui), (unsigned long __user *) data);
    data += sizeof (long);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/ptrace_64.c.ifdefed" startline="517" endline="535">
{
    unsigned long tmp;
    if (!access_ok (VERIFY_READ, (unsigned __user *) data, sizeof (struct user_regs_struct))) {
        ret = -EIO;
        break;
    }
    ret = 0;
    for (ui = 0; ui < sizeof (struct user_regs_struct); ui += sizeof (long)) {
        ret = __get_user (tmp, (unsigned long __user *) data);
        if (ret)
            break;
        ret = putreg (child, ui, tmp);
        if (ret)
            break;
        data += sizeof (long);
    }
    break;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/ptrace_64.c.ifdefed" startline="520" endline="523">
{
    ret = -EIO;
    break;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/ptrace_64.c.ifdefed" startline="525" endline="533">
{
    ret = __get_user (tmp, (unsigned long __user *) data);
    if (ret)
        break;
    ret = putreg (child, ui, tmp);
    if (ret)
        break;
    data += sizeof (long);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/ptrace_64.c.ifdefed" startline="537" endline="545">
{
    if (!access_ok (VERIFY_WRITE, (unsigned __user *) data, sizeof (struct user_i387_struct))) {
        ret = -EIO;
        break;
    }
    ret = get_fpregs ((struct user_i387_struct __user *) data, child);
    break;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/ptrace_64.c.ifdefed" startline="539" endline="542">
{
    ret = -EIO;
    break;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/ptrace_64.c.ifdefed" startline="547" endline="556">
{
    if (!access_ok (VERIFY_READ, (unsigned __user *) data, sizeof (struct user_i387_struct))) {
        ret = -EIO;
        break;
    }
    set_stopped_child_used_math (child);
    ret = set_fpregs (child, (struct user_i387_struct __user *) data);
    break;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/ptrace_64.c.ifdefed" startline="549" endline="552">
{
    ret = -EIO;
    break;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/ptrace_64.c.ifdefed" startline="566" endline="586">
{
    ptrace_notify (SIGTRAP | ((current -> ptrace & PT_TRACESYSGOOD) ? 0x80 : 0));
    if (current->exit_code) {
        send_sig (current -> exit_code, current, 1);
        current->exit_code = 0;
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/ptrace_64.c.ifdefed" startline="582" endline="585">
{
    send_sig (current -> exit_code, current, 1);
    current->exit_code = 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/ptrace_64.c.ifdefed" startline="589" endline="610">
{
    secure_computing (regs -> orig_rax);
    if (test_thread_flag (TIF_SYSCALL_TRACE) && (current->ptrace & PT_PTRACED))
        syscall_trace (regs);
    if (unlikely (current->audit_context)) {
        if (test_thread_flag (TIF_IA32)) {
            audit_syscall_entry (AUDIT_ARCH_I386, regs -> orig_rax, regs -> rbx, regs -> rcx, regs -> rdx, regs -> rsi);
        }
        else {
            audit_syscall_entry (AUDIT_ARCH_X86_64, regs -> orig_rax, regs -> rdi, regs -> rsi, regs -> rdx, regs -> r10);
        }
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/ptrace_64.c.ifdefed" startline="597" endline="609">
{
    if (test_thread_flag (TIF_IA32)) {
        audit_syscall_entry (AUDIT_ARCH_I386, regs -> orig_rax, regs -> rbx, regs -> rcx, regs -> rdx, regs -> rsi);
    }
    else {
        audit_syscall_entry (AUDIT_ARCH_X86_64, regs -> orig_rax, regs -> rdi, regs -> rsi, regs -> rdx, regs -> r10);
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/ptrace_64.c.ifdefed" startline="598" endline="603">
{
    audit_syscall_entry (AUDIT_ARCH_I386, regs -> orig_rax, regs -> rbx, regs -> rcx, regs -> rdx, regs -> rsi);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/ptrace_64.c.ifdefed" startline="603" endline="608">
{
    audit_syscall_entry (AUDIT_ARCH_X86_64, regs -> orig_rax, regs -> rdi, regs -> rsi, regs -> rdx, regs -> r10);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/ptrace_64.c.ifdefed" startline="613" endline="621">
{
    if (unlikely (current->audit_context))
        audit_syscall_exit (AUDITSC_RESULT (regs->rax), regs->rax);
    if ((test_thread_flag (TIF_SYSCALL_TRACE) || test_thread_flag (TIF_SINGLESTEP)) && (current->ptrace & PT_PTRACED))
        syscall_trace (regs);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/hpet.c.ifdefed" startline="29" endline="31">
{
    return readl (hpet_virt_address +a);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/hpet.c.ifdefed" startline="34" endline="36">
{
    writel (d, hpet_virt_address + a);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/hpet.c.ifdefed" startline="57" endline="59">
{
    hpet_virt_address = ioremap_nocache (hpet_address, HPET_MMAP_SIZE);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/hpet.c.ifdefed" startline="62" endline="65">
{
    iounmap (hpet_virt_address);
    hpet_virt_address = NULL;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/hpet.c.ifdefed" startline="75" endline="83">
{
    if (str) {
        if (!strncmp ("disable", str, 7))
            boot_hpet_disable = 1;
        if (!strncmp ("force", str, 5))
            hpet_force_user = 1;
    }
    return 1;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/hpet.c.ifdefed" startline="76" endline="81">
{
    if (!strncmp ("disable", str, 7))
        boot_hpet_disable = 1;
    if (!strncmp ("force", str, 5))
        hpet_force_user = 1;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/hpet.c.ifdefed" startline="87" endline="90">
{
    boot_hpet_disable = 1;
    return 1;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/hpet.c.ifdefed" startline="94" endline="96">
{
    return (!boot_hpet_disable && hpet_address);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/hpet.c.ifdefed" startline="107" endline="109">
{
    return is_hpet_capable () && hpet_legacy_int_enabled;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/hpet.c.ifdefed" startline="147" endline="147">
{
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/hpet.c.ifdefed" startline="174" endline="183">
{
    unsigned long cfg = hpet_readl (HPET_CFG);
    cfg &= ~HPET_CFG_ENABLE;
    hpet_writel (cfg, HPET_CFG);
    hpet_writel (0, HPET_COUNTER);
    hpet_writel (0, HPET_COUNTER + 4);
    cfg |= HPET_CFG_ENABLE;
    hpet_writel (cfg, HPET_CFG);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/hpet.c.ifdefed" startline="186" endline="188">
{
    force_hpet_resume ();
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/hpet.c.ifdefed" startline="191" endline="194">
{
    hpet_resume_device ();
    hpet_start_counter ();
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/hpet.c.ifdefed" startline="197" endline="203">
{
    unsigned long cfg = hpet_readl (HPET_CFG);
    cfg |= HPET_CFG_LEGACY;
    hpet_writel (cfg, HPET_CFG);
    hpet_legacy_int_enabled = 1;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/hpet.c.ifdefed" startline="206" endline="235">
{
    uint64_t hpet_freq;
    hpet_enable_legacy_int ();
    hpet_freq = 1000000000000000ULL;
    do_div (hpet_freq, hpet_period);
    hpet_clockevent.mult = div_sc ((unsigned long) hpet_freq, NSEC_PER_SEC, 32);
    hpet_clockevent.max_delta_ns = clockevent_delta2ns (0x7FFFFFFF, &hpet_clockevent);
    hpet_clockevent.min_delta_ns = clockevent_delta2ns (0x30, &hpet_clockevent);
    hpet_clockevent.cpumask = cpumask_of_cpu (smp_processor_id ());
    clockevents_register_device (& hpet_clockevent);
    global_clock_event = &hpet_clockevent;
    printk (KERN_DEBUG "hpet clockevent registered\n");
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/hpet.c.ifdefed" startline="239" endline="281">
{
    unsigned long cfg, cmp, now;
    uint64_t delta;
    switch (mode) {
    case CLOCK_EVT_MODE_PERIODIC :
        delta = ((uint64_t) (NSEC_PER_SEC / HZ)) * hpet_clockevent.mult;
        delta >>= hpet_clockevent.shift;
        now = hpet_readl (HPET_COUNTER);
        cmp = now + (unsigned long) delta;
        cfg = hpet_readl (HPET_T0_CFG);
        cfg |= HPET_TN_ENABLE | HPET_TN_PERIODIC | HPET_TN_SETVAL | HPET_TN_32BIT;
        hpet_writel (cfg, HPET_T0_CFG);
        hpet_writel (cmp, HPET_T0_CMP);
        udelay (1);
        hpet_writel ((unsigned long) delta, HPET_T0_CMP);
        break;
    case CLOCK_EVT_MODE_ONESHOT :
        cfg = hpet_readl (HPET_T0_CFG);
        cfg &= ~HPET_TN_PERIODIC;
        cfg |= HPET_TN_ENABLE | HPET_TN_32BIT;
        hpet_writel (cfg, HPET_T0_CFG);
        break;
    case CLOCK_EVT_MODE_UNUSED :
    case CLOCK_EVT_MODE_SHUTDOWN :
        cfg = hpet_readl (HPET_T0_CFG);
        cfg &= ~HPET_TN_ENABLE;
        hpet_writel (cfg, HPET_T0_CFG);
        break;
    case CLOCK_EVT_MODE_RESUME :
        hpet_enable_legacy_int ();
        break;
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/hpet.c.ifdefed" startline="243" endline="280">
{
case CLOCK_EVT_MODE_PERIODIC :
    delta = ((uint64_t) (NSEC_PER_SEC / HZ)) * hpet_clockevent.mult;
    delta >>= hpet_clockevent.shift;
    now = hpet_readl (HPET_COUNTER);
    cmp = now + (unsigned long) delta;
    cfg = hpet_readl (HPET_T0_CFG);
    cfg |= HPET_TN_ENABLE | HPET_TN_PERIODIC | HPET_TN_SETVAL | HPET_TN_32BIT;
    hpet_writel (cfg, HPET_T0_CFG);
    hpet_writel (cmp, HPET_T0_CMP);
    udelay (1);
    hpet_writel ((unsigned long) delta, HPET_T0_CMP);
    break;
case CLOCK_EVT_MODE_ONESHOT :
    cfg = hpet_readl (HPET_T0_CFG);
    cfg &= ~HPET_TN_PERIODIC;
    cfg |= HPET_TN_ENABLE | HPET_TN_32BIT;
    hpet_writel (cfg, HPET_T0_CFG);
    break;
case CLOCK_EVT_MODE_UNUSED :
case CLOCK_EVT_MODE_SHUTDOWN :
    cfg = hpet_readl (HPET_T0_CFG);
    cfg &= ~HPET_TN_ENABLE;
    hpet_writel (cfg, HPET_T0_CFG);
    break;
case CLOCK_EVT_MODE_RESUME :
    hpet_enable_legacy_int ();
    break;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/hpet.c.ifdefed" startline="285" endline="293">
{
    unsigned long cnt;
    cnt = hpet_readl (HPET_COUNTER);
    cnt += delta;
    hpet_writel (cnt, HPET_T0_CMP);
    return ((long) (hpet_readl (HPET_COUNTER) - cnt) > 0) ? -ETIME : 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/hpet.c.ifdefed" startline="299" endline="301">
{
    return (cycle_t) hpet_readl (HPET_COUNTER);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/hpet.c.ifdefed" startline="324" endline="371">
{
    u64 tmp, start, now;
    cycle_t t1;
    hpet_start_counter ();
    t1 = read_hpet ();
    rdtscll (start);
    do {
        rep_nop ();
        rdtscll (now);
    }
    while ((now - start) < 200000UL);
    if (t1 == read_hpet ()) {
        printk (KERN_WARNING "HPET counter not counting. HPET disabled\n");
        return -ENODEV;
    }
    tmp = (u64) hpet_period << HPET_SHIFT;
    do_div (tmp, FSEC_PER_NSEC);
    clocksource_hpet.mult = (u32) tmp;
    clocksource_register (& clocksource_hpet);
    return 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/hpet.c.ifdefed" startline="341" endline="344">
{
    rep_nop ();
    rdtscll (now);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/hpet.c.ifdefed" startline="346" endline="350">
{
    printk (KERN_WARNING "HPET counter not counting. HPET disabled\n");
    return -ENODEV;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/hpet.c.ifdefed" startline="377" endline="420">
{
    unsigned long id;
    if (!is_hpet_capable ())
        return 0;
    hpet_set_mapping ();
    hpet_period = hpet_readl (HPET_PERIOD);
    if (hpet_period < HPET_MIN_PERIOD || hpet_period > HPET_MAX_PERIOD)
        goto out_nohpet;
    id = hpet_readl (HPET_ID);
    if (hpet_clocksource_register ())
        goto out_nohpet;
    if (id & HPET_ID_LEGSUP) {
        hpet_legacy_clockevent_register ();
        return 1;
    }
    return 0;
out_nohpet :
    hpet_clear_mapping ();
    boot_hpet_disable = 1;
    return 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/hpet.c.ifdefed" startline="410" endline="413">
{
    hpet_legacy_clockevent_register ();
    return 1;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/hpet.c.ifdefed" startline="429" endline="446">
{
    if (boot_hpet_disable)
        return -ENODEV;
    if (!hpet_address) {
        if (!force_hpet_address)
            return -ENODEV;
        hpet_address = force_hpet_address;
        hpet_enable ();
        if (!hpet_virt_address)
            return -ENODEV;
    }
    hpet_reserve_platform_timers (hpet_readl (HPET_ID));
    return 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/hpet.c.ifdefed" startline="433" endline="441">
{
    if (!force_hpet_address)
        return -ENODEV;
    hpet_address = force_hpet_address;
    hpet_enable ();
    if (!hpet_virt_address)
        return -ENODEV;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/hpet.c.ifdefed" startline="450" endline="461">
{
    if (is_hpet_capable ()) {
        unsigned long cfg = hpet_readl (HPET_CFG);
        if (hpet_legacy_int_enabled) {
            cfg &= ~HPET_CFG_LEGACY;
            hpet_legacy_int_enabled = 0;
        }
        cfg &= ~HPET_CFG_ENABLE;
        hpet_writel (cfg, HPET_CFG);
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/hpet.c.ifdefed" startline="451" endline="460">
{
    unsigned long cfg = hpet_readl (HPET_CFG);
    if (hpet_legacy_int_enabled) {
        cfg &= ~HPET_CFG_LEGACY;
        hpet_legacy_int_enabled = 0;
    }
    cfg &= ~HPET_CFG_ENABLE;
    hpet_writel (cfg, HPET_CFG);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/hpet.c.ifdefed" startline="454" endline="457">
{
    cfg &= ~HPET_CFG_LEGACY;
    hpet_legacy_int_enabled = 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/setup_64.c.ifdefed" startline="163" endline="174">
{
    unsigned long bootmap_size, bootmap;
    bootmap_size = bootmem_bootmap_pages (end_pfn) << PAGE_SHIFT;
    bootmap = find_e820_area (0, end_pfn << PAGE_SHIFT, bootmap_size);
    if (bootmap == -1L)
        panic ("Cannot find bootmem map of size %ld\n", bootmap_size);
    bootmap_size = init_bootmem (bootmap >> PAGE_SHIFT, end_pfn);
    e820_register_active_regions (0, start_pfn, end_pfn);
    free_bootmem_with_active_regions (0, end_pfn);
    reserve_bootmem (bootmap, bootmap_size);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/setup_64.c.ifdefed" startline="197" endline="198">
{
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/setup_64.c.ifdefed" startline="229" endline="229">
{
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/setup_64.c.ifdefed" startline="238" endline="255">
{
    ebda_addr = *(unsignedshort*) __va (EBDA_ADDR_POINTER);
    ebda_addr <<= 4;
    ebda_size = *(unsignedshort*) __va (ebda_addr);
    if (ebda_size == 0)
        ebda_size = 1;
    ebda_size <<= 10;
    ebda_size = round_up (ebda_size +(ebda_addr & ~PAGE_MASK), PAGE_SIZE);
    if (ebda_size > 64 * 1024)
        ebda_size = 64 * 1024;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/setup_64.c.ifdefed" startline="258" endline="456">
{
    printk (KERN_INFO "Command line: %s\n", boot_command_line);
    ROOT_DEV = old_decode_dev (boot_params.hdr.root_dev);
    screen_info = boot_params.screen_info;
    edid_info = boot_params.edid_info;
    saved_video_mode = boot_params.hdr.vid_mode;
    bootloader_type = boot_params.hdr.type_of_loader;
    setup_memory_region ();
    copy_edd ();
    if (!boot_params.hdr.root_flags)
        root_mountflags &= ~MS_RDONLY;
    init_mm.start_code = (unsigned long) &_text;
    init_mm.end_code = (unsigned long) &_etext;
    init_mm.end_data = (unsigned long) &_edata;
    init_mm.brk = (unsigned long) &_end;
    code_resource.start = virt_to_phys (&_text);
    code_resource.end = virt_to_phys (&_etext) - 1;
    data_resource.start = virt_to_phys (&_etext);
    data_resource.end = virt_to_phys (&_edata) - 1;
    bss_resource.start = virt_to_phys (&__bss_start);
    bss_resource.end = virt_to_phys (&__bss_stop) - 1;
    early_identify_cpu (& boot_cpu_data);
    strlcpy (command_line, boot_command_line, COMMAND_LINE_SIZE);
    *cmdline_p = command_line;
    parse_early_param ();
    finish_e820_parsing ();
    e820_register_active_regions (0, 0, - 1UL);
    end_pfn = e820_end_of_ram ();
    num_physpages = end_pfn;
    check_efer ();
    discover_ebda ();
    init_memory_mapping (0, (end_pfn_map << PAGE_SHIFT));
    dmi_scan_machine ();
    max_low_pfn = end_pfn;
    max_pfn = end_pfn;
    high_memory = (void *) __va (end_pfn *PAGE_SIZE - 1) + 1;
    remove_all_active_ranges ();
    contig_initmem_init (0, end_pfn);
    reserve_bootmem_generic (table_start << PAGE_SHIFT, (table_end - table_start) << PAGE_SHIFT);
    reserve_bootmem_generic (__pa_symbol (& _text), __pa_symbol (& _end) - __pa_symbol (& _text));
    reserve_bootmem_generic (0, PAGE_SIZE);
    if (ebda_addr)
        reserve_bootmem_generic (ebda_addr, ebda_size);
    find_smp_config ();
    reserve_crashkernel ();
    paging_init ();
    cpu_set (0, cpu_present_map);
    init_cpu_to_node ();
    if (smp_found_config)
        get_smp_config ();
    init_apic_mappings ();
    e820_reserve_resources ();
    e820_mark_nosave_regions ();
    {
        unsigned i;
        for (i = 0; i < ARRAY_SIZE (standard_io_resources); i++)
            request_resource (&ioport_resource, &standard_io_resources[i]);
    }
    e820_setup_gap ();
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/setup_64.c.ifdefed" startline="440" endline="445">
{
    unsigned i;
    for (i = 0; i < ARRAY_SIZE (standard_io_resources); i++)
        request_resource (&ioport_resource, &standard_io_resources[i]);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/setup_64.c.ifdefed" startline="459" endline="471">
{
    unsigned int *v;
    if (c->extended_cpuid_level < 0x80000004)
        return 0;
    v = (unsigned int *) c->x86_model_id;
    cpuid (0x80000002, & v [0], & v [1], & v [2], & v [3]);
    cpuid (0x80000003, & v [4], & v [5], & v [6], & v [7]);
    cpuid (0x80000004, & v [8], & v [9], & v [10], & v [11]);
    c->x86_model_id[48] = 0;
    return 1;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/setup_64.c.ifdefed" startline="475" endline="506">
{
    unsigned int n, dummy, eax, ebx, ecx, edx;
    n = c->extended_cpuid_level;
    if (n >= 0x80000005) {
        cpuid (0x80000005, & dummy, & ebx, & ecx, & edx);
        printk (KERN_INFO "CPU: L1 I Cache: %dK (%d bytes/line), D cache %dK (%d bytes/line)\n", edx >> 24, edx & 0xFF, ecx >> 24, ecx & 0xFF);
        c->x86_cache_size = (ecx >> 24) + (edx >> 24);
        c->x86_tlbsize = 0;
    }
    if (n >= 0x80000006) {
        cpuid (0x80000006, & dummy, & ebx, & ecx, & edx);
        ecx = cpuid_ecx (0x80000006);
        c->x86_cache_size = ecx >> 16;
        c->x86_tlbsize += ((ebx >> 16) & 0xfff) + (ebx & 0xfff);
        printk (KERN_INFO "CPU: L2 Cache: %dK (%d bytes/line)\n", c -> x86_cache_size, ecx & 0xFF);
    }
    if (n >= 0x80000007)
        cpuid (0x80000007, &dummy, &dummy, &dummy, &c->x86_power);
    if (n >= 0x80000008) {
        cpuid (0x80000008, & eax, & dummy, & dummy, & dummy);
        c->x86_virt_bits = (eax >> 8) & 0xff;
        c->x86_phys_bits = eax & 0xff;
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/setup_64.c.ifdefed" startline="480" endline="487">
{
    cpuid (0x80000005, & dummy, & ebx, & ecx, & edx);
    printk (KERN_INFO "CPU: L1 I Cache: %dK (%d bytes/line), D cache %dK (%d bytes/line)\n", edx >> 24, edx & 0xFF, ecx >> 24, ecx & 0xFF);
    c->x86_cache_size = (ecx >> 24) + (edx >> 24);
    c->x86_tlbsize = 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/setup_64.c.ifdefed" startline="489" endline="497">
{
    cpuid (0x80000006, & dummy, & ebx, & ecx, & edx);
    ecx = cpuid_ecx (0x80000006);
    c->x86_cache_size = ecx >> 16;
    c->x86_tlbsize += ((ebx >> 16) & 0xfff) + (ebx & 0xfff);
    printk (KERN_INFO "CPU: L2 Cache: %dK (%d bytes/line)\n", c -> x86_cache_size, ecx & 0xFF);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/setup_64.c.ifdefed" startline="501" endline="505">
{
    cpuid (0x80000008, & eax, & dummy, & dummy, & dummy);
    c->x86_virt_bits = (eax >> 8) & 0xff;
    c->x86_phys_bits = eax & 0xff;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/setup_64.c.ifdefed" startline="531" endline="584">
{
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/setup_64.c.ifdefed" startline="597" endline="615">
{
    u32 lo, hi;
    u32 eax = cpuid_eax (CPUID_PROCESSOR_SIGNATURE);
    switch (eax & CPUID_XFAM) {
    case CPUID_XFAM_K8 :
        if ((eax & CPUID_XMOD) < CPUID_XMOD_REV_F)
            break;
    case CPUID_XFAM_10H :
    case CPUID_XFAM_11H :
        rdmsr (MSR_K8_ENABLE_C1E, lo, hi);
        if (lo & ENABLE_C1E_MASK)
            return 1;
        break;
    default :
        return 1;
    }
    return 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/setup_64.c.ifdefed" startline="600" endline="613">
{
case CPUID_XFAM_K8 :
    if ((eax & CPUID_XMOD) < CPUID_XMOD_REV_F)
        break;
case CPUID_XFAM_10H :
case CPUID_XFAM_11H :
    rdmsr (MSR_K8_ENABLE_C1E, lo, hi);
    if (lo & ENABLE_C1E_MASK)
        return 1;
    break;
default :
    return 1;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/setup_64.c.ifdefed" startline="618" endline="691">
{
    unsigned level;
    clear_bit (0 * 32 + 31, & c -> x86_capability);
    level = cpuid_eax (1);
    if (c->x86 == 15 && ((level >= 0x0f48 && level < 0x0f50) || level >= 0x0f58))
        set_bit (X86_FEATURE_REP_GOOD, &c->x86_capability);
    if (c->x86 == 0x10 || c->x86 == 0x11)
        set_bit (X86_FEATURE_REP_GOOD, &c->x86_capability);
    if (c->x86 >= 6)
        set_bit (X86_FEATURE_FXSAVE_LEAK, &c->x86_capability);
    level = get_model_name (c);
    if (!level) {
        switch (c->x86) {
        case 15 :
            strcpy (c->x86_model_id, "Hammer");
            break;
        }
    }
    display_cacheinfo (c);
    if (c->x86_power & (1 << 8))
        set_bit (X86_FEATURE_CONSTANT_TSC, &c->x86_capability);
    if (c->extended_cpuid_level >= 0x80000008)
        amd_detect_cmp (c);
    if (c->extended_cpuid_level >= 0x80000006 && (cpuid_edx (0x80000006) & 0xf000))
        num_cache_leaves = 4;
    else
        num_cache_leaves = 3;
    if (c->x86 == 0xf || c->x86 == 0x10 || c->x86 == 0x11)
        set_bit (X86_FEATURE_K8, &c->x86_capability);
    clear_bit (X86_FEATURE_SYNC_RDTSC, & c -> x86_capability);
    if (c->x86 == 0x10 && !force_mwait)
        clear_bit (X86_FEATURE_MWAIT, &c->x86_capability);
    if (amd_apic_timer_broken ())
        disable_apic_timer = 1;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/setup_64.c.ifdefed" startline="654" endline="662">
{
    switch (c->x86) {
    case 15 :
        strcpy (c->x86_model_id, "Hammer");
        break;
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/setup_64.c.ifdefed" startline="655" endline="661">
{
case 15 :
    strcpy (c->x86_model_id, "Hammer");
    break;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/setup_64.c.ifdefed" startline="694" endline="738">
{
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/setup_64.c.ifdefed" startline="744" endline="756">
{
    unsigned int eax, t;
    if (c->cpuid_level < 4)
        return 1;
    cpuid_count (4, 0, & eax, & t, & t, & t);
    if (eax & 0x1f)
        return ((eax >> 26) + 1);
    else
        return 1;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/setup_64.c.ifdefed" startline="759" endline="774">
{
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/setup_64.c.ifdefed" startline="777" endline="824">
{
    unsigned n;
    init_intel_cacheinfo (c);
    if (c->cpuid_level > 9) {
        unsigned eax = cpuid_eax (10);
        if ((eax & 0xff) && (((eax >> 8) & 0xff) > 1))
            set_bit (X86_FEATURE_ARCH_PERFMON, &c->x86_capability);
    }
    if (cpu_has_ds) {
        unsigned int l1, l2;
        rdmsr (MSR_IA32_MISC_ENABLE, l1, l2);
        if (!(l1 & (1 << 11)))
            set_bit (X86_FEATURE_BTS, c->x86_capability);
        if (!(l1 & (1 << 12)))
            set_bit (X86_FEATURE_PEBS, c->x86_capability);
    }
    n = c->extended_cpuid_level;
    if (n >= 0x80000008) {
        unsigned eax = cpuid_eax (0x80000008);
        c->x86_virt_bits = (eax >> 8) & 0xff;
        c->x86_phys_bits = eax & 0xff;
        if (c->x86_vendor == X86_VENDOR_INTEL && c->x86 == 0xF && c->x86_model == 0x3 && c->x86_mask == 0x4)
            c->x86_phys_bits = 36;
    }
    if (c->x86 == 15)
        c->x86_cache_alignment = c->x86_clflush_size * 2;
    if ((c->x86 == 0xf && c->x86_model >= 0x03) || (c->x86 == 0x6 && c->x86_model >= 0x0e))
        set_bit (X86_FEATURE_CONSTANT_TSC, &c->x86_capability);
    if (c->x86 == 6)
        set_bit (X86_FEATURE_REP_GOOD, &c->x86_capability);
    if (c->x86 == 15)
        set_bit (X86_FEATURE_SYNC_RDTSC, &c->x86_capability);
    else
        clear_bit (X86_FEATURE_SYNC_RDTSC, &c->x86_capability);
    c->x86_max_cores = intel_num_cpu_cores (c);
    srat_detect_node ();
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/setup_64.c.ifdefed" startline="782" endline="787">
{
    unsigned eax = cpuid_eax (10);
    if ((eax & 0xff) && (((eax >> 8) & 0xff) > 1))
        set_bit (X86_FEATURE_ARCH_PERFMON, &c->x86_capability);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/setup_64.c.ifdefed" startline="789" endline="796">
{
    unsigned int l1, l2;
    rdmsr (MSR_IA32_MISC_ENABLE, l1, l2);
    if (!(l1 & (1 << 11)))
        set_bit (X86_FEATURE_BTS, c->x86_capability);
    if (!(l1 & (1 << 12)))
        set_bit (X86_FEATURE_PEBS, c->x86_capability);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/setup_64.c.ifdefed" startline="799" endline="808">
{
    unsigned eax = cpuid_eax (0x80000008);
    c->x86_virt_bits = (eax >> 8) & 0xff;
    c->x86_phys_bits = eax & 0xff;
    if (c->x86_vendor == X86_VENDOR_INTEL && c->x86 == 0xF && c->x86_model == 0x3 && c->x86_mask == 0x4)
        c->x86_phys_bits = 36;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/setup_64.c.ifdefed" startline="827" endline="836">
{
    char *v = c->x86_vendor_id;
    if (!strcmp (v, "AuthenticAMD"))
        c->x86_vendor = X86_VENDOR_AMD;
    else if (!strcmp (v, "GenuineIntel"))
        c->x86_vendor = X86_VENDOR_INTEL;
    else
        c->x86_vendor = X86_VENDOR_UNKNOWN;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/setup_64.c.ifdefed" startline="848" endline="896">
{
    u32 tfms;
    c->loops_per_jiffy = loops_per_jiffy;
    c->x86_cache_size = -1;
    c->x86_vendor = X86_VENDOR_UNKNOWN;
    c->x86_model = c->x86_mask = 0;
    c->x86_vendor_id[0] = '\0';
    c->x86_model_id[0] = '\0';
    c->x86_clflush_size = 64;
    c->x86_cache_alignment = c->x86_clflush_size;
    c->x86_max_cores = 1;
    c->extended_cpuid_level = 0;
    memset (& c -> x86_capability, 0, sizeof c -> x86_capability);
    cpuid (0x00000000, (unsigned int *) & c -> cpuid_level, (unsigned int *) & c -> x86_vendor_id [0], (unsigned int *) & c -> x86_vendor_id [8], (unsigned int *) & c -> x86_vendor_id [4]);
    get_cpu_vendor (c);
    if (c->cpuid_level >= 0x00000001) {
        __u32 misc;
        cpuid (0x00000001, & tfms, & misc, & c -> x86_capability [4], & c -> x86_capability [0]);
        c->x86 = (tfms >> 8) & 0xf;
        c->x86_model = (tfms >> 4) & 0xf;
        c->x86_mask = tfms & 0xf;
        if (c->x86 == 0xf)
            c->x86 += (tfms >> 20) & 0xff;
        if (c->x86 >= 0x6)
            c->x86_model += ((tfms >> 16) & 0xF) << 4;
        if (c->x86_capability[0] & (1 << 19))
            c->x86_clflush_size = ((misc >> 8) & 0xff) * 8;
    }
    else {
        c->x86 = 4;
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/setup_64.c.ifdefed" startline="875" endline="888">
{
    __u32 misc;
    cpuid (0x00000001, & tfms, & misc, & c -> x86_capability [4], & c -> x86_capability [0]);
    c->x86 = (tfms >> 8) & 0xf;
    c->x86_model = (tfms >> 4) & 0xf;
    c->x86_mask = tfms & 0xf;
    if (c->x86 == 0xf)
        c->x86 += (tfms >> 20) & 0xff;
    if (c->x86 >= 0x6)
        c->x86_model += ((tfms >> 16) & 0xF) << 4;
    if (c->x86_capability[0] & (1 << 19))
        c->x86_clflush_size = ((misc >> 8) & 0xff) * 8;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/setup_64.c.ifdefed" startline="888" endline="891">
{
    c->x86 = 4;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/setup_64.c.ifdefed" startline="902" endline="980">
{
    int i;
    u32 xlvl;
    early_identify_cpu (c);
    xlvl = cpuid_eax (0x80000000);
    c->extended_cpuid_level = xlvl;
    if ((xlvl & 0xffff0000) == 0x80000000) {
        if (xlvl >= 0x80000001) {
            c->x86_capability[1] = cpuid_edx (0x80000001);
            c->x86_capability[6] = cpuid_ecx (0x80000001);
        }
        if (xlvl >= 0x80000004)
            get_model_name (c);
    }
    xlvl = cpuid_eax (0x80860000);
    if ((xlvl & 0xffff0000) == 0x80860000) {
        if (xlvl >= 0x80860001)
            c->x86_capability[2] = cpuid_edx (0x80860001);
    }
    init_scattered_cpuid_features (c);
    c->apicid = phys_pkg_id (0);
    switch (c->x86_vendor) {
    case X86_VENDOR_AMD :
        init_amd (c);
        break;
    case X86_VENDOR_INTEL :
        init_intel (c);
        break;
    case X86_VENDOR_UNKNOWN :
    default :
        display_cacheinfo (c);
        break;
    }
    select_idle_routine (c);
    detect_ht (c);
    if (c != &boot_cpu_data) {
        for (i = 0; i < NCAPINTS; i++)
            boot_cpu_data.x86_capability[i] &= c->x86_capability[i];
    }
    if (c != &boot_cpu_data)
        mtrr_ap_init ();
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/setup_64.c.ifdefed" startline="911" endline="918">
{
    if (xlvl >= 0x80000001) {
        c->x86_capability[1] = cpuid_edx (0x80000001);
        c->x86_capability[6] = cpuid_ecx (0x80000001);
    }
    if (xlvl >= 0x80000004)
        get_model_name (c);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/setup_64.c.ifdefed" startline="912" endline="915">
{
    c->x86_capability[1] = cpuid_edx (0x80000001);
    c->x86_capability[6] = cpuid_ecx (0x80000001);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/setup_64.c.ifdefed" startline="922" endline="926">
{
    if (xlvl >= 0x80860001)
        c->x86_capability[2] = cpuid_edx (0x80860001);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/setup_64.c.ifdefed" startline="942" endline="955">
{
case X86_VENDOR_AMD :
    init_amd (c);
    break;
case X86_VENDOR_INTEL :
    init_intel (c);
    break;
case X86_VENDOR_UNKNOWN :
default :
    display_cacheinfo (c);
    break;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/setup_64.c.ifdefed" startline="966" endline="970">
{
    for (i = 0; i < NCAPINTS; i++)
        boot_cpu_data.x86_capability[i] &= c->x86_capability[i];
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/setup_64.c.ifdefed" startline="984" endline="992">
{
    if (c->x86_model_id[0])
        printk ("%s", c->x86_model_id);
    if (c->x86_mask || c->cpuid_level >= 0)
        printk (" stepping %02x\n", c->x86_mask);
    else
        printk ("\n");
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/setup_64.c.ifdefed" startline="999" endline="1166">
{
    struct cpuinfo_x86 *c = v;
    int cpu = 0;
    static const char * const x86_cap_flags [] = {"fpu", "vme", "de", "pse", "tsc", "msr", "pae", "mce", "cx8", "apic", NULL, "sep", "mtrr", "pge", "mca", "cmov", "pat", "pse36", "pn", "clflush", NULL, "dts", "acpi", "mmx", "fxsr", "sse", "sse2", "ss", "ht", "tm", "ia64", "pbe", NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, "syscall", NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, "nx", NULL, "mmxext", NULL, NULL, "fxsr_opt", "pdpe1gb", "rdtscp", NULL, "lm", "3dnowext", "3dnow", "recovery", "longrun", NULL, "lrti", NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, "cxmmx", "k6_mtrr", "cyrix_arr", "centaur_mcr", NULL, NULL, NULL, NULL, "constant_tsc", "up", NULL, "arch_perfmon", "pebs", "bts", NULL, "sync_rdtsc", "rep_good", NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, "pni", NULL, NULL, "monitor", "ds_cpl", "vmx", "smx", "est", "tm2", "ssse3", "cid", NULL, NULL, "cx16", "xtpr", NULL, NULL, NULL, "dca", "sse4_1", "sse4_2", NULL, NULL, "popcnt", NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, "rng", "rng_en", NULL, NULL, "ace", "ace_en", "ace2", "ace2_en", "phe", "phe_en", "pmm", "pmm_en", NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, "lahf_lm", "cmp_legacy", "svm", "extapic", "cr8_legacy", "abm", "sse4a", "misalignsse", "3dnowprefetch", "osvw", "ibs", "sse5", "skinit", "wdt", NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, "ida", NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,};
    static const char * const x86_power_flags [] = {"ts", "fid", "vid", "ttp", "tm", "stc", "100mhzsteps", "hwpstate", "",};
    seq_printf (m, "processor\t: %u\n" "vendor_id\t: %s\n" "cpu family\t: %d\n" "model\t\t: %d\n" "model name\t: %s\n", (unsigned) cpu, c -> x86_vendor_id [0] ? c -> x86_vendor_id : "unknown", c -> x86, (int) c -> x86_model, c -> x86_model_id [0] ? c -> x86_model_id : "unknown");
    if (c->x86_mask || c->cpuid_level >= 0)
        seq_printf (m, "stepping\t: %d\n", c->x86_mask);
    else
        seq_printf (m, "stepping\t: unknown\n");
    if (cpu_has (c, X86_FEATURE_TSC)) {
        unsigned int freq = cpufreq_quick_get ((unsigned) cpu);
        if (!freq)
            freq = cpu_khz;
        seq_printf (m, "cpu MHz\t\t: %u.%03u\n", freq / 1000, (freq % 1000));
    }
    if (c->x86_cache_size >= 0)
        seq_printf (m, "cache size\t: %d KB\n", c->x86_cache_size);
    seq_printf (m, "fpu\t\t: yes\n" "fpu_exception\t: yes\n" "cpuid level\t: %d\n" "wp\t\t: yes\n" "flags\t\t:", c -> cpuid_level);
    {
        int i;
        for (i = 0; i < 32 * NCAPINTS; i++)
            if (cpu_has (c, i) && x86_cap_flags[i] != NULL)
                seq_printf (m, " %s", x86_cap_flags[i]);
    }
    seq_printf (m, "\nbogomips\t: %lu.%02lu\n", c -> loops_per_jiffy / (500000 / HZ), (c -> loops_per_jiffy / (5000 / HZ)) % 100);
    if (c->x86_tlbsize > 0)
        seq_printf (m, "TLB size\t: %d 4K pages\n", c->x86_tlbsize);
    seq_printf (m, "clflush size\t: %d\n", c -> x86_clflush_size);
    seq_printf (m, "cache_alignment\t: %d\n", c -> x86_cache_alignment);
    seq_printf (m, "address sizes\t: %u bits physical, %u bits virtual\n", c -> x86_phys_bits, c -> x86_virt_bits);
    seq_printf (m, "power management:");
    {
        unsigned i;
        for (i = 0; i < 32; i++)
            if (c->x86_power & (1 << i)) {
                if (i < ARRAY_SIZE (x86_power_flags) && x86_power_flags[i])
                    seq_printf (m, "%s%s", x86_power_flags[i][0] ? " " : "", x86_power_flags[i]);
                else
                    seq_printf (m, " [%d]", i);
            }
    }
    seq_printf (m, "\n\n");
    return 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/setup_64.c.ifdefed" startline="1099" endline="1105">
{
    unsigned int freq = cpufreq_quick_get ((unsigned) cpu);
    if (!freq)
        freq = cpu_khz;
    seq_printf (m, "cpu MHz\t\t: %u.%03u\n", freq / 1000, (freq % 1000));
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/setup_64.c.ifdefed" startline="1129" endline="1134">
{
    int i;
    for (i = 0; i < 32 * NCAPINTS; i++)
        if (cpu_has (c, i) && x86_cap_flags[i] != NULL)
            seq_printf (m, " %s", x86_cap_flags[i]);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/setup_64.c.ifdefed" startline="1149" endline="1161">
{
    unsigned i;
    for (i = 0; i < 32; i++)
        if (c->x86_power & (1 << i)) {
            if (i < ARRAY_SIZE (x86_power_flags) && x86_power_flags[i])
                seq_printf (m, "%s%s", x86_power_flags[i][0] ? " " : "", x86_power_flags[i]);
            else
                seq_printf (m, " [%d]", i);
        }
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/setup_64.c.ifdefed" startline="1152" endline="1160">
{
    if (i < ARRAY_SIZE (x86_power_flags) && x86_power_flags[i])
        seq_printf (m, "%s%s", x86_power_flags[i][0] ? " " : "", x86_power_flags[i]);
    else
        seq_printf (m, " [%d]", i);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/setup_64.c.ifdefed" startline="1169" endline="1175">
{
    if (*pos == 0)
        *pos = first_cpu (cpu_online_map);
    if ((*pos) < NR_CPUS && cpu_online (*pos))
        return &cpu_data (*pos);
    return NULL;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/setup_64.c.ifdefed" startline="1178" endline="1181">
{
    *pos = next_cpu (*pos, cpu_online_map);
    return c_start (m, pos);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/setup_64.c.ifdefed" startline="1184" endline="1185">
{
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/early_printk.c.ifdefed" startline="19" endline="49">
{
    char c;
    int i, k, j;
    while ((c = *str++) != '\0' && n-- > 0) {
        if (current_ypos >= max_ypos) {
            for (k = 1, j = 0; k < max_ypos; k++, j++) {
                for (i = 0; i < max_xpos; i++) {
                    writew (readw (VGABASE + 2 * (max_xpos * k + i)), VGABASE + 2 * (max_xpos * j + i));
                }
            }
            for (i = 0; i < max_xpos; i++)
                writew (0x720, VGABASE +2 * (max_xpos * j + i));
            current_ypos = max_ypos - 1;
        }
        if (c == '\n') {
            current_xpos = 0;
            current_ypos++;
        }
        else if (c != '\r') {
            writew (((0x7 << 8) | (unsigned short) c), VGABASE + 2 * (max_xpos * current_ypos + current_xpos ++));
            if (current_xpos >= max_xpos) {
                current_xpos = 0;
                current_ypos++;
            }
        }
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/early_printk.c.ifdefed" startline="23" endline="48">
{
    if (current_ypos >= max_ypos) {
        for (k = 1, j = 0; k < max_ypos; k++, j++) {
            for (i = 0; i < max_xpos; i++) {
                writew (readw (VGABASE + 2 * (max_xpos * k + i)), VGABASE + 2 * (max_xpos * j + i));
            }
        }
        for (i = 0; i < max_xpos; i++)
            writew (0x720, VGABASE +2 * (max_xpos * j + i));
        current_ypos = max_ypos - 1;
    }
    if (c == '\n') {
        current_xpos = 0;
        current_ypos++;
    }
    else if (c != '\r') {
        writew (((0x7 << 8) | (unsigned short) c), VGABASE + 2 * (max_xpos * current_ypos + current_xpos ++));
        if (current_xpos >= max_xpos) {
            current_xpos = 0;
            current_ypos++;
        }
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/early_printk.c.ifdefed" startline="24" endline="35">
{
    for (k = 1, j = 0; k < max_ypos; k++, j++) {
        for (i = 0; i < max_xpos; i++) {
            writew (readw (VGABASE + 2 * (max_xpos * k + i)), VGABASE + 2 * (max_xpos * j + i));
        }
    }
    for (i = 0; i < max_xpos; i++)
        writew (0x720, VGABASE +2 * (max_xpos * j + i));
    current_ypos = max_ypos - 1;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/early_printk.c.ifdefed" startline="26" endline="31">
{
    for (i = 0; i < max_xpos; i++) {
        writew (readw (VGABASE + 2 * (max_xpos * k + i)), VGABASE + 2 * (max_xpos * j + i));
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/early_printk.c.ifdefed" startline="27" endline="30">
{
    writew (readw (VGABASE + 2 * (max_xpos * k + i)), VGABASE + 2 * (max_xpos * j + i));
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/early_printk.c.ifdefed" startline="36" endline="39">
{
    current_xpos = 0;
    current_ypos++;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/early_printk.c.ifdefed" startline="39" endline="47">
{
    writew (((0x7 << 8) | (unsigned short) c), VGABASE + 2 * (max_xpos * current_ypos + current_xpos ++));
    if (current_xpos >= max_xpos) {
        current_xpos = 0;
        current_ypos++;
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/early_printk.c.ifdefed" startline="43" endline="46">
{
    current_xpos = 0;
    current_ypos++;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/early_printk.c.ifdefed" startline="79" endline="85">
{
    unsigned timeout = 0xffff;
    while ((inb (early_serial_base +LSR) & XMTRDY) == 0 && --timeout)
        cpu_relax ();
    outb (ch, early_serial_base + TXR);
    return timeout ? 0 : -1;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/early_printk.c.ifdefed" startline="88" endline="95">
{
    while (*s && n-- > 0) {
        if (*s == '\n')
            early_serial_putc ('\r');
        early_serial_putc (*s);
        s++;
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/early_printk.c.ifdefed" startline="89" endline="94">
{
    if (*s == '\n')
        early_serial_putc ('\r');
    early_serial_putc (*s);
    s++;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/early_printk.c.ifdefed" startline="100" endline="145">
{
    unsigned char c;
    unsigned divisor;
    unsigned baud = DEFAULT_BAUD;
    char *e;
    if (*s == ',')
        ++s;
    if (*s) {
        unsigned port;
        if (!strncmp (s, "0x", 2)) {
            early_serial_base = simple_strtoul (s, &e, 16);
        }
        else {
            static int bases [] = {0x3f8, 0x2f8};
            if (!strncmp (s, "ttyS", 4))
                s += 4;
            port = simple_strtoul (s, &e, 10);
            if (port > 1 || s == e)
                port = 0;
            early_serial_base = bases[port];
        }
        s += strcspn (s, ",");
        if (*s == ',')
            s++;
    }
    outb (0x3, early_serial_base + LCR);
    outb (0, early_serial_base + IER);
    outb (0, early_serial_base + FCR);
    outb (0x3, early_serial_base + MCR);
    if (*s) {
        baud = simple_strtoul (s, &e, 0);
        if (baud == 0 || s == e)
            baud = DEFAULT_BAUD;
    }
    divisor = 115200 / baud;
    c = inb (early_serial_base +LCR);
    outb (c | DLAB, early_serial_base + LCR);
    outb (divisor & 0xff, early_serial_base + DLL);
    outb ((divisor >> 8) & 0xff, early_serial_base + DLH);
    outb (c & ~ DLAB, early_serial_base + LCR);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/early_printk.c.ifdefed" startline="109" endline="126">
{
    unsigned port;
    if (!strncmp (s, "0x", 2)) {
        early_serial_base = simple_strtoul (s, &e, 16);
    }
    else {
        static int bases [] = {0x3f8, 0x2f8};
        if (!strncmp (s, "ttyS", 4))
            s += 4;
        port = simple_strtoul (s, &e, 10);
        if (port > 1 || s == e)
            port = 0;
        early_serial_base = bases[port];
    }
    s += strcspn (s, ",");
    if (*s == ',')
        s++;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/early_printk.c.ifdefed" startline="111" endline="113">
{
    early_serial_base = simple_strtoul (s, &e, 16);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/early_printk.c.ifdefed" startline="113" endline="122">
{
    static int bases [] = {0x3f8, 0x2f8};
    if (!strncmp (s, "ttyS", 4))
        s += 4;
    port = simple_strtoul (s, &e, 10);
    if (port > 1 || s == e)
        port = 0;
    early_serial_base = bases[port];
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/early_printk.c.ifdefed" startline="133" endline="137">
{
    baud = simple_strtoul (s, &e, 0);
    if (baud == 0 || s == e)
        baud = DEFAULT_BAUD;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/early_printk.c.ifdefed" startline="166" endline="172">
{
    long ret;
    asm volatile ("cpuid"
        : "=a" (ret)
        : "b" (a), "c" (b), "d" (c), "0" (MAGIC1), "D" (cmd + MAGIC2)
    ) return ret;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/early_printk.c.ifdefed" startline="175" endline="181">
{
    char *fn = "klog";
    if (*str == '=')
        fn = ++str;
    simnow_fd = simnow (XOPEN, (unsigned long) fn, O_WRONLY | O_APPEND | O_CREAT, 0644);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/early_printk.c.ifdefed" startline="184" endline="186">
{
    simnow (XWRITE, simnow_fd, (unsigned long) s, n);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/early_printk.c.ifdefed" startline="200" endline="209">
{
    char buf [512];
    int n;
    va_list ap;
    va_start (ap, fmt);
    n = vscnprintf (buf, 512, fmt, ap);
    early_console->write (early_console, buf, n);
    va_end (ap);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/early_printk.c.ifdefed" startline="214" endline="253">
{
    if (!buf)
        return 0;
    if (early_console_initialized)
        return 0;
    early_console_initialized = 1;
    if (strstr (buf, "keep"))
        keep_early = 1;
    if (!strncmp (buf, "serial", 6)) {
        early_serial_init (buf + 6);
        early_console = &early_serial_console;
    }
    else if (!strncmp (buf, "ttyS", 4)) {
        early_serial_init (buf);
        early_console = &early_serial_console;
    }
    else if (!strncmp (buf, "vga", 3) && boot_params.screen_info.orig_video_isVGA == 1) {
        max_xpos = boot_params.screen_info.orig_video_cols;
        max_ypos = boot_params.screen_info.orig_video_lines;
        current_ypos = boot_params.screen_info.orig_y;
        early_console = &early_vga_console;
    }
    else if (!strncmp (buf, "simnow", 6)) {
        simnow_init (buf + 6);
        early_console = &simnow_console;
        keep_early = 1;
    }
    if (keep_early)
        early_console->flags &= ~CON_BOOT;
    else
        early_console->flags |= CON_BOOT;
    register_console (early_console);
    return 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/early_printk.c.ifdefed" startline="225" endline="228">
{
    early_serial_init (buf + 6);
    early_console = &early_serial_console;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/early_printk.c.ifdefed" startline="228" endline="231">
{
    early_serial_init (buf);
    early_console = &early_serial_console;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/early_printk.c.ifdefed" startline="232" endline="237">
{
    max_xpos = boot_params.screen_info.orig_video_cols;
    max_ypos = boot_params.screen_info.orig_video_lines;
    current_ypos = boot_params.screen_info.orig_y;
    early_console = &early_vga_console;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/early_printk.c.ifdefed" startline="237" endline="245">
{
    simnow_init (buf + 6);
    early_console = &simnow_console;
    keep_early = 1;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/io_apic_64.c.ifdefed" startline="127" endline="130">
{
    return (void __iomem *) __fix_to_virt (FIX_IO_APIC_BASE_0 +idx) + (mp_ioapics[idx].mpc_apicaddr & ~PAGE_MASK);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/io_apic_64.c.ifdefed" startline="133" endline="137">
{
    struct io_apic __iomem *io_apic = io_apic_base (apic);
    writel (reg, & io_apic -> index);
    return readl (&io_apic->data);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/io_apic_64.c.ifdefed" startline="140" endline="144">
{
    struct io_apic __iomem *io_apic = io_apic_base (apic);
    writel (reg, & io_apic -> index);
    writel (value, & io_apic -> data);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/io_apic_64.c.ifdefed" startline="151" endline="154">
{
    struct io_apic __iomem *io_apic = io_apic_base (apic);
    writel (value, & io_apic -> data);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/io_apic_64.c.ifdefed" startline="157" endline="180">
{
    struct irq_pin_list *entry;
    unsigned long flags;
    int pending = 0;
    spin_lock_irqsave (& ioapic_lock, flags);
    entry = irq_2_pin + irq;
    for (;;) {
        unsigned int reg;
        int pin;
        pin = entry->pin;
        if (pin == -1)
            break;
        reg = io_apic_read (entry->apic, 0x10 + pin * 2);
        pending |= (reg >> 14) & 1;
        if (!entry->next)
            break;
        entry = irq_2_pin + entry->next;
    }
    spin_unlock_irqrestore (& ioapic_lock, flags);
    return pending;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/io_apic_64.c.ifdefed" startline="164" endline="177">
{
    unsigned int reg;
    int pin;
    pin = entry->pin;
    if (pin == -1)
        break;
    reg = io_apic_read (entry->apic, 0x10 + pin * 2);
    pending |= (reg >> 14) & 1;
    if (!entry->next)
        break;
    entry = irq_2_pin + entry->next;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/io_apic_64.c.ifdefed" startline="187" endline="190">
{
    struct io_apic __iomem *io_apic = io_apic_base (apic);
    readl (& io_apic -> data);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/io_apic_64.c.ifdefed" startline="220" endline="228">
{
    union entry_union eu;
    unsigned long flags;
    spin_lock_irqsave (& ioapic_lock, flags);
    eu.w1 = io_apic_read (apic, 0x10 + 2 * pin);
    eu.w2 = io_apic_read (apic, 0x11 + 2 * pin);
    spin_unlock_irqrestore (& ioapic_lock, flags);
    return eu.entry;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/io_apic_64.c.ifdefed" startline="238" endline="243">
{
    union entry_union eu;
    eu.entry = e;
    io_apic_write (apic, 0x11 + 2 * pin, eu.w2);
    io_apic_write (apic, 0x10 + 2 * pin, eu.w1);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/io_apic_64.c.ifdefed" startline="246" endline="251">
{
    unsigned long flags;
    spin_lock_irqsave (& ioapic_lock, flags);
    __ioapic_write_entry (apic, pin, e);
    spin_unlock_irqrestore (& ioapic_lock, flags);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/io_apic_64.c.ifdefed" startline="259" endline="267">
{
    unsigned long flags;
    union entry_union eu = {
        .entry.mask = 1
    };
    spin_lock_irqsave (& ioapic_lock, flags);
    io_apic_write (apic, 0x10 + 2 * pin, eu.w1);
    io_apic_write (apic, 0x11 + 2 * pin, eu.w2);
    spin_unlock_irqrestore (& ioapic_lock, flags);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/io_apic_64.c.ifdefed" startline="328" endline="344">
{
    static int first_free_entry = NR_IRQS;
    struct irq_pin_list *entry = irq_2_pin + irq;
    BUG_ON (irq >= NR_IRQS);
    while (entry->next)
        entry = irq_2_pin + entry->next;
    if (entry->pin != -1) {
        entry->next = first_free_entry;
        entry = irq_2_pin + entry->next;
        if (++first_free_entry >= PIN_MAP_SIZE)
            panic ("io_apic.c: ran out of irq_2_pin entries!");
    }
    entry->apic = apic;
    entry->pin = pin;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/io_apic_64.c.ifdefed" startline="336" endline="341">
{
    entry->next = first_free_entry;
    entry = irq_2_pin + entry->next;
    if (++first_free_entry >= PIN_MAP_SIZE)
        panic ("io_apic.c: ran out of irq_2_pin entries!");
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/io_apic_64.c.ifdefed" startline="358" endline="364">
{
    unsigned long flags;
    spin_lock_irqsave (& ioapic_lock, flags);
    __mask_IO_APIC_irq (irq);
    spin_unlock_irqrestore (& ioapic_lock, flags);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/io_apic_64.c.ifdefed" startline="367" endline="373">
{
    unsigned long flags;
    spin_lock_irqsave (& ioapic_lock, flags);
    __unmask_IO_APIC_irq (irq);
    spin_unlock_irqrestore (& ioapic_lock, flags);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/io_apic_64.c.ifdefed" startline="376" endline="387">
{
    struct IO_APIC_route_entry entry;
    entry = ioapic_read_entry (apic, pin);
    if (entry.delivery_mode == dest_SMI)
        return;
    ioapic_mask_entry (apic, pin);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/io_apic_64.c.ifdefed" startline="390" endline="396">
{
    int apic, pin;
    for (apic = 0; apic < nr_ioapics; apic++)
        for (pin = 0; pin < nr_ioapic_registers[apic]; pin++)
            clear_IO_APIC_pin (apic, pin);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/io_apic_64.c.ifdefed" startline="402" endline="405">
{
    disable_ioapic_setup ();
    return 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/io_apic_64.c.ifdefed" startline="410" endline="413">
{
    disable_timer_pin_1 = 1;
    return 1;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/io_apic_64.c.ifdefed" startline="417" endline="420">
{
    timer_over_8254 = -1;
    return 1;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/io_apic_64.c.ifdefed" startline="422" endline="425">
{
    timer_over_8254 = 2;
    return 1;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/io_apic_64.c.ifdefed" startline="435" endline="446">
{
    int i;
    for (i = 0; i < mp_irq_entries; i++)
        if (mp_irqs[i].mpc_irqtype == type && (mp_irqs[i].mpc_dstapic == mp_ioapics[apic].mpc_apicid || mp_irqs[i].mpc_dstapic == MP_APIC_ALL) && mp_irqs[i].mpc_dstirq == pin)
            return i;
    return -1;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/io_apic_64.c.ifdefed" startline="452" endline="465">
{
    int i;
    for (i = 0; i < mp_irq_entries; i++) {
        int lbus = mp_irqs[i].mpc_srcbus;
        if (test_bit (lbus, mp_bus_not_pci) && (mp_irqs[i].mpc_irqtype == type) && (mp_irqs[i].mpc_srcbusirq == irq))
            return mp_irqs[i].mpc_dstirq;
    }
    return -1;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/io_apic_64.c.ifdefed" startline="455" endline="463">
{
    int lbus = mp_irqs[i].mpc_srcbus;
    if (test_bit (lbus, mp_bus_not_pci) && (mp_irqs[i].mpc_irqtype == type) && (mp_irqs[i].mpc_srcbusirq == irq))
        return mp_irqs[i].mpc_dstirq;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/io_apic_64.c.ifdefed" startline="468" endline="488">
{
    int i;
    for (i = 0; i < mp_irq_entries; i++) {
        int lbus = mp_irqs[i].mpc_srcbus;
        if (test_bit (lbus, mp_bus_not_pci) && (mp_irqs[i].mpc_irqtype == type) && (mp_irqs[i].mpc_srcbusirq == irq))
            break;
    }
    if (i < mp_irq_entries) {
        int apic;
        for (apic = 0; apic < nr_ioapics; apic++) {
            if (mp_ioapics[apic].mpc_apicid == mp_irqs[i].mpc_dstapic)
                return apic;
        }
    }
    return -1;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/io_apic_64.c.ifdefed" startline="471" endline="478">
{
    int lbus = mp_irqs[i].mpc_srcbus;
    if (test_bit (lbus, mp_bus_not_pci) && (mp_irqs[i].mpc_irqtype == type) && (mp_irqs[i].mpc_srcbusirq == irq))
        break;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/io_apic_64.c.ifdefed" startline="479" endline="485">
{
    int apic;
    for (apic = 0; apic < nr_ioapics; apic++) {
        if (mp_ioapics[apic].mpc_apicid == mp_irqs[i].mpc_dstapic)
            return apic;
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/io_apic_64.c.ifdefed" startline="481" endline="484">
{
    if (mp_ioapics[apic].mpc_apicid == mp_irqs[i].mpc_dstapic)
        return apic;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/io_apic_64.c.ifdefed" startline="497" endline="535">
{
    int apic, i, best_guess = -1;
    apic_printk (APIC_DEBUG, "querying PCI -> IRQ mapping bus:%d, slot:%d, pin:%d.\n", bus, slot, pin);
    if (mp_bus_id_to_pci_bus[bus] == -1) {
        apic_printk (APIC_VERBOSE, "PCI BIOS passed nonexistent PCI bus %d!\n", bus);
        return -1;
    }
    for (i = 0; i < mp_irq_entries; i++) {
        int lbus = mp_irqs[i].mpc_srcbus;
        for (apic = 0; apic < nr_ioapics; apic++)
            if (mp_ioapics[apic].mpc_apicid == mp_irqs[i].mpc_dstapic || mp_irqs[i].mpc_dstapic == MP_APIC_ALL)
                break;
        if (!test_bit (lbus, mp_bus_not_pci) && !mp_irqs[i].mpc_irqtype && (bus == lbus) && (slot == ((mp_irqs[i].mpc_srcbusirq >> 2) & 0x1f))) {
            int irq = pin_2_irq (i, apic, mp_irqs[i].mpc_dstirq);
            if (!(apic || IO_APIC_IRQ (irq)))
                continue;
            if (pin == (mp_irqs[i].mpc_srcbusirq & 3))
                return irq;
            if (best_guess < 0)
                best_guess = irq;
        }
    }
    BUG_ON (best_guess >= NR_IRQS);
    return best_guess;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/io_apic_64.c.ifdefed" startline="502" endline="505">
{
    apic_printk (APIC_VERBOSE, "PCI BIOS passed nonexistent PCI bus %d!\n", bus);
    return -1;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/io_apic_64.c.ifdefed" startline="506" endline="532">
{
    int lbus = mp_irqs[i].mpc_srcbus;
    for (apic = 0; apic < nr_ioapics; apic++)
        if (mp_ioapics[apic].mpc_apicid == mp_irqs[i].mpc_dstapic || mp_irqs[i].mpc_dstapic == MP_APIC_ALL)
            break;
    if (!test_bit (lbus, mp_bus_not_pci) && !mp_irqs[i].mpc_irqtype && (bus == lbus) && (slot == ((mp_irqs[i].mpc_srcbusirq >> 2) & 0x1f))) {
        int irq = pin_2_irq (i, apic, mp_irqs[i].mpc_dstirq);
        if (!(apic || IO_APIC_IRQ (irq)))
            continue;
        if (pin == (mp_irqs[i].mpc_srcbusirq & 3))
            return irq;
        if (best_guess < 0)
            best_guess = irq;
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/io_apic_64.c.ifdefed" startline="517" endline="531">
{
    int irq = pin_2_irq (i, apic, mp_irqs[i].mpc_dstirq);
    if (!(apic || IO_APIC_IRQ (irq)))
        continue;
    if (pin == (mp_irqs[i].mpc_srcbusirq & 3))
        return irq;
    if (best_guess < 0)
        best_guess = irq;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/io_apic_64.c.ifdefed" startline="550" endline="589">
{
    int bus = mp_irqs[idx].mpc_srcbus;
    int polarity;
    switch (mp_irqs[idx].mpc_irqflag & 3) {
    case 0 :
        if (test_bit (bus, mp_bus_not_pci))
            polarity = default_ISA_polarity (idx);
        else
            polarity = default_PCI_polarity (idx);
        break;
    case 1 :
        {
            polarity = 0;
            break;
        }
    case 2 :
        {
            printk (KERN_WARNING "broken BIOS!!\n");
            polarity = 1;
            break;
        }
    case 3 :
        {
            polarity = 1;
            break;
        }
    default :
        {
            printk (KERN_WARNING "broken BIOS!!\n");
            polarity = 1;
            break;
        }
    }
    return polarity;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/io_apic_64.c.ifdefed" startline="558" endline="587">
{
case 0 :
    if (test_bit (bus, mp_bus_not_pci))
        polarity = default_ISA_polarity (idx);
    else
        polarity = default_PCI_polarity (idx);
    break;
case 1 :
    {
        polarity = 0;
        break;
    }
case 2 :
    {
        printk (KERN_WARNING "broken BIOS!!\n");
        polarity = 1;
        break;
    }
case 3 :
    {
        polarity = 1;
        break;
    }
default :
    {
        printk (KERN_WARNING "broken BIOS!!\n");
        polarity = 1;
        break;
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/io_apic_64.c.ifdefed" startline="566" endline="569">
{
    polarity = 0;
    break;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/io_apic_64.c.ifdefed" startline="571" endline="575">
{
    printk (KERN_WARNING "broken BIOS!!\n");
    polarity = 1;
    break;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/io_apic_64.c.ifdefed" startline="577" endline="580">
{
    polarity = 1;
    break;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/io_apic_64.c.ifdefed" startline="582" endline="586">
{
    printk (KERN_WARNING "broken BIOS!!\n");
    polarity = 1;
    break;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/io_apic_64.c.ifdefed" startline="592" endline="631">
{
    int bus = mp_irqs[idx].mpc_srcbus;
    int trigger;
    switch ((mp_irqs[idx].mpc_irqflag >> 2) & 3) {
    case 0 :
        if (test_bit (bus, mp_bus_not_pci))
            trigger = default_ISA_trigger (idx);
        else
            trigger = default_PCI_trigger (idx);
        break;
    case 1 :
        {
            trigger = 0;
            break;
        }
    case 2 :
        {
            printk (KERN_WARNING "broken BIOS!!\n");
            trigger = 1;
            break;
        }
    case 3 :
        {
            trigger = 1;
            break;
        }
    default :
        {
            printk (KERN_WARNING "broken BIOS!!\n");
            trigger = 0;
            break;
        }
    }
    return trigger;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/io_apic_64.c.ifdefed" startline="600" endline="629">
{
case 0 :
    if (test_bit (bus, mp_bus_not_pci))
        trigger = default_ISA_trigger (idx);
    else
        trigger = default_PCI_trigger (idx);
    break;
case 1 :
    {
        trigger = 0;
        break;
    }
case 2 :
    {
        printk (KERN_WARNING "broken BIOS!!\n");
        trigger = 1;
        break;
    }
case 3 :
    {
        trigger = 1;
        break;
    }
default :
    {
        printk (KERN_WARNING "broken BIOS!!\n");
        trigger = 0;
        break;
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/io_apic_64.c.ifdefed" startline="608" endline="611">
{
    trigger = 0;
    break;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/io_apic_64.c.ifdefed" startline="613" endline="617">
{
    printk (KERN_WARNING "broken BIOS!!\n");
    trigger = 1;
    break;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/io_apic_64.c.ifdefed" startline="619" endline="622">
{
    trigger = 1;
    break;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/io_apic_64.c.ifdefed" startline="624" endline="628">
{
    printk (KERN_WARNING "broken BIOS!!\n");
    trigger = 0;
    break;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/io_apic_64.c.ifdefed" startline="634" endline="636">
{
    return MPBIOS_polarity (idx);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/io_apic_64.c.ifdefed" startline="639" endline="641">
{
    return MPBIOS_trigger (idx);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/io_apic_64.c.ifdefed" startline="644" endline="667">
{
    int irq, i;
    int bus = mp_irqs[idx].mpc_srcbus;
    if (mp_irqs[idx].mpc_dstirq != pin)
        printk (KERN_ERR "broken BIOS or MPTABLE parser, ayiee!!\n");
    if (test_bit (bus, mp_bus_not_pci)) {
        irq = mp_irqs[idx].mpc_srcbusirq;
    }
    else {
        i = irq = 0;
        while (i < apic)
            irq += nr_ioapic_registers[i++];
        irq += pin;
    }
    BUG_ON (irq >= NR_IRQS);
    return irq;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/io_apic_64.c.ifdefed" startline="654" endline="656">
{
    irq = mp_irqs[idx].mpc_srcbusirq;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/io_apic_64.c.ifdefed" startline="656" endline="664">
{
    i = irq = 0;
    while (i < apic)
        irq += nr_ioapic_registers[i++];
    irq += pin;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/io_apic_64.c.ifdefed" startline="670" endline="742">
{
    static int current_vector = FIRST_DEVICE_VECTOR, current_offset = 0;
    unsigned int old_vector;
    int cpu;
    struct irq_cfg *cfg;
    BUG_ON ((unsigned) irq >= NR_IRQS);
    cfg = &irq_cfg[irq];
    cpus_and (mask, mask, cpu_online_map);
    if ((cfg->move_in_progress) || cfg->move_cleanup_count)
        return -EBUSY;
    old_vector = cfg->vector;
    if (old_vector) {
        cpumask_t tmp;
        cpus_and (tmp, cfg -> domain, mask);
        if (!cpus_empty (tmp))
            return 0;
    }

    for_each_cpu_mask (cpu, mask) {
        cpumask_t domain, new_mask;
        int new_cpu;
        int vector, offset;
        domain = vector_allocation_domain (cpu);
        cpus_and (new_mask, domain, cpu_online_map);
        vector = current_vector;
        offset = current_offset;
    next :
        vector += 8;
        if (vector >= FIRST_SYSTEM_VECTOR) {
            offset = (offset + 1) % 8;
            vector = FIRST_DEVICE_VECTOR + offset;
        }
        if (unlikely (current_vector == vector))
            continue;
        if (vector == IA32_SYSCALL_VECTOR)
            goto next;
        for_each_cpu_mask (new_cpu, new_mask)
        if (per_cpu (vector_irq, new_cpu)[vector] != -1)
            goto next;
        current_vector = vector;
        current_offset = offset;
        if (old_vector) {
            cfg->move_in_progress = 1;
            cfg->old_domain = cfg->domain;
        }
        for_each_cpu_mask (new_cpu, new_mask)
        per_cpu (vector_irq, new_cpu) [vector] = irq;
        cfg->vector = vector;
        cfg->domain = domain;
        return 0;
    }

    return -ENOSPC;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/io_apic_64.c.ifdefed" startline="697" endline="702">
{
    cpumask_t tmp;
    cpus_and (tmp, cfg -> domain, mask);
    if (!cpus_empty (tmp))
        return 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/io_apic_64.c.ifdefed" startline="704" endline="740">
{
    cpumask_t domain, new_mask;
    int new_cpu;
    int vector, offset;
    domain = vector_allocation_domain (cpu);
    cpus_and (new_mask, domain, cpu_online_map);
    vector = current_vector;
    offset = current_offset;
next :
    vector += 8;
    if (vector >= FIRST_SYSTEM_VECTOR) {
        offset = (offset + 1) % 8;
        vector = FIRST_DEVICE_VECTOR + offset;
    }
    if (unlikely (current_vector == vector))
        continue;
    if (vector == IA32_SYSCALL_VECTOR)
        goto next;
    for_each_cpu_mask (new_cpu, new_mask)
    if (per_cpu (vector_irq, new_cpu)[vector] != -1)
        goto next;
    current_vector = vector;
    current_offset = offset;
    if (old_vector) {
        cfg->move_in_progress = 1;
        cfg->old_domain = cfg->domain;
    }
    for_each_cpu_mask (new_cpu, new_mask)
    per_cpu (vector_irq, new_cpu) [vector] = irq;
    cfg->vector = vector;
    cfg->domain = domain;
    return 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/io_apic_64.c.ifdefed" startline="716" endline="720">
{
    offset = (offset + 1) % 8;
    vector = FIRST_DEVICE_VECTOR + offset;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/io_apic_64.c.ifdefed" startline="731" endline="734">
{
    cfg->move_in_progress = 1;
    cfg->old_domain = cfg->domain;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/io_apic_64.c.ifdefed" startline="745" endline="753">
{
    int err;
    unsigned long flags;
    spin_lock_irqsave (& vector_lock, flags);
    err = __assign_irq_vector (irq, mask);
    spin_unlock_irqrestore (& vector_lock, flags);
    return err;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/io_apic_64.c.ifdefed" startline="756" endline="772">
{
    struct irq_cfg *cfg;
    cpumask_t mask;
    int cpu, vector;
    BUG_ON ((unsigned) irq >= NR_IRQS);
    cfg = &irq_cfg[irq];
    BUG_ON (! cfg -> vector);
    vector = cfg->vector;
    cpus_and (mask, cfg -> domain, cpu_online_map);
    for_each_cpu_mask (cpu, mask)
    per_cpu (vector_irq, cpu) [vector] = -1;
    cfg->vector = 0;
    cfg->domain = CPU_MASK_NONE;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/io_apic_64.c.ifdefed" startline="775" endline="795">
{
    int irq, vector;
    for (irq = 0; irq < NR_IRQS; ++irq) {
        if (!cpu_isset (cpu, irq_cfg[irq].domain))
            continue;
        vector = irq_cfg[irq].vector;
        per_cpu (vector_irq, cpu)[vector] = irq;
    }
    for (vector = 0; vector < NR_VECTORS; ++vector) {
        irq = per_cpu (vector_irq, cpu)[vector];
        if (irq < 0)
            continue;
        if (!cpu_isset (cpu, irq_cfg[irq].domain))
            per_cpu (vector_irq, cpu)[vector] = -1;
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/io_apic_64.c.ifdefed" startline="781" endline="786">
{
    if (!cpu_isset (cpu, irq_cfg[irq].domain))
        continue;
    vector = irq_cfg[irq].vector;
    per_cpu (vector_irq, cpu)[vector] = irq;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/io_apic_64.c.ifdefed" startline="788" endline="794">
{
    irq = per_cpu (vector_irq, cpu)[vector];
    if (irq < 0)
        continue;
    if (!cpu_isset (cpu, irq_cfg[irq].domain))
        per_cpu (vector_irq, cpu)[vector] = -1;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/io_apic_64.c.ifdefed" startline="801" endline="811">
{
    if (trigger) {
        irq_desc[irq].status |= IRQ_LEVEL;
        set_irq_chip_and_handler_name (irq, & ioapic_chip, handle_fasteoi_irq, "fasteoi");
    }
    else {
        irq_desc[irq].status &= ~IRQ_LEVEL;
        set_irq_chip_and_handler_name (irq, & ioapic_chip, handle_edge_irq, "edge");
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/io_apic_64.c.ifdefed" startline="802" endline="806">
{
    irq_desc[irq].status |= IRQ_LEVEL;
    set_irq_chip_and_handler_name (irq, & ioapic_chip, handle_fasteoi_irq, "fasteoi");
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/io_apic_64.c.ifdefed" startline="806" endline="810">
{
    irq_desc[irq].status &= ~IRQ_LEVEL;
    set_irq_chip_and_handler_name (irq, & ioapic_chip, handle_edge_irq, "edge");
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/io_apic_64.c.ifdefed" startline="815" endline="859">
{
    struct irq_cfg *cfg = irq_cfg + irq;
    struct IO_APIC_route_entry entry;
    cpumask_t mask;
    if (!IO_APIC_IRQ (irq))
        return;
    mask = TARGET_CPUS;
    if (assign_irq_vector (irq, mask))
        return;
    cpus_and (mask, cfg -> domain, mask);
    apic_printk (APIC_VERBOSE, KERN_DEBUG "IOAPIC[%d]: Set routing entry (%d-%d -> 0x%x -> " "IRQ %d Mode:%i Active:%i)\n", apic, mp_ioapics [apic].mpc_apicid, pin, cfg -> vector, irq, trigger, polarity);
    memset (& entry, 0, sizeof (entry));
    entry.delivery_mode = INT_DELIVERY_MODE;
    entry.dest_mode = INT_DEST_MODE;
    entry.dest = cpu_mask_to_apicid (mask);
    entry.mask = 0;
    entry.trigger = trigger;
    entry.polarity = polarity;
    entry.vector = cfg->vector;
    if (trigger)
        entry.mask = 1;
    ioapic_register_intr (irq, trigger);
    if (irq < 16)
        disable_8259A_irq (irq);
    ioapic_write_entry (apic, pin, entry);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/io_apic_64.c.ifdefed" startline="862" endline="894">
{
    int apic, pin, idx, irq, first_notcon = 1;
    apic_printk (APIC_VERBOSE, KERN_DEBUG "init IO_APIC IRQs\n");
    for (apic = 0; apic < nr_ioapics; apic++) {
        for (pin = 0; pin < nr_ioapic_registers[apic]; pin++) {
            idx = find_irq_entry (apic, pin, mp_INT);
            if (idx == -1) {
                if (first_notcon) {
                    apic_printk (APIC_VERBOSE, KERN_DEBUG " IO-APIC (apicid-pin) %d-%d", mp_ioapics [apic].mpc_apicid, pin);
                    first_notcon = 0;
                }
                else
                    apic_printk (APIC_VERBOSE, ", %d-%d", mp_ioapics[apic].mpc_apicid, pin);
                continue;
            }
            if (!first_notcon) {
                apic_printk (APIC_VERBOSE, " not connected.\n");
                first_notcon = 1;
            }
            irq = pin_2_irq (idx, apic, pin);
            add_pin_to_irq (irq, apic, pin);
            setup_IO_APIC_irq (apic, pin, irq, irq_trigger (idx), irq_polarity (idx));
        }
    }
    if (!first_notcon)
        apic_printk (APIC_VERBOSE, " not connected.\n");
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/io_apic_64.c.ifdefed" startline="867" endline="890">
{
    for (pin = 0; pin < nr_ioapic_registers[apic]; pin++) {
        idx = find_irq_entry (apic, pin, mp_INT);
        if (idx == -1) {
            if (first_notcon) {
                apic_printk (APIC_VERBOSE, KERN_DEBUG " IO-APIC (apicid-pin) %d-%d", mp_ioapics [apic].mpc_apicid, pin);
                first_notcon = 0;
            }
            else
                apic_printk (APIC_VERBOSE, ", %d-%d", mp_ioapics[apic].mpc_apicid, pin);
            continue;
        }
        if (!first_notcon) {
            apic_printk (APIC_VERBOSE, " not connected.\n");
            first_notcon = 1;
        }
        irq = pin_2_irq (idx, apic, pin);
        add_pin_to_irq (irq, apic, pin);
        setup_IO_APIC_irq (apic, pin, irq, irq_trigger (idx), irq_polarity (idx));
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/io_apic_64.c.ifdefed" startline="868" endline="889">
{
    idx = find_irq_entry (apic, pin, mp_INT);
    if (idx == -1) {
        if (first_notcon) {
            apic_printk (APIC_VERBOSE, KERN_DEBUG " IO-APIC (apicid-pin) %d-%d", mp_ioapics [apic].mpc_apicid, pin);
            first_notcon = 0;
        }
        else
            apic_printk (APIC_VERBOSE, ", %d-%d", mp_ioapics[apic].mpc_apicid, pin);
        continue;
    }
    if (!first_notcon) {
        apic_printk (APIC_VERBOSE, " not connected.\n");
        first_notcon = 1;
    }
    irq = pin_2_irq (idx, apic, pin);
    add_pin_to_irq (irq, apic, pin);
    setup_IO_APIC_irq (apic, pin, irq, irq_trigger (idx), irq_polarity (idx));
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/io_apic_64.c.ifdefed" startline="871" endline="878">
{
    if (first_notcon) {
        apic_printk (APIC_VERBOSE, KERN_DEBUG " IO-APIC (apicid-pin) %d-%d", mp_ioapics [apic].mpc_apicid, pin);
        first_notcon = 0;
    }
    else
        apic_printk (APIC_VERBOSE, ", %d-%d", mp_ioapics[apic].mpc_apicid, pin);
    continue;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/io_apic_64.c.ifdefed" startline="872" endline="875">
{
    apic_printk (APIC_VERBOSE, KERN_DEBUG " IO-APIC (apicid-pin) %d-%d", mp_ioapics [apic].mpc_apicid, pin);
    first_notcon = 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/io_apic_64.c.ifdefed" startline="879" endline="882">
{
    apic_printk (APIC_VERBOSE, " not connected.\n");
    first_notcon = 1;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/io_apic_64.c.ifdefed" startline="901" endline="939">
{
    struct IO_APIC_route_entry entry;
    unsigned long flags;
    memset (& entry, 0, sizeof (entry));
    disable_8259A_irq (0);
    apic_write (APIC_LVT0, APIC_LVT_MASKED | APIC_DM_EXTINT);
    entry.dest_mode = INT_DEST_MODE;
    entry.mask = 0;
    entry.dest = cpu_mask_to_apicid (TARGET_CPUS);
    entry.delivery_mode = INT_DELIVERY_MODE;
    entry.polarity = 0;
    entry.trigger = 0;
    entry.vector = vector;
    set_irq_chip_and_handler_name (0, & ioapic_chip, handle_edge_irq, "edge");
    spin_lock_irqsave (& ioapic_lock, flags);
    io_apic_write (apic, 0x11 + 2 * pin, * (((int *) & entry) + 1));
    io_apic_write (apic, 0x10 + 2 * pin, * (((int *) & entry) + 0));
    spin_unlock_irqrestore (& ioapic_lock, flags);
    enable_8259A_irq (0);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/io_apic_64.c.ifdefed" startline="942" endline="1033">
{
    int apic, i;
    union IO_APIC_reg_00 reg_00;
    union IO_APIC_reg_01 reg_01;
    union IO_APIC_reg_02 reg_02;
    unsigned long flags;
    if (apic_verbosity == APIC_QUIET)
        return;
    printk (KERN_DEBUG "number of MP IRQ sources: %d.\n", mp_irq_entries);
    for (i = 0; i < nr_ioapics; i++)
        printk (KERN_DEBUG "number of IO-APIC #%d registers: %d.\n", mp_ioapics[i].mpc_apicid, nr_ioapic_registers[i]);
    printk (KERN_INFO "testing the IO APIC.......................\n");
    for (apic = 0; apic < nr_ioapics; apic++) {
        spin_lock_irqsave (& ioapic_lock, flags);
        reg_00.raw = io_apic_read (apic, 0);
        reg_01.raw = io_apic_read (apic, 1);
        if (reg_01.bits.version >= 0x10)
            reg_02.raw = io_apic_read (apic, 2);
        spin_unlock_irqrestore (& ioapic_lock, flags);
        printk ("\n");
        printk (KERN_DEBUG "IO APIC #%d......\n", mp_ioapics [apic].mpc_apicid);
        printk (KERN_DEBUG ".... register #00: %08X\n", reg_00.raw);
        printk (KERN_DEBUG ".......    : physical APIC id: %02X\n", reg_00.bits.ID);
        printk (KERN_DEBUG ".... register #01: %08X\n", * (int *) & reg_01);
        printk (KERN_DEBUG ".......     : max redirection entries: %04X\n", reg_01.bits.entries);
        printk (KERN_DEBUG ".......     : PRQ implemented: %X\n", reg_01.bits.PRQ);
        printk (KERN_DEBUG ".......     : IO APIC version: %04X\n", reg_01.bits.version);
        if (reg_01.bits.version >= 0x10) {
            printk (KERN_DEBUG ".... register #02: %08X\n", reg_02.raw);
            printk (KERN_DEBUG ".......     : arbitration: %02X\n", reg_02.bits.arbitration);
        }
        printk (KERN_DEBUG ".... IRQ redirection table:\n");
        printk (KERN_DEBUG " NR Dst Mask Trig IRR Pol" " Stat Dmod Deli Vect:   \n");
        for (i = 0; i <= reg_01.bits.entries; i++) {
            struct IO_APIC_route_entry entry;
            entry = ioapic_read_entry (apic, i);
            printk (KERN_DEBUG " %02x %03X ", i, entry.dest);
            printk ("%1d    %1d    %1d   %1d   %1d    %1d    %1d    %02X\n", entry.mask, entry.trigger, entry.irr, entry.polarity, entry.delivery_status, entry.dest_mode, entry.delivery_mode, entry.vector);
        }
    }
    printk (KERN_DEBUG "IRQ to pin mappings:\n");
    for (i = 0; i < NR_IRQS; i++) {
        struct irq_pin_list *entry = irq_2_pin + i;
        if (entry->pin < 0)
            continue;
        printk (KERN_DEBUG "IRQ%d ", i);
        for (;;) {
            printk ("-> %d:%d", entry -> apic, entry -> pin);
            if (!entry->next)
                break;
            entry = irq_2_pin + entry->next;
        }
        printk ("\n");
    }
    printk (KERN_INFO ".................................... done.\n");
    return;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/io_apic_64.c.ifdefed" startline="963" endline="1014">
{
    spin_lock_irqsave (& ioapic_lock, flags);
    reg_00.raw = io_apic_read (apic, 0);
    reg_01.raw = io_apic_read (apic, 1);
    if (reg_01.bits.version >= 0x10)
        reg_02.raw = io_apic_read (apic, 2);
    spin_unlock_irqrestore (& ioapic_lock, flags);
    printk ("\n");
    printk (KERN_DEBUG "IO APIC #%d......\n", mp_ioapics [apic].mpc_apicid);
    printk (KERN_DEBUG ".... register #00: %08X\n", reg_00.raw);
    printk (KERN_DEBUG ".......    : physical APIC id: %02X\n", reg_00.bits.ID);
    printk (KERN_DEBUG ".... register #01: %08X\n", * (int *) & reg_01);
    printk (KERN_DEBUG ".......     : max redirection entries: %04X\n", reg_01.bits.entries);
    printk (KERN_DEBUG ".......     : PRQ implemented: %X\n", reg_01.bits.PRQ);
    printk (KERN_DEBUG ".......     : IO APIC version: %04X\n", reg_01.bits.version);
    if (reg_01.bits.version >= 0x10) {
        printk (KERN_DEBUG ".... register #02: %08X\n", reg_02.raw);
        printk (KERN_DEBUG ".......     : arbitration: %02X\n", reg_02.bits.arbitration);
    }
    printk (KERN_DEBUG ".... IRQ redirection table:\n");
    printk (KERN_DEBUG " NR Dst Mask Trig IRR Pol" " Stat Dmod Deli Vect:   \n");
    for (i = 0; i <= reg_01.bits.entries; i++) {
        struct IO_APIC_route_entry entry;
        entry = ioapic_read_entry (apic, i);
        printk (KERN_DEBUG " %02x %03X ", i, entry.dest);
        printk ("%1d    %1d    %1d   %1d   %1d    %1d    %1d    %02X\n", entry.mask, entry.trigger, entry.irr, entry.polarity, entry.delivery_status, entry.dest_mode, entry.delivery_mode, entry.vector);
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/io_apic_64.c.ifdefed" startline="983" endline="986">
{
    printk (KERN_DEBUG ".... register #02: %08X\n", reg_02.raw);
    printk (KERN_DEBUG ".......     : arbitration: %02X\n", reg_02.bits.arbitration);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/io_apic_64.c.ifdefed" startline="993" endline="1013">
{
    struct IO_APIC_route_entry entry;
    entry = ioapic_read_entry (apic, i);
    printk (KERN_DEBUG " %02x %03X ", i, entry.dest);
    printk ("%1d    %1d    %1d   %1d   %1d    %1d    %1d    %02X\n", entry.mask, entry.trigger, entry.irr, entry.polarity, entry.delivery_status, entry.dest_mode, entry.delivery_mode, entry.vector);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/io_apic_64.c.ifdefed" startline="1016" endline="1028">
{
    struct irq_pin_list *entry = irq_2_pin + i;
    if (entry->pin < 0)
        continue;
    printk (KERN_DEBUG "IRQ%d ", i);
    for (;;) {
        printk ("-> %d:%d", entry -> apic, entry -> pin);
        if (!entry->next)
            break;
        entry = irq_2_pin + entry->next;
    }
    printk ("\n");
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/io_apic_64.c.ifdefed" startline="1021" endline="1026">
{
    printk ("-> %d:%d", entry -> apic, entry -> pin);
    if (!entry->next)
        break;
    entry = irq_2_pin + entry->next;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/io_apic_64.c.ifdefed" startline="1175" endline="1233">
{
    union IO_APIC_reg_01 reg_01;
    int i8259_apic, i8259_pin;
    int i, apic;
    unsigned long flags;
    for (i = 0; i < PIN_MAP_SIZE; i++) {
        irq_2_pin[i].pin = -1;
        irq_2_pin[i].next = 0;
    }
    for (apic = 0; apic < nr_ioapics; apic++) {
        spin_lock_irqsave (& ioapic_lock, flags);
        reg_01.raw = io_apic_read (apic, 1);
        spin_unlock_irqrestore (& ioapic_lock, flags);
        nr_ioapic_registers[apic] = reg_01.bits.entries + 1;
    }
    for (apic = 0; apic < nr_ioapics; apic++) {
        int pin;
        for (pin = 0; pin < nr_ioapic_registers[apic]; pin++) {
            struct IO_APIC_route_entry entry;
            entry = ioapic_read_entry (apic, pin);
            if ((entry.mask == 0) && (entry.delivery_mode == dest_ExtINT)) {
                ioapic_i8259.apic = apic;
                ioapic_i8259.pin = pin;
                goto found_i8259;
            }
        }
    }
found_i8259 :
    i8259_pin = find_isa_irq_pin (0, mp_ExtINT);
    i8259_apic = find_isa_irq_apic (0, mp_ExtINT);
    if ((ioapic_i8259.pin == -1) && (i8259_pin >= 0)) {
        printk (KERN_WARNING "ExtINT not setup in hardware but reported by MP table\n");
        ioapic_i8259.pin = i8259_pin;
        ioapic_i8259.apic = i8259_apic;
    }
    if (((ioapic_i8259.apic != i8259_apic) || (ioapic_i8259.pin != i8259_pin)) && (i8259_pin >= 0) && (ioapic_i8259.pin >= 0)) {
        printk (KERN_WARNING "ExtINT in hardware and MP table differ\n");
    }
    clear_IO_APIC ();
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/io_apic_64.c.ifdefed" startline="1181" endline="1184">
{
    irq_2_pin[i].pin = -1;
    irq_2_pin[i].next = 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/io_apic_64.c.ifdefed" startline="1189" endline="1194">
{
    spin_lock_irqsave (& ioapic_lock, flags);
    reg_01.raw = io_apic_read (apic, 1);
    spin_unlock_irqrestore (& ioapic_lock, flags);
    nr_ioapic_registers[apic] = reg_01.bits.entries + 1;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/io_apic_64.c.ifdefed" startline="1195" endline="1211">
{
    int pin;
    for (pin = 0; pin < nr_ioapic_registers[apic]; pin++) {
        struct IO_APIC_route_entry entry;
        entry = ioapic_read_entry (apic, pin);
        if ((entry.mask == 0) && (entry.delivery_mode == dest_ExtINT)) {
            ioapic_i8259.apic = apic;
            ioapic_i8259.pin = pin;
            goto found_i8259;
        }
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/io_apic_64.c.ifdefed" startline="1198" endline="1210">
{
    struct IO_APIC_route_entry entry;
    entry = ioapic_read_entry (apic, pin);
    if ((entry.mask == 0) && (entry.delivery_mode == dest_ExtINT)) {
        ioapic_i8259.apic = apic;
        ioapic_i8259.pin = pin;
        goto found_i8259;
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/io_apic_64.c.ifdefed" startline="1205" endline="1209">
{
    ioapic_i8259.apic = apic;
    ioapic_i8259.pin = pin;
    goto found_i8259;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/io_apic_64.c.ifdefed" startline="1217" endline="1221">
{
    printk (KERN_WARNING "ExtINT not setup in hardware but reported by MP table\n");
    ioapic_i8259.pin = i8259_pin;
    ioapic_i8259.apic = i8259_apic;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/io_apic_64.c.ifdefed" startline="1225" endline="1227">
{
    printk (KERN_WARNING "ExtINT in hardware and MP table differ\n");
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/io_apic_64.c.ifdefed" startline="1239" endline="1271">
{
    clear_IO_APIC ();
    if (ioapic_i8259.pin != -1) {
        struct IO_APIC_route_entry entry;
        memset (& entry, 0, sizeof (entry));
        entry.mask = 0;
        entry.trigger = 0;
        entry.irr = 0;
        entry.polarity = 0;
        entry.delivery_status = 0;
        entry.dest_mode = 0;
        entry.delivery_mode = dest_ExtINT;
        entry.vector = 0;
        entry.dest = GET_APIC_ID (apic_read (APIC_ID));
        ioapic_write_entry (ioapic_i8259.apic, ioapic_i8259.pin, entry);
    }
    disconnect_bsp_APIC (ioapic_i8259.pin != - 1);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/io_apic_64.c.ifdefed" startline="1250" endline="1268">
{
    struct IO_APIC_route_entry entry;
    memset (& entry, 0, sizeof (entry));
    entry.mask = 0;
    entry.trigger = 0;
    entry.irr = 0;
    entry.polarity = 0;
    entry.delivery_status = 0;
    entry.dest_mode = 0;
    entry.delivery_mode = dest_ExtINT;
    entry.vector = 0;
    entry.dest = GET_APIC_ID (apic_read (APIC_ID));
    ioapic_write_entry (ioapic_i8259.apic, ioapic_i8259.pin, entry);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/io_apic_64.c.ifdefed" startline="1282" endline="1304">
{
    unsigned long t1 = jiffies;
    unsigned long flags;
    local_save_flags (flags);
    local_irq_enable ();
    mdelay ((10 * 1000) / HZ);
    local_irq_restore (flags);
    if (jiffies - t1 > 4)
        return 1;
    return 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/io_apic_64.c.ifdefed" startline="1330" endline="1344">
{
    int was_pending = 0;
    unsigned long flags;
    spin_lock_irqsave (& ioapic_lock, flags);
    if (irq < 16) {
        disable_8259A_irq (irq);
        if (i8259A_irq_pending (irq))
            was_pending = 1;
    }
    __unmask_IO_APIC_irq (irq);
    spin_unlock_irqrestore (& ioapic_lock, flags);
    return was_pending;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/io_apic_64.c.ifdefed" startline="1335" endline="1339">
{
    disable_8259A_irq (irq);
    if (i8259A_irq_pending (irq))
        was_pending = 1;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/io_apic_64.c.ifdefed" startline="1347" endline="1360">
{
    struct irq_cfg *cfg = &irq_cfg[irq];
    cpumask_t mask;
    unsigned long flags;
    spin_lock_irqsave (& vector_lock, flags);
    cpus_clear (mask);
    cpu_set (first_cpu (cfg -> domain), mask);
    send_IPI_mask (mask, cfg -> vector);
    spin_unlock_irqrestore (& vector_lock, flags);
    return 1;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/io_apic_64.c.ifdefed" startline="1426" endline="1426">
{
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/io_apic_64.c.ifdefed" startline="1430" endline="1434">
{
    irq_complete_move (irq);
    move_native_irq (irq);
    ack_APIC_irq ();
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/io_apic_64.c.ifdefed" startline="1437" endline="1487">
{
    int do_unmask_irq = 0;
    irq_complete_move (irq);
    ack_APIC_irq ();
    if (unlikely (do_unmask_irq)) {
        if (!io_apic_level_ack_pending (irq))
            move_masked_irq (irq);
        unmask_IO_APIC_irq (irq);
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/io_apic_64.c.ifdefed" startline="1456" endline="1486">
{
    if (!io_apic_level_ack_pending (irq))
        move_masked_irq (irq);
    unmask_IO_APIC_irq (irq);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/io_apic_64.c.ifdefed" startline="1503" endline="1532">
{
    int irq;
    for (irq = 0; irq < NR_IRQS; irq++) {
        int tmp = irq;
        if (IO_APIC_IRQ (tmp) && !irq_cfg[tmp].vector) {
            if (irq < 16)
                make_8259A_irq (irq);
            else
                irq_desc[irq].chip = &no_irq_chip;
        }
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/io_apic_64.c.ifdefed" startline="1517" endline="1531">
{
    int tmp = irq;
    if (IO_APIC_IRQ (tmp) && !irq_cfg[tmp].vector) {
        if (irq < 16)
            make_8259A_irq (irq);
        else
            irq_desc[irq].chip = &no_irq_chip;
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/io_apic_64.c.ifdefed" startline="1519" endline="1530">
{
    if (irq < 16)
        make_8259A_irq (irq);
    else
        irq_desc[irq].chip = &no_irq_chip;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/io_apic_64.c.ifdefed" startline="1535" endline="1540">
{
    unsigned long v;
    v = apic_read (APIC_LVT0);
    apic_write (APIC_LVT0, v & ~ APIC_LVT_MASKED);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/io_apic_64.c.ifdefed" startline="1543" endline="1548">
{
    unsigned long v;
    v = apic_read (APIC_LVT0);
    apic_write (APIC_LVT0, v | APIC_LVT_MASKED);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/io_apic_64.c.ifdefed" startline="1551" endline="1553">
{
    ack_APIC_irq ();
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/io_apic_64.c.ifdefed" startline="1555" endline="1555">
{
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/io_apic_64.c.ifdefed" startline="1569" endline="1584">
{
    printk (KERN_INFO "activating NMI Watchdog ...");
    enable_NMI_through_LVT0 (NULL);
    printk (" done.\n");
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/io_apic_64.c.ifdefed" startline="1594" endline="1647">
{
    int apic, pin, i;
    struct IO_APIC_route_entry entry0, entry1;
    unsigned char save_control, save_freq_select;
    unsigned long flags;
    pin = find_isa_irq_pin (8, mp_INT);
    apic = find_isa_irq_apic (8, mp_INT);
    if (pin == -1)
        return;
    spin_lock_irqsave (& ioapic_lock, flags);
    *(((int *) &entry0) + 1) = io_apic_read (apic, 0x11 + 2 * pin);
    *(((int *) &entry0) + 0) = io_apic_read (apic, 0x10 + 2 * pin);
    spin_unlock_irqrestore (& ioapic_lock, flags);
    clear_IO_APIC_pin (apic, pin);
    memset (& entry1, 0, sizeof (entry1));
    entry1.dest_mode = 0;
    entry1.mask = 0;
    entry1.dest = hard_smp_processor_id ();
    entry1.delivery_mode = dest_ExtINT;
    entry1.polarity = entry0.polarity;
    entry1.trigger = 0;
    entry1.vector = 0;
    spin_lock_irqsave (& ioapic_lock, flags);
    io_apic_write (apic, 0x11 + 2 * pin, * (((int *) & entry1) + 1));
    io_apic_write (apic, 0x10 + 2 * pin, * (((int *) & entry1) + 0));
    spin_unlock_irqrestore (& ioapic_lock, flags);
    save_control = CMOS_READ (RTC_CONTROL);
    save_freq_select = CMOS_READ (RTC_FREQ_SELECT);
    CMOS_WRITE ((save_freq_select & ~ RTC_RATE_SELECT) | 0x6, RTC_FREQ_SELECT);
    CMOS_WRITE (save_control | RTC_PIE, RTC_CONTROL);
    i = 100;
    while (i-- > 0) {
        mdelay (10);
        if ((CMOS_READ (RTC_INTR_FLAGS) & RTC_PF) == RTC_PF)
            i -= 10;
    }
    CMOS_WRITE (save_control, RTC_CONTROL);
    CMOS_WRITE (save_freq_select, RTC_FREQ_SELECT);
    clear_IO_APIC_pin (apic, pin);
    spin_lock_irqsave (& ioapic_lock, flags);
    io_apic_write (apic, 0x11 + 2 * pin, * (((int *) & entry0) + 1));
    io_apic_write (apic, 0x10 + 2 * pin, * (((int *) & entry0) + 0));
    spin_unlock_irqrestore (& ioapic_lock, flags);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/io_apic_64.c.ifdefed" startline="1633" endline="1637">
{
    mdelay (10);
    if ((CMOS_READ (RTC_INTR_FLAGS) & RTC_PF) == RTC_PF)
        i -= 10;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/io_apic_64.c.ifdefed" startline="1658" endline="1771">
{
    struct irq_cfg *cfg = irq_cfg + 0;
    int apic1, pin1, apic2, pin2;
    unsigned long flags;
    local_irq_save (flags);
    disable_8259A_irq (0);
    assign_irq_vector (0, TARGET_CPUS);
    apic_write (APIC_LVT0, APIC_LVT_MASKED | APIC_DM_EXTINT);
    init_8259A (1);
    if (timer_over_8254 > 0)
        enable_8259A_irq (0);
    pin1 = find_isa_irq_pin (0, mp_INT);
    apic1 = find_isa_irq_apic (0, mp_INT);
    pin2 = ioapic_i8259.pin;
    apic2 = ioapic_i8259.apic;
    apic_printk (APIC_VERBOSE, KERN_INFO "..TIMER: vector=0x%02X apic1=%d pin1=%d apic2=%d pin2=%d\n", cfg -> vector, apic1, pin1, apic2, pin2);
    if (pin1 != -1) {
        unmask_IO_APIC_irq (0);
        if (!no_timer_check && timer_irq_works ()) {
            nmi_watchdog_default ();
            if (nmi_watchdog == NMI_IO_APIC) {
                disable_8259A_irq (0);
                setup_nmi ();
                enable_8259A_irq (0);
            }
            if (disable_timer_pin_1 > 0)
                clear_IO_APIC_pin (0, pin1);
            goto out;
        }
        clear_IO_APIC_pin (apic1, pin1);
        apic_printk (APIC_QUIET, KERN_ERR "..MP-BIOS bug: 8254 timer not " "connected to IO-APIC\n");
    }
    apic_printk (APIC_VERBOSE, KERN_INFO "...trying to set up timer (IRQ0) " "through the 8259A ... ");
    if (pin2 != -1) {
        apic_printk (APIC_VERBOSE, "\n..... (found apic %d pin %d) ...", apic2, pin2);
        setup_ExtINT_IRQ0_pin (apic2, pin2, cfg -> vector);
        if (timer_irq_works ()) {
            apic_printk (APIC_VERBOSE, " works.\n");
            nmi_watchdog_default ();
            if (nmi_watchdog == NMI_IO_APIC) {
                setup_nmi ();
            }
            goto out;
        }
        clear_IO_APIC_pin (apic2, pin2);
    }
    apic_printk (APIC_VERBOSE, " failed.\n");
    if (nmi_watchdog == NMI_IO_APIC) {
        printk (KERN_WARNING "timer doesn't work through the IO-APIC - disabling NMI Watchdog!\n");
        nmi_watchdog = 0;
    }
    apic_printk (APIC_VERBOSE, KERN_INFO "...trying to set up timer as Virtual Wire IRQ...");
    disable_8259A_irq (0);
    irq_desc[0].chip = &lapic_irq_type;
    apic_write (APIC_LVT0, APIC_DM_FIXED | cfg -> vector);
    enable_8259A_irq (0);
    if (timer_irq_works ()) {
        apic_printk (APIC_VERBOSE, " works.\n");
        goto out;
    }
    apic_write (APIC_LVT0, APIC_LVT_MASKED | APIC_DM_FIXED | cfg -> vector);
    apic_printk (APIC_VERBOSE, " failed.\n");
    apic_printk (APIC_VERBOSE, KERN_INFO "...trying to set up timer as ExtINT IRQ...");
    init_8259A (0);
    make_8259A_irq (0);
    apic_write (APIC_LVT0, APIC_DM_EXTINT);
    unlock_ExtINT_logic ();
    if (timer_irq_works ()) {
        apic_printk (APIC_VERBOSE, " works.\n");
        goto out;
    }
    apic_printk (APIC_VERBOSE, " failed :(.\n");
    panic ("IO-APIC + timer doesn't work! Try using the 'noapic' kernel parameter\n");
out :
    local_irq_restore (flags);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/io_apic_64.c.ifdefed" startline="1691" endline="1710">
{
    unmask_IO_APIC_irq (0);
    if (!no_timer_check && timer_irq_works ()) {
        nmi_watchdog_default ();
        if (nmi_watchdog == NMI_IO_APIC) {
            disable_8259A_irq (0);
            setup_nmi ();
            enable_8259A_irq (0);
        }
        if (disable_timer_pin_1 > 0)
            clear_IO_APIC_pin (0, pin1);
        goto out;
    }
    clear_IO_APIC_pin (apic1, pin1);
    apic_printk (APIC_QUIET, KERN_ERR "..MP-BIOS bug: 8254 timer not " "connected to IO-APIC\n");
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/io_apic_64.c.ifdefed" startline="1696" endline="1706">
{
    nmi_watchdog_default ();
    if (nmi_watchdog == NMI_IO_APIC) {
        disable_8259A_irq (0);
        setup_nmi ();
        enable_8259A_irq (0);
    }
    if (disable_timer_pin_1 > 0)
        clear_IO_APIC_pin (0, pin1);
    goto out;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/io_apic_64.c.ifdefed" startline="1698" endline="1702">
{
    disable_8259A_irq (0);
    setup_nmi ();
    enable_8259A_irq (0);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/io_apic_64.c.ifdefed" startline="1714" endline="1733">
{
    apic_printk (APIC_VERBOSE, "\n..... (found apic %d pin %d) ...", apic2, pin2);
    setup_ExtINT_IRQ0_pin (apic2, pin2, cfg -> vector);
    if (timer_irq_works ()) {
        apic_printk (APIC_VERBOSE, " works.\n");
        nmi_watchdog_default ();
        if (nmi_watchdog == NMI_IO_APIC) {
            setup_nmi ();
        }
        goto out;
    }
    clear_IO_APIC_pin (apic2, pin2);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/io_apic_64.c.ifdefed" startline="1721" endline="1728">
{
    apic_printk (APIC_VERBOSE, " works.\n");
    nmi_watchdog_default ();
    if (nmi_watchdog == NMI_IO_APIC) {
        setup_nmi ();
    }
    goto out;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/io_apic_64.c.ifdefed" startline="1724" endline="1726">
{
    setup_nmi ();
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/io_apic_64.c.ifdefed" startline="1736" endline="1739">
{
    printk (KERN_WARNING "timer doesn't work through the IO-APIC - disabling NMI Watchdog!\n");
    nmi_watchdog = 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/io_apic_64.c.ifdefed" startline="1748" endline="1751">
{
    apic_printk (APIC_VERBOSE, " works.\n");
    goto out;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/io_apic_64.c.ifdefed" startline="1763" endline="1766">
{
    apic_printk (APIC_VERBOSE, " works.\n");
    goto out;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/io_apic_64.c.ifdefed" startline="1774" endline="1777">
{
    no_timer_check = 1;
    return 1;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/io_apic_64.c.ifdefed" startline="1790" endline="1806">
{
    enable_IO_APIC ();
    if (acpi_ioapic)
        io_apic_irqs = ~0;
    else
        io_apic_irqs = ~PIC_IRQS;
    apic_printk (APIC_VERBOSE, "ENABLING IO-APIC IRQs\n");
    sync_Arb_IDs ();
    setup_IO_APIC_irqs ();
    init_IO_APIC_traps ();
    check_timer ();
    if (!acpi_ioapic)
        print_IO_APIC ();
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/io_apic_64.c.ifdefed" startline="1815" endline="1826">
{
    struct IO_APIC_route_entry *entry;
    struct sysfs_ioapic_data *data;
    int i;
    data = container_of (dev, struct sysfs_ioapic_data, dev);
    entry = data->entry;
    for (i = 0; i < nr_ioapic_registers[dev->id]; i++, entry++)
        *entry = ioapic_read_entry (dev->id, i);
    return 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/io_apic_64.c.ifdefed" startline="1829" endline="1850">
{
    struct IO_APIC_route_entry *entry;
    struct sysfs_ioapic_data *data;
    unsigned long flags;
    union IO_APIC_reg_00 reg_00;
    int i;
    data = container_of (dev, struct sysfs_ioapic_data, dev);
    entry = data->entry;
    spin_lock_irqsave (& ioapic_lock, flags);
    reg_00.raw = io_apic_read (dev->id, 0);
    if (reg_00.bits.ID != mp_ioapics[dev->id].mpc_apicid) {
        reg_00.bits.ID = mp_ioapics[dev->id].mpc_apicid;
        io_apic_write (dev -> id, 0, reg_00.raw);
    }
    spin_unlock_irqrestore (& ioapic_lock, flags);
    for (i = 0; i < nr_ioapic_registers[dev->id]; i++)
        ioapic_write_entry (dev->id, i, entry[i]);
    return 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/io_apic_64.c.ifdefed" startline="1841" endline="1844">
{
    reg_00.bits.ID = mp_ioapics[dev->id].mpc_apicid;
    io_apic_write (dev -> id, 0, reg_00.raw);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/io_apic_64.c.ifdefed" startline="1859" endline="1888">
{
    struct sys_device *dev;
    int i, size, error;
    error = sysdev_class_register (&ioapic_sysdev_class);
    if (error)
        return error;
    for (i = 0; i < nr_ioapics; i++) {
        size = sizeof (struct sys_device) + nr_ioapic_registers[i] * sizeof (struct IO_APIC_route_entry);
        mp_ioapic_data[i] = kzalloc (size, GFP_KERNEL);
        if (!mp_ioapic_data[i]) {
            printk (KERN_ERR "Can't suspend/resume IOAPIC %d\n", i);
            continue;
        }
        dev = &mp_ioapic_data[i]->dev;
        dev->id = i;
        dev->cls = &ioapic_sysdev_class;
        error = sysdev_register (dev);
        if (error) {
            kfree (mp_ioapic_data [i]);
            mp_ioapic_data[i] = NULL;
            printk (KERN_ERR "Can't suspend/resume IOAPIC %d\n", i);
            continue;
        }
    }
    return 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/io_apic_64.c.ifdefed" startline="1867" endline="1885">
{
    size = sizeof (struct sys_device) + nr_ioapic_registers[i] * sizeof (struct IO_APIC_route_entry);
    mp_ioapic_data[i] = kzalloc (size, GFP_KERNEL);
    if (!mp_ioapic_data[i]) {
        printk (KERN_ERR "Can't suspend/resume IOAPIC %d\n", i);
        continue;
    }
    dev = &mp_ioapic_data[i]->dev;
    dev->id = i;
    dev->cls = &ioapic_sysdev_class;
    error = sysdev_register (dev);
    if (error) {
        kfree (mp_ioapic_data [i]);
        mp_ioapic_data[i] = NULL;
        printk (KERN_ERR "Can't suspend/resume IOAPIC %d\n", i);
        continue;
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/io_apic_64.c.ifdefed" startline="1871" endline="1874">
{
    printk (KERN_ERR "Can't suspend/resume IOAPIC %d\n", i);
    continue;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/io_apic_64.c.ifdefed" startline="1879" endline="1884">
{
    kfree (mp_ioapic_data [i]);
    mp_ioapic_data[i] = NULL;
    printk (KERN_ERR "Can't suspend/resume IOAPIC %d\n", i);
    continue;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/io_apic_64.c.ifdefed" startline="1896" endline="1919">
{
    int irq;
    int new;
    unsigned long flags;
    irq = -ENOSPC;
    spin_lock_irqsave (& vector_lock, flags);
    for (new = (NR_IRQS - 1); new >= 0; new--) {
        if (platform_legacy_irq (new))
            continue;
        if (irq_cfg[new].vector != 0)
            continue;
        if (__assign_irq_vector (new, TARGET_CPUS) == 0)
            irq = new;
        break;
    }
    spin_unlock_irqrestore (& vector_lock, flags);
    if (irq >= 0) {
        dynamic_irq_init (irq);
    }
    return irq;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/io_apic_64.c.ifdefed" startline="1904" endline="1912">
{
    if (platform_legacy_irq (new))
        continue;
    if (irq_cfg[new].vector != 0)
        continue;
    if (__assign_irq_vector (new, TARGET_CPUS) == 0)
        irq = new;
    break;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/io_apic_64.c.ifdefed" startline="1915" endline="1917">
{
    dynamic_irq_init (irq);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/io_apic_64.c.ifdefed" startline="1922" endline="1930">
{
    unsigned long flags;
    dynamic_irq_cleanup (irq);
    spin_lock_irqsave (& vector_lock, flags);
    __clear_irq_vector (irq);
    spin_unlock_irqrestore (& vector_lock, flags);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/process_64.c.ifdefed" startline="72" endline="74">
{
    atomic_notifier_chain_register (& idle_notifier, n);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/process_64.c.ifdefed" startline="78" endline="80">
{
    atomic_notifier_chain_unregister (& idle_notifier, n);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/process_64.c.ifdefed" startline="84" endline="87">
{
    write_pda (isidle, 1);
    atomic_notifier_call_chain (& idle_notifier, IDLE_START, NULL);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/process_64.c.ifdefed" startline="90" endline="94">
{
    if (test_and_clear_bit_pda (0, isidle) == 0)
        return;
    atomic_notifier_call_chain (& idle_notifier, IDLE_END, NULL);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/process_64.c.ifdefed" startline="98" endline="103">
{
    if (current->pid)
        return;
    __exit_idle ();
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/process_64.c.ifdefed" startline="110" endline="125">
{
    current_thread_info ()->status &= ~TS_POLLING;
    smp_mb ();
    local_irq_disable ();
    if (!need_resched ()) {
        safe_halt ();
    }
    else
        local_irq_enable ();
    current_thread_info ()->status |= TS_POLLING;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/process_64.c.ifdefed" startline="118" endline="122">
{
    safe_halt ();
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/process_64.c.ifdefed" startline="133" endline="136">
{
    local_irq_enable ();
    cpu_relax ();
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/process_64.c.ifdefed" startline="139" endline="140">
{
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/process_64.c.ifdefed" startline="143" endline="177">
{
    unsigned int cpu, this_cpu = get_cpu ();
    cpumask_t map, tmp = current->cpus_allowed;
    set_cpus_allowed (current, cpumask_of_cpu (this_cpu));
    put_cpu ();
    cpus_clear (map);

    for_each_online_cpu (cpu) {
        per_cpu (cpu_idle_state, cpu) = 1;
        cpu_set (cpu, map);
    }

    __get_cpu_var (cpu_idle_state) = 0;
    wmb ();
    do {
        ssleep (1);

        for_each_online_cpu (cpu) {
            if (cpu_isset (cpu, map) && !per_cpu (cpu_idle_state, cpu))
                cpu_clear (cpu, map);
        }

        cpus_and (map, map, cpu_online_map);
        smp_call_function_mask (map, do_nothing, 0, 0);
    }
    while (!cpus_empty (map));
    set_cpus_allowed (current, tmp);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/process_64.c.ifdefed" startline="151" endline="154">
{
    per_cpu (cpu_idle_state, cpu) = 1;
    cpu_set (cpu, map);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/process_64.c.ifdefed" startline="159" endline="174">
{
    ssleep (1);

    for_each_online_cpu (cpu) {
        if (cpu_isset (cpu, map) && !per_cpu (cpu_idle_state, cpu))
            cpu_clear (cpu, map);
    }

    cpus_and (map, map, cpu_online_map);
    smp_call_function_mask (map, do_nothing, 0, 0);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/process_64.c.ifdefed" startline="161" endline="165">
{
    if (cpu_isset (cpu, map) && !per_cpu (cpu_idle_state, cpu))
        cpu_clear (cpu, map);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/process_64.c.ifdefed" startline="199" endline="201">
{
    BUG ();
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/process_64.c.ifdefed" startline="211" endline="248">
{
    current_thread_info ()->status |= TS_POLLING;
    while (1) {
        while (!need_resched ()) {
            void (*idle) (void);
            if (__get_cpu_var (cpu_idle_state))
                __get_cpu_var (cpu_idle_state) = 0;
            tick_nohz_stop_sched_tick ();
            rmb ();
            idle = pm_idle;
            if (!idle)
                idle = default_idle;
            if (cpu_is_offline (smp_processor_id ()))
                play_dead ();
            local_irq_disable ();
            enter_idle ();
            idle ();
            __exit_idle ();
        }
        tick_nohz_restart_sched_tick ();
        preempt_enable_no_resched ();
        schedule ();
        preempt_disable ();
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/process_64.c.ifdefed" startline="214" endline="247">
{
    while (!need_resched ()) {
        void (*idle) (void);
        if (__get_cpu_var (cpu_idle_state))
            __get_cpu_var (cpu_idle_state) = 0;
        tick_nohz_stop_sched_tick ();
        rmb ();
        idle = pm_idle;
        if (!idle)
            idle = default_idle;
        if (cpu_is_offline (smp_processor_id ()))
            play_dead ();
        local_irq_disable ();
        enter_idle ();
        idle ();
        __exit_idle ();
    }
    tick_nohz_restart_sched_tick ();
    preempt_enable_no_resched ();
    schedule ();
    preempt_disable ();
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/process_64.c.ifdefed" startline="215" endline="241">
{
    void (*idle) (void);
    if (__get_cpu_var (cpu_idle_state))
        __get_cpu_var (cpu_idle_state) = 0;
    tick_nohz_stop_sched_tick ();
    rmb ();
    idle = pm_idle;
    if (!idle)
        idle = default_idle;
    if (cpu_is_offline (smp_processor_id ()))
        play_dead ();
    local_irq_disable ();
    enter_idle ();
    idle ();
    __exit_idle ();
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/process_64.c.ifdefed" startline="261" endline="268">
{
    if (!need_resched ()) {
        __monitor ((void *) & current_thread_info () -> flags, 0, 0);
        smp_mb ();
        if (!need_resched ())
            __mwait (eax, ecx);
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/process_64.c.ifdefed" startline="262" endline="267">
{
    __monitor ((void *) & current_thread_info () -> flags, 0, 0);
    smp_mb ();
    if (!need_resched ())
        __mwait (eax, ecx);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/process_64.c.ifdefed" startline="272" endline="283">
{
    if (!need_resched ()) {
        __monitor ((void *) & current_thread_info () -> flags, 0, 0);
        smp_mb ();
        if (!need_resched ())
            __sti_mwait (0, 0);
        else
            local_irq_enable ();
    }
    else {
        local_irq_enable ();
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/process_64.c.ifdefed" startline="273" endline="280">
{
    __monitor ((void *) & current_thread_info () -> flags, 0, 0);
    smp_mb ();
    if (!need_resched ())
        __sti_mwait (0, 0);
    else
        local_irq_enable ();
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/process_64.c.ifdefed" startline="280" endline="282">
{
    local_irq_enable ();
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/process_64.c.ifdefed" startline="286" endline="301">
{
    static int printed;
    if (cpu_has (c, X86_FEATURE_MWAIT)) {
        if (!pm_idle) {
            if (!printed) {
                printk (KERN_INFO "using mwait in idle threads.\n");
                printed = 1;
            }
            pm_idle = mwait_idle;
        }
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/process_64.c.ifdefed" startline="288" endline="300">
{
    if (!pm_idle) {
        if (!printed) {
            printk (KERN_INFO "using mwait in idle threads.\n");
            printed = 1;
        }
        pm_idle = mwait_idle;
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/process_64.c.ifdefed" startline="293" endline="299">
{
    if (!printed) {
        printk (KERN_INFO "using mwait in idle threads.\n");
        printed = 1;
    }
    pm_idle = mwait_idle;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/process_64.c.ifdefed" startline="294" endline="297">
{
    printk (KERN_INFO "using mwait in idle threads.\n");
    printed = 1;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/process_64.c.ifdefed" startline="304" endline="315">
{
    if (!strcmp (str, "poll")) {
        printk ("using polling idle threads.\n");
        pm_idle = poll_idle;
    }
    else if (!strcmp (str, "mwait"))
        force_mwait = 1;
    else
        return -1;
    boot_option_idle_override = 1;
    return 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/process_64.c.ifdefed" startline="305" endline="308">
{
    printk ("using polling idle threads.\n");
    pm_idle = poll_idle;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/process_64.c.ifdefed" startline="320" endline="376">
{
    unsigned long cr0 = 0L, cr2 = 0L, cr3 = 0L, cr4 = 0L, fs, gs, shadowgs;
    unsigned long d0, d1, d2, d3, d6, d7;
    unsigned int fsindex, gsindex;
    unsigned int ds, cs, es;
    printk ("\n");
    print_modules ();
    printk ("Pid: %d, comm: %.20s %s %s %.*s\n", current -> pid, current -> comm, print_tainted (), init_utsname () -> release, (int) strcspn (init_utsname () -> version, " "), init_utsname () -> version);
    printk ("RIP: %04lx:[<%016lx>] ", regs -> cs & 0xffff, regs -> rip);
    printk_address (regs -> rip);
    printk ("RSP: %04lx:%016lx  EFLAGS: %08lx\n", regs -> ss, regs -> rsp, regs -> eflags);
    printk ("RAX: %016lx RBX: %016lx RCX: %016lx\n", regs -> rax, regs -> rbx, regs -> rcx);
    printk ("RDX: %016lx RSI: %016lx RDI: %016lx\n", regs -> rdx, regs -> rsi, regs -> rdi);
    printk ("RBP: %016lx R08: %016lx R09: %016lx\n", regs -> rbp, regs -> r8, regs -> r9);
    printk ("R10: %016lx R11: %016lx R12: %016lx\n", regs -> r10, regs -> r11, regs -> r12);
    printk ("R13: %016lx R14: %016lx R15: %016lx\n", regs -> r13, regs -> r14, regs -> r15);
    asm ("movl %%ds,%0"
        : "=r" (ds)
    ) asm ("movl %%cs,%0"
        : "=r" (cs)
    ) asm ("movl %%es,%0"
        : "=r" (es)
    ) asm ("movl %%fs,%0"
        : "=r" (fsindex)
    ) asm ("movl %%gs,%0"
        : "=r" (gsindex)
    ) rdmsrl (MSR_FS_BASE, fs);
    rdmsrl (MSR_GS_BASE, gs);
    rdmsrl (MSR_KERNEL_GS_BASE, shadowgs);
    cr0 = read_cr0 ();
    cr2 = read_cr2 ();
    cr3 = read_cr3 ();
    cr4 = read_cr4 ();
    printk ("FS:  %016lx(%04x) GS:%016lx(%04x) knlGS:%016lx\n", fs, fsindex, gs, gsindex, shadowgs);
    printk ("CS:  %04x DS: %04x ES: %04x CR0: %016lx\n", cs, ds, es, cr0);
    printk ("CR2: %016lx CR3: %016lx CR4: %016lx\n", cr2, cr3, cr4);
    get_debugreg (d0, 0);
    get_debugreg (d1, 1);
    get_debugreg (d2, 2);
    printk ("DR0: %016lx DR1: %016lx DR2: %016lx\n", d0, d1, d2);
    get_debugreg (d3, 3);
    get_debugreg (d6, 6);
    get_debugreg (d7, 7);
    printk ("DR3: %016lx DR6: %016lx DR7: %016lx\n", d3, d6, d7);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/process_64.c.ifdefed" startline="379" endline="383">
{
    printk ("CPU %d:", smp_processor_id ());
    __show_regs (regs);
    show_trace (NULL, regs, (void *) (regs + 1));
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/process_64.c.ifdefed" startline="389" endline="406">
{
    struct task_struct *me = current;
    struct thread_struct *t = &me->thread;
    if (me->thread.io_bitmap_ptr) {
        struct tss_struct *tss = &per_cpu (init_tss, get_cpu ());
        kfree (t -> io_bitmap_ptr);
        t->io_bitmap_ptr = NULL;
        clear_thread_flag (TIF_IO_BITMAP);
        memset (tss -> io_bitmap, 0xff, t -> io_bitmap_max);
        t->io_bitmap_max = 0;
        put_cpu ();
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/process_64.c.ifdefed" startline="393" endline="405">
{
    struct tss_struct *tss = &per_cpu (init_tss, get_cpu ());
    kfree (t -> io_bitmap_ptr);
    t->io_bitmap_ptr = NULL;
    clear_thread_flag (TIF_IO_BITMAP);
    memset (tss -> io_bitmap, 0xff, t -> io_bitmap_max);
    t->io_bitmap_max = 0;
    put_cpu ();
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/process_64.c.ifdefed" startline="409" endline="435">
{
    struct task_struct *tsk = current;
    if (test_tsk_thread_flag (tsk, TIF_ABI_PENDING)) {
        clear_tsk_thread_flag (tsk, TIF_ABI_PENDING);
        if (test_tsk_thread_flag (tsk, TIF_IA32)) {
            clear_tsk_thread_flag (tsk, TIF_IA32);
        }
        else {
            set_tsk_thread_flag (tsk, TIF_IA32);
            current_thread_info ()->status |= TS_COMPAT;
        }
    }
    clear_tsk_thread_flag (tsk, TIF_DEBUG);
    tsk->thread.debugreg0 = 0;
    tsk->thread.debugreg1 = 0;
    tsk->thread.debugreg2 = 0;
    tsk->thread.debugreg3 = 0;
    tsk->thread.debugreg6 = 0;
    tsk->thread.debugreg7 = 0;
    memset (tsk -> thread.tls_array, 0, sizeof (tsk -> thread.tls_array));
    clear_fpu (tsk);
    clear_used_math ();
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/process_64.c.ifdefed" startline="412" endline="420">
{
    clear_tsk_thread_flag (tsk, TIF_ABI_PENDING);
    if (test_tsk_thread_flag (tsk, TIF_IA32)) {
        clear_tsk_thread_flag (tsk, TIF_IA32);
    }
    else {
        set_tsk_thread_flag (tsk, TIF_IA32);
        current_thread_info ()->status |= TS_COMPAT;
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/process_64.c.ifdefed" startline="414" endline="416">
{
    clear_tsk_thread_flag (tsk, TIF_IA32);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/process_64.c.ifdefed" startline="416" endline="419">
{
    set_tsk_thread_flag (tsk, TIF_IA32);
    current_thread_info ()->status |= TS_COMPAT;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/process_64.c.ifdefed" startline="438" endline="448">
{
    if (dead_task->mm) {
        if (dead_task->mm->context.size) {
            printk ("WARNING: dead process %8s still has LDT? <%p/%d>\n", dead_task -> comm, dead_task -> mm -> context.ldt, dead_task -> mm -> context.size);
            BUG ();
        }
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/process_64.c.ifdefed" startline="439" endline="447">
{
    if (dead_task->mm->context.size) {
        printk ("WARNING: dead process %8s still has LDT? <%p/%d>\n", dead_task -> comm, dead_task -> mm -> context.ldt, dead_task -> mm -> context.size);
        BUG ();
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/process_64.c.ifdefed" startline="440" endline="446">
{
    printk ("WARNING: dead process %8s still has LDT? <%p/%d>\n", dead_task -> comm, dead_task -> mm -> context.ldt, dead_task -> mm -> context.size);
    BUG ();
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/process_64.c.ifdefed" startline="451" endline="463">
{
    struct user_desc ud = {
        .base_addr = addr,
        .limit = 0xfffff,
        .seg_32bit = 1,
        .limit_in_pages = 1,
        .useable = 1,
    };
    struct n_desc_struct *desc = (void *) t->thread.tls_array;
    desc += tls;
    desc->a = LDT_entry_a (&ud);
    desc->b = LDT_entry_b (&ud);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/process_64.c.ifdefed" startline="466" endline="472">
{
    struct desc_struct *desc = (void *) t->thread.tls_array;
    desc += tls;
    return desc->base0 | (((u32) desc->base1) << 16) | (((u32) desc->base2) << 24);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/process_64.c.ifdefed" startline="479" endline="481">
{
    unlazy_fpu (tsk);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/process_64.c.ifdefed" startline="486" endline="545">
{
    int err;
    struct pt_regs *childregs;
    struct task_struct *me = current;
    childregs = ((struct pt_regs *) (THREAD_SIZE + task_stack_page (p))) - 1;
    *childregs = *regs;
    childregs->rax = 0;
    childregs->rsp = rsp;
    if (rsp == ~0UL)
        childregs->rsp = (unsigned long) childregs;
    p->thread.rsp = (unsigned long) childregs;
    p->thread.rsp0 = (unsigned long) (childregs + 1);
    p->thread.userrsp = me->thread.userrsp;
    set_tsk_thread_flag (p, TIF_FORK);
    p->thread.fs = me->thread.fs;
    p->thread.gs = me->thread.gs;
    asm ("mov %%gs,%0"
        : "=m" (p->thread.gsindex)
    ) asm ("mov %%fs,%0"
        : "=m" (p->thread.fsindex)
    ) asm ("mov %%es,%0"
        : "=m" (p->thread.es)
    ) asm ("mov %%ds,%0"
        : "=m" (p->thread.ds)
    ) if (unlikely (test_tsk_thread_flag (me, TIF_IO_BITMAP))) {
        p->thread.io_bitmap_ptr = kmalloc (IO_BITMAP_BYTES, GFP_KERNEL);
        if (!p->thread.io_bitmap_ptr) {
            p->thread.io_bitmap_max = 0;
            return -ENOMEM;
        }
        memcpy (p -> thread.io_bitmap_ptr, me -> thread.io_bitmap_ptr, IO_BITMAP_BYTES);
        set_tsk_thread_flag (p, TIF_IO_BITMAP);
    }
    if (clone_flags & CLONE_SETTLS) {
        err = do_arch_prctl (p, ARCH_SET_FS, childregs->r8);
        if (err)
            goto out;
    }
    err = 0;
out :
    if (err && p->thread.io_bitmap_ptr) {
        kfree (p -> thread.io_bitmap_ptr);
        p->thread.io_bitmap_max = 0;
    }
    return err;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/process_64.c.ifdefed" startline="514" endline="523">
{
    p->thread.io_bitmap_ptr = kmalloc (IO_BITMAP_BYTES, GFP_KERNEL);
    if (!p->thread.io_bitmap_ptr) {
        p->thread.io_bitmap_max = 0;
        return -ENOMEM;
    }
    memcpy (p -> thread.io_bitmap_ptr, me -> thread.io_bitmap_ptr, IO_BITMAP_BYTES);
    set_tsk_thread_flag (p, TIF_IO_BITMAP);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/process_64.c.ifdefed" startline="516" endline="519">
{
    p->thread.io_bitmap_max = 0;
    return -ENOMEM;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/process_64.c.ifdefed" startline="528" endline="537">
{
    err = do_arch_prctl (p, ARCH_SET_FS, childregs->r8);
    if (err)
        goto out;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/process_64.c.ifdefed" startline="540" endline="543">
{
    kfree (p -> thread.io_bitmap_ptr);
    p->thread.io_bitmap_max = 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/process_64.c.ifdefed" startline="555" endline="584">
{
    struct thread_struct *prev, *next;
    prev = &prev_p->thread, next = &next_p->thread;
    if (test_tsk_thread_flag (next_p, TIF_DEBUG)) {
        loaddebug (next, 0);
        loaddebug (next, 1);
        loaddebug (next, 2);
        loaddebug (next, 3);
        loaddebug (next, 6);
        loaddebug (next, 7);
    }
    if (test_tsk_thread_flag (next_p, TIF_IO_BITMAP)) {
        memcpy (tss -> io_bitmap, next -> io_bitmap_ptr, max (prev -> io_bitmap_max, next -> io_bitmap_max));
    }
    else if (test_tsk_thread_flag (prev_p, TIF_IO_BITMAP)) {
        memset (tss -> io_bitmap, 0xff, prev -> io_bitmap_max);
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/process_64.c.ifdefed" startline="561" endline="569">
{
    loaddebug (next, 0);
    loaddebug (next, 1);
    loaddebug (next, 2);
    loaddebug (next, 3);
    loaddebug (next, 6);
    loaddebug (next, 7);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/process_64.c.ifdefed" startline="571" endline="578">
{
    memcpy (tss -> io_bitmap, next -> io_bitmap_ptr, max (prev -> io_bitmap_max, next -> io_bitmap_max));
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/process_64.c.ifdefed" startline="578" endline="583">
{
    memset (tss -> io_bitmap, 0xff, prev -> io_bitmap_max);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/process_64.c.ifdefed" startline="597" endline="698">
{
    struct thread_struct *prev = &prev_p->thread, *next = &next_p->thread;
    int cpu = smp_processor_id ();
    struct tss_struct *tss = &per_cpu (init_tss, cpu);
    if (next_p->fpu_counter > 5)
        prefetch (&next->i387.fxsave);
    tss->rsp0 = next->rsp0;
    asm volatile ("mov %%es,%0"
        : "=m" (prev->es)
    ) if (unlikely (next->es | prev->es))
        loadsegment (es, next->es);
    asm volatile ("mov %%ds,%0"
        : "=m" (prev->ds)
    ) if (unlikely (next->ds | prev->ds))
        loadsegment (ds, next->ds);
    load_TLS (next, cpu);
    {
        unsigned fsindex;
        asm volatile ("movl %%fs,%0"
            : "=r" (fsindex)
        ) if (unlikely (fsindex | next->fsindex | prev->fs)) {
            loadsegment (fs, next -> fsindex);
            if (fsindex)
                prev->fs = 0;
        }
        if (next->fs)
            wrmsrl (MSR_FS_BASE, next->fs);
        prev->fsindex = fsindex;
    }
    {
        unsigned gsindex;
        asm volatile ("movl %%gs,%0"
            : "=r" (gsindex)
        ) if (unlikely (gsindex | next->gsindex | prev->gs)) {
            load_gs_index (next -> gsindex);
            if (gsindex)
                prev->gs = 0;
        }
        if (next->gs)
            wrmsrl (MSR_KERNEL_GS_BASE, next->gs);
        prev->gsindex = gsindex;
    }
    unlazy_fpu (prev_p);
    prev->userrsp = read_pda (oldrsp);
    write_pda (oldrsp, next -> userrsp);
    write_pda (pcurrent, next_p);
    write_pda (kernelstack, (unsigned long) task_stack_page (next_p) + THREAD_SIZE - PDA_STACKOFFSET);
    if (unlikely ((task_thread_info (next_p)->flags & _TIF_WORK_CTXSW)) || test_tsk_thread_flag (prev_p, TIF_IO_BITMAP))
        __switch_to_xtra (prev_p, next_p, tss);
    if (next_p->fpu_counter > 5)
        math_state_restore ();
    return prev_p;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/process_64.c.ifdefed" startline="629" endline="649">
{
    unsigned fsindex;
    asm volatile ("movl %%fs,%0"
        : "=r" (fsindex)
    ) if (unlikely (fsindex | next->fsindex | prev->fs)) {
        loadsegment (fs, next -> fsindex);
        if (fsindex)
            prev->fs = 0;
    }
    if (next->fs)
        wrmsrl (MSR_FS_BASE, next->fs);
    prev->fsindex = fsindex;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/process_64.c.ifdefed" startline="636" endline="644">
{
    loadsegment (fs, next -> fsindex);
    if (fsindex)
        prev->fs = 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/process_64.c.ifdefed" startline="650" endline="661">
{
    unsigned gsindex;
    asm volatile ("movl %%gs,%0"
        : "=r" (gsindex)
    ) if (unlikely (gsindex | next->gsindex | prev->gs)) {
        load_gs_index (next -> gsindex);
        if (gsindex)
            prev->gs = 0;
    }
    if (next->gs)
        wrmsrl (MSR_KERNEL_GS_BASE, next->gs);
    prev->gsindex = gsindex;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/process_64.c.ifdefed" startline="653" endline="657">
{
    load_gs_index (next -> gsindex);
    if (gsindex)
        prev->gs = 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/process_64.c.ifdefed" startline="706" endline="722">
{
    long error;
    char *filename;
    filename = getname (name);
    error = PTR_ERR (filename);
    if (IS_ERR (filename))
        return error;
    error = do_execve (filename, argv, envp, &regs);
    if (error == 0) {
        task_lock (current);
        current->ptrace &= ~PT_DTRACE;
        task_unlock (current);
    }
    putname (filename);
    return error;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/process_64.c.ifdefed" startline="715" endline="719">
{
    task_lock (current);
    current->ptrace &= ~PT_DTRACE;
    task_unlock (current);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/process_64.c.ifdefed" startline="725" endline="736">
{
    clear_thread_flag (TIF_IA32);
    current->personality &= ~READ_IMPLIES_EXEC;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/process_64.c.ifdefed" startline="739" endline="741">
{
    return do_fork (SIGCHLD, regs->rsp, regs, 0, NULL, NULL);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/process_64.c.ifdefed" startline="746" endline="750">
{
    if (!newsp)
        newsp = regs->rsp;
    return do_fork (clone_flags, newsp, regs, 0, parent_tid, child_tid);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/process_64.c.ifdefed" startline="763" endline="766">
{
    return do_fork (CLONE_VFORK | CLONE_VM | SIGCHLD, regs->rsp, regs, 0, NULL, NULL);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/process_64.c.ifdefed" startline="769" endline="790">
{
    unsigned long stack;
    u64 fp, rip;
    int count = 0;
    if (!p || p == current || p->state == TASK_RUNNING)
        return 0;
    stack = (unsigned long) task_stack_page (p);
    if (p->thread.rsp < stack || p->thread.rsp > stack + THREAD_SIZE)
        return 0;
    fp = *(u64*) (p->thread.rsp);
    do {
        if (fp < (unsigned long) stack || fp > (unsigned long) stack + THREAD_SIZE)
            return 0;
        rip = *(u64*) (fp + 8);
        if (!in_sched_functions (rip))
            return rip;
        fp = *(u64*) fp;
    }
    while (count++ < 16);
    return 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/process_64.c.ifdefed" startline="780" endline="788">
{
    if (fp < (unsigned long) stack || fp > (unsigned long) stack + THREAD_SIZE)
        return 0;
    rip = *(u64*) (fp + 8);
    if (!in_sched_functions (rip))
        return rip;
    fp = *(u64*) fp;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/process_64.c.ifdefed" startline="793" endline="886">
{
    int ret = 0;
    int doit = task == current;
    int cpu;
    switch (code) {
    case ARCH_SET_GS :
        if (addr >= TASK_SIZE_OF (task))
            return -EPERM;
        cpu = get_cpu ();
        if (addr <= 0xffffffff) {
            set_32bit_tls (task, GS_TLS, addr);
            if (doit) {
                load_TLS (& task -> thread, cpu);
                load_gs_index (GS_TLS_SEL);
            }
            task->thread.gsindex = GS_TLS_SEL;
            task->thread.gs = 0;
        }
        else {
            task->thread.gsindex = 0;
            task->thread.gs = addr;
            if (doit) {
                load_gs_index (0);
                ret = checking_wrmsrl (MSR_KERNEL_GS_BASE, addr);
            }
        }
        put_cpu ();
        break;
    case ARCH_SET_FS :
        if (addr >= TASK_SIZE_OF (task))
            return -EPERM;
        cpu = get_cpu ();
        if (addr <= 0xffffffff) {
            set_32bit_tls (task, FS_TLS, addr);
            if (doit) {
                load_TLS (& task -> thread, cpu);
                asm volatile ("movl %0,%%fs"
                    :
                    : "r" (FS_TLS_SEL)
                )}
            task->thread.fsindex = FS_TLS_SEL;
            task->thread.fs = 0;
        }
        else {
            task->thread.fsindex = 0;
            task->thread.fs = addr;
            if (doit) {
                asm volatile ("movl %0,%%fs"
                    :
                    : "r" (0)
                ) ret = checking_wrmsrl (MSR_FS_BASE, addr);
            }
        }
        put_cpu ();
        break;
    case ARCH_GET_FS :
        {
            unsigned long base;
            if (task->thread.fsindex == FS_TLS_SEL)
                base = read_32bit_tls (task, FS_TLS);
            else if (doit)
                rdmsrl (MSR_FS_BASE, base);
            else
                base = task->thread.fs;
            ret = put_user (base, (unsigned long __user *) addr);
            break;
        }
    case ARCH_GET_GS :
        {
            unsigned long base;
            unsigned gsindex;
            if (task->thread.gsindex == GS_TLS_SEL)
                base = read_32bit_tls (task, GS_TLS);
            else if (doit) {
                asm ("movl %%gs,%0"
                    : "=r" (gsindex)
                ) if (gsindex)
                    rdmsrl (MSR_KERNEL_GS_BASE, base);
                else
                    base = task->thread.gs;
            }
            else
                base = task->thread.gs;
            ret = put_user (base, (unsigned long __user *) addr);
            break;
        }
    default :
        ret = -EINVAL;
        break;
    }
    return ret;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/process_64.c.ifdefed" startline="798" endline="883">
{
case ARCH_SET_GS :
    if (addr >= TASK_SIZE_OF (task))
        return -EPERM;
    cpu = get_cpu ();
    if (addr <= 0xffffffff) {
        set_32bit_tls (task, GS_TLS, addr);
        if (doit) {
            load_TLS (& task -> thread, cpu);
            load_gs_index (GS_TLS_SEL);
        }
        task->thread.gsindex = GS_TLS_SEL;
        task->thread.gs = 0;
    }
    else {
        task->thread.gsindex = 0;
        task->thread.gs = addr;
        if (doit) {
            load_gs_index (0);
            ret = checking_wrmsrl (MSR_KERNEL_GS_BASE, addr);
        }
    }
    put_cpu ();
    break;
case ARCH_SET_FS :
    if (addr >= TASK_SIZE_OF (task))
        return -EPERM;
    cpu = get_cpu ();
    if (addr <= 0xffffffff) {
        set_32bit_tls (task, FS_TLS, addr);
        if (doit) {
            load_TLS (& task -> thread, cpu);
            asm volatile ("movl %0,%%fs"
                :
                : "r" (FS_TLS_SEL)
            )}
        task->thread.fsindex = FS_TLS_SEL;
        task->thread.fs = 0;
    }
    else {
        task->thread.fsindex = 0;
        task->thread.fs = addr;
        if (doit) {
            asm volatile ("movl %0,%%fs"
                :
                : "r" (0)
            ) ret = checking_wrmsrl (MSR_FS_BASE, addr);
        }
    }
    put_cpu ();
    break;
case ARCH_GET_FS :
    {
        unsigned long base;
        if (task->thread.fsindex == FS_TLS_SEL)
            base = read_32bit_tls (task, FS_TLS);
        else if (doit)
            rdmsrl (MSR_FS_BASE, base);
        else
            base = task->thread.fs;
        ret = put_user (base, (unsigned long __user *) addr);
        break;
    }
case ARCH_GET_GS :
    {
        unsigned long base;
        unsigned gsindex;
        if (task->thread.gsindex == GS_TLS_SEL)
            base = read_32bit_tls (task, GS_TLS);
        else if (doit) {
            asm ("movl %%gs,%0"
                : "=r" (gsindex)
            ) if (gsindex)
                rdmsrl (MSR_KERNEL_GS_BASE, base);
            else
                base = task->thread.gs;
        }
        else
            base = task->thread.gs;
        ret = put_user (base, (unsigned long __user *) addr);
        break;
    }
default :
    ret = -EINVAL;
    break;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/process_64.c.ifdefed" startline="805" endline="813">
{
    set_32bit_tls (task, GS_TLS, addr);
    if (doit) {
        load_TLS (& task -> thread, cpu);
        load_gs_index (GS_TLS_SEL);
    }
    task->thread.gsindex = GS_TLS_SEL;
    task->thread.gs = 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/process_64.c.ifdefed" startline="807" endline="810">
{
    load_TLS (& task -> thread, cpu);
    load_gs_index (GS_TLS_SEL);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/process_64.c.ifdefed" startline="813" endline="820">
{
    task->thread.gsindex = 0;
    task->thread.gs = addr;
    if (doit) {
        load_gs_index (0);
        ret = checking_wrmsrl (MSR_KERNEL_GS_BASE, addr);
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/process_64.c.ifdefed" startline="816" endline="819">
{
    load_gs_index (0);
    ret = checking_wrmsrl (MSR_KERNEL_GS_BASE, addr);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/process_64.c.ifdefed" startline="831" endline="839">
{
    set_32bit_tls (task, FS_TLS, addr);
    if (doit) {
        load_TLS (& task -> thread, cpu);
        asm volatile ("movl %0,%%fs"
            :
            : "r" (FS_TLS_SEL)
        )}
    task->thread.fsindex = FS_TLS_SEL;
    task->thread.fs = 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/process_64.c.ifdefed" startline="833" endline="836">
{
    load_TLS (& task -> thread, cpu);
    asm volatile ("movl %0,%%fs"
        :
        : "r" (FS_TLS_SEL)
    )}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/process_64.c.ifdefed" startline="839" endline="848">
{
    task->thread.fsindex = 0;
    task->thread.fs = addr;
    if (doit) {
        asm volatile ("movl %0,%%fs"
            :
            : "r" (0)
        ) ret = checking_wrmsrl (MSR_FS_BASE, addr);
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/process_64.c.ifdefed" startline="842" endline="847">
{
    asm volatile ("movl %0,%%fs"
        :
        : "r" (0)
    ) ret = checking_wrmsrl (MSR_FS_BASE, addr);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/process_64.c.ifdefed" startline="851" endline="861">
{
    unsigned long base;
    if (task->thread.fsindex == FS_TLS_SEL)
        base = read_32bit_tls (task, FS_TLS);
    else if (doit)
        rdmsrl (MSR_FS_BASE, base);
    else
        base = task->thread.fs;
    ret = put_user (base, (unsigned long __user *) addr);
    break;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/process_64.c.ifdefed" startline="862" endline="878">
{
    unsigned long base;
    unsigned gsindex;
    if (task->thread.gsindex == GS_TLS_SEL)
        base = read_32bit_tls (task, GS_TLS);
    else if (doit) {
        asm ("movl %%gs,%0"
            : "=r" (gsindex)
        ) if (gsindex)
            rdmsrl (MSR_KERNEL_GS_BASE, base);
        else
            base = task->thread.gs;
    }
    else
        base = task->thread.gs;
    ret = put_user (base, (unsigned long __user *) addr);
    break;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/process_64.c.ifdefed" startline="867" endline="873">
{
    asm ("movl %%gs,%0"
        : "=r" (gsindex)
    ) if (gsindex)
        rdmsrl (MSR_KERNEL_GS_BASE, base);
    else
        base = task->thread.gs;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/process_64.c.ifdefed" startline="889" endline="891">
{
    return do_arch_prctl (current, code, addr);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/process_64.c.ifdefed" startline="897" endline="909">
{
    struct pt_regs *pp, ptregs;
    pp = task_pt_regs (tsk);
    ptregs = *pp;
    ptregs.cs &= 0xffff;
    ptregs.ss &= 0xffff;
    elf_core_copy_regs (regs, & ptregs);
    return 1;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/process_64.c.ifdefed" startline="912" endline="916">
{
    if (!(current->personality & ADDR_NO_RANDOMIZE) && randomize_va_space)
        sp -= get_random_int () % 8192;
    return sp & ~0xf;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/tsc_sync.c.ifdefed" startline="45" endline="92">
{
    cycles_t start, now, prev, end;
    int i;
    start = get_cycles_sync ();
    end = start + tsc_khz * 20ULL;
    now = start;
    for (i = 0;; i++) {
        __raw_spin_lock (& sync_lock);
        prev = last_tsc;
        now = get_cycles_sync ();
        last_tsc = now;
        __raw_spin_unlock (& sync_lock);
        if (unlikely (!(i & 7))) {
            if (now > end || i > 100000000)
                break;
            cpu_relax ();
            touch_nmi_watchdog ();
        }
        if (unlikely (prev > now)) {
            __raw_spin_lock (& sync_lock);
            max_warp = max (max_warp, prev -now);
            nr_warps++;
            __raw_spin_unlock (& sync_lock);
        }
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/tsc_sync.c.ifdefed" startline="56" endline="91">
{
    __raw_spin_lock (& sync_lock);
    prev = last_tsc;
    now = get_cycles_sync ();
    last_tsc = now;
    __raw_spin_unlock (& sync_lock);
    if (unlikely (!(i & 7))) {
        if (now > end || i > 100000000)
            break;
        cpu_relax ();
        touch_nmi_watchdog ();
    }
    if (unlikely (prev > now)) {
        __raw_spin_lock (& sync_lock);
        max_warp = max (max_warp, prev -now);
        nr_warps++;
        __raw_spin_unlock (& sync_lock);
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/tsc_sync.c.ifdefed" startline="74" endline="79">
{
    if (now > end || i > 100000000)
        break;
    cpu_relax ();
    touch_nmi_watchdog ();
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/tsc_sync.c.ifdefed" startline="84" endline="89">
{
    __raw_spin_lock (& sync_lock);
    max_warp = max (max_warp, prev -now);
    nr_warps++;
    __raw_spin_unlock (& sync_lock);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/tsc_sync.c.ifdefed" startline="99" endline="153">
{
    int cpus = 2;
    if (unsynchronized_tsc ())
        return;
    printk (KERN_INFO "checking TSC synchronization [CPU#%d -> CPU#%d]:", smp_processor_id (), cpu);
    atomic_set (& stop_count, 0);
    while (atomic_read (&start_count) != cpus - 1)
        cpu_relax ();
    atomic_inc (& start_count);
    check_tsc_warp ();
    while (atomic_read (&stop_count) != cpus - 1)
        cpu_relax ();
    atomic_set (& start_count, 0);
    if (nr_warps) {
        printk ("\n");
        printk (KERN_WARNING "Measured %Ld cycles TSC warp between CPUs," " turning off TSC clock.\n", max_warp);
        mark_tsc_unstable ("check_tsc_sync_source failed");
        nr_warps = 0;
        max_warp = 0;
        last_tsc = 0;
    }
    else {
        printk (" passed.\n");
    }
    atomic_inc (& stop_count);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/tsc_sync.c.ifdefed" startline="137" endline="145">
{
    printk ("\n");
    printk (KERN_WARNING "Measured %Ld cycles TSC warp between CPUs," " turning off TSC clock.\n", max_warp);
    mark_tsc_unstable ("check_tsc_sync_source failed");
    nr_warps = 0;
    max_warp = 0;
    last_tsc = 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/tsc_sync.c.ifdefed" startline="145" endline="147">
{
    printk (" passed.\n");
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/tsc_sync.c.ifdefed" startline="159" endline="185">
{
    int cpus = 2;
    if (unsynchronized_tsc ())
        return;
    atomic_inc (& start_count);
    while (atomic_read (&start_count) != cpus)
        cpu_relax ();
    check_tsc_warp ();
    atomic_inc (& stop_count);
    while (atomic_read (&stop_count) != cpus)
        cpu_relax ();
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/msr.c.ifdefed" startline="47" endline="62">
{
    loff_t ret = -EINVAL;
    lock_kernel ();
    switch (orig) {
    case 0 :
        file->f_pos = offset;
        ret = file->f_pos;
        break;
    case 1 :
        file->f_pos += offset;
        ret = file->f_pos;
    }
    unlock_kernel ();
    return ret;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/msr.c.ifdefed" startline="51" endline="59">
{
case 0 :
    file->f_pos = offset;
    ret = file->f_pos;
    break;
case 1 :
    file->f_pos += offset;
    ret = file->f_pos;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/msr.c.ifdefed" startline="66" endline="86">
{
    u32 __user *tmp = (u32 __user *) buf;
    u32 data [2];
    u32 reg = *ppos;
    int cpu = iminor (file->f_path.dentry->d_inode);
    int err;
    if (count % 8)
        return -EINVAL;
    for (; count; count -= 8) {
        err = rdmsr_safe_on_cpu (cpu, reg, &data[0], &data[1]);
        if (err)
            return -EIO;
        if (copy_to_user (tmp, &data, 8))
            return -EFAULT;
        tmp += 2;
    }
    return ((char __user *) tmp) - buf;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/msr.c.ifdefed" startline="76" endline="83">
{
    err = rdmsr_safe_on_cpu (cpu, reg, &data[0], &data[1]);
    if (err)
        return -EIO;
    if (copy_to_user (tmp, &data, 8))
        return -EFAULT;
    tmp += 2;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/msr.c.ifdefed" startline="90" endline="110">
{
    const u32 __user *tmp = (const u32 __user *) buf;
    u32 data [2];
    u32 reg = *ppos;
    int cpu = iminor (file->f_path.dentry->d_inode);
    int err;
    if (count % 8)
        return -EINVAL;
    for (; count; count -= 8) {
        if (copy_from_user (&data, tmp, 8))
            return -EFAULT;
        err = wrmsr_safe_on_cpu (cpu, reg, data[0], data[1]);
        if (err)
            return -EIO;
        tmp += 2;
    }
    return ((char __user *) tmp) - buf;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/msr.c.ifdefed" startline="100" endline="107">
{
    if (copy_from_user (&data, tmp, 8))
        return -EFAULT;
    err = wrmsr_safe_on_cpu (cpu, reg, data[0], data[1]);
    if (err)
        return -EIO;
    tmp += 2;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/msr.c.ifdefed" startline="113" endline="123">
{
    unsigned int cpu = iminor (file->f_path.dentry->d_inode);
    struct cpuinfo_x86 *c = &cpu_data (cpu);
    if (cpu >= NR_CPUS || !cpu_online (cpu))
        return -ENXIO;
    if (!cpu_has (c, X86_FEATURE_MSR))
        return -EIO;
    return 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/msr.c.ifdefed" startline="137" endline="143">
{
    struct device *dev;
    dev = device_create (msr_class, NULL, MKDEV (MSR_MAJOR, cpu), "msr%d", cpu);
    return IS_ERR (dev) ? PTR_ERR (dev) : 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/msr.c.ifdefed" startline="146" endline="148">
{
    device_destroy (msr_class, MKDEV (MSR_MAJOR, cpu));
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/msr.c.ifdefed" startline="152" endline="169">
{
    unsigned int cpu = (unsigned long) hcpu;
    int err = 0;
    switch (action) {
    case CPU_UP_PREPARE :
    case CPU_UP_PREPARE_FROZEN :
        err = msr_device_create (cpu);
        break;
    case CPU_UP_CANCELED :
    case CPU_UP_CANCELED_FROZEN :
    case CPU_DEAD :
    case CPU_DEAD_FROZEN :
        msr_device_destroy (cpu);
        break;
    }
    return err ? NOTIFY_BAD : NOTIFY_OK;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/msr.c.ifdefed" startline="156" endline="167">
{
case CPU_UP_PREPARE :
case CPU_UP_PREPARE_FROZEN :
    err = msr_device_create (cpu);
    break;
case CPU_UP_CANCELED :
case CPU_UP_CANCELED_FROZEN :
case CPU_DEAD :
case CPU_DEAD_FROZEN :
    msr_device_destroy (cpu);
    break;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/msr.c.ifdefed" startline="176" endline="210">
{
    int i, err = 0;
    i = 0;
    if (register_chrdev (MSR_MAJOR, "cpu/msr", &msr_fops)) {
        printk (KERN_ERR "msr: unable to get major %d for msr\n", MSR_MAJOR);
        err = -EBUSY;
        goto out;
    }
    msr_class = class_create (THIS_MODULE, "msr");
    if (IS_ERR (msr_class)) {
        err = PTR_ERR (msr_class);
        goto out_chrdev;
    }

    for_each_online_cpu (i) {
        err = msr_device_create (i);
        if (err != 0)
            goto out_class;
    }

    register_hotcpu_notifier (& msr_class_cpu_notifier);
    err = 0;
    goto out;
out_class :
    i = 0;
    for_each_online_cpu (i)
    msr_device_destroy (i);
    class_destroy (msr_class);
out_chrdev :
    unregister_chrdev (MSR_MAJOR, "cpu/msr");
out :
    return err;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/msr.c.ifdefed" startline="180" endline="185">
{
    printk (KERN_ERR "msr: unable to get major %d for msr\n", MSR_MAJOR);
    err = -EBUSY;
    goto out;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/msr.c.ifdefed" startline="187" endline="190">
{
    err = PTR_ERR (msr_class);
    goto out_chrdev;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/msr.c.ifdefed" startline="191" endline="195">
{
    err = msr_device_create (i);
    if (err != 0)
        goto out_class;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/msr.c.ifdefed" startline="213" endline="220">
{
    int cpu = 0;
    for_each_online_cpu (cpu)
    msr_device_destroy (cpu);
    class_destroy (msr_class);
    unregister_chrdev (MSR_MAJOR, "cpu/msr");
    unregister_hotcpu_notifier (& msr_class_cpu_notifier);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/nmi_64.c.ifdefed" startline="54" endline="58">
{
    if (nmi_watchdog != NMI_DEFAULT)
        return;
    nmi_watchdog = NMI_NONE;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/nmi_64.c.ifdefed" startline="82" endline="137">
{
    int *counts;
    int cpu;
    if ((nmi_watchdog == NMI_NONE) || (nmi_watchdog == NMI_DISABLED))
        return 0;
    if (!atomic_read (&nmi_active))
        return 0;
    counts = kmalloc (NR_CPUS * sizeof (int), GFP_KERNEL);
    if (!counts)
        return -1;
    printk (KERN_INFO "testing NMI watchdog ... ");
    for (cpu = 0; cpu < NR_CPUS; cpu++)
        counts[cpu] = cpu_pda (cpu)->__nmi_count;
    local_irq_enable ();
    mdelay ((20 * 1000) / nmi_hz);

    for_each_online_cpu (cpu) {
        if (!per_cpu (wd_enabled, cpu))
            continue;
        if (cpu_pda (cpu)->__nmi_count - counts[cpu] <= 5) {
            printk (KERN_WARNING "WARNING: CPU#%d: NMI " "appears to be stuck (%d->%d)!\n", cpu, counts [cpu], cpu_pda (cpu) -> __nmi_count);
            per_cpu (wd_enabled, cpu) = 0;
            atomic_dec (& nmi_active);
        }
    }

    if (!atomic_read (&nmi_active)) {
        kfree (counts);
        atomic_set (& nmi_active, - 1);
        endflag = 1;
        return -1;
    }
    endflag = 1;
    printk ("OK.\n");
    if (nmi_watchdog == NMI_LOCAL_APIC)
        nmi_hz = lapic_adjust_nmi_hz (1);
    kfree (counts);
    return 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/nmi_64.c.ifdefed" startline="108" endline="120">
{
    if (!per_cpu (wd_enabled, cpu))
        continue;
    if (cpu_pda (cpu)->__nmi_count - counts[cpu] <= 5) {
        printk (KERN_WARNING "WARNING: CPU#%d: NMI " "appears to be stuck (%d->%d)!\n", cpu, counts [cpu], cpu_pda (cpu) -> __nmi_count);
        per_cpu (wd_enabled, cpu) = 0;
        atomic_dec (& nmi_active);
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/nmi_64.c.ifdefed" startline="111" endline="119">
{
    printk (KERN_WARNING "WARNING: CPU#%d: NMI " "appears to be stuck (%d->%d)!\n", cpu, counts [cpu], cpu_pda (cpu) -> __nmi_count);
    per_cpu (wd_enabled, cpu) = 0;
    atomic_dec (& nmi_active);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/nmi_64.c.ifdefed" startline="121" endline="126">
{
    kfree (counts);
    atomic_set (& nmi_active, - 1);
    endflag = 1;
    return -1;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/nmi_64.c.ifdefed" startline="140" endline="158">
{
    int nmi;
    if (!strncmp (str, "panic", 5)) {
        panic_on_timeout = 1;
        str = strchr (str, ',');
        if (!str)
            return 1;
        ++str;
    }
    get_option (& str, & nmi);
    if ((nmi >= NMI_INVALID) || (nmi < NMI_NONE))
        return 0;
    nmi_watchdog = nmi;
    return 1;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/nmi_64.c.ifdefed" startline="143" endline="149">
{
    panic_on_timeout = 1;
    str = strchr (str, ',');
    if (!str)
        return 1;
    ++str;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/nmi_64.c.ifdefed" startline="164" endline="166">
{
    apic_write (APIC_LVT0, APIC_DM_NMI | APIC_LVT_MASKED);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/nmi_64.c.ifdefed" startline="172" endline="175">
{
    if (atomic_read (&nmi_active) && nmi_watchdog == NMI_IO_APIC)
        on_each_cpu (__acpi_nmi_disable, NULL, 0, 1);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/nmi_64.c.ifdefed" startline="178" endline="180">
{
    apic_write (APIC_LVT0, APIC_DM_NMI);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/nmi_64.c.ifdefed" startline="186" endline="189">
{
    if (atomic_read (&nmi_active) && nmi_watchdog == NMI_IO_APIC)
        on_each_cpu (__acpi_nmi_enable, NULL, 0, 1);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/nmi_64.c.ifdefed" startline="248" endline="269">
{
    if (__get_cpu_var (wd_enabled) == 1)
        return;
    if ((smp_processor_id () != 0) && (atomic_read (&nmi_active) <= 0))
        return;
    switch (nmi_watchdog) {
    case NMI_LOCAL_APIC :
        __get_cpu_var (wd_enabled) = 1;
        if (lapic_watchdog_init (nmi_hz) < 0) {
            __get_cpu_var (wd_enabled) = 0;
            return;
        }
    case NMI_IO_APIC :
        __get_cpu_var (wd_enabled) = 1;
        atomic_inc (& nmi_active);
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/nmi_64.c.ifdefed" startline="257" endline="268">
{
case NMI_LOCAL_APIC :
    __get_cpu_var (wd_enabled) = 1;
    if (lapic_watchdog_init (nmi_hz) < 0) {
        __get_cpu_var (wd_enabled) = 0;
        return;
    }
case NMI_IO_APIC :
    __get_cpu_var (wd_enabled) = 1;
    atomic_inc (& nmi_active);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/nmi_64.c.ifdefed" startline="260" endline="263">
{
    __get_cpu_var (wd_enabled) = 0;
    return;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/nmi_64.c.ifdefed" startline="272" endline="283">
{
    if ((nmi_watchdog != NMI_LOCAL_APIC) && (nmi_watchdog != NMI_IO_APIC))
        return;
    if (__get_cpu_var (wd_enabled) == 0)
        return;
    if (nmi_watchdog == NMI_LOCAL_APIC)
        lapic_watchdog_stop ();
    __get_cpu_var (wd_enabled) = 0;
    atomic_dec (& nmi_active);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/nmi_64.c.ifdefed" startline="299" endline="315">
{
    if (nmi_watchdog > 0) {
        unsigned cpu;

        for_each_present_cpu (cpu) {
            if (per_cpu (nmi_touch, cpu) != 1)
                per_cpu (nmi_touch, cpu) = 1;
        }

    }
    touch_softlockup_watchdog ();
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/nmi_64.c.ifdefed" startline="300" endline="312">
{
    unsigned cpu;

    for_each_present_cpu (cpu) {
        if (per_cpu (nmi_touch, cpu) != 1)
            per_cpu (nmi_touch, cpu) = 1;
    }

}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/nmi_64.c.ifdefed" startline="308" endline="311">
{
    if (per_cpu (nmi_touch, cpu) != 1)
        per_cpu (nmi_touch, cpu) = 1;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/nmi_64.c.ifdefed" startline="318" endline="384">
{
    int sum;
    int touched = 0;
    int cpu = smp_processor_id ();
    int rc = 0;
    if (notify_die (DIE_NMI, "nmi", regs, reason, 2, SIGINT) == NOTIFY_STOP) {
        rc = 1;
        touched = 1;
    }
    sum = read_pda (apic_timer_irqs) + read_pda (irq0_irqs);
    if (__get_cpu_var (nmi_touch)) {
        __get_cpu_var (nmi_touch) = 0;
        touched = 1;
    }
    if (cpu_isset (cpu, backtrace_mask)) {
        static DEFINE_SPINLOCK (lock);
        spin_lock (& lock);
        printk ("NMI backtrace for cpu %d\n", cpu);
        dump_stack ();
        spin_unlock (& lock);
        cpu_clear (cpu, backtrace_mask);
    }
    if (!touched && __get_cpu_var (last_irq_sum) == sum) {
        local_inc (& __get_cpu_var (alert_counter));
        if (local_read (&__get_cpu_var (alert_counter)) == 5 * nmi_hz)
            die_nmi ("NMI Watchdog detected LOCKUP on CPU %d\n", regs, panic_on_timeout);
    }
    else {
        __get_cpu_var (last_irq_sum) = sum;
        local_set (& __get_cpu_var (alert_counter), 0);
    }
    if (!__get_cpu_var (wd_enabled))
        return rc;
    switch (nmi_watchdog) {
    case NMI_LOCAL_APIC :
        rc |= lapic_wd_event (nmi_hz);
        break;
    case NMI_IO_APIC :
        rc = 1;
        break;
    }
    return rc;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/nmi_64.c.ifdefed" startline="326" endline="329">
{
    rc = 1;
    touched = 1;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/nmi_64.c.ifdefed" startline="332" endline="335">
{
    __get_cpu_var (nmi_touch) = 0;
    touched = 1;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/nmi_64.c.ifdefed" startline="337" endline="345">
{
    static DEFINE_SPINLOCK (lock);
    spin_lock (& lock);
    printk ("NMI backtrace for cpu %d\n", cpu);
    dump_stack ();
    spin_unlock (& lock);
    cpu_clear (cpu, backtrace_mask);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/nmi_64.c.ifdefed" startline="354" endline="363">
{
    local_inc (& __get_cpu_var (alert_counter));
    if (local_read (&__get_cpu_var (alert_counter)) == 5 * nmi_hz)
        die_nmi ("NMI Watchdog detected LOCKUP on CPU %d\n", regs, panic_on_timeout);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/nmi_64.c.ifdefed" startline="363" endline="366">
{
    __get_cpu_var (last_irq_sum) = sum;
    local_set (& __get_cpu_var (alert_counter), 0);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/nmi_64.c.ifdefed" startline="371" endline="382">
{
case NMI_LOCAL_APIC :
    rc |= lapic_wd_event (nmi_hz);
    break;
case NMI_IO_APIC :
    rc = 1;
    break;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/nmi_64.c.ifdefed" startline="389" endline="395">
{
    nmi_enter ();
    add_pda (__nmi_count, 1);
    if (!ignore_nmis)
        default_do_nmi (regs);
    nmi_exit ();
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/nmi_64.c.ifdefed" startline="398" endline="404">
{
    return 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/nmi_64.c.ifdefed" startline="407" endline="410">
{
    acpi_nmi_disable ();
    ignore_nmis++;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/nmi_64.c.ifdefed" startline="413" endline="416">
{
    ignore_nmis--;
    acpi_nmi_enable ();
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/nmi_64.c.ifdefed" startline="468" endline="478">
{
    int i;
    backtrace_mask = cpu_online_map;
    for (i = 0; i < 10 * 1000; i++) {
        if (cpus_empty (backtrace_mask))
            break;
        mdelay (1);
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/nmi_64.c.ifdefed" startline="473" endline="477">
{
    if (cpus_empty (backtrace_mask))
        break;
    mdelay (1);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/early-quirks.c.ifdefed" startline="25" endline="35">
{
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/early-quirks.c.ifdefed" startline="48" endline="73">
{
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/early-quirks.c.ifdefed" startline="76" endline="84">
{
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/early-quirks.c.ifdefed" startline="99" endline="138">
{
    int num, slot, func;
    if (!early_pci_allowed ())
        return;
    for (num = 0; num < 32; num++) {
        for (slot = 0; slot < 32; slot++) {
            for (func = 0; func < 8; func++) {
                u32 class;
                u32 vendor;
                u8 type;
                int i;
                class = read_pci_config (num, slot, func, PCI_CLASS_REVISION);
                if (class == 0xffffffff)
                    break;
                if ((class >> 16) != PCI_CLASS_BRIDGE_PCI)
                    continue;
                vendor = read_pci_config (num, slot, func, PCI_VENDOR_ID);
                vendor &= 0xffff;
                for (i = 0; early_qrk[i].f; i++)
                    if (early_qrk[i].vendor == vendor) {
                        early_qrk[i].f ();
                        return;
                    }
                type = read_pci_config_byte (num, slot, func, PCI_HEADER_TYPE);
                if (!(type & 0x80))
                    break;
            }
        }
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/early-quirks.c.ifdefed" startline="106" endline="137">
{
    for (slot = 0; slot < 32; slot++) {
        for (func = 0; func < 8; func++) {
            u32 class;
            u32 vendor;
            u8 type;
            int i;
            class = read_pci_config (num, slot, func, PCI_CLASS_REVISION);
            if (class == 0xffffffff)
                break;
            if ((class >> 16) != PCI_CLASS_BRIDGE_PCI)
                continue;
            vendor = read_pci_config (num, slot, func, PCI_VENDOR_ID);
            vendor &= 0xffff;
            for (i = 0; early_qrk[i].f; i++)
                if (early_qrk[i].vendor == vendor) {
                    early_qrk[i].f ();
                    return;
                }
            type = read_pci_config_byte (num, slot, func, PCI_HEADER_TYPE);
            if (!(type & 0x80))
                break;
        }
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/early-quirks.c.ifdefed" startline="107" endline="136">
{
    for (func = 0; func < 8; func++) {
        u32 class;
        u32 vendor;
        u8 type;
        int i;
        class = read_pci_config (num, slot, func, PCI_CLASS_REVISION);
        if (class == 0xffffffff)
            break;
        if ((class >> 16) != PCI_CLASS_BRIDGE_PCI)
            continue;
        vendor = read_pci_config (num, slot, func, PCI_VENDOR_ID);
        vendor &= 0xffff;
        for (i = 0; early_qrk[i].f; i++)
            if (early_qrk[i].vendor == vendor) {
                early_qrk[i].f ();
                return;
            }
        type = read_pci_config_byte (num, slot, func, PCI_HEADER_TYPE);
        if (!(type & 0x80))
            break;
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/early-quirks.c.ifdefed" startline="108" endline="135">
{
    u32 class;
    u32 vendor;
    u8 type;
    int i;
    class = read_pci_config (num, slot, func, PCI_CLASS_REVISION);
    if (class == 0xffffffff)
        break;
    if ((class >> 16) != PCI_CLASS_BRIDGE_PCI)
        continue;
    vendor = read_pci_config (num, slot, func, PCI_VENDOR_ID);
    vendor &= 0xffff;
    for (i = 0; early_qrk[i].f; i++)
        if (early_qrk[i].vendor == vendor) {
            early_qrk[i].f ();
            return;
        }
    type = read_pci_config_byte (num, slot, func, PCI_HEADER_TYPE);
    if (!(type & 0x80))
        break;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/early-quirks.c.ifdefed" startline="126" endline="129">
{
    early_qrk[i].f ();
    return;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/bootflag.c.ifdefed" startline="29" endline="39">
{
    int x = 0;
    int i;
    for (i = 0; i < 8; i++) {
        x ^= (v & 1);
        v >>= 1;
    }
    return x;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/bootflag.c.ifdefed" startline="34" endline="37">
{
    x ^= (v & 1);
    v >>= 1;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/bootflag.c.ifdefed" startline="42" endline="56">
{
    unsigned long flags;
    if (sbf_port != -1) {
        v &= ~SBF_PARITY;
        if (!parity (v))
            v |= SBF_PARITY;
        printk (KERN_INFO "Simple Boot Flag at 0x%x set to 0x%x\n", sbf_port, v);
        spin_lock_irqsave (& rtc_lock, flags);
        CMOS_WRITE (v, sbf_port);
        spin_unlock_irqrestore (& rtc_lock, flags);
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/bootflag.c.ifdefed" startline="45" endline="55">
{
    v &= ~SBF_PARITY;
    if (!parity (v))
        v |= SBF_PARITY;
    printk (KERN_INFO "Simple Boot Flag at 0x%x set to 0x%x\n", sbf_port, v);
    spin_lock_irqsave (& rtc_lock, flags);
    CMOS_WRITE (v, sbf_port);
    spin_unlock_irqrestore (& rtc_lock, flags);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/bootflag.c.ifdefed" startline="59" endline="68">
{
    u8 v;
    unsigned long flags;
    if (sbf_port == -1)
        return 0;
    spin_lock_irqsave (& rtc_lock, flags);
    v = CMOS_READ (sbf_port);
    spin_unlock_irqrestore (& rtc_lock, flags);
    return v;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/bootflag.c.ifdefed" startline="71" endline="77">
{
    if (v & SBF_RESERVED)
        return 0;
    if (!parity (v))
        return 0;
    return 1;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/bootflag.c.ifdefed" startline="80" endline="96">
{
    u8 v;
    if (sbf_port == -1)
        return 0;
    v = sbf_read ();
    if (!sbf_value_valid (v))
        printk (KERN_WARNING "Simple Boot Flag value 0x%x read from CMOS RAM was invalid\n", v);
    v &= ~SBF_RESERVED;
    v &= ~SBF_BOOTING;
    v &= ~SBF_DIAG;
    sbf_write (v);
    return 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/aperture_64.c.ifdefed" startline="43" endline="47">
{
    gart_resource.start = aper_base;
    gart_resource.end = aper_base + aper_size - 1;
    insert_resource (& iomem_resource, & gart_resource);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/aperture_64.c.ifdefed" startline="53" endline="79">
{
    u32 aper_size;
    void *p;
    if (fallback_aper_order > 7)
        fallback_aper_order = 7;
    aper_size = (32 * 1024 * 1024) << fallback_aper_order;
    p = __alloc_bootmem_nopanic (aper_size, aper_size, 0);
    if (!p || __pa (p) + aper_size > 0xffffffff) {
        printk ("Cannot allocate aperture memory hole (%p,%uK)\n", p, aper_size >> 10);
        if (p)
            free_bootmem (__pa (p), aper_size);
        return 0;
    }
    printk ("Mapping aperture over %d KB of RAM @ %lx\n", aper_size >> 10, __pa (p));
    insert_aperture_resource ((u32) __pa (p), aper_size);
    return (u32) __pa (p);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/aperture_64.c.ifdefed" startline="68" endline="74">
{
    printk ("Cannot allocate aperture memory hole (%p,%uK)\n", p, aper_size >> 10);
    if (p)
        free_bootmem (__pa (p), aper_size);
    return 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/aperture_64.c.ifdefed" startline="82" endline="98">
{
    if (!aper_base)
        return 0;
    if (aper_size < 64 * 1024 * 1024) {
        printk ("Aperture too small (%d MB)\n", aper_size >> 20);
        return 0;
    }
    if (aper_base + aper_size > 0x100000000UL) {
        printk ("Aperture beyond 4GB. Ignoring.\n");
        return 0;
    }
    if (e820_any_mapped (aper_base, aper_base +aper_size, E820_RAM)) {
        printk ("Aperture pointing to e820 RAM. Ignoring.\n");
        return 0;
    }
    return 1;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/aperture_64.c.ifdefed" startline="85" endline="88">
{
    printk ("Aperture too small (%d MB)\n", aper_size >> 20);
    return 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/aperture_64.c.ifdefed" startline="89" endline="92">
{
    printk ("Aperture beyond 4GB. Ignoring.\n");
    return 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/aperture_64.c.ifdefed" startline="93" endline="96">
{
    printk ("Aperture pointing to e820 RAM. Ignoring.\n");
    return 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/aperture_64.c.ifdefed" startline="102" endline="119">
{
    u8 pos;
    int bytes;
    if (!(read_pci_config_16 (num, slot, func, PCI_STATUS) & PCI_STATUS_CAP_LIST))
        return 0;
    pos = read_pci_config_byte (num, slot, func, PCI_CAPABILITY_LIST);
    for (bytes = 0; bytes < 48 && pos >= 0x40; bytes++) {
        u8 id;
        pos &= ~3;
        id = read_pci_config_byte (num, slot, func, pos +PCI_CAP_LIST_ID);
        if (id == 0xff)
            break;
        if (id == cap)
            return pos;
        pos = read_pci_config_byte (num, slot, func, pos +PCI_CAP_LIST_NEXT);
    }
    return 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/aperture_64.c.ifdefed" startline="108" endline="117">
{
    u8 id;
    pos &= ~3;
    id = read_pci_config_byte (num, slot, func, pos +PCI_CAP_LIST_ID);
    if (id == 0xff)
        break;
    if (id == cap)
        return pos;
    pos = read_pci_config_byte (num, slot, func, pos +PCI_CAP_LIST_NEXT);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/aperture_64.c.ifdefed" startline="123" endline="156">
{
    u32 apsize;
    u32 apsizereg;
    int nbits;
    u32 aper_low, aper_hi;
    u64 aper;
    printk ("AGP bridge at %02x:%02x:%02x\n", num, slot, func);
    apsizereg = read_pci_config_16 (num, slot, func, cap +0x14);
    if (apsizereg == 0xffffffff) {
        printk ("APSIZE in AGP bridge unreadable\n");
        return 0;
    }
    apsize = apsizereg & 0xfff;
    if (apsize & 0xff)
        apsize |= 0xf00;
    nbits = hweight16 (apsize);
    *order = 7 - nbits;
    if ((int) *order < 0)
        *order = 0;
    aper_low = read_pci_config (num, slot, func, 0x10);
    aper_hi = read_pci_config (num, slot, func, 0x14);
    aper = (aper_low & ~((1 << 22) - 1)) | ((u64) aper_hi << 32);
    printk ("Aperture from AGP @ %Lx size %u MB (APSIZE %x)\n", aper, 32 << * order, apsizereg);
    if (!aperture_valid (aper, (32 * 1024 * 1024) << *order))
        return 0;
    return (u32) aper;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/aperture_64.c.ifdefed" startline="132" endline="135">
{
    printk ("APSIZE in AGP bridge unreadable\n");
    return 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/aperture_64.c.ifdefed" startline="170" endline="205">
{
    int num, slot, func;
    for (num = 0; num < 256; num++) {
        for (slot = 0; slot < 32; slot++) {
            for (func = 0; func < 8; func++) {
                u32 class, cap;
                u8 type;
                class = read_pci_config (num, slot, func, PCI_CLASS_REVISION);
                if (class == 0xffffffff)
                    break;
                switch (class >> 16) {
                case PCI_CLASS_BRIDGE_HOST :
                case PCI_CLASS_BRIDGE_OTHER :
                    cap = find_cap (num, slot, func, PCI_CAP_ID_AGP);
                    if (!cap)
                        break;
                    *valid_agp = 1;
                    return read_agp (num, slot, func, cap, order);
                }
                type = read_pci_config_byte (num, slot, func, PCI_HEADER_TYPE);
                if (!(type & 0x80))
                    break;
            }
        }
    }
    printk ("No AGP bridge found\n");
    return 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/aperture_64.c.ifdefed" startline="174" endline="202">
{
    for (slot = 0; slot < 32; slot++) {
        for (func = 0; func < 8; func++) {
            u32 class, cap;
            u8 type;
            class = read_pci_config (num, slot, func, PCI_CLASS_REVISION);
            if (class == 0xffffffff)
                break;
            switch (class >> 16) {
            case PCI_CLASS_BRIDGE_HOST :
            case PCI_CLASS_BRIDGE_OTHER :
                cap = find_cap (num, slot, func, PCI_CAP_ID_AGP);
                if (!cap)
                    break;
                *valid_agp = 1;
                return read_agp (num, slot, func, cap, order);
            }
            type = read_pci_config_byte (num, slot, func, PCI_HEADER_TYPE);
            if (!(type & 0x80))
                break;
        }
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/aperture_64.c.ifdefed" startline="175" endline="201">
{
    for (func = 0; func < 8; func++) {
        u32 class, cap;
        u8 type;
        class = read_pci_config (num, slot, func, PCI_CLASS_REVISION);
        if (class == 0xffffffff)
            break;
        switch (class >> 16) {
        case PCI_CLASS_BRIDGE_HOST :
        case PCI_CLASS_BRIDGE_OTHER :
            cap = find_cap (num, slot, func, PCI_CAP_ID_AGP);
            if (!cap)
                break;
            *valid_agp = 1;
            return read_agp (num, slot, func, cap, order);
        }
        type = read_pci_config_byte (num, slot, func, PCI_HEADER_TYPE);
        if (!(type & 0x80))
            break;
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/aperture_64.c.ifdefed" startline="176" endline="200">
{
    u32 class, cap;
    u8 type;
    class = read_pci_config (num, slot, func, PCI_CLASS_REVISION);
    if (class == 0xffffffff)
        break;
    switch (class >> 16) {
    case PCI_CLASS_BRIDGE_HOST :
    case PCI_CLASS_BRIDGE_OTHER :
        cap = find_cap (num, slot, func, PCI_CAP_ID_AGP);
        if (!cap)
            break;
        *valid_agp = 1;
        return read_agp (num, slot, func, cap, order);
    }
    type = read_pci_config_byte (num, slot, func, PCI_HEADER_TYPE);
    if (!(type & 0x80))
        break;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/aperture_64.c.ifdefed" startline="184" endline="193">
{
case PCI_CLASS_BRIDGE_HOST :
case PCI_CLASS_BRIDGE_OTHER :
    cap = find_cap (num, slot, func, PCI_CAP_ID_AGP);
    if (!cap)
        break;
    *valid_agp = 1;
    return read_agp (num, slot, func, cap, order);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/aperture_64.c.ifdefed" startline="208" endline="299">
{
    int fix, num;
    u32 aper_size, aper_alloc = 0, aper_order = 0, last_aper_order = 0;
    u64 aper_base, last_aper_base = 0;
    int valid_agp = 0;
    if (gart_iommu_aperture_disabled || !fix_aperture || !early_pci_allowed ())
        return;
    printk (KERN_INFO "Checking aperture...\n");
    fix = 0;
    for (num = 24; num < 32; num++) {
        if (!early_is_k8_nb (read_pci_config (0, num, 3, 0x00)))
            continue;
        iommu_detected = 1;
        gart_iommu_aperture = 1;
        aper_order = (read_pci_config (0, num, 3, 0x90) >> 1) & 7;
        aper_size = (32 * 1024 * 1024) << aper_order;
        aper_base = read_pci_config (0, num, 3, 0x94) & 0x7fff;
        aper_base <<= 25;
        printk ("CPU %d: aperture @ %Lx size %u MB\n", num - 24, aper_base, aper_size >> 20);
        if (!aperture_valid (aper_base, aper_size)) {
            fix = 1;
            break;
        }
        if ((last_aper_order && aper_order != last_aper_order) || (last_aper_base && aper_base != last_aper_base)) {
            fix = 1;
            break;
        }
        last_aper_order = aper_order;
        last_aper_base = aper_base;
    }
    if (!fix && !fallback_aper_force) {
        if (last_aper_base) {
            unsigned long n = (32 * 1024 * 1024) << last_aper_order;
            insert_aperture_resource ((u32) last_aper_base, n);
        }
        return;
    }
    if (!fallback_aper_force)
        aper_alloc = search_agp_bridge (&aper_order, &valid_agp);
    if (aper_alloc) {
    }
    else if (swiotlb && !valid_agp) {
    }
    else if ((!no_iommu && end_pfn > MAX_DMA32_PFN) || force_iommu || valid_agp || fallback_aper_force) {
        printk ("Your BIOS doesn't leave a aperture memory hole\n");
        printk ("Please enable the IOMMU option in the BIOS setup\n");
        printk ("This costs you %d MB of RAM\n", 32 << fallback_aper_order);
        aper_order = fallback_aper_order;
        aper_alloc = allocate_aperture ();
        if (!aper_alloc) {
            panic ("Not enough memory for aperture");
        }
    }
    else {
        return;
    }
    for (num = 24; num < 32; num++) {
        if (!early_is_k8_nb (read_pci_config (0, num, 3, 0x00)))
            continue;
        write_pci_config (0, num, 3, 0x90, aper_order << 1);
        write_pci_config (0, num, 3, 0x94, aper_alloc >> 25);
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/aperture_64.c.ifdefed" startline="221" endline="248">
{
    if (!early_is_k8_nb (read_pci_config (0, num, 3, 0x00)))
        continue;
    iommu_detected = 1;
    gart_iommu_aperture = 1;
    aper_order = (read_pci_config (0, num, 3, 0x90) >> 1) & 7;
    aper_size = (32 * 1024 * 1024) << aper_order;
    aper_base = read_pci_config (0, num, 3, 0x94) & 0x7fff;
    aper_base <<= 25;
    printk ("CPU %d: aperture @ %Lx size %u MB\n", num - 24, aper_base, aper_size >> 20);
    if (!aperture_valid (aper_base, aper_size)) {
        fix = 1;
        break;
    }
    if ((last_aper_order && aper_order != last_aper_order) || (last_aper_base && aper_base != last_aper_base)) {
        fix = 1;
        break;
    }
    last_aper_order = aper_order;
    last_aper_base = aper_base;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/aperture_64.c.ifdefed" startline="236" endline="239">
{
    fix = 1;
    break;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/aperture_64.c.ifdefed" startline="242" endline="245">
{
    fix = 1;
    break;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/aperture_64.c.ifdefed" startline="250" endline="256">
{
    if (last_aper_base) {
        unsigned long n = (32 * 1024 * 1024) << last_aper_order;
        insert_aperture_resource ((u32) last_aper_base, n);
    }
    return;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/aperture_64.c.ifdefed" startline="251" endline="254">
{
    unsigned long n = (32 * 1024 * 1024) << last_aper_order;
    insert_aperture_resource ((u32) last_aper_base, n);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/aperture_64.c.ifdefed" startline="261" endline="263">
{
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/aperture_64.c.ifdefed" startline="263" endline="265">
{
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/aperture_64.c.ifdefed" startline="268" endline="284">
{
    printk ("Your BIOS doesn't leave a aperture memory hole\n");
    printk ("Please enable the IOMMU option in the BIOS setup\n");
    printk ("This costs you %d MB of RAM\n", 32 << fallback_aper_order);
    aper_order = fallback_aper_order;
    aper_alloc = allocate_aperture ();
    if (!aper_alloc) {
        panic ("Not enough memory for aperture");
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/aperture_64.c.ifdefed" startline="276" endline="283">
{
    panic ("Not enough memory for aperture");
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/aperture_64.c.ifdefed" startline="284" endline="286">
{
    return;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/aperture_64.c.ifdefed" startline="289" endline="298">
{
    if (!early_is_k8_nb (read_pci_config (0, num, 3, 0x00)))
        continue;
    write_pci_config (0, num, 3, 0x90, aper_order << 1);
    write_pci_config (0, num, 3, 0x94, aper_alloc >> 25);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/vsyscall_64.c.ifdefed" startline="68" endline="75">
{
    unsigned long flags;
    write_seqlock_irqsave (& vsyscall_gtod_data.lock, flags);
    vsyscall_gtod_data.sys_tz = sys_tz;
    write_sequnlock_irqrestore (& vsyscall_gtod_data.lock, flags);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/vsyscall_64.c.ifdefed" startline="78" endline="92">
{
    unsigned long flags;
    write_seqlock_irqsave (& vsyscall_gtod_data.lock, flags);
    vsyscall_gtod_data.clock.vread = clock->vread;
    vsyscall_gtod_data.clock.cycle_last = clock->cycle_last;
    vsyscall_gtod_data.clock.mask = clock->mask;
    vsyscall_gtod_data.clock.mult = clock->mult;
    vsyscall_gtod_data.clock.shift = clock->shift;
    vsyscall_gtod_data.wall_time_sec = wall_time->tv_sec;
    vsyscall_gtod_data.wall_time_nsec = wall_time->tv_nsec;
    vsyscall_gtod_data.wall_to_monotonic = wall_to_monotonic;
    write_sequnlock_irqrestore (& vsyscall_gtod_data.lock, flags);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/vsyscall_64.c.ifdefed" startline="98" endline="100">
{
    *tz = __vsyscall_gtod_data.sys_tz;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/vsyscall_64.c.ifdefed" startline="103" endline="110">
{
    int ret;
    asm volatile ("vsysc2: syscall"
        : "=a" (ret)
        : "0" (__NR_gettimeofday), "D" (tv), "S" (tz)
        : __syscall_clobber
    ) return ret;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/vsyscall_64.c.ifdefed" startline="113" endline="119">
{
    long secs;
    asm volatile ("vsysc1: syscall"
        : "=a" (secs)
        : "0" (__NR_time), "D" (t)
        : __syscall_clobber
    ) return secs;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/vsyscall_64.c.ifdefed" startline="122" endline="155">
{
    cycle_t now, base, mask, cycle_delta;
    unsigned seq;
    unsigned long mult, shift, nsec;
    cycle_t (*vread) (void);
    do {
        seq = read_seqbegin (&__vsyscall_gtod_data.lock);
        vread = __vsyscall_gtod_data.clock.vread;
        if (unlikely (!__vsyscall_gtod_data.sysctl_enabled || !vread)) {
            gettimeofday (tv, NULL);
            return;
        }
        now = vread ();
        base = __vsyscall_gtod_data.clock.cycle_last;
        mask = __vsyscall_gtod_data.clock.mask;
        mult = __vsyscall_gtod_data.clock.mult;
        shift = __vsyscall_gtod_data.clock.shift;
        tv->tv_sec = __vsyscall_gtod_data.wall_time_sec;
        nsec = __vsyscall_gtod_data.wall_time_nsec;
    }
    while (read_seqretry (&__vsyscall_gtod_data.lock, seq));
    cycle_delta = (now - base) & mask;
    nsec += (cycle_delta * mult) >> shift;
    while (nsec >= NSEC_PER_SEC) {
        tv->tv_sec += 1;
        nsec -= NSEC_PER_SEC;
    }
    tv->tv_usec = nsec / NSEC_PER_USEC;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/vsyscall_64.c.ifdefed" startline="127" endline="143">
{
    seq = read_seqbegin (&__vsyscall_gtod_data.lock);
    vread = __vsyscall_gtod_data.clock.vread;
    if (unlikely (!__vsyscall_gtod_data.sysctl_enabled || !vread)) {
        gettimeofday (tv, NULL);
        return;
    }
    now = vread ();
    base = __vsyscall_gtod_data.clock.cycle_last;
    mask = __vsyscall_gtod_data.clock.mask;
    mult = __vsyscall_gtod_data.clock.mult;
    shift = __vsyscall_gtod_data.clock.shift;
    tv->tv_sec = __vsyscall_gtod_data.wall_time_sec;
    nsec = __vsyscall_gtod_data.wall_time_nsec;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/vsyscall_64.c.ifdefed" startline="131" endline="134">
{
    gettimeofday (tv, NULL);
    return;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/vsyscall_64.c.ifdefed" startline="150" endline="153">
{
    tv->tv_sec += 1;
    nsec -= NSEC_PER_SEC;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/vsyscall_64.c.ifdefed" startline="158" endline="164">
{
    if (tv)
        do_vgettimeofday (tv);
    if (tz)
        do_get_tz (tz);
    return 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/vsyscall_64.c.ifdefed" startline="169" endline="180">
{
    struct timeval tv;
    time_t result;
    if (unlikely (!__vsyscall_gtod_data.sysctl_enabled))
        return time_syscall (t);
    vgettimeofday (& tv, NULL);
    result = tv.tv_sec;
    if (t)
        *t = result;
    return result;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/vsyscall_64.c.ifdefed" startline="192" endline="222">
{
    unsigned int dummy, p;
    unsigned long j = 0;
    if (tcache && tcache->blob[0] == (j = __jiffies)) {
        p = tcache->blob[1];
    }
    else if (__vgetcpu_mode == VGETCPU_RDTSCP) {
        rdtscp (dummy, dummy, p);
    }
    else {
        asm ("lsl %1,%0"
            : "=r" (p)
            : "r" (__PER_CPU_SEG)
        )}
    if (tcache) {
        tcache->blob[0] = j;
        tcache->blob[1] = p;
    }
    if (cpu)
        *cpu = p & 0xfff;
    if (node)
        *node = p >> 12;
    return 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/vsyscall_64.c.ifdefed" startline="204" endline="206">
{
    p = tcache->blob[1];
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/vsyscall_64.c.ifdefed" startline="206" endline="209">
{
    rdtscp (dummy, dummy, p);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/vsyscall_64.c.ifdefed" startline="209" endline="212">
{
    asm ("lsl %1,%0"
        : "=r" (p)
        : "r" (__PER_CPU_SEG)
    )}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/vsyscall_64.c.ifdefed" startline="213" endline="216">
{
    tcache->blob[0] = j;
    tcache->blob[1] = p;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/vsyscall_64.c.ifdefed" startline="225" endline="227">
{
    return -ENOSYS;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/vsyscall_64.c.ifdefed" startline="288" endline="305">
{
    unsigned long *d;
    unsigned long node = 0;
    if (cpu_has (&cpu_data (cpu), X86_FEATURE_RDTSCP))
        write_rdtscp_aux ((node << 12) | cpu);
    d = (unsigned long *) (cpu_gdt (cpu) + GDT_ENTRY_PER_CPU);
    *d = 0x0f40000000000ULL;
    *d |= cpu;
    *d |= (node & 0xf) << 12;
    *d |= (node >> 4) << 48;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/vsyscall_64.c.ifdefed" startline="308" endline="311">
{
    vsyscall_set_cpu (raw_smp_processor_id ());
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/vsyscall_64.c.ifdefed" startline="315" endline="320">
{
    long cpu = (long) arg;
    if (action == CPU_ONLINE || action == CPU_ONLINE_FROZEN)
        smp_call_function_single (cpu, cpu_vsyscall_init, NULL, 0, 1);
    return NOTIFY_DONE;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/vsyscall_64.c.ifdefed" startline="323" endline="329">
{
    extern char __vsyscall_0;
    unsigned long physaddr_page0 = __pa_symbol (&__vsyscall_0);
    __set_fixmap (VSYSCALL_FIRST_PAGE, physaddr_page0, PAGE_KERNEL_VSYSCALL);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/vsyscall_64.c.ifdefed" startline="332" endline="345">
{
    BUG_ON (((unsigned long) & vgettimeofday != VSYSCALL_ADDR (__NR_vgettimeofday)));
    BUG_ON ((unsigned long) & vtime != VSYSCALL_ADDR (__NR_vtime));
    BUG_ON ((VSYSCALL_ADDR (0) != __fix_to_virt (VSYSCALL_FIRST_PAGE)));
    BUG_ON ((unsigned long) & vgetcpu != VSYSCALL_ADDR (__NR_vgetcpu));
    map_vsyscall ();
    on_each_cpu (cpu_vsyscall_init, NULL, 0, 1);
    hotcpu_notifier (cpu_vsyscall_notifier, 0);
    return 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/signal_64.c.ifdefed" startline="41" endline="43">
{
    return do_sigaltstack (uss, uoss, regs->rsp);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/signal_64.c.ifdefed" startline="59" endline="116">
{
    unsigned int err = 0;
    current_thread_info ()->restart_block.fn = do_no_restart_syscall;
    COPY (rdi);
    COPY (rsi);
    COPY (rbp);
    COPY (rsp);
    COPY (rbx);
    COPY (rdx);
    COPY (rcx);
    COPY (rip);
    COPY (r8);
    COPY (r9);
    COPY (r10);
    COPY (r11);
    COPY (r12);
    COPY (r13);
    COPY (r14);
    COPY (r15);
    {
        unsigned cs;
        err |= __get_user (cs, &sc->cs);
        regs->cs = cs | 3;
    }
    {
        unsigned int tmpflags;
        err |= __get_user (tmpflags, &sc->eflags);
        regs->eflags = (regs->eflags & ~0x40DD5) | (tmpflags & 0x40DD5);
        regs->orig_rax = -1;
    }
    {
        struct _fpstate __user *buf;
        err |= __get_user (buf, &sc->fpstate);
        if (buf) {
            if (!access_ok (VERIFY_READ, buf, sizeof (*buf)))
                goto badframe;
            err |= restore_i387 (buf);
        }
        else {
            struct task_struct *me = current;
            if (used_math ()) {
                clear_fpu (me);
                clear_used_math ();
            }
        }
    }
    err |= __get_user (*prax, &sc->rax);
    return err;
badframe :
    return 1;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/signal_64.c.ifdefed" startline="81" endline="85">
{
    unsigned cs;
    err |= __get_user (cs, &sc->cs);
    regs->cs = cs | 3;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/signal_64.c.ifdefed" startline="87" endline="92">
{
    unsigned int tmpflags;
    err |= __get_user (tmpflags, &sc->eflags);
    regs->eflags = (regs->eflags & ~0x40DD5) | (tmpflags & 0x40DD5);
    regs->orig_rax = -1;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/signal_64.c.ifdefed" startline="94" endline="109">
{
    struct _fpstate __user *buf;
    err |= __get_user (buf, &sc->fpstate);
    if (buf) {
        if (!access_ok (VERIFY_READ, buf, sizeof (*buf)))
            goto badframe;
        err |= restore_i387 (buf);
    }
    else {
        struct task_struct *me = current;
        if (used_math ()) {
            clear_fpu (me);
            clear_used_math ();
        }
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/signal_64.c.ifdefed" startline="98" endline="102">
{
    if (!access_ok (VERIFY_READ, buf, sizeof (*buf)))
        goto badframe;
    err |= restore_i387 (buf);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/signal_64.c.ifdefed" startline="102" endline="108">
{
    struct task_struct *me = current;
    if (used_math ()) {
        clear_fpu (me);
        clear_used_math ();
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/signal_64.c.ifdefed" startline="104" endline="107">
{
    clear_fpu (me);
    clear_used_math ();
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/signal_64.c.ifdefed" startline="119" endline="153">
{
    struct rt_sigframe __user *frame;
    sigset_t set;
    unsigned long eax;
    frame = (struct rt_sigframe __user *) (regs->rsp - 8);
    if (!access_ok (VERIFY_READ, frame, sizeof (*frame))) {
        goto badframe;
    }
    if (__copy_from_user (&set, &frame->uc.uc_sigmask, sizeof (set))) {
        goto badframe;
    }
    sigdelsetmask (& set, ~ _BLOCKABLE);
    spin_lock_irq (& current -> sighand -> siglock);
    current->blocked = set;
    recalc_sigpending ();
    spin_unlock_irq (& current -> sighand -> siglock);
    if (restore_sigcontext (regs, &frame->uc.uc_mcontext, &eax))
        goto badframe;
    if (do_sigaltstack (&frame->uc.uc_stack, NULL, regs->rsp) == -EFAULT)
        goto badframe;
    return eax;
badframe :
    signal_fault (regs, frame, "sigreturn");
    return 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/signal_64.c.ifdefed" startline="125" endline="127">
{
    goto badframe;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/signal_64.c.ifdefed" startline="128" endline="130">
{
    goto badframe;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/signal_64.c.ifdefed" startline="161" endline="192">
{
    int err = 0;
    err |= __put_user (regs->cs, &sc->cs);
    err |= __put_user (0, &sc->gs);
    err |= __put_user (0, &sc->fs);
    err |= __put_user (regs->rdi, &sc->rdi);
    err |= __put_user (regs->rsi, &sc->rsi);
    err |= __put_user (regs->rbp, &sc->rbp);
    err |= __put_user (regs->rsp, &sc->rsp);
    err |= __put_user (regs->rbx, &sc->rbx);
    err |= __put_user (regs->rdx, &sc->rdx);
    err |= __put_user (regs->rcx, &sc->rcx);
    err |= __put_user (regs->rax, &sc->rax);
    err |= __put_user (regs->r8, &sc->r8);
    err |= __put_user (regs->r9, &sc->r9);
    err |= __put_user (regs->r10, &sc->r10);
    err |= __put_user (regs->r11, &sc->r11);
    err |= __put_user (regs->r12, &sc->r12);
    err |= __put_user (regs->r13, &sc->r13);
    err |= __put_user (regs->r14, &sc->r14);
    err |= __put_user (regs->r15, &sc->r15);
    err |= __put_user (me->thread.trap_no, &sc->trapno);
    err |= __put_user (me->thread.error_code, &sc->err);
    err |= __put_user (regs->rip, &sc->rip);
    err |= __put_user (regs->eflags, &sc->eflags);
    err |= __put_user (mask, &sc->oldmask);
    err |= __put_user (me->thread.cr2, &sc->cr2);
    return err;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/signal_64.c.ifdefed" startline="200" endline="213">
{
    unsigned long rsp;
    rsp = regs->rsp - 128;
    if (ka->sa.sa_flags & SA_ONSTACK) {
        if (sas_ss_flags (rsp) == 0)
            rsp = current->sas_ss_sp + current->sas_ss_size;
    }
    return (void __user *) round_down (rsp -size, 16);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/signal_64.c.ifdefed" startline="207" endline="210">
{
    if (sas_ss_flags (rsp) == 0)
        rsp = current->sas_ss_sp + current->sas_ss_size;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/signal_64.c.ifdefed" startline="217" endline="311">
{
    struct rt_sigframe __user *frame;
    struct _fpstate __user *fp = NULL;
    int err = 0;
    struct task_struct *me = current;
    if (used_math ()) {
        fp = get_stack (ka, regs, sizeof (struct _fpstate));
        frame = (void __user *) round_down ((unsigned long) fp - sizeof (struct rt_sigframe), 16) - 8;
        if (!access_ok (VERIFY_WRITE, fp, sizeof (struct _fpstate)))
            goto give_sigsegv;
        if (save_i387 (fp) < 0)
            err |= -1;
    }
    else
        frame = get_stack (ka, regs, sizeof (struct rt_sigframe)) - 8;
    if (!access_ok (VERIFY_WRITE, frame, sizeof (*frame)))
        goto give_sigsegv;
    if (ka->sa.sa_flags & SA_SIGINFO) {
        err |= copy_siginfo_to_user (&frame->info, info);
        if (err)
            goto give_sigsegv;
    }
    err |= __put_user (0, &frame->uc.uc_flags);
    err |= __put_user (0, &frame->uc.uc_link);
    err |= __put_user (me->sas_ss_sp, &frame->uc.uc_stack.ss_sp);
    err |= __put_user (sas_ss_flags (regs->rsp), &frame->uc.uc_stack.ss_flags);
    err |= __put_user (me->sas_ss_size, &frame->uc.uc_stack.ss_size);
    err |= setup_sigcontext (&frame->uc.uc_mcontext, regs, set->sig[0], me);
    err |= __put_user (fp, &frame->uc.uc_mcontext.fpstate);
    if (sizeof (*set) == 16) {
        __put_user (set -> sig [0], & frame -> uc.uc_sigmask.sig [0]);
        __put_user (set -> sig [1], & frame -> uc.uc_sigmask.sig [1]);
    }
    else
        err |= __copy_to_user (&frame->uc.uc_sigmask, set, sizeof (*set));
    if (ka->sa.sa_flags & SA_RESTORER) {
        err |= __put_user (ka->sa.sa_restorer, &frame->pretcode);
    }
    else {
        goto give_sigsegv;
    }
    if (err)
        goto give_sigsegv;
    regs->rdi = sig;
    regs->rax = 0;
    regs->rsi = (unsigned long) &frame->info;
    regs->rdx = (unsigned long) &frame->uc;
    regs->rip = (unsigned long) ka->sa.sa_handler;
    regs->rsp = (unsigned long) frame;
    regs->cs = __USER_CS;
    set_fs (USER_DS);
    regs->eflags &= ~TF_MASK;
    if (test_thread_flag (TIF_SINGLESTEP))
        ptrace_notify (SIGTRAP);
    return 0;
give_sigsegv :
    force_sigsegv (sig, current);
    return -EFAULT;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/signal_64.c.ifdefed" startline="223" endline="233">
{
    fp = get_stack (ka, regs, sizeof (struct _fpstate));
    frame = (void __user *) round_down ((unsigned long) fp - sizeof (struct rt_sigframe), 16) - 8;
    if (!access_ok (VERIFY_WRITE, fp, sizeof (struct _fpstate)))
        goto give_sigsegv;
    if (save_i387 (fp) < 0)
        err |= -1;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/signal_64.c.ifdefed" startline="239" endline="243">
{
    err |= copy_siginfo_to_user (&frame->info, info);
    if (err)
        goto give_sigsegv;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/signal_64.c.ifdefed" startline="254" endline="257">
{
    __put_user (set -> sig [0], & frame -> uc.uc_sigmask.sig [0]);
    __put_user (set -> sig [1], & frame -> uc.uc_sigmask.sig [1]);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/signal_64.c.ifdefed" startline="263" endline="265">
{
    err |= __put_user (ka->sa.sa_restorer, &frame->pretcode);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/signal_64.c.ifdefed" startline="265" endline="268">
{
    goto give_sigsegv;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/signal_64.c.ifdefed" startline="320" endline="383">
{
    int ret;
    if ((long) regs->orig_rax >= 0) {
        switch (regs->rax) {
        case -ERESTART_RESTARTBLOCK :
        case -ERESTARTNOHAND :
            regs->rax = -EINTR;
            break;
        case -ERESTARTSYS :
            if (!(ka->sa.sa_flags & SA_RESTART)) {
                regs->rax = -EINTR;
                break;
            }
        case -ERESTARTNOINTR :
            regs->rax = regs->orig_rax;
            regs->rip -= 2;
            break;
        }
    }
    if (unlikely (regs->eflags & TF_MASK)) {
        if (likely (current->ptrace & PT_DTRACE)) {
            current->ptrace &= ~PT_DTRACE;
            regs->eflags &= ~TF_MASK;
        }
    }
    ret = setup_rt_frame (sig, ka, info, oldset, regs);
    if (ret == 0) {
        spin_lock_irq (& current -> sighand -> siglock);
        sigorsets (& current -> blocked, & current -> blocked, & ka -> sa.sa_mask);
        if (!(ka->sa.sa_flags & SA_NODEFER))
            sigaddset (&current->blocked, sig);
        recalc_sigpending ();
        spin_unlock_irq (& current -> sighand -> siglock);
    }
    return ret;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/signal_64.c.ifdefed" startline="330" endline="349">
{
    switch (regs->rax) {
    case -ERESTART_RESTARTBLOCK :
    case -ERESTARTNOHAND :
        regs->rax = -EINTR;
        break;
    case -ERESTARTSYS :
        if (!(ka->sa.sa_flags & SA_RESTART)) {
            regs->rax = -EINTR;
            break;
        }
    case -ERESTARTNOINTR :
        regs->rax = regs->orig_rax;
        regs->rip -= 2;
        break;
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/signal_64.c.ifdefed" startline="332" endline="348">
{
case -ERESTART_RESTARTBLOCK :
case -ERESTARTNOHAND :
    regs->rax = -EINTR;
    break;
case -ERESTARTSYS :
    if (!(ka->sa.sa_flags & SA_RESTART)) {
        regs->rax = -EINTR;
        break;
    }
case -ERESTARTNOINTR :
    regs->rax = regs->orig_rax;
    regs->rip -= 2;
    break;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/signal_64.c.ifdefed" startline="339" endline="342">
{
    regs->rax = -EINTR;
    break;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/signal_64.c.ifdefed" startline="356" endline="361">
{
    if (likely (current->ptrace & PT_DTRACE)) {
        current->ptrace &= ~PT_DTRACE;
        regs->eflags &= ~TF_MASK;
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/signal_64.c.ifdefed" startline="357" endline="360">
{
    current->ptrace &= ~PT_DTRACE;
    regs->eflags &= ~TF_MASK;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/signal_64.c.ifdefed" startline="373" endline="380">
{
    spin_lock_irq (& current -> sighand -> siglock);
    sigorsets (& current -> blocked, & current -> blocked, & ka -> sa.sa_mask);
    if (!(ka->sa.sa_flags & SA_NODEFER))
        sigaddset (&current->blocked, sig);
    recalc_sigpending ();
    spin_unlock_irq (& current -> sighand -> siglock);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/signal_64.c.ifdefed" startline="391" endline="458">
{
    struct k_sigaction ka;
    siginfo_t info;
    int signr;
    sigset_t *oldset;
    if (!user_mode (regs))
        return;
    if (test_thread_flag (TIF_RESTORE_SIGMASK))
        oldset = &current->saved_sigmask;
    else
        oldset = &current->blocked;
    signr = get_signal_to_deliver (&info, &ka, regs, NULL);
    if (signr > 0) {
        if (current->thread.debugreg7)
            set_debugreg (current->thread.debugreg7, 7);
        if (handle_signal (signr, &info, &ka, oldset, regs) == 0) {
            clear_thread_flag (TIF_RESTORE_SIGMASK);
        }
        return;
    }
    if ((long) regs->orig_rax >= 0) {
        long res = regs->rax;
        switch (res) {
        case -ERESTARTNOHAND :
        case -ERESTARTSYS :
        case -ERESTARTNOINTR :
            regs->rax = regs->orig_rax;
            regs->rip -= 2;
            break;
        case -ERESTART_RESTARTBLOCK :
            regs->rax = test_thread_flag (TIF_IA32) ? __NR_ia32_restart_syscall : __NR_restart_syscall;
            regs->rip -= 2;
            break;
        }
    }
    if (test_thread_flag (TIF_RESTORE_SIGMASK)) {
        clear_thread_flag (TIF_RESTORE_SIGMASK);
        sigprocmask (SIG_SETMASK, & current -> saved_sigmask, NULL);
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/signal_64.c.ifdefed" startline="412" endline="430">
{
    if (current->thread.debugreg7)
        set_debugreg (current->thread.debugreg7, 7);
    if (handle_signal (signr, &info, &ka, oldset, regs) == 0) {
        clear_thread_flag (TIF_RESTORE_SIGMASK);
    }
    return;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/signal_64.c.ifdefed" startline="422" endline="428">
{
    clear_thread_flag (TIF_RESTORE_SIGMASK);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/signal_64.c.ifdefed" startline="433" endline="450">
{
    long res = regs->rax;
    switch (res) {
    case -ERESTARTNOHAND :
    case -ERESTARTSYS :
    case -ERESTARTNOINTR :
        regs->rax = regs->orig_rax;
        regs->rip -= 2;
        break;
    case -ERESTART_RESTARTBLOCK :
        regs->rax = test_thread_flag (TIF_IA32) ? __NR_ia32_restart_syscall : __NR_restart_syscall;
        regs->rip -= 2;
        break;
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/signal_64.c.ifdefed" startline="436" endline="449">
{
case -ERESTARTNOHAND :
case -ERESTARTSYS :
case -ERESTARTNOINTR :
    regs->rax = regs->orig_rax;
    regs->rip -= 2;
    break;
case -ERESTART_RESTARTBLOCK :
    regs->rax = test_thread_flag (TIF_IA32) ? __NR_ia32_restart_syscall : __NR_restart_syscall;
    regs->rip -= 2;
    break;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/signal_64.c.ifdefed" startline="454" endline="457">
{
    clear_thread_flag (TIF_RESTORE_SIGMASK);
    sigprocmask (SIG_SETMASK, & current -> saved_sigmask, NULL);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/signal_64.c.ifdefed" startline="462" endline="483">
{
    if (thread_info_flags & _TIF_SINGLESTEP) {
        regs->eflags |= TF_MASK;
        clear_thread_flag (TIF_SINGLESTEP);
    }
    if (thread_info_flags & (_TIF_SIGPENDING | _TIF_RESTORE_SIGMASK))
        do_signal (regs);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/signal_64.c.ifdefed" startline="469" endline="472">
{
    regs->eflags |= TF_MASK;
    clear_thread_flag (TIF_SINGLESTEP);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/signal_64.c.ifdefed" startline="486" endline="493">
{
    struct task_struct *me = current;
    if (show_unhandled_signals && printk_ratelimit ())
        printk ("%s[%d] bad frame in %s frame:%p rip:%lx rsp:%lx orax:%lx\n", me->comm, me->pid, where, frame, regs->rip, regs->rsp, regs->orig_rax);
    force_sig (SIGSEGV, me);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/setup64.c.ifdefed" startline="49" endline="60">
{
    if (!str)
        return -EINVAL;
    if (!strncmp (str, "on", 2)) {
        __supported_pte_mask |= _PAGE_NX;
        do_not_nx = 0;
    }
    else if (!strncmp (str, "off", 3)) {
        do_not_nx = 1;
        __supported_pte_mask &= ~_PAGE_NX;
    }
    return 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/setup64.c.ifdefed" startline="52" endline="55">
{
    __supported_pte_mask |= _PAGE_NX;
    do_not_nx = 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/setup64.c.ifdefed" startline="55" endline="58">
{
    do_not_nx = 1;
    __supported_pte_mask &= ~_PAGE_NX;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/setup64.c.ifdefed" startline="73" endline="79">
{
    if (!strcmp (str, "on"))
        force_personality32 &= ~READ_IMPLIES_EXEC;
    else if (!strcmp (str, "off"))
        force_personality32 |= READ_IMPLIES_EXEC;
    return 1;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/setup64.c.ifdefed" startline="88" endline="115">
{
    int i;
    unsigned long size;
    size = PERCPU_ENOUGH_ROOM;
    printk (KERN_INFO "PERCPU: Allocating %lu bytes of per cpu data\n", size);

    for_each_cpu_mask (i, cpu_possible_map) {
        char *ptr;
        if (!NODE_DATA (cpu_to_node (i))) {
            printk ("cpu with no node %d, num_online_nodes %d\n", i, num_online_nodes ());
            ptr = alloc_bootmem_pages (size);
        }
        else {
            ptr = alloc_bootmem_pages_node (NODE_DATA (cpu_to_node (i)), size);
        }
        if (!ptr)
            panic ("Cannot allocate cpu data for CPU %d\n", i);
        cpu_pda (i)->data_offset = ptr - __per_cpu_start;
        memcpy (ptr, __per_cpu_start, __per_cpu_end - __per_cpu_start);
    }

}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/setup64.c.ifdefed" startline="100" endline="114">
{
    char *ptr;
    if (!NODE_DATA (cpu_to_node (i))) {
        printk ("cpu with no node %d, num_online_nodes %d\n", i, num_online_nodes ());
        ptr = alloc_bootmem_pages (size);
    }
    else {
        ptr = alloc_bootmem_pages_node (NODE_DATA (cpu_to_node (i)), size);
    }
    if (!ptr)
        panic ("Cannot allocate cpu data for CPU %d\n", i);
    cpu_pda (i)->data_offset = ptr - __per_cpu_start;
    memcpy (ptr, __per_cpu_start, __per_cpu_end - __per_cpu_start);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/setup64.c.ifdefed" startline="103" endline="107">
{
    printk ("cpu with no node %d, num_online_nodes %d\n", i, num_online_nodes ());
    ptr = alloc_bootmem_pages (size);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/setup64.c.ifdefed" startline="107" endline="109">
{
    ptr = alloc_bootmem_pages_node (NODE_DATA (cpu_to_node (i)), size);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/setup64.c.ifdefed" startline="118" endline="148">
{
    struct x8664_pda *pda = cpu_pda (cpu);
    asm volatile ("movl %0,%%fs ; movl %0,%%gs"
        :
        : "r" (0)
    ) mb ();
    wrmsrl (MSR_GS_BASE, pda);
    mb ();
    pda->cpunumber = cpu;
    pda->irqcount = -1;
    pda->kernelstack = (unsigned long) stack_thread_info () - PDA_STACKOFFSET + THREAD_SIZE;
    pda->active_mm = &init_mm;
    pda->mmu_state = 0;
    if (cpu == 0) {
        pda->pcurrent = &init_task;
        pda->irqstackptr = boot_cpu_stack;
    }
    else {
        pda->irqstackptr = (char *) __get_free_pages (GFP_ATOMIC, IRQSTACK_ORDER);
        if (!pda->irqstackptr)
            panic ("cannot allocate irqstack for cpu %d", cpu);
    }
    pda->irqstackptr += IRQSTACKSIZE - 64;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/setup64.c.ifdefed" startline="135" endline="139">
{
    pda->pcurrent = &init_task;
    pda->irqstackptr = boot_cpu_stack;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/setup64.c.ifdefed" startline="139" endline="144">
{
    pda->irqstackptr = (char *) __get_free_pages (GFP_ATOMIC, IRQSTACK_ORDER);
    if (!pda->irqstackptr)
        panic ("cannot allocate irqstack for cpu %d", cpu);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/setup64.c.ifdefed" startline="157" endline="173">
{
    wrmsrl (MSR_STAR, ((u64) __USER32_CS) << 48 | ((u64) __KERNEL_CS) << 32);
    wrmsrl (MSR_LSTAR, system_call);
    wrmsrl (MSR_CSTAR, ignore_sysret);
    wrmsrl (MSR_SYSCALL_MASK, EF_TF | EF_DF | EF_IE | 0x3000);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/setup64.c.ifdefed" startline="176" endline="183">
{
    unsigned long efer;
    rdmsrl (MSR_EFER, efer);
    if (!(efer & EFER_NX) || do_not_nx) {
        __supported_pte_mask &= ~_PAGE_NX;
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/setup64.c.ifdefed" startline="180" endline="182">
{
    __supported_pte_mask &= ~_PAGE_NX;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/setup64.c.ifdefed" startline="201" endline="295">
{
    int cpu = stack_smp_processor_id ();
    struct tss_struct *t = &per_cpu (init_tss, cpu);
    struct orig_ist *orig_ist = &per_cpu (orig_ist, cpu);
    unsigned long v;
    char *estacks = NULL;
    struct task_struct *me;
    int i;
    if (cpu != 0) {
        pda_init (cpu);
    }
    else
        estacks = boot_exception_stacks;
    me = current;
    if (cpu_test_and_set (cpu, cpu_initialized))
        panic ("CPU#%d already initialized!\n", cpu);
    printk ("Initializing CPU#%d\n", cpu);
    clear_in_cr4 (X86_CR4_VME | X86_CR4_PVI | X86_CR4_TSD | X86_CR4_DE);
    if (cpu)
        memcpy (cpu_gdt (cpu), cpu_gdt_table, GDT_SIZE);
    cpu_gdt_descr[cpu].size = GDT_SIZE;
    load_gdt ((const struct desc_ptr *) & cpu_gdt_descr [cpu]);
    load_idt ((const struct desc_ptr *) & idt_descr);
    memset (me -> thread.tls_array, 0, GDT_ENTRY_TLS_ENTRIES * 8);
    syscall_init ();
    wrmsrl (MSR_FS_BASE, 0);
    wrmsrl (MSR_KERNEL_GS_BASE, 0);
    barrier ();
    check_efer ();
    for (v = 0; v < N_EXCEPTION_STACKS; v++) {
        static const unsigned int order [N_EXCEPTION_STACKS] = {
            [0 ... N_EXCEPTION_STACKS - 1] = EXCEPTION_STACK_ORDER,
            [DEBUG_STACK - 1] = DEBUG_STACK_ORDER
        };
        if (cpu) {
            estacks = (char *) __get_free_pages (GFP_ATOMIC, order[v]);
            if (!estacks)
                panic ("Cannot allocate exception stack %ld %d\n", v, cpu);
        }
        estacks += PAGE_SIZE << order[v];
        orig_ist->ist[v] = t->ist[v] = (unsigned long) estacks;
    }
    t->io_bitmap_base = offsetof (struct tss_struct, io_bitmap);
    for (i = 0; i <= IO_BITMAP_LONGS; i++)
        t->io_bitmap[i] = ~0UL;
    atomic_inc (& init_mm.mm_count);
    me->active_mm = &init_mm;
    if (me->mm)
        BUG ();
    enter_lazy_tlb (& init_mm, me);
    set_tss_desc (cpu, t);
    load_TR_desc ();
    load_LDT (& init_mm.context);
    set_debugreg (0UL, 0);
    set_debugreg (0UL, 1);
    set_debugreg (0UL, 2);
    set_debugreg (0UL, 3);
    set_debugreg (0UL, 6);
    set_debugreg (0UL, 7);
    fpu_init ();
    raw_local_save_flags (kernel_eflags);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/setup64.c.ifdefed" startline="211" endline="213">
{
    pda_init (cpu);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/setup64.c.ifdefed" startline="248" endline="261">
{
    static const unsigned int order [N_EXCEPTION_STACKS] = {
        [0 ... N_EXCEPTION_STACKS - 1] = EXCEPTION_STACK_ORDER,
        [DEBUG_STACK - 1] = DEBUG_STACK_ORDER
    };
    if (cpu) {
        estacks = (char *) __get_free_pages (GFP_ATOMIC, order[v]);
        if (!estacks)
            panic ("Cannot allocate exception stack %ld %d\n", v, cpu);
    }
    estacks += PAGE_SIZE << order[v];
    orig_ist->ist[v] = t->ist[v] = (unsigned long) estacks;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/setup64.c.ifdefed" startline="253" endline="258">
{
    estacks = (char *) __get_free_pages (GFP_ATOMIC, order[v]);
    if (!estacks)
        panic ("Cannot allocate exception stack %ld %d\n", v, cpu);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/i387_64.c.ifdefed" startline="27" endline="36">
{
    unsigned int mask;
    clts ();
    memset (& current -> thread.i387.fxsave, 0, sizeof (struct i387_fxsave_struct));
    asm volatile ("fxsave %0"
        :
        : "m" (current->thread.i387.fxsave)
    ) mask = current->thread.i387.fxsave.mxcsr_mask;
    if (mask == 0)
        mask = 0x0000ffbf;
    mxcsr_feature_mask &= mask;
    stts ();
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/i387_64.c.ifdefed" startline="43" endline="58">
{
    unsigned long oldcr0 = read_cr0 ();
    extern void __bad_fxsave_alignment (void);
    if (offsetof (struct task_struct, thread.i387.fxsave) & 15)
        __bad_fxsave_alignment ();
    set_in_cr4 (X86_CR4_OSFXSR);
    set_in_cr4 (X86_CR4_OSXMMEXCPT);
    write_cr0 (oldcr0 & ~ ((1UL << 3) | (1UL << 2)));
    mxcsr_feature_mask_init ();
    current_thread_info ()->status = 0;
    clear_used_math ();
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/i387_64.c.ifdefed" startline="61" endline="72">
{
    if (tsk_used_math (child)) {
        if (child == current)
            unlazy_fpu (child);
        return;
    }
    memset (& child -> thread.i387.fxsave, 0, sizeof (struct i387_fxsave_struct));
    child->thread.i387.fxsave.cwd = 0x37f;
    child->thread.i387.fxsave.mxcsr = 0x1f80;
    set_stopped_child_used_math (child);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/i387_64.c.ifdefed" startline="62" endline="66">
{
    if (child == current)
        unlazy_fpu (child);
    return;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/i387_64.c.ifdefed" startline="79" endline="103">
{
    struct task_struct *tsk = current;
    int err = 0;
    BUILD_BUG_ON (sizeof (struct user_i387_struct) != sizeof (tsk -> thread.i387.fxsave));
    if ((unsigned long) buf % 16)
        printk ("save_i387: bad fpstate %p\n", buf);
    if (!used_math ())
        return 0;
    clear_used_math ();
    if (task_thread_info (tsk)->status & TS_USEDFPU) {
        err = save_i387_checking ((struct i387_fxsave_struct __user *) buf);
        if (err)
            return err;
        task_thread_info (tsk)->status &= ~TS_USEDFPU;
        stts ();
    }
    else {
        if (__copy_to_user (buf, &tsk->thread.i387.fxsave, sizeof (struct i387_fxsave_struct)))
            return -1;
    }
    return 1;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/i387_64.c.ifdefed" startline="92" endline="97">
{
    err = save_i387_checking ((struct i387_fxsave_struct __user *) buf);
    if (err)
        return err;
    task_thread_info (tsk)->status &= ~TS_USEDFPU;
    stts ();
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/i387_64.c.ifdefed" startline="97" endline="101">
{
    if (__copy_to_user (buf, &tsk->thread.i387.fxsave, sizeof (struct i387_fxsave_struct)))
        return -1;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/i387_64.c.ifdefed" startline="110" endline="114">
{
    init_fpu (tsk);
    return __copy_to_user (buf, &tsk->thread.i387.fxsave, sizeof (struct user_i387_struct)) ? -EFAULT : 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/i387_64.c.ifdefed" startline="117" endline="122">
{
    if (__copy_from_user (&tsk->thread.i387.fxsave, buf, sizeof (struct user_i387_struct)))
        return -EFAULT;
    return 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/i387_64.c.ifdefed" startline="129" endline="138">
{
    struct task_struct *tsk = current;
    if (!used_math ())
        return 0;
    unlazy_fpu (tsk);
    memcpy (fpu, & tsk -> thread.i387.fxsave, sizeof (struct user_i387_struct));
    return 1;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/i387_64.c.ifdefed" startline="141" endline="150">
{
    int fpvalid = !!tsk_used_math (tsk);
    if (fpvalid) {
        if (tsk == current)
            unlazy_fpu (tsk);
        memcpy (fpu, & tsk -> thread.i387.fxsave, sizeof (struct user_i387_struct));
    }
    return fpvalid;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/i387_64.c.ifdefed" startline="144" endline="148">
{
    if (tsk == current)
        unlazy_fpu (tsk);
    memcpy (fpu, & tsk -> thread.i387.fxsave, sizeof (struct user_i387_struct));
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/mpparse_64.c.ifdefed" startline="82" endline="89">
{
    int sum = 0;
    while (len--)
        sum += *mp++;
    return sum & 0xFF;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/mpparse_64.c.ifdefed" startline="92" endline="143">
{
    int cpu;
    cpumask_t tmp_map;
    char *bootup_cpu = "";
    if (!(m->mpc_cpuflag & CPU_ENABLED)) {
        disabled_cpus++;
        return;
    }
    if (m->mpc_cpuflag & CPU_BOOTPROCESSOR) {
        bootup_cpu = " (Bootup-CPU)";
        boot_cpu_id = m->mpc_apicid;
    }
    printk (KERN_INFO "Processor #%d%s\n", m -> mpc_apicid, bootup_cpu);
    if (num_processors >= NR_CPUS) {
        printk (KERN_WARNING "WARNING: NR_CPUS limit of %i reached." " Processor ignored.\n", NR_CPUS);
        return;
    }
    num_processors++;
    cpus_complement (tmp_map, cpu_present_map);
    cpu = first_cpu (tmp_map);
    physid_set (m -> mpc_apicid, phys_cpu_present_map);
    if (m->mpc_cpuflag & CPU_BOOTPROCESSOR) {
        cpu = 0;
    }
    bios_cpu_apicid[cpu] = m->mpc_apicid;
    if (x86_cpu_to_apicid_ptr) {
        u8 *x86_cpu_to_apicid = (u8 *) x86_cpu_to_apicid_ptr;
        x86_cpu_to_apicid[cpu] = m->mpc_apicid;
    }
    else {
        per_cpu (x86_cpu_to_apicid, cpu) = m->mpc_apicid;
    }
    cpu_set (cpu, cpu_possible_map);
    cpu_set (cpu, cpu_present_map);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/mpparse_64.c.ifdefed" startline="97" endline="100">
{
    disabled_cpus++;
    return;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/mpparse_64.c.ifdefed" startline="101" endline="104">
{
    bootup_cpu = " (Bootup-CPU)";
    boot_cpu_id = m->mpc_apicid;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/mpparse_64.c.ifdefed" startline="108" endline="112">
{
    printk (KERN_WARNING "WARNING: NR_CPUS limit of %i reached." " Processor ignored.\n", NR_CPUS);
    return;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/mpparse_64.c.ifdefed" startline="119" endline="126">
{
    cpu = 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/mpparse_64.c.ifdefed" startline="134" endline="137">
{
    u8 *x86_cpu_to_apicid = (u8 *) x86_cpu_to_apicid_ptr;
    x86_cpu_to_apicid[cpu] = m->mpc_apicid;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/mpparse_64.c.ifdefed" startline="137" endline="139">
{
    per_cpu (x86_cpu_to_apicid, cpu) = m->mpc_apicid;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/mpparse_64.c.ifdefed" startline="146" endline="162">
{
    char str [7];
    memcpy (str, m -> mpc_bustype, 6);
    str[6] = 0;
    Dprintk ("Bus #%d is %s\n", m -> mpc_busid, str);
    if (strncmp (str, "ISA", 3) == 0) {
        set_bit (m -> mpc_busid, mp_bus_not_pci);
    }
    else if (strncmp (str, "PCI", 3) == 0) {
        clear_bit (m -> mpc_busid, mp_bus_not_pci);
        mp_bus_id_to_pci_bus[m->mpc_busid] = mp_current_pci_id;
        mp_current_pci_id++;
    }
    else {
        printk (KERN_ERR "Unknown bustype %s\n", str);
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/mpparse_64.c.ifdefed" startline="153" endline="155">
{
    set_bit (m -> mpc_busid, mp_bus_not_pci);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/mpparse_64.c.ifdefed" startline="155" endline="159">
{
    clear_bit (m -> mpc_busid, mp_bus_not_pci);
    mp_bus_id_to_pci_bus[m->mpc_busid] = mp_current_pci_id;
    mp_current_pci_id++;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/mpparse_64.c.ifdefed" startline="159" endline="161">
{
    printk (KERN_ERR "Unknown bustype %s\n", str);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/mpparse_64.c.ifdefed" startline="165" endline="177">
{
    if (nr_ioapics >= MAX_IO_APICS) {
        printk (KERN_ERR "ERROR: Max # of I/O APICs (%d) exceeded " "(found %d)\n", MAX_IO_APICS, nr_ioapics);
        panic ("Recompile kernel with bigger MAX_IO_APICS!\n");
    }
    if (!address) {
        printk (KERN_ERR "WARNING: Bogus (zero) I/O APIC address" " found in table, skipping!\n");
        return 1;
    }
    return 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/mpparse_64.c.ifdefed" startline="166" endline="170">
{
    printk (KERN_ERR "ERROR: Max # of I/O APICs (%d) exceeded " "(found %d)\n", MAX_IO_APICS, nr_ioapics);
    panic ("Recompile kernel with bigger MAX_IO_APICS!\n");
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/mpparse_64.c.ifdefed" startline="171" endline="175">
{
    printk (KERN_ERR "WARNING: Bogus (zero) I/O APIC address" " found in table, skipping!\n");
    return 1;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/mpparse_64.c.ifdefed" startline="180" endline="192">
{
    if (!(m->mpc_flags & MPC_APIC_USABLE))
        return;
    printk ("I/O APIC #%d at 0x%X.\n", m -> mpc_apicid, m -> mpc_apicaddr);
    if (bad_ioapic (m->mpc_apicaddr))
        return;
    mp_ioapics[nr_ioapics] = *m;
    nr_ioapics++;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/mpparse_64.c.ifdefed" startline="195" endline="204">
{
    mp_irqs[mp_irq_entries] = *m;
    Dprintk ("Int: type %d, pol %d, trig %d, bus %d," " IRQ %02x, APIC ID %x, APIC INT %02x\n", m -> mpc_irqtype, m -> mpc_irqflag & 3, (m -> mpc_irqflag >> 2) & 3, m -> mpc_srcbus, m -> mpc_srcbusirq, m -> mpc_dstapic, m -> mpc_dstirq);
    if (++mp_irq_entries >= MAX_IRQ_SOURCES)
        panic ("Max # of irq sources exceeded!!\n");
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/mpparse_64.c.ifdefed" startline="207" endline="213">
{
    Dprintk ("Lint: type %d, pol %d, trig %d, bus %d," " IRQ %02x, APIC ID %x, APIC LINT %02x\n", m -> mpc_irqtype, m -> mpc_irqflag & 3, (m -> mpc_irqflag >> 2) & 3, m -> mpc_srcbusid, m -> mpc_srcbusirq, m -> mpc_destapic, m -> mpc_destapiclint);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/mpparse_64.c.ifdefed" startline="220" endline="318">
{
    char str [16];
    int count = sizeof (*mpc);
    unsigned char *mpt = ((unsigned char *) mpc) + count;
    if (memcmp (mpc->mpc_signature, MPC_SIGNATURE, 4)) {
        printk ("MPTABLE: bad signature [%c%c%c%c]!\n", mpc -> mpc_signature [0], mpc -> mpc_signature [1], mpc -> mpc_signature [2], mpc -> mpc_signature [3]);
        return 0;
    }
    if (mpf_checksum ((unsigned char *) mpc, mpc->mpc_length)) {
        printk ("MPTABLE: checksum error!\n");
        return 0;
    }
    if (mpc->mpc_spec != 0x01 && mpc->mpc_spec != 0x04) {
        printk (KERN_ERR "MPTABLE: bad table version (%d)!!\n", mpc -> mpc_spec);
        return 0;
    }
    if (!mpc->mpc_lapic) {
        printk (KERN_ERR "MPTABLE: null local APIC address!\n");
        return 0;
    }
    memcpy (str, mpc -> mpc_oem, 8);
    str[8] = 0;
    printk (KERN_INFO "MPTABLE: OEM ID: %s ", str);
    memcpy (str, mpc -> mpc_productid, 12);
    str[12] = 0;
    printk ("MPTABLE: Product ID: %s ", str);
    printk ("MPTABLE: APIC at: 0x%X\n", mpc -> mpc_lapic);
    if (!acpi_lapic)
        mp_lapic_addr = mpc->mpc_lapic;
    while (count < mpc->mpc_length) {
        switch (*mpt) {
        case MP_PROCESSOR :
            {
                struct mpc_config_processor *m = (struct mpc_config_processor *) mpt;
                if (!acpi_lapic)
                    MP_processor_info (m);
                mpt += sizeof (*m);
                count += sizeof (*m);
                break;
            }
        case MP_BUS :
            {
                struct mpc_config_bus *m = (struct mpc_config_bus *) mpt;
                MP_bus_info (m);
                mpt += sizeof (*m);
                count += sizeof (*m);
                break;
            }
        case MP_IOAPIC :
            {
                struct mpc_config_ioapic *m = (struct mpc_config_ioapic *) mpt;
                MP_ioapic_info (m);
                mpt += sizeof (*m);
                count += sizeof (*m);
                break;
            }
        case MP_INTSRC :
            {
                struct mpc_config_intsrc *m = (struct mpc_config_intsrc *) mpt;
                MP_intsrc_info (m);
                mpt += sizeof (*m);
                count += sizeof (*m);
                break;
            }
        case MP_LINTSRC :
            {
                struct mpc_config_lintsrc *m = (struct mpc_config_lintsrc *) mpt;
                MP_lintsrc_info (m);
                mpt += sizeof (*m);
                count += sizeof (*m);
                break;
            }
        }
    }
    setup_apic_routing ();
    if (!num_processors)
        printk (KERN_ERR "MPTABLE: no processors registered!\n");
    return num_processors;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/mpparse_64.c.ifdefed" startline="225" endline="232">
{
    printk ("MPTABLE: bad signature [%c%c%c%c]!\n", mpc -> mpc_signature [0], mpc -> mpc_signature [1], mpc -> mpc_signature [2], mpc -> mpc_signature [3]);
    return 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/mpparse_64.c.ifdefed" startline="233" endline="236">
{
    printk ("MPTABLE: checksum error!\n");
    return 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/mpparse_64.c.ifdefed" startline="237" endline="241">
{
    printk (KERN_ERR "MPTABLE: bad table version (%d)!!\n", mpc -> mpc_spec);
    return 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/mpparse_64.c.ifdefed" startline="242" endline="245">
{
    printk (KERN_ERR "MPTABLE: null local APIC address!\n");
    return 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/mpparse_64.c.ifdefed" startline="263" endline="313">
{
    switch (*mpt) {
    case MP_PROCESSOR :
        {
            struct mpc_config_processor *m = (struct mpc_config_processor *) mpt;
            if (!acpi_lapic)
                MP_processor_info (m);
            mpt += sizeof (*m);
            count += sizeof (*m);
            break;
        }
    case MP_BUS :
        {
            struct mpc_config_bus *m = (struct mpc_config_bus *) mpt;
            MP_bus_info (m);
            mpt += sizeof (*m);
            count += sizeof (*m);
            break;
        }
    case MP_IOAPIC :
        {
            struct mpc_config_ioapic *m = (struct mpc_config_ioapic *) mpt;
            MP_ioapic_info (m);
            mpt += sizeof (*m);
            count += sizeof (*m);
            break;
        }
    case MP_INTSRC :
        {
            struct mpc_config_intsrc *m = (struct mpc_config_intsrc *) mpt;
            MP_intsrc_info (m);
            mpt += sizeof (*m);
            count += sizeof (*m);
            break;
        }
    case MP_LINTSRC :
        {
            struct mpc_config_lintsrc *m = (struct mpc_config_lintsrc *) mpt;
            MP_lintsrc_info (m);
            mpt += sizeof (*m);
            count += sizeof (*m);
            break;
        }
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/mpparse_64.c.ifdefed" startline="264" endline="312">
{
case MP_PROCESSOR :
    {
        struct mpc_config_processor *m = (struct mpc_config_processor *) mpt;
        if (!acpi_lapic)
            MP_processor_info (m);
        mpt += sizeof (*m);
        count += sizeof (*m);
        break;
    }
case MP_BUS :
    {
        struct mpc_config_bus *m = (struct mpc_config_bus *) mpt;
        MP_bus_info (m);
        mpt += sizeof (*m);
        count += sizeof (*m);
        break;
    }
case MP_IOAPIC :
    {
        struct mpc_config_ioapic *m = (struct mpc_config_ioapic *) mpt;
        MP_ioapic_info (m);
        mpt += sizeof (*m);
        count += sizeof (*m);
        break;
    }
case MP_INTSRC :
    {
        struct mpc_config_intsrc *m = (struct mpc_config_intsrc *) mpt;
        MP_intsrc_info (m);
        mpt += sizeof (*m);
        count += sizeof (*m);
        break;
    }
case MP_LINTSRC :
    {
        struct mpc_config_lintsrc *m = (struct mpc_config_lintsrc *) mpt;
        MP_lintsrc_info (m);
        mpt += sizeof (*m);
        count += sizeof (*m);
        break;
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/mpparse_64.c.ifdefed" startline="266" endline="274">
{
    struct mpc_config_processor *m = (struct mpc_config_processor *) mpt;
    if (!acpi_lapic)
        MP_processor_info (m);
    mpt += sizeof (*m);
    count += sizeof (*m);
    break;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/mpparse_64.c.ifdefed" startline="276" endline="283">
{
    struct mpc_config_bus *m = (struct mpc_config_bus *) mpt;
    MP_bus_info (m);
    mpt += sizeof (*m);
    count += sizeof (*m);
    break;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/mpparse_64.c.ifdefed" startline="285" endline="292">
{
    struct mpc_config_ioapic *m = (struct mpc_config_ioapic *) mpt;
    MP_ioapic_info (m);
    mpt += sizeof (*m);
    count += sizeof (*m);
    break;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/mpparse_64.c.ifdefed" startline="294" endline="302">
{
    struct mpc_config_intsrc *m = (struct mpc_config_intsrc *) mpt;
    MP_intsrc_info (m);
    mpt += sizeof (*m);
    count += sizeof (*m);
    break;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/mpparse_64.c.ifdefed" startline="304" endline="311">
{
    struct mpc_config_lintsrc *m = (struct mpc_config_lintsrc *) mpt;
    MP_lintsrc_info (m);
    mpt += sizeof (*m);
    count += sizeof (*m);
    break;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/mpparse_64.c.ifdefed" startline="321" endline="326">
{
    unsigned int port;
    port = 0x4d0 + (irq >> 3);
    return (inb (port) >> (irq & 7)) & 1;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/mpparse_64.c.ifdefed" startline="329" endline="392">
{
    struct mpc_config_intsrc intsrc;
    int i;
    int ELCR_fallback = 0;
    intsrc.mpc_type = MP_INTSRC;
    intsrc.mpc_irqflag = 0;
    intsrc.mpc_srcbus = 0;
    intsrc.mpc_dstapic = mp_ioapics[0].mpc_apicid;
    intsrc.mpc_irqtype = mp_INT;
    if (mpc_default_type == 5) {
        printk (KERN_INFO "ISA/PCI bus type with no IRQ information... falling back to ELCR\n");
        if (ELCR_trigger (0) || ELCR_trigger (1) || ELCR_trigger (2) || ELCR_trigger (13))
            printk (KERN_ERR "ELCR contains invalid data... not using ELCR\n");
        else {
            printk (KERN_INFO "Using ELCR to identify PCI interrupts\n");
            ELCR_fallback = 1;
        }
    }
    for (i = 0; i < 16; i++) {
        switch (mpc_default_type) {
        case 2 :
            if (i == 0 || i == 13)
                continue;
        default :
            if (i == 2)
                continue;
        }
        if (ELCR_fallback) {
            if (ELCR_trigger (i))
                intsrc.mpc_irqflag = 13;
            else
                intsrc.mpc_irqflag = 0;
        }
        intsrc.mpc_srcbusirq = i;
        intsrc.mpc_dstirq = i ? i : 2;
        MP_intsrc_info (& intsrc);
    }
    intsrc.mpc_irqtype = mp_ExtINT;
    intsrc.mpc_srcbusirq = 0;
    intsrc.mpc_dstirq = 0;
    MP_intsrc_info (& intsrc);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/mpparse_64.c.ifdefed" startline="349" endline="358">
{
    printk (KERN_INFO "ISA/PCI bus type with no IRQ information... falling back to ELCR\n");
    if (ELCR_trigger (0) || ELCR_trigger (1) || ELCR_trigger (2) || ELCR_trigger (13))
        printk (KERN_ERR "ELCR contains invalid data... not using ELCR\n");
    else {
        printk (KERN_INFO "Using ELCR to identify PCI interrupts\n");
        ELCR_fallback = 1;
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/mpparse_64.c.ifdefed" startline="354" endline="357">
{
    printk (KERN_INFO "Using ELCR to identify PCI interrupts\n");
    ELCR_fallback = 1;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/mpparse_64.c.ifdefed" startline="360" endline="386">
{
    switch (mpc_default_type) {
    case 2 :
        if (i == 0 || i == 13)
            continue;
    default :
        if (i == 2)
            continue;
    }
    if (ELCR_fallback) {
        if (ELCR_trigger (i))
            intsrc.mpc_irqflag = 13;
        else
            intsrc.mpc_irqflag = 0;
    }
    intsrc.mpc_srcbusirq = i;
    intsrc.mpc_dstirq = i ? i : 2;
    MP_intsrc_info (& intsrc);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/mpparse_64.c.ifdefed" startline="361" endline="369">
{
case 2 :
    if (i == 0 || i == 13)
        continue;
default :
    if (i == 2)
        continue;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/mpparse_64.c.ifdefed" startline="371" endline="381">
{
    if (ELCR_trigger (i))
        intsrc.mpc_irqflag = 13;
    else
        intsrc.mpc_irqflag = 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/mpparse_64.c.ifdefed" startline="395" endline="464">
{
    struct mpc_config_processor processor;
    struct mpc_config_bus bus;
    struct mpc_config_ioapic ioapic;
    struct mpc_config_lintsrc lintsrc;
    int linttypes [2] = {mp_ExtINT, mp_NMI};
    int i;
    mp_lapic_addr = APIC_DEFAULT_PHYS_BASE;
    processor.mpc_type = MP_PROCESSOR;
    processor.mpc_apicver = 0;
    processor.mpc_cpuflag = CPU_ENABLED;
    processor.mpc_cpufeature = 0;
    processor.mpc_featureflag = 0;
    processor.mpc_reserved[0] = 0;
    processor.mpc_reserved[1] = 0;
    for (i = 0; i < 2; i++) {
        processor.mpc_apicid = i;
        MP_processor_info (& processor);
    }
    bus.mpc_type = MP_BUS;
    bus.mpc_busid = 0;
    switch (mpc_default_type) {
    default :
        printk (KERN_ERR "???\nUnknown standard configuration %d\n", mpc_default_type);
    case 1 :
    case 5 :
        memcpy (bus.mpc_bustype, "ISA   ", 6);
        break;
    }
    MP_bus_info (& bus);
    if (mpc_default_type > 4) {
        bus.mpc_busid = 1;
        memcpy (bus.mpc_bustype, "PCI   ", 6);
        MP_bus_info (& bus);
    }
    ioapic.mpc_type = MP_IOAPIC;
    ioapic.mpc_apicid = 2;
    ioapic.mpc_apicver = 0;
    ioapic.mpc_flags = MPC_APIC_USABLE;
    ioapic.mpc_apicaddr = 0xFEC00000;
    MP_ioapic_info (& ioapic);
    construct_default_ioirq_mptable (mpc_default_type);
    lintsrc.mpc_type = MP_LINTSRC;
    lintsrc.mpc_irqflag = 0;
    lintsrc.mpc_srcbusid = 0;
    lintsrc.mpc_srcbusirq = 0;
    lintsrc.mpc_destapic = MP_APIC_ALL;
    for (i = 0; i < 2; i++) {
        lintsrc.mpc_irqtype = linttypes[i];
        lintsrc.mpc_destapiclint = i;
        MP_lintsrc_info (& lintsrc);
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/mpparse_64.c.ifdefed" startline="418" endline="421">
{
    processor.mpc_apicid = i;
    MP_processor_info (& processor);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/mpparse_64.c.ifdefed" startline="425" endline="434">
{
default :
    printk (KERN_ERR "???\nUnknown standard configuration %d\n", mpc_default_type);
case 1 :
case 5 :
    memcpy (bus.mpc_bustype, "ISA   ", 6);
    break;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/mpparse_64.c.ifdefed" startline="436" endline="440">
{
    bus.mpc_busid = 1;
    memcpy (bus.mpc_bustype, "PCI   ", 6);
    MP_bus_info (& bus);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/mpparse_64.c.ifdefed" startline="459" endline="463">
{
    lintsrc.mpc_irqtype = linttypes[i];
    lintsrc.mpc_destapiclint = i;
    MP_lintsrc_info (& lintsrc);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/mpparse_64.c.ifdefed" startline="472" endline="533">
{
    struct intel_mp_floating *mpf = mpf_found;
    if (acpi_lapic && acpi_ioapic) {
        printk (KERN_INFO "Using ACPI (MADT) for SMP configuration information\n");
        return;
    }
    else if (acpi_lapic)
        printk (KERN_INFO "Using ACPI for processor (LAPIC) configuration information\n");
    printk ("Intel MultiProcessor Specification v1.%d\n", mpf -> mpf_specification);
    if (mpf->mpf_feature1 != 0) {
        printk (KERN_INFO "Default MP configuration #%d\n", mpf -> mpf_feature1);
        construct_default_ISA_mptable (mpf -> mpf_feature1);
    }
    else if (mpf->mpf_physptr) {
        if (!smp_read_mpc (phys_to_virt (mpf->mpf_physptr))) {
            smp_found_config = 0;
            printk (KERN_ERR "BIOS bug, MP table errors detected!...\n");
            printk (KERN_ERR "... disabling SMP support. (tell your hw vendor)\n");
            return;
        }
        if (!mp_irq_entries) {
            struct mpc_config_bus bus;
            printk (KERN_ERR "BIOS bug, no explicit IRQ entries, using default mptable. (tell your hw vendor)\n");
            bus.mpc_type = MP_BUS;
            bus.mpc_busid = 0;
            memcpy (bus.mpc_bustype, "ISA   ", 6);
            MP_bus_info (& bus);
            construct_default_ioirq_mptable (0);
        }
    }
    else
        BUG ();
    printk (KERN_INFO "Processors: %d\n", num_processors);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/mpparse_64.c.ifdefed" startline="479" endline="482">
{
    printk (KERN_INFO "Using ACPI (MADT) for SMP configuration information\n");
    return;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/mpparse_64.c.ifdefed" startline="491" endline="496">
{
    printk (KERN_INFO "Default MP configuration #%d\n", mpf -> mpf_feature1);
    construct_default_ISA_mptable (mpf -> mpf_feature1);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/mpparse_64.c.ifdefed" startline="496" endline="526">
{
    if (!smp_read_mpc (phys_to_virt (mpf->mpf_physptr))) {
        smp_found_config = 0;
        printk (KERN_ERR "BIOS bug, MP table errors detected!...\n");
        printk (KERN_ERR "... disabling SMP support. (tell your hw vendor)\n");
        return;
    }
    if (!mp_irq_entries) {
        struct mpc_config_bus bus;
        printk (KERN_ERR "BIOS bug, no explicit IRQ entries, using default mptable. (tell your hw vendor)\n");
        bus.mpc_type = MP_BUS;
        bus.mpc_busid = 0;
        memcpy (bus.mpc_bustype, "ISA   ", 6);
        MP_bus_info (& bus);
        construct_default_ioirq_mptable (0);
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/mpparse_64.c.ifdefed" startline="502" endline="507">
{
    smp_found_config = 0;
    printk (KERN_ERR "BIOS bug, MP table errors detected!...\n");
    printk (KERN_ERR "... disabling SMP support. (tell your hw vendor)\n");
    return;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/mpparse_64.c.ifdefed" startline="513" endline="524">
{
    struct mpc_config_bus bus;
    printk (KERN_ERR "BIOS bug, no explicit IRQ entries, using default mptable. (tell your hw vendor)\n");
    bus.mpc_type = MP_BUS;
    bus.mpc_busid = 0;
    memcpy (bus.mpc_bustype, "ISA   ", 6);
    MP_bus_info (& bus);
    construct_default_ioirq_mptable (0);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/mpparse_64.c.ifdefed" startline="536" endline="564">
{
    extern void __bad_mpf_size (void);
    unsigned int *bp = phys_to_virt (base);
    struct intel_mp_floating *mpf;
    Dprintk ("Scan SMP from %p for %ld bytes.\n", bp, length);
    if (sizeof (*mpf) != 16)
        __bad_mpf_size ();
    while (length > 0) {
        mpf = (struct intel_mp_floating *) bp;
        if ((*bp == SMP_MAGIC_IDENT) && (mpf->mpf_length == 1) && !mpf_checksum ((unsigned char *) bp, 16) && ((mpf->mpf_specification == 1) || (mpf->mpf_specification == 4))) {
            smp_found_config = 1;
            reserve_bootmem_generic (virt_to_phys (mpf), PAGE_SIZE);
            if (mpf->mpf_physptr)
                reserve_bootmem_generic (mpf->mpf_physptr, PAGE_SIZE);
            mpf_found = mpf;
            return 1;
        }
        bp += 4;
        length -= 16;
    }
    return 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/mpparse_64.c.ifdefed" startline="545" endline="562">
{
    mpf = (struct intel_mp_floating *) bp;
    if ((*bp == SMP_MAGIC_IDENT) && (mpf->mpf_length == 1) && !mpf_checksum ((unsigned char *) bp, 16) && ((mpf->mpf_specification == 1) || (mpf->mpf_specification == 4))) {
        smp_found_config = 1;
        reserve_bootmem_generic (virt_to_phys (mpf), PAGE_SIZE);
        if (mpf->mpf_physptr)
            reserve_bootmem_generic (mpf->mpf_physptr, PAGE_SIZE);
        mpf_found = mpf;
        return 1;
    }
    bp += 4;
    length -= 16;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/mpparse_64.c.ifdefed" startline="551" endline="559">
{
    smp_found_config = 1;
    reserve_bootmem_generic (virt_to_phys (mpf), PAGE_SIZE);
    if (mpf->mpf_physptr)
        reserve_bootmem_generic (mpf->mpf_physptr, PAGE_SIZE);
    mpf_found = mpf;
    return 1;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/mpparse_64.c.ifdefed" startline="567" endline="602">
{
    unsigned int address;
    if (smp_scan_config (0x0, 0x400) || smp_scan_config (639 * 0x400, 0x400) || smp_scan_config (0xF0000, 0x10000))
        return;
    address = *(unsignedshort*) phys_to_virt (0x40E);
    address <<= 4;
    if (smp_scan_config (address, 0x1000))
        return;
    printk (KERN_INFO "No mptable found.\n");
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/addon_cpuid_features.c.ifdefed" startline="26" endline="50">
{
    u32 max_level;
    u32 regs [4];
    const struct cpuid_bit *cb;
    static const struct cpuid_bit cpuid_bits [] = {{X86_FEATURE_IDA, CR_EAX, 1, 0x00000006}, {0, 0, 0, 0}};
    for (cb = cpuid_bits; cb->feature; cb++) {
        max_level = cpuid_eax (cb->level & 0xffff0000);
        if (max_level < cb->level || max_level > (cb->level | 0xffff))
            continue;
        cpuid (cb -> level, & regs [CR_EAX], & regs [CR_EBX], & regs [CR_ECX], & regs [CR_EDX]);
        if (regs[cb->reg] & (1 << cb->bit))
            set_bit (cb->feature, c->x86_capability);
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/addon_cpuid_features.c.ifdefed" startline="36" endline="49">
{
    max_level = cpuid_eax (cb->level & 0xffff0000);
    if (max_level < cb->level || max_level > (cb->level | 0xffff))
        continue;
    cpuid (cb -> level, & regs [CR_EAX], & regs [CR_EBX], & regs [CR_ECX], & regs [CR_EDX]);
    if (regs[cb->reg] & (1 << cb->bit))
        set_bit (cb->feature, c->x86_capability);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/intel_cacheinfo.c.ifdefed" startline="187" endline="251">
{
    unsigned dummy;
    unsigned line_size, lines_per_tag, assoc, size_in_kb;
    union l1_cache l1i, l1d;
    union l2_cache l2;
    union l3_cache l3;
    union l1_cache *l1 = &l1d;
    eax->full = 0;
    ebx->full = 0;
    ecx->full = 0;
    cpuid (0x80000005, & dummy, & dummy, & l1d.val, & l1i.val);
    cpuid (0x80000006, & dummy, & dummy, & l2.val, & l3.val);
    switch (leaf) {
    case 1 :
        l1 = &l1i;
    case 0 :
        if (!l1->val)
            return;
        assoc = l1->assoc;
        line_size = l1->line_size;
        lines_per_tag = l1->lines_per_tag;
        size_in_kb = l1->size_in_kb;
        break;
    case 2 :
        if (!l2.val)
            return;
        assoc = l2.assoc;
        line_size = l2.line_size;
        lines_per_tag = l2.lines_per_tag;
        size_in_kb = current_cpu_data.x86_cache_size;
        break;
    case 3 :
        if (!l3.val)
            return;
        assoc = l3.assoc;
        line_size = l3.line_size;
        lines_per_tag = l3.lines_per_tag;
        size_in_kb = l3.size_encoded * 512;
        break;
    default :
        return;
    }
    eax->split.is_self_initializing = 1;
    eax->split.type = types[leaf];
    eax->split.level = levels[leaf];
    if (leaf == 3)
        eax->split.num_threads_sharing = current_cpu_data.x86_max_cores - 1;
    else
        eax->split.num_threads_sharing = 0;
    eax->split.num_cores_on_die = current_cpu_data.x86_max_cores - 1;
    if (assoc == 0xf)
        eax->split.is_fully_associative = 1;
    ebx->split.coherency_line_size = line_size - 1;
    ebx->split.ways_of_associativity = assocs[assoc] - 1;
    ebx->split.physical_line_partition = lines_per_tag - 1;
    ecx->split.number_of_sets = (size_in_kb * 1024) / line_size / (ebx->split.ways_of_associativity + 1) - 1;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/intel_cacheinfo.c.ifdefed" startline="202" endline="232">
{
case 1 :
    l1 = &l1i;
case 0 :
    if (!l1->val)
        return;
    assoc = l1->assoc;
    line_size = l1->line_size;
    lines_per_tag = l1->lines_per_tag;
    size_in_kb = l1->size_in_kb;
    break;
case 2 :
    if (!l2.val)
        return;
    assoc = l2.assoc;
    line_size = l2.line_size;
    lines_per_tag = l2.lines_per_tag;
    size_in_kb = current_cpu_data.x86_cache_size;
    break;
case 3 :
    if (!l3.val)
        return;
    assoc = l3.assoc;
    line_size = l3.line_size;
    lines_per_tag = l3.lines_per_tag;
    size_in_kb = l3.size_encoded * 512;
    break;
default :
    return;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/intel_cacheinfo.c.ifdefed" startline="254" endline="275">
{
    union _cpuid4_leaf_eax eax;
    union _cpuid4_leaf_ebx ebx;
    union _cpuid4_leaf_ecx ecx;
    unsigned edx;
    if (boot_cpu_data.x86_vendor == X86_VENDOR_AMD)
        amd_cpuid4 (index, &eax, &ebx, &ecx);
    else
        cpuid_count (4, index, &eax.full, &ebx.full, &ecx.full, &edx);
    if (eax.split.type == CACHE_TYPE_NULL)
        return -EIO;
    this_leaf->eax = eax;
    this_leaf->ebx = ebx;
    this_leaf->ecx = ecx;
    this_leaf->size = (ecx.split.number_of_sets + 1) * (ebx.split.coherency_line_size + 1) * (ebx.split.physical_line_partition + 1) * (ebx.split.ways_of_associativity + 1);
    return 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/intel_cacheinfo.c.ifdefed" startline="278" endline="290">
{
    unsigned int eax, ebx, ecx, edx;
    union _cpuid4_leaf_eax cache_eax;
    int i = -1;
    do {
        ++i;
        cpuid_count (4, i, & eax, & ebx, & ecx, & edx);
        cache_eax.full = eax;
    }
    while (cache_eax.split.type != CACHE_TYPE_NULL);
    return i;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/intel_cacheinfo.c.ifdefed" startline="283" endline="288">
{
    ++i;
    cpuid_count (4, i, & eax, & ebx, & ecx, & edx);
    cache_eax.full = eax;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/intel_cacheinfo.c.ifdefed" startline="293" endline="451">
{
    unsigned int trace = 0, l1i = 0, l1d = 0, l2 = 0, l3 = 0;
    unsigned int new_l1d = 0, new_l1i = 0;
    unsigned int new_l2 = 0, new_l3 = 0, i;
    unsigned int l2_id = 0, l3_id = 0, num_threads_sharing, index_msb;
    if (c->cpuid_level > 3) {
        static int is_initialized;
        if (is_initialized == 0) {
            num_cache_leaves = find_num_cache_leaves ();
            is_initialized++;
        }
        for (i = 0; i < num_cache_leaves; i++) {
            struct _cpuid4_info this_leaf;
            int retval;
            retval = cpuid4_cache_lookup (i, &this_leaf);
            if (retval >= 0) {
                switch (this_leaf.eax.split.level) {
                case 1 :
                    if (this_leaf.eax.split.type == CACHE_TYPE_DATA)
                        new_l1d = this_leaf.size / 1024;
                    else if (this_leaf.eax.split.type == CACHE_TYPE_INST)
                        new_l1i = this_leaf.size / 1024;
                    break;
                case 2 :
                    new_l2 = this_leaf.size / 1024;
                    num_threads_sharing = 1 + this_leaf.eax.split.num_threads_sharing;
                    index_msb = get_count_order (num_threads_sharing);
                    l2_id = c->apicid >> index_msb;
                    break;
                case 3 :
                    new_l3 = this_leaf.size / 1024;
                    num_threads_sharing = 1 + this_leaf.eax.split.num_threads_sharing;
                    index_msb = get_count_order (num_threads_sharing);
                    l3_id = c->apicid >> index_msb;
                    break;
                default :
                    break;
                }
            }
        }
    }
    if ((num_cache_leaves == 0 || c->x86 == 15) && c->cpuid_level > 1) {
        int i, j, n;
        int regs [4];
        unsigned char *dp = (unsigned char *) regs;
        int only_trace = 0;
        if (num_cache_leaves != 0 && c->x86 == 15)
            only_trace = 1;
        n = cpuid_eax (2) & 0xFF;
        for (i = 0; i < n; i++) {
            cpuid (2, & regs [0], & regs [1], & regs [2], & regs [3]);
            for (j = 0; j < 3; j++) {
                if (regs[j] < 0)
                    regs[j] = 0;
            }
            for (j = 1; j < 16; j++) {
                unsigned char des = dp[j];
                unsigned char k = 0;
                while (cache_table[k].descriptor != 0) {
                    if (cache_table[k].descriptor == des) {
                        if (only_trace && cache_table[k].cache_type != LVL_TRACE)
                            break;
                        switch (cache_table[k].cache_type) {
                        case LVL_1_INST :
                            l1i += cache_table[k].size;
                            break;
                        case LVL_1_DATA :
                            l1d += cache_table[k].size;
                            break;
                        case LVL_2 :
                            l2 += cache_table[k].size;
                            break;
                        case LVL_3 :
                            l3 += cache_table[k].size;
                            break;
                        case LVL_TRACE :
                            trace += cache_table[k].size;
                            break;
                        }
                        break;
                    }
                    k++;
                }
            }
        }
    }
    if (new_l1d)
        l1d = new_l1d;
    if (new_l1i)
        l1i = new_l1i;
    if (new_l2) {
        l2 = new_l2;
    }
    if (new_l3) {
        l3 = new_l3;
    }
    if (trace)
        printk (KERN_INFO "CPU: Trace cache: %dK uops", trace);
    else if (l1i)
        printk (KERN_INFO "CPU: L1 I cache: %dK", l1i);
    if (l1d)
        printk (", L1 D cache: %dK\n", l1d);
    else
        printk ("\n");
    if (l2)
        printk (KERN_INFO "CPU: L2 cache: %dK\n", l2);
    if (l3)
        printk (KERN_INFO "CPU: L3 cache: %dK\n", l3);
    c->x86_cache_size = l3 ? l3 : (l2 ? l2 : (l1i + l1d));
    return l2;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/intel_cacheinfo.c.ifdefed" startline="302" endline="348">
{
    static int is_initialized;
    if (is_initialized == 0) {
        num_cache_leaves = find_num_cache_leaves ();
        is_initialized++;
    }
    for (i = 0; i < num_cache_leaves; i++) {
        struct _cpuid4_info this_leaf;
        int retval;
        retval = cpuid4_cache_lookup (i, &this_leaf);
        if (retval >= 0) {
            switch (this_leaf.eax.split.level) {
            case 1 :
                if (this_leaf.eax.split.type == CACHE_TYPE_DATA)
                    new_l1d = this_leaf.size / 1024;
                else if (this_leaf.eax.split.type == CACHE_TYPE_INST)
                    new_l1i = this_leaf.size / 1024;
                break;
            case 2 :
                new_l2 = this_leaf.size / 1024;
                num_threads_sharing = 1 + this_leaf.eax.split.num_threads_sharing;
                index_msb = get_count_order (num_threads_sharing);
                l2_id = c->apicid >> index_msb;
                break;
            case 3 :
                new_l3 = this_leaf.size / 1024;
                num_threads_sharing = 1 + this_leaf.eax.split.num_threads_sharing;
                index_msb = get_count_order (num_threads_sharing);
                l3_id = c->apicid >> index_msb;
                break;
            default :
                break;
            }
        }
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/intel_cacheinfo.c.ifdefed" startline="305" endline="309">
{
    num_cache_leaves = find_num_cache_leaves ();
    is_initialized++;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/intel_cacheinfo.c.ifdefed" startline="315" endline="347">
{
    struct _cpuid4_info this_leaf;
    int retval;
    retval = cpuid4_cache_lookup (i, &this_leaf);
    if (retval >= 0) {
        switch (this_leaf.eax.split.level) {
        case 1 :
            if (this_leaf.eax.split.type == CACHE_TYPE_DATA)
                new_l1d = this_leaf.size / 1024;
            else if (this_leaf.eax.split.type == CACHE_TYPE_INST)
                new_l1i = this_leaf.size / 1024;
            break;
        case 2 :
            new_l2 = this_leaf.size / 1024;
            num_threads_sharing = 1 + this_leaf.eax.split.num_threads_sharing;
            index_msb = get_count_order (num_threads_sharing);
            l2_id = c->apicid >> index_msb;
            break;
        case 3 :
            new_l3 = this_leaf.size / 1024;
            num_threads_sharing = 1 + this_leaf.eax.split.num_threads_sharing;
            index_msb = get_count_order (num_threads_sharing);
            l3_id = c->apicid >> index_msb;
            break;
        default :
            break;
        }
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/intel_cacheinfo.c.ifdefed" startline="321" endline="346">
{
    switch (this_leaf.eax.split.level) {
    case 1 :
        if (this_leaf.eax.split.type == CACHE_TYPE_DATA)
            new_l1d = this_leaf.size / 1024;
        else if (this_leaf.eax.split.type == CACHE_TYPE_INST)
            new_l1i = this_leaf.size / 1024;
        break;
    case 2 :
        new_l2 = this_leaf.size / 1024;
        num_threads_sharing = 1 + this_leaf.eax.split.num_threads_sharing;
        index_msb = get_count_order (num_threads_sharing);
        l2_id = c->apicid >> index_msb;
        break;
    case 3 :
        new_l3 = this_leaf.size / 1024;
        num_threads_sharing = 1 + this_leaf.eax.split.num_threads_sharing;
        index_msb = get_count_order (num_threads_sharing);
        l3_id = c->apicid >> index_msb;
        break;
    default :
        break;
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/intel_cacheinfo.c.ifdefed" startline="322" endline="345">
{
case 1 :
    if (this_leaf.eax.split.type == CACHE_TYPE_DATA)
        new_l1d = this_leaf.size / 1024;
    else if (this_leaf.eax.split.type == CACHE_TYPE_INST)
        new_l1i = this_leaf.size / 1024;
    break;
case 2 :
    new_l2 = this_leaf.size / 1024;
    num_threads_sharing = 1 + this_leaf.eax.split.num_threads_sharing;
    index_msb = get_count_order (num_threads_sharing);
    l2_id = c->apicid >> index_msb;
    break;
case 3 :
    new_l3 = this_leaf.size / 1024;
    num_threads_sharing = 1 + this_leaf.eax.split.num_threads_sharing;
    index_msb = get_count_order (num_threads_sharing);
    l3_id = c->apicid >> index_msb;
    break;
default :
    break;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/intel_cacheinfo.c.ifdefed" startline="353" endline="410">
{
    int i, j, n;
    int regs [4];
    unsigned char *dp = (unsigned char *) regs;
    int only_trace = 0;
    if (num_cache_leaves != 0 && c->x86 == 15)
        only_trace = 1;
    n = cpuid_eax (2) & 0xFF;
    for (i = 0; i < n; i++) {
        cpuid (2, & regs [0], & regs [1], & regs [2], & regs [3]);
        for (j = 0; j < 3; j++) {
            if (regs[j] < 0)
                regs[j] = 0;
        }
        for (j = 1; j < 16; j++) {
            unsigned char des = dp[j];
            unsigned char k = 0;
            while (cache_table[k].descriptor != 0) {
                if (cache_table[k].descriptor == des) {
                    if (only_trace && cache_table[k].cache_type != LVL_TRACE)
                        break;
                    switch (cache_table[k].cache_type) {
                    case LVL_1_INST :
                        l1i += cache_table[k].size;
                        break;
                    case LVL_1_DATA :
                        l1d += cache_table[k].size;
                        break;
                    case LVL_2 :
                        l2 += cache_table[k].size;
                        break;
                    case LVL_3 :
                        l3 += cache_table[k].size;
                        break;
                    case LVL_TRACE :
                        trace += cache_table[k].size;
                        break;
                    }
                    break;
                }
                k++;
            }
        }
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/intel_cacheinfo.c.ifdefed" startline="366" endline="409">
{
    cpuid (2, & regs [0], & regs [1], & regs [2], & regs [3]);
    for (j = 0; j < 3; j++) {
        if (regs[j] < 0)
            regs[j] = 0;
    }
    for (j = 1; j < 16; j++) {
        unsigned char des = dp[j];
        unsigned char k = 0;
        while (cache_table[k].descriptor != 0) {
            if (cache_table[k].descriptor == des) {
                if (only_trace && cache_table[k].cache_type != LVL_TRACE)
                    break;
                switch (cache_table[k].cache_type) {
                case LVL_1_INST :
                    l1i += cache_table[k].size;
                    break;
                case LVL_1_DATA :
                    l1d += cache_table[k].size;
                    break;
                case LVL_2 :
                    l2 += cache_table[k].size;
                    break;
                case LVL_3 :
                    l3 += cache_table[k].size;
                    break;
                case LVL_TRACE :
                    trace += cache_table[k].size;
                    break;
                }
                break;
            }
            k++;
        }
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/intel_cacheinfo.c.ifdefed" startline="370" endline="372">
{
    if (regs[j] < 0)
        regs[j] = 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/intel_cacheinfo.c.ifdefed" startline="375" endline="408">
{
    unsigned char des = dp[j];
    unsigned char k = 0;
    while (cache_table[k].descriptor != 0) {
        if (cache_table[k].descriptor == des) {
            if (only_trace && cache_table[k].cache_type != LVL_TRACE)
                break;
            switch (cache_table[k].cache_type) {
            case LVL_1_INST :
                l1i += cache_table[k].size;
                break;
            case LVL_1_DATA :
                l1d += cache_table[k].size;
                break;
            case LVL_2 :
                l2 += cache_table[k].size;
                break;
            case LVL_3 :
                l3 += cache_table[k].size;
                break;
            case LVL_TRACE :
                trace += cache_table[k].size;
                break;
            }
            break;
        }
        k++;
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/intel_cacheinfo.c.ifdefed" startline="381" endline="407">
{
    if (cache_table[k].descriptor == des) {
        if (only_trace && cache_table[k].cache_type != LVL_TRACE)
            break;
        switch (cache_table[k].cache_type) {
        case LVL_1_INST :
            l1i += cache_table[k].size;
            break;
        case LVL_1_DATA :
            l1d += cache_table[k].size;
            break;
        case LVL_2 :
            l2 += cache_table[k].size;
            break;
        case LVL_3 :
            l3 += cache_table[k].size;
            break;
        case LVL_TRACE :
            trace += cache_table[k].size;
            break;
        }
        break;
    }
    k++;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/intel_cacheinfo.c.ifdefed" startline="382" endline="404">
{
    if (only_trace && cache_table[k].cache_type != LVL_TRACE)
        break;
    switch (cache_table[k].cache_type) {
    case LVL_1_INST :
        l1i += cache_table[k].size;
        break;
    case LVL_1_DATA :
        l1d += cache_table[k].size;
        break;
    case LVL_2 :
        l2 += cache_table[k].size;
        break;
    case LVL_3 :
        l3 += cache_table[k].size;
        break;
    case LVL_TRACE :
        trace += cache_table[k].size;
        break;
    }
    break;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/intel_cacheinfo.c.ifdefed" startline="385" endline="401">
{
case LVL_1_INST :
    l1i += cache_table[k].size;
    break;
case LVL_1_DATA :
    l1d += cache_table[k].size;
    break;
case LVL_2 :
    l2 += cache_table[k].size;
    break;
case LVL_3 :
    l3 += cache_table[k].size;
    break;
case LVL_TRACE :
    trace += cache_table[k].size;
    break;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/intel_cacheinfo.c.ifdefed" startline="418" endline="423">
{
    l2 = new_l2;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/intel_cacheinfo.c.ifdefed" startline="425" endline="430">
{
    l3 = new_l3;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/intel_cacheinfo.c.ifdefed" startline="497" endline="497">
{
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/intel_cacheinfo.c.ifdefed" startline="498" endline="498">
{
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/intel_cacheinfo.c.ifdefed" startline="502" endline="510">
{
    int i;
    for (i = 0; i < num_cache_leaves; i++)
        cache_remove_shared_cpu_map (cpu, i);
    kfree (cpuid4_info [cpu]);
    cpuid4_info[cpu] = NULL;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/intel_cacheinfo.c.ifdefed" startline="513" endline="554">
{
    struct _cpuid4_info *this_leaf;
    unsigned long j;
    int retval;
    cpumask_t oldmask;
    if (num_cache_leaves == 0)
        return -ENOENT;
    cpuid4_info[cpu] = kzalloc (sizeof (struct _cpuid4_info) * num_cache_leaves, GFP_KERNEL);
    if (cpuid4_info[cpu] == NULL)
        return -ENOMEM;
    oldmask = current->cpus_allowed;
    retval = set_cpus_allowed (current, cpumask_of_cpu (cpu));
    if (retval)
        goto out;
    for (j = 0; j < num_cache_leaves; j++) {
        this_leaf = CPUID4_INFO_IDX (cpu, j);
        retval = cpuid4_cache_lookup (j, this_leaf);
        if (unlikely (retval < 0)) {
            int i;
            for (i = 0; i < j; i++)
                cache_remove_shared_cpu_map (cpu, i);
            break;
        }
        cache_shared_cpu_map_setup (cpu, j);
    }
    set_cpus_allowed (current, oldmask);
out :
    if (retval) {
        kfree (cpuid4_info [cpu]);
        cpuid4_info[cpu] = NULL;
    }
    return retval;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/intel_cacheinfo.c.ifdefed" startline="533" endline="544">
{
    this_leaf = CPUID4_INFO_IDX (cpu, j);
    retval = cpuid4_cache_lookup (j, this_leaf);
    if (unlikely (retval < 0)) {
        int i;
        for (i = 0; i < j; i++)
            cache_remove_shared_cpu_map (cpu, i);
        break;
    }
    cache_shared_cpu_map_setup (cpu, j);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/intel_cacheinfo.c.ifdefed" startline="536" endline="542">
{
    int i;
    for (i = 0; i < j; i++)
        cache_remove_shared_cpu_map (cpu, i);
    break;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/intel_cacheinfo.c.ifdefed" startline="548" endline="551">
{
    kfree (cpuid4_info [cpu]);
    cpuid4_info[cpu] = NULL;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/cpufreq/acpi-cpufreq.c.ifdefed" startline="79" endline="87">
{
    struct cpuinfo_x86 *cpu = &cpu_data (cpuid);
    if (cpu->x86_vendor != X86_VENDOR_INTEL || !cpu_has (cpu, X86_FEATURE_EST))
        return 0;
    return 1;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/cpufreq/acpi-cpufreq.c.ifdefed" startline="90" endline="101">
{
    struct acpi_processor_performance *perf;
    int i;
    perf = data->acpi_data;
    for (i = 0; i < perf->state_count; i++) {
        if (value == perf->states[i].status)
            return data->freq_table[i].frequency;
    }
    return 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/cpufreq/acpi-cpufreq.c.ifdefed" startline="96" endline="99">
{
    if (value == perf->states[i].status)
        return data->freq_table[i].frequency;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/cpufreq/acpi-cpufreq.c.ifdefed" startline="104" endline="116">
{
    int i;
    struct acpi_processor_performance *perf;
    msr &= INTEL_MSR_RANGE;
    perf = data->acpi_data;
    for (i = 0; data->freq_table[i].frequency != CPUFREQ_TABLE_END; i++) {
        if (msr == perf->states[data->freq_table[i].index].status)
            return data->freq_table[i].frequency;
    }
    return data->freq_table[0].frequency;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/cpufreq/acpi-cpufreq.c.ifdefed" startline="111" endline="114">
{
    if (msr == perf->states[data->freq_table[i].index].status)
        return data->freq_table[i].frequency;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/cpufreq/acpi-cpufreq.c.ifdefed" startline="119" endline="128">
{
    switch (data->cpu_feature) {
    case SYSTEM_INTEL_MSR_CAPABLE :
        return extract_msr (val, data);
    case SYSTEM_IO_CAPABLE :
        return extract_io (val, data);
    default :
        return 0;
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/cpufreq/acpi-cpufreq.c.ifdefed" startline="120" endline="127">
{
case SYSTEM_INTEL_MSR_CAPABLE :
    return extract_msr (val, data);
case SYSTEM_IO_CAPABLE :
    return extract_io (val, data);
default :
    return 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/cpufreq/acpi-cpufreq.c.ifdefed" startline="152" endline="167">
{
    u32 h;
    switch (cmd->type) {
    case SYSTEM_INTEL_MSR_CAPABLE :
        rdmsr (cmd->addr.msr.reg, cmd->val, h);
        break;
    case SYSTEM_IO_CAPABLE :
        acpi_os_read_port ((acpi_io_address) cmd->addr.io.port, &cmd->val, (u32) cmd->addr.io.bit_width);
        break;
    default :
        break;
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/cpufreq/acpi-cpufreq.c.ifdefed" startline="155" endline="166">
{
case SYSTEM_INTEL_MSR_CAPABLE :
    rdmsr (cmd->addr.msr.reg, cmd->val, h);
    break;
case SYSTEM_IO_CAPABLE :
    acpi_os_read_port ((acpi_io_address) cmd->addr.io.port, &cmd->val, (u32) cmd->addr.io.bit_width);
    break;
default :
    break;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/cpufreq/acpi-cpufreq.c.ifdefed" startline="170" endline="187">
{
    u32 lo, hi;
    switch (cmd->type) {
    case SYSTEM_INTEL_MSR_CAPABLE :
        rdmsr (cmd->addr.msr.reg, lo, hi);
        lo = (lo & ~INTEL_MSR_RANGE) | (cmd->val & INTEL_MSR_RANGE);
        wrmsr (cmd -> addr.msr.reg, lo, hi);
        break;
    case SYSTEM_IO_CAPABLE :
        acpi_os_write_port ((acpi_io_address) cmd->addr.io.port, cmd->val, (u32) cmd->addr.io.bit_width);
        break;
    default :
        break;
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/cpufreq/acpi-cpufreq.c.ifdefed" startline="173" endline="186">
{
case SYSTEM_INTEL_MSR_CAPABLE :
    rdmsr (cmd->addr.msr.reg, lo, hi);
    lo = (lo & ~INTEL_MSR_RANGE) | (cmd->val & INTEL_MSR_RANGE);
    wrmsr (cmd -> addr.msr.reg, lo, hi);
    break;
case SYSTEM_IO_CAPABLE :
    acpi_os_write_port ((acpi_io_address) cmd->addr.io.port, cmd->val, (u32) cmd->addr.io.bit_width);
    break;
default :
    break;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/cpufreq/acpi-cpufreq.c.ifdefed" startline="190" endline="197">
{
    cpumask_t saved_mask = current->cpus_allowed;
    cmd->val = 0;
    set_cpus_allowed (current, cmd -> mask);
    do_drv_read (cmd);
    set_cpus_allowed (current, saved_mask);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/cpufreq/acpi-cpufreq.c.ifdefed" startline="200" endline="211">
{
    cpumask_t saved_mask = current->cpus_allowed;
    unsigned int i;
    for_each_cpu_mask (i, cmd -> mask) {
        set_cpus_allowed (current, cpumask_of_cpu (i)) do_drv_write (cmd)
    } set_cpus_allowed (current, saved_mask)
    return;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/cpufreq/acpi-cpufreq.c.ifdefed" startline="214" endline="243">
{
    struct acpi_processor_performance *perf;
    struct drv_cmd cmd;
    if (unlikely (cpus_empty (mask)))
        return 0;
    switch (drv_data[first_cpu (mask)]->cpu_feature) {
    case SYSTEM_INTEL_MSR_CAPABLE :
        cmd.type = SYSTEM_INTEL_MSR_CAPABLE;
        cmd.addr.msr.reg = MSR_IA32_PERF_STATUS;
        break;
    case SYSTEM_IO_CAPABLE :
        cmd.type = SYSTEM_IO_CAPABLE;
        perf = drv_data[first_cpu (mask)]->acpi_data;
        cmd.addr.io.port = perf->control_register.address;
        cmd.addr.io.bit_width = perf->control_register.bit_width;
        break;
    default :
        return 0;
    }
    cmd.mask = mask;
    drv_read (& cmd);
    dprintk ("get_cur_val = %u\n", cmd.val);
    return cmd.val;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/cpufreq/acpi-cpufreq.c.ifdefed" startline="221" endline="234">
{
case SYSTEM_INTEL_MSR_CAPABLE :
    cmd.type = SYSTEM_INTEL_MSR_CAPABLE;
    cmd.addr.msr.reg = MSR_IA32_PERF_STATUS;
    break;
case SYSTEM_IO_CAPABLE :
    cmd.type = SYSTEM_IO_CAPABLE;
    perf = drv_data[first_cpu (mask)]->acpi_data;
    cmd.addr.io.port = perf->control_register.address;
    cmd.addr.io.bit_width = perf->control_register.bit_width;
    break;
default :
    return 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/cpufreq/acpi-cpufreq.c.ifdefed" startline="259" endline="335">
{
    union {
        struct {
            u32 lo;
            u32 hi;
        } split;
        u64 whole;
    } aperf_cur, mperf_cur;
    cpumask_t saved_mask;
    unsigned int perf_percent;
    unsigned int retval;
    saved_mask = current->cpus_allowed;
    set_cpus_allowed (current, cpumask_of_cpu (cpu));
    if (get_cpu () != cpu) {
        put_cpu ();
        return 0;
    }
    rdmsr (MSR_IA32_APERF, aperf_cur.split.lo, aperf_cur.split.hi);
    rdmsr (MSR_IA32_MPERF, mperf_cur.split.lo, mperf_cur.split.hi);
    wrmsr (MSR_IA32_APERF, 0, 0);
    wrmsr (MSR_IA32_MPERF, 0, 0);
    if (unlikely (((unsigned long) (-1) / 100) < aperf_cur.whole)) {
        int shift_count = 7;
        aperf_cur.whole >>= shift_count;
        mperf_cur.whole >>= shift_count;
    }
    if (aperf_cur.whole && mperf_cur.whole)
        perf_percent = (aperf_cur.whole * 100) / mperf_cur.whole;
    else
        perf_percent = 0;
    retval = drv_data[cpu]->max_freq * perf_percent / 100;
    put_cpu ();
    set_cpus_allowed (current, saved_mask);
    dprintk ("cpu %d: performance percent %d\n", cpu, perf_percent);
    return retval;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/cpufreq/acpi-cpufreq.c.ifdefed" startline="274" endline="278">
{
    put_cpu ();
    return 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/cpufreq/acpi-cpufreq.c.ifdefed" startline="315" endline="319">
{
    int shift_count = 7;
    aperf_cur.whole >>= shift_count;
    mperf_cur.whole >>= shift_count;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/cpufreq/acpi-cpufreq.c.ifdefed" startline="338" endline="353">
{
    struct acpi_cpufreq_data *data = drv_data[cpu];
    unsigned int freq;
    dprintk ("get_cur_freq_on_cpu (%d)\n", cpu);
    if (unlikely (data == NULL || data->acpi_data == NULL || data->freq_table == NULL)) {
        return 0;
    }
    freq = extract_freq (get_cur_val (cpumask_of_cpu (cpu)), data);
    dprintk ("cur freq = %u\n", freq);
    return freq;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/cpufreq/acpi-cpufreq.c.ifdefed" startline="345" endline="347">
{
    return 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/cpufreq/acpi-cpufreq.c.ifdefed" startline="357" endline="368">
{
    unsigned int cur_freq;
    unsigned int i;
    for (i = 0; i < 100; i++) {
        cur_freq = extract_freq (get_cur_val (mask), data);
        if (cur_freq == freq)
            return 1;
        udelay (10);
    }
    return 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/cpufreq/acpi-cpufreq.c.ifdefed" startline="361" endline="366">
{
    cur_freq = extract_freq (get_cur_val (mask), data);
    if (cur_freq == freq)
        return 1;
    udelay (10);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/cpufreq/acpi-cpufreq.c.ifdefed" startline="372" endline="465">
{
    struct acpi_cpufreq_data *data = drv_data[policy->cpu];
    struct acpi_processor_performance *perf;
    struct cpufreq_freqs freqs;
    cpumask_t online_policy_cpus;
    struct drv_cmd cmd;
    unsigned int next_state = 0;
    unsigned int next_perf_state = 0;
    unsigned int i;
    int result = 0;
    dprintk ("acpi_cpufreq_target %d (%d)\n", target_freq, policy -> cpu);
    if (unlikely (data == NULL || data->acpi_data == NULL || data->freq_table == NULL)) {
        return -ENODEV;
    }
    perf = data->acpi_data;
    result = cpufreq_frequency_table_target (policy, data->freq_table, target_freq, relation, &next_state);
    if (unlikely (result))
        return -ENODEV;
    online_policy_cpus = policy->cpus;
    next_perf_state = data->freq_table[next_state].index;
    if (perf->state == next_perf_state) {
        if (unlikely (data->resume)) {
            dprintk ("Called after resume, resetting to P%d\n", next_perf_state);
            data->resume = 0;
        }
        else {
            dprintk ("Already at target state (P%d)\n", next_perf_state);
            return 0;
        }
    }
    switch (data->cpu_feature) {
    case SYSTEM_INTEL_MSR_CAPABLE :
        cmd.type = SYSTEM_INTEL_MSR_CAPABLE;
        cmd.addr.msr.reg = MSR_IA32_PERF_CTL;
        cmd.val = (u32) perf->states[next_perf_state].control;
        break;
    case SYSTEM_IO_CAPABLE :
        cmd.type = SYSTEM_IO_CAPABLE;
        cmd.addr.io.port = perf->control_register.address;
        cmd.addr.io.bit_width = perf->control_register.bit_width;
        cmd.val = (u32) perf->states[next_perf_state].control;
        break;
    default :
        return -ENODEV;
    }
    cpus_clear (cmd.mask);
    if (policy->shared_type != CPUFREQ_SHARED_TYPE_ANY)
        cmd.mask = online_policy_cpus;
    else
        cpu_set (policy->cpu, cmd.mask);
    freqs.old = perf->states[perf->state].core_frequency * 1000;
    freqs.new = data->freq_table[next_state].frequency;
    for_each_cpu_mask (i, cmd.mask) {freqs
        .cpu = i cpufreq_notify_transition (&freqs, CPUFREQ_PRECHANGE)
    } drv_write (&cmd)
    if (acpi_pstate_strict) {
        if (!check_freqs (cmd.mask, freqs.new, data)) {
            dprintk ("acpi_cpufreq_target failed (%d)\n", policy -> cpu);
            return -EAGAIN;
        }
    }
    for_each_cpu_mask (i, cmd.mask) {freqs
        .cpu = i cpufreq_notify_transition (&freqs, CPUFREQ_POSTCHANGE)
    } perf->state
    = next_perf_state;
    return result;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/cpufreq/acpi-cpufreq.c.ifdefed" startline="386" endline="388">
{
    return -ENODEV;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/cpufreq/acpi-cpufreq.c.ifdefed" startline="406" endline="416">
{
    if (unlikely (data->resume)) {
        dprintk ("Called after resume, resetting to P%d\n", next_perf_state);
        data->resume = 0;
    }
    else {
        dprintk ("Already at target state (P%d)\n", next_perf_state);
        return 0;
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/cpufreq/acpi-cpufreq.c.ifdefed" startline="407" endline="411">
{
    dprintk ("Called after resume, resetting to P%d\n", next_perf_state);
    data->resume = 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/cpufreq/acpi-cpufreq.c.ifdefed" startline="411" endline="415">
{
    dprintk ("Already at target state (P%d)\n", next_perf_state);
    return 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/cpufreq/acpi-cpufreq.c.ifdefed" startline="418" endline="432">
{
case SYSTEM_INTEL_MSR_CAPABLE :
    cmd.type = SYSTEM_INTEL_MSR_CAPABLE;
    cmd.addr.msr.reg = MSR_IA32_PERF_CTL;
    cmd.val = (u32) perf->states[next_perf_state].control;
    break;
case SYSTEM_IO_CAPABLE :
    cmd.type = SYSTEM_IO_CAPABLE;
    cmd.addr.io.port = perf->control_register.address;
    cmd.addr.io.bit_width = perf->control_register.bit_width;
    cmd.val = (u32) perf->states[next_perf_state].control;
    break;
default :
    return -ENODEV;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/cpufreq/acpi-cpufreq.c.ifdefed" startline="450" endline="456">
{
    if (!check_freqs (cmd.mask, freqs.new, data)) {
        dprintk ("acpi_cpufreq_target failed (%d)\n", policy -> cpu);
        return -EAGAIN;
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/cpufreq/acpi-cpufreq.c.ifdefed" startline="451" endline="455">
{
    dprintk ("acpi_cpufreq_target failed (%d)\n", policy -> cpu);
    return -EAGAIN;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/cpufreq/acpi-cpufreq.c.ifdefed" startline="468" endline="474">
{
    struct acpi_cpufreq_data *data = drv_data[policy->cpu];
    dprintk ("acpi_cpufreq_verify\n");
    return cpufreq_frequency_table_verify (policy, data->freq_table);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/cpufreq/acpi-cpufreq.c.ifdefed" startline="478" endline="502">
{
    struct acpi_processor_performance *perf = data->acpi_data;
    if (cpu_khz) {
        unsigned int i;
        unsigned long freq;
        unsigned long freqn = perf->states[0].core_frequency * 1000;
        for (i = 0; i < (perf->state_count - 1); i++) {
            freq = freqn;
            freqn = perf->states[i + 1].core_frequency * 1000;
            if ((2 * cpu_khz) > (freqn + freq)) {
                perf->state = i;
                return freq;
            }
        }
        perf->state = perf->state_count - 1;
        return freqn;
    }
    else {
        perf->state = 0;
        return perf->states[0].core_frequency * 1000;
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/cpufreq/acpi-cpufreq.c.ifdefed" startline="481" endline="497">
{
    unsigned int i;
    unsigned long freq;
    unsigned long freqn = perf->states[0].core_frequency * 1000;
    for (i = 0; i < (perf->state_count - 1); i++) {
        freq = freqn;
        freqn = perf->states[i + 1].core_frequency * 1000;
        if ((2 * cpu_khz) > (freqn + freq)) {
            perf->state = i;
            return freq;
        }
    }
    perf->state = perf->state_count - 1;
    return freqn;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/cpufreq/acpi-cpufreq.c.ifdefed" startline="487" endline="494">
{
    freq = freqn;
    freqn = perf->states[i + 1].core_frequency * 1000;
    if ((2 * cpu_khz) > (freqn + freq)) {
        perf->state = i;
        return freq;
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/cpufreq/acpi-cpufreq.c.ifdefed" startline="490" endline="493">
{
    perf->state = i;
    return freq;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/cpufreq/acpi-cpufreq.c.ifdefed" startline="497" endline="501">
{
    perf->state = 0;
    return perf->states[0].core_frequency * 1000;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/cpufreq/acpi-cpufreq.c.ifdefed" startline="513" endline="525">
{
    dprintk ("acpi_cpufreq_early_init\n");
    acpi_perf_data = alloc_percpu (struct acpi_processor_performance);
    if (!acpi_perf_data) {
        dprintk ("Memory allocation error for acpi_perf_data.\n");
        return -ENOMEM;
    }
    acpi_processor_preregister_performance (acpi_perf_data);
    return 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/cpufreq/acpi-cpufreq.c.ifdefed" startline="517" endline="520">
{
    dprintk ("Memory allocation error for acpi_perf_data.\n");
    return -ENOMEM;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/cpufreq/acpi-cpufreq.c.ifdefed" startline="557" endline="720">
{
    unsigned int i;
    unsigned int valid_states = 0;
    unsigned int cpu = policy->cpu;
    struct acpi_cpufreq_data *data;
    unsigned int result = 0;
    struct cpuinfo_x86 *c = &cpu_data (policy->cpu);
    struct acpi_processor_performance *perf;
    dprintk ("acpi_cpufreq_cpu_init\n");
    data = kzalloc (sizeof (struct acpi_cpufreq_data), GFP_KERNEL);
    if (!data)
        return -ENOMEM;
    data->acpi_data = percpu_ptr (acpi_perf_data, cpu);
    drv_data[cpu] = data;
    if (cpu_has (c, X86_FEATURE_CONSTANT_TSC))
        acpi_cpufreq_driver.flags |= CPUFREQ_CONST_LOOPS;
    result = acpi_processor_register_performance (data->acpi_data, cpu);
    if (result)
        goto err_free;
    perf = data->acpi_data;
    policy->shared_type = perf->shared_type;
    if (policy->shared_type == CPUFREQ_SHARED_TYPE_ALL || policy->shared_type == CPUFREQ_SHARED_TYPE_ANY) {
        policy->cpus = perf->shared_cpu_map;
    }
    if (perf->state_count <= 1) {
        dprintk ("No P-States\n");
        result = -ENODEV;
        goto err_unreg;
    }
    if (perf->control_register.space_id != perf->status_register.space_id) {
        result = -ENODEV;
        goto err_unreg;
    }
    switch (perf->control_register.space_id) {
    case ACPI_ADR_SPACE_SYSTEM_IO :
        dprintk ("SYSTEM IO addr space\n");
        data->cpu_feature = SYSTEM_IO_CAPABLE;
        break;
    case ACPI_ADR_SPACE_FIXED_HARDWARE :
        dprintk ("HARDWARE addr space\n");
        if (!check_est_cpu (cpu)) {
            result = -ENODEV;
            goto err_unreg;
        }
        data->cpu_feature = SYSTEM_INTEL_MSR_CAPABLE;
        break;
    default :
        dprintk ("Unknown addr space %d\n", (u32) (perf->control_register.space_id));
        result = -ENODEV;
        goto err_unreg;
    }
    data->freq_table = kmalloc (sizeof (struct cpufreq_frequency_table) * (perf->state_count + 1), GFP_KERNEL);
    if (!data->freq_table) {
        result = -ENOMEM;
        goto err_unreg;
    }
    policy->cpuinfo.transition_latency = 0;
    for (i = 0; i < perf->state_count; i++) {
        if ((perf->states[i].transition_latency * 1000) > policy->cpuinfo.transition_latency)
            policy->cpuinfo.transition_latency = perf->states[i].transition_latency * 1000;
    }
    data->max_freq = perf->states[0].core_frequency * 1000;
    for (i = 0; i < perf->state_count; i++) {
        if (i > 0 && perf->states[i].core_frequency >= data->freq_table[valid_states - 1].frequency / 1000)
            continue;
        data->freq_table[valid_states].index = i;
        data->freq_table[valid_states].frequency = perf->states[i].core_frequency * 1000;
        valid_states++;
    }
    data->freq_table[valid_states].frequency = CPUFREQ_TABLE_END;
    perf->state = 0;
    result = cpufreq_frequency_table_cpuinfo (policy, data->freq_table);
    if (result)
        goto err_freqfree;
    switch (perf->control_register.space_id) {
    case ACPI_ADR_SPACE_SYSTEM_IO :
        policy->cur = acpi_cpufreq_guess_freq (data, policy->cpu);
        break;
    case ACPI_ADR_SPACE_FIXED_HARDWARE :
        acpi_cpufreq_driver.get = get_cur_freq_on_cpu;
        policy->cur = get_cur_freq_on_cpu (cpu);
        break;
    default :
        break;
    }
    acpi_processor_notify_smm (THIS_MODULE);
    if (c->x86_vendor == X86_VENDOR_INTEL && c->cpuid_level >= 6) {
        unsigned int ecx;
        ecx = cpuid_ecx (6);
        if (ecx & CPUID_6_ECX_APERFMPERF_CAPABILITY)
            acpi_cpufreq_driver.getavg = get_measured_perf;
    }
    dprintk ("CPU%u - ACPI performance management activated.\n", cpu);
    for (i = 0; i < perf->state_count; i++)
        dprintk ("     %cP%d: %d MHz, %d mW, %d uS\n", (i == perf->state ? '*' : ' '), i, (u32) perf->states[i].core_frequency, (u32) perf->states[i].power, (u32) perf->states[i].transition_latency);
    cpufreq_frequency_table_get_attr (data -> freq_table, policy -> cpu);
    data->resume = 1;
    return result;
err_freqfree :
    kfree (data->freq_table);
err_unreg :
    acpi_processor_unregister_performance (perf, cpu);
err_free :
    kfree (data);
    drv_data[cpu] = NULL;
    return result;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/cpufreq/acpi-cpufreq.c.ifdefed" startline="590" endline="592">
{
    policy->cpus = perf->shared_cpu_map;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/cpufreq/acpi-cpufreq.c.ifdefed" startline="603" endline="607">
{
    dprintk ("No P-States\n");
    result = -ENODEV;
    goto err_unreg;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/cpufreq/acpi-cpufreq.c.ifdefed" startline="609" endline="612">
{
    result = -ENODEV;
    goto err_unreg;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/cpufreq/acpi-cpufreq.c.ifdefed" startline="614" endline="632">
{
case ACPI_ADR_SPACE_SYSTEM_IO :
    dprintk ("SYSTEM IO addr space\n");
    data->cpu_feature = SYSTEM_IO_CAPABLE;
    break;
case ACPI_ADR_SPACE_FIXED_HARDWARE :
    dprintk ("HARDWARE addr space\n");
    if (!check_est_cpu (cpu)) {
        result = -ENODEV;
        goto err_unreg;
    }
    data->cpu_feature = SYSTEM_INTEL_MSR_CAPABLE;
    break;
default :
    dprintk ("Unknown addr space %d\n", (u32) (perf->control_register.space_id));
    result = -ENODEV;
    goto err_unreg;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/cpufreq/acpi-cpufreq.c.ifdefed" startline="621" endline="624">
{
    result = -ENODEV;
    goto err_unreg;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/cpufreq/acpi-cpufreq.c.ifdefed" startline="636" endline="639">
{
    result = -ENOMEM;
    goto err_unreg;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/cpufreq/acpi-cpufreq.c.ifdefed" startline="643" endline="648">
{
    if ((perf->states[i].transition_latency * 1000) > policy->cpuinfo.transition_latency)
        policy->cpuinfo.transition_latency = perf->states[i].transition_latency * 1000;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/cpufreq/acpi-cpufreq.c.ifdefed" startline="652" endline="661">
{
    if (i > 0 && perf->states[i].core_frequency >= data->freq_table[valid_states - 1].frequency / 1000)
        continue;
    data->freq_table[valid_states].index = i;
    data->freq_table[valid_states].frequency = perf->states[i].core_frequency * 1000;
    valid_states++;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/cpufreq/acpi-cpufreq.c.ifdefed" startline="669" endline="680">
{
case ACPI_ADR_SPACE_SYSTEM_IO :
    policy->cur = acpi_cpufreq_guess_freq (data, policy->cpu);
    break;
case ACPI_ADR_SPACE_FIXED_HARDWARE :
    acpi_cpufreq_driver.get = get_cur_freq_on_cpu;
    policy->cur = get_cur_freq_on_cpu (cpu);
    break;
default :
    break;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/cpufreq/acpi-cpufreq.c.ifdefed" startline="686" endline="691">
{
    unsigned int ecx;
    ecx = cpuid_ecx (6);
    if (ecx & CPUID_6_ECX_APERFMPERF_CAPABILITY)
        acpi_cpufreq_driver.getavg = get_measured_perf;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/cpufreq/acpi-cpufreq.c.ifdefed" startline="723" endline="737">
{
    struct acpi_cpufreq_data *data = drv_data[policy->cpu];
    dprintk ("acpi_cpufreq_cpu_exit\n");
    if (data) {
        cpufreq_frequency_table_put_attr (policy -> cpu);
        drv_data[policy->cpu] = NULL;
        acpi_processor_unregister_performance (data -> acpi_data, policy -> cpu);
        kfree (data);
    }
    return 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/cpufreq/acpi-cpufreq.c.ifdefed" startline="728" endline="734">
{
    cpufreq_frequency_table_put_attr (policy -> cpu);
    drv_data[policy->cpu] = NULL;
    acpi_processor_unregister_performance (data -> acpi_data, policy -> cpu);
    kfree (data);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/cpufreq/acpi-cpufreq.c.ifdefed" startline="740" endline="748">
{
    struct acpi_cpufreq_data *data = drv_data[policy->cpu];
    dprintk ("acpi_cpufreq_resume\n");
    data->resume = 1;
    return 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/cpufreq/acpi-cpufreq.c.ifdefed" startline="767" endline="777">
{
    int ret;
    dprintk ("acpi_cpufreq_init\n");
    ret = acpi_cpufreq_early_init ();
    if (ret)
        return ret;
    return cpufreq_register_driver (&acpi_cpufreq_driver);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/cpufreq/acpi-cpufreq.c.ifdefed" startline="780" endline="788">
{
    dprintk ("acpi_cpufreq_exit\n");
    cpufreq_unregister_driver (& acpi_cpufreq_driver);
    free_percpu (acpi_perf_data);
    return;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/cpufreq/powernow-k8.c.ifdefed" startline="65" endline="67">
{
    return 800 + (fid * 100);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/cpufreq/powernow-k8.c.ifdefed" startline="72" endline="74">
{
    return 1000 * find_freq_from_fid (fid);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/cpufreq/powernow-k8.c.ifdefed" startline="77" endline="79">
{
    return data[pstate].frequency;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/cpufreq/powernow-k8.c.ifdefed" startline="89" endline="94">
{
    if (fid < HI_FID_TABLE_BOTTOM)
        return 8 + (2 * fid);
    else
        return fid;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/cpufreq/powernow-k8.c.ifdefed" startline="101" endline="109">
{
    u32 lo, hi;
    if (cpu_family == CPU_HW_PSTATE)
        return 0;
    rdmsr (MSR_FIDVID_STATUS, lo, hi);
    return lo & MSR_S_LO_CHANGE_PENDING ? 1 : 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/cpufreq/powernow-k8.c.ifdefed" startline="116" endline="138">
{
    u32 lo, hi;
    u32 i = 0;
    if (cpu_family == CPU_HW_PSTATE) {
        rdmsr (MSR_PSTATE_STATUS, lo, hi);
        i = lo & HW_PSTATE_MASK;
        data->currpstate = i;
        return 0;
    }
    do {
        if (i++ > 10000) {
            dprintk ("detected change pending stuck\n");
            return 1;
        }
        rdmsr (MSR_FIDVID_STATUS, lo, hi);
    }
    while (lo & MSR_S_LO_CHANGE_PENDING);
    data->currvid = hi & MSR_S_HI_CURRENT_VID;
    data->currfid = lo & MSR_S_LO_CURRENT_FID;
    return 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/cpufreq/powernow-k8.c.ifdefed" startline="120" endline="125">
{
    rdmsr (MSR_PSTATE_STATUS, lo, hi);
    i = lo & HW_PSTATE_MASK;
    data->currpstate = i;
    return 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/cpufreq/powernow-k8.c.ifdefed" startline="126" endline="132">
{
    if (i++ > 10000) {
        dprintk ("detected change pending stuck\n");
        return 1;
    }
    rdmsr (MSR_FIDVID_STATUS, lo, hi);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/cpufreq/powernow-k8.c.ifdefed" startline="127" endline="130">
{
    dprintk ("detected change pending stuck\n");
    return 1;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/cpufreq/powernow-k8.c.ifdefed" startline="142" endline="145">
{
    udelay ((1 << data -> irt) * 10);
    return;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/cpufreq/powernow-k8.c.ifdefed" startline="149" endline="152">
{
    udelay (data -> vstable * VST_UNITS_20US);
    return;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/cpufreq/powernow-k8.c.ifdefed" startline="156" endline="167">
{
    u32 lo, hi;
    u8 fid, vid;
    rdmsr (MSR_FIDVID_STATUS, lo, hi);
    vid = hi & MSR_S_HI_CURRENT_VID;
    fid = lo & MSR_S_LO_CURRENT_FID;
    lo = fid | (vid << MSR_C_LO_VID_SHIFT);
    hi = MSR_C_HI_STP_GNT_BENIGN;
    dprintk ("cpu%d, init lo 0x%x, hi 0x%x\n", smp_processor_id (), lo, hi);
    wrmsr (MSR_FIDVID_CTL, lo, hi);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/cpufreq/powernow-k8.c.ifdefed" startline="172" endline="210">
{
    u32 lo;
    u32 savevid = data->currvid;
    u32 i = 0;
    if ((fid & INVALID_FID_MASK) || (data->currvid & INVALID_VID_MASK)) {
        printk (KERN_ERR PFX "internal error - overflow on fid write\n");
        return 1;
    }
    lo = fid | (data->currvid << MSR_C_LO_VID_SHIFT) | MSR_C_LO_INIT_FID_VID;
    dprintk ("writing fid 0x%x, lo 0x%x, hi 0x%x\n", fid, lo, data -> plllock * PLL_LOCK_CONVERSION);
    do {
        wrmsr (MSR_FIDVID_CTL, lo, data -> plllock * PLL_LOCK_CONVERSION);
        if (i++ > 100) {
            printk (KERN_ERR PFX "Hardware error - pending bit very stuck - no further pstate changes possible\n");
            return 1;
        }
    }
    while (query_current_values_with_pending_wait (data));
    count_off_irt (data);
    if (savevid != data->currvid) {
        printk (KERN_ERR PFX "vid change on fid trans, old 0x%x, new 0x%x\n", savevid, data -> currvid);
        return 1;
    }
    if (fid != data->currfid) {
        printk (KERN_ERR PFX "fid trans failed, fid 0x%x, curr 0x%x\n", fid, data -> currfid);
        return 1;
    }
    return 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/cpufreq/powernow-k8.c.ifdefed" startline="177" endline="180">
{
    printk (KERN_ERR PFX "internal error - overflow on fid write\n");
    return 1;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/cpufreq/powernow-k8.c.ifdefed" startline="187" endline="193">
{
    wrmsr (MSR_FIDVID_CTL, lo, data -> plllock * PLL_LOCK_CONVERSION);
    if (i++ > 100) {
        printk (KERN_ERR PFX "Hardware error - pending bit very stuck - no further pstate changes possible\n");
        return 1;
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/cpufreq/powernow-k8.c.ifdefed" startline="189" endline="192">
{
    printk (KERN_ERR PFX "Hardware error - pending bit very stuck - no further pstate changes possible\n");
    return 1;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/cpufreq/powernow-k8.c.ifdefed" startline="197" endline="201">
{
    printk (KERN_ERR PFX "vid change on fid trans, old 0x%x, new 0x%x\n", savevid, data -> currvid);
    return 1;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/cpufreq/powernow-k8.c.ifdefed" startline="203" endline="207">
{
    printk (KERN_ERR PFX "fid trans failed, fid 0x%x, curr 0x%x\n", fid, data -> currfid);
    return 1;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/cpufreq/powernow-k8.c.ifdefed" startline="214" endline="250">
{
    u32 lo;
    u32 savefid = data->currfid;
    int i = 0;
    if ((data->currfid & INVALID_FID_MASK) || (vid & INVALID_VID_MASK)) {
        printk (KERN_ERR PFX "internal error - overflow on vid write\n");
        return 1;
    }
    lo = data->currfid | (vid << MSR_C_LO_VID_SHIFT) | MSR_C_LO_INIT_FID_VID;
    dprintk ("writing vid 0x%x, lo 0x%x, hi 0x%x\n", vid, lo, STOP_GRANT_5NS);
    do {
        wrmsr (MSR_FIDVID_CTL, lo, STOP_GRANT_5NS);
        if (i++ > 100) {
            printk (KERN_ERR PFX "internal error - pending bit very stuck - no further pstate changes possible\n");
            return 1;
        }
    }
    while (query_current_values_with_pending_wait (data));
    if (savefid != data->currfid) {
        printk (KERN_ERR PFX "fid changed on vid trans, old 0x%x new 0x%x\n", savefid, data -> currfid);
        return 1;
    }
    if (vid != data->currvid) {
        printk (KERN_ERR PFX "vid trans failed, vid 0x%x, curr 0x%x\n", vid, data -> currvid);
        return 1;
    }
    return 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/cpufreq/powernow-k8.c.ifdefed" startline="219" endline="222">
{
    printk (KERN_ERR PFX "internal error - overflow on vid write\n");
    return 1;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/cpufreq/powernow-k8.c.ifdefed" startline="229" endline="235">
{
    wrmsr (MSR_FIDVID_CTL, lo, STOP_GRANT_5NS);
    if (i++ > 100) {
        printk (KERN_ERR PFX "internal error - pending bit very stuck - no further pstate changes possible\n");
        return 1;
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/cpufreq/powernow-k8.c.ifdefed" startline="231" endline="234">
{
    printk (KERN_ERR PFX "internal error - pending bit very stuck - no further pstate changes possible\n");
    return 1;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/cpufreq/powernow-k8.c.ifdefed" startline="237" endline="241">
{
    printk (KERN_ERR PFX "fid changed on vid trans, old 0x%x new 0x%x\n", savefid, data -> currfid);
    return 1;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/cpufreq/powernow-k8.c.ifdefed" startline="243" endline="247">
{
    printk (KERN_ERR PFX "vid trans failed, vid 0x%x, curr 0x%x\n", vid, data -> currvid);
    return 1;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/cpufreq/powernow-k8.c.ifdefed" startline="258" endline="268">
{
    if ((data->currvid - reqvid) > step)
        reqvid = data->currvid - step;
    if (write_new_vid (data, reqvid))
        return 1;
    count_off_vst (data);
    return 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/cpufreq/powernow-k8.c.ifdefed" startline="272" endline="276">
{
    wrmsr (MSR_PSTATE_CTRL, pstate, 0);
    data->currpstate = pstate;
    return 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/cpufreq/powernow-k8.c.ifdefed" startline="280" endline="304">
{
    if (core_voltage_pre_transition (data, reqvid))
        return 1;
    if (core_frequency_transition (data, reqfid))
        return 1;
    if (core_voltage_post_transition (data, reqvid))
        return 1;
    if (query_current_values_with_pending_wait (data))
        return 1;
    if ((reqfid != data->currfid) || (reqvid != data->currvid)) {
        printk (KERN_ERR PFX "failed (cpu%d): req 0x%x 0x%x, curr 0x%x 0x%x\n", smp_processor_id (), reqfid, reqvid, data -> currfid, data -> currvid);
        return 1;
    }
    dprintk ("transitioned (cpu%d): new fid 0x%x, vid 0x%x\n", smp_processor_id (), data -> currfid, data -> currvid);
    return 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/cpufreq/powernow-k8.c.ifdefed" startline="293" endline="298">
{
    printk (KERN_ERR PFX "failed (cpu%d): req 0x%x 0x%x, curr 0x%x 0x%x\n", smp_processor_id (), reqfid, reqvid, data -> currfid, data -> currvid);
    return 1;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/cpufreq/powernow-k8.c.ifdefed" startline="308" endline="354">
{
    u32 rvosteps = data->rvo;
    u32 savefid = data->currfid;
    u32 maxvid, lo;
    dprintk ("ph1 (cpu%d): start, currfid 0x%x, currvid 0x%x, reqvid 0x%x, rvo 0x%x\n", smp_processor_id (), data -> currfid, data -> currvid, reqvid, data -> rvo);
    rdmsr (MSR_FIDVID_STATUS, lo, maxvid);
    maxvid = 0x1f & (maxvid >> 16);
    dprintk ("ph1 maxvid=0x%x\n", maxvid);
    if (reqvid < maxvid)
        reqvid = maxvid;
    while (data->currvid > reqvid) {
        dprintk ("ph1: curr 0x%x, req vid 0x%x\n", data -> currvid, reqvid);
        if (decrease_vid_code_by_step (data, reqvid, data->vidmvs))
            return 1;
    }
    while ((rvosteps > 0) && ((data->rvo + data->currvid) > reqvid)) {
        if (data->currvid == maxvid) {
            rvosteps = 0;
        }
        else {
            dprintk ("ph1: changing vid for rvo, req 0x%x\n", data -> currvid - 1);
            if (decrease_vid_code_by_step (data, data->currvid - 1, 1))
                return 1;
            rvosteps--;
        }
    }
    if (query_current_values_with_pending_wait (data))
        return 1;
    if (savefid != data->currfid) {
        printk (KERN_ERR PFX "ph1 err, currfid changed 0x%x\n", data -> currfid);
        return 1;
    }
    dprintk ("ph1 complete, currfid 0x%x, currvid 0x%x\n", data -> currfid, data -> currvid);
    return 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/cpufreq/powernow-k8.c.ifdefed" startline="323" endline="328">
{
    dprintk ("ph1: curr 0x%x, req vid 0x%x\n", data -> currvid, reqvid);
    if (decrease_vid_code_by_step (data, reqvid, data->vidmvs))
        return 1;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/cpufreq/powernow-k8.c.ifdefed" startline="330" endline="340">
{
    if (data->currvid == maxvid) {
        rvosteps = 0;
    }
    else {
        dprintk ("ph1: changing vid for rvo, req 0x%x\n", data -> currvid - 1);
        if (decrease_vid_code_by_step (data, data->currvid - 1, 1))
            return 1;
        rvosteps--;
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/cpufreq/powernow-k8.c.ifdefed" startline="331" endline="333">
{
    rvosteps = 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/cpufreq/powernow-k8.c.ifdefed" startline="333" endline="339">
{
    dprintk ("ph1: changing vid for rvo, req 0x%x\n", data -> currvid - 1);
    if (decrease_vid_code_by_step (data, data->currvid - 1, 1))
        return 1;
    rvosteps--;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/cpufreq/powernow-k8.c.ifdefed" startline="345" endline="348">
{
    printk (KERN_ERR PFX "ph1 err, currfid changed 0x%x\n", data -> currfid);
    return 1;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/cpufreq/powernow-k8.c.ifdefed" startline="358" endline="428">
{
    u32 vcoreqfid, vcocurrfid, vcofiddiff, fid_interval, savevid = data->currvid;
    if ((reqfid < HI_FID_TABLE_BOTTOM) && (data->currfid < HI_FID_TABLE_BOTTOM)) {
        printk (KERN_ERR PFX "ph2: illegal lo-lo transition 0x%x 0x%x\n", reqfid, data -> currfid);
        return 1;
    }
    if (data->currfid == reqfid) {
        printk (KERN_ERR PFX "ph2 null fid transition 0x%x\n", data -> currfid);
        return 0;
    }
    dprintk ("ph2 (cpu%d): starting, currfid 0x%x, currvid 0x%x, reqfid 0x%x\n", smp_processor_id (), data -> currfid, data -> currvid, reqfid);
    vcoreqfid = convert_fid_to_vco_fid (reqfid);
    vcocurrfid = convert_fid_to_vco_fid (data->currfid);
    vcofiddiff = vcocurrfid > vcoreqfid ? vcocurrfid - vcoreqfid : vcoreqfid - vcocurrfid;
    while (vcofiddiff > 2) {
        (data->currfid & 1) ? (fid_interval = 1) : (fid_interval = 2);
        if (reqfid > data->currfid) {
            if (data->currfid > LO_FID_TABLE_TOP) {
                if (write_new_fid (data, data->currfid + fid_interval)) {
                    return 1;
                }
            }
            else {
                if (write_new_fid (data, 2 + convert_fid_to_vco_fid (data->currfid))) {
                    return 1;
                }
            }
        }
        else {
            if (write_new_fid (data, data->currfid - fid_interval))
                return 1;
        }
        vcocurrfid = convert_fid_to_vco_fid (data->currfid);
        vcofiddiff = vcocurrfid > vcoreqfid ? vcocurrfid - vcoreqfid : vcoreqfid - vcocurrfid;
    }
    if (write_new_fid (data, reqfid))
        return 1;
    if (query_current_values_with_pending_wait (data))
        return 1;
    if (data->currfid != reqfid) {
        printk (KERN_ERR PFX "ph2: mismatch, failed fid transition, curr 0x%x, req 0x%x\n", data -> currfid, reqfid);
        return 1;
    }
    if (savevid != data->currvid) {
        printk (KERN_ERR PFX "ph2: vid changed, save 0x%x, curr 0x%x\n", savevid, data -> currvid);
        return 1;
    }
    dprintk ("ph2 complete, currfid 0x%x, currvid 0x%x\n", data -> currfid, data -> currvid);
    return 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/cpufreq/powernow-k8.c.ifdefed" startline="361" endline="365">
{
    printk (KERN_ERR PFX "ph2: illegal lo-lo transition 0x%x 0x%x\n", reqfid, data -> currfid);
    return 1;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/cpufreq/powernow-k8.c.ifdefed" startline="367" endline="370">
{
    printk (KERN_ERR PFX "ph2 null fid transition 0x%x\n", data -> currfid);
    return 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/cpufreq/powernow-k8.c.ifdefed" startline="381" endline="403">
{
    (data->currfid & 1) ? (fid_interval = 1) : (fid_interval = 2);
    if (reqfid > data->currfid) {
        if (data->currfid > LO_FID_TABLE_TOP) {
            if (write_new_fid (data, data->currfid + fid_interval)) {
                return 1;
            }
        }
        else {
            if (write_new_fid (data, 2 + convert_fid_to_vco_fid (data->currfid))) {
                return 1;
            }
        }
    }
    else {
        if (write_new_fid (data, data->currfid - fid_interval))
            return 1;
    }
    vcocurrfid = convert_fid_to_vco_fid (data->currfid);
    vcofiddiff = vcocurrfid > vcoreqfid ? vcocurrfid - vcoreqfid : vcoreqfid - vcocurrfid;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/cpufreq/powernow-k8.c.ifdefed" startline="384" endline="395">
{
    if (data->currfid > LO_FID_TABLE_TOP) {
        if (write_new_fid (data, data->currfid + fid_interval)) {
            return 1;
        }
    }
    else {
        if (write_new_fid (data, 2 + convert_fid_to_vco_fid (data->currfid))) {
            return 1;
        }
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/cpufreq/powernow-k8.c.ifdefed" startline="385" endline="389">
{
    if (write_new_fid (data, data->currfid + fid_interval)) {
        return 1;
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/cpufreq/powernow-k8.c.ifdefed" startline="386" endline="388">
{
    return 1;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/cpufreq/powernow-k8.c.ifdefed" startline="389" endline="394">
{
    if (write_new_fid (data, 2 + convert_fid_to_vco_fid (data->currfid))) {
        return 1;
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/cpufreq/powernow-k8.c.ifdefed" startline="391" endline="393">
{
    return 1;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/cpufreq/powernow-k8.c.ifdefed" startline="395" endline="398">
{
    if (write_new_fid (data, data->currfid - fid_interval))
        return 1;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/cpufreq/powernow-k8.c.ifdefed" startline="411" endline="416">
{
    printk (KERN_ERR PFX "ph2: mismatch, failed fid transition, curr 0x%x, req 0x%x\n", data -> currfid, reqfid);
    return 1;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/cpufreq/powernow-k8.c.ifdefed" startline="418" endline="422">
{
    printk (KERN_ERR PFX "ph2: vid changed, save 0x%x, curr 0x%x\n", savevid, data -> currvid);
    return 1;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/cpufreq/powernow-k8.c.ifdefed" startline="432" endline="477">
{
    u32 savefid = data->currfid;
    u32 savereqvid = reqvid;
    dprintk ("ph3 (cpu%d): starting, currfid 0x%x, currvid 0x%x\n", smp_processor_id (), data -> currfid, data -> currvid);
    if (reqvid != data->currvid) {
        if (write_new_vid (data, reqvid))
            return 1;
        if (savefid != data->currfid) {
            printk (KERN_ERR PFX "ph3: bad fid change, save 0x%x, curr 0x%x\n", savefid, data -> currfid);
            return 1;
        }
        if (data->currvid != reqvid) {
            printk (KERN_ERR PFX "ph3: failed vid transition\n, req 0x%x, curr 0x%x", reqvid, data -> currvid);
            return 1;
        }
    }
    if (query_current_values_with_pending_wait (data))
        return 1;
    if (savereqvid != data->currvid) {
        dprintk ("ph3 failed, currvid 0x%x\n", data -> currvid);
        return 1;
    }
    if (savefid != data->currfid) {
        dprintk ("ph3 failed, currfid changed 0x%x\n", data -> currfid);
        return 1;
    }
    dprintk ("ph3 complete, currfid 0x%x, currvid 0x%x\n", data -> currfid, data -> currvid);
    return 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/cpufreq/powernow-k8.c.ifdefed" startline="440" endline="457">
{
    if (write_new_vid (data, reqvid))
        return 1;
    if (savefid != data->currfid) {
        printk (KERN_ERR PFX "ph3: bad fid change, save 0x%x, curr 0x%x\n", savefid, data -> currfid);
        return 1;
    }
    if (data->currvid != reqvid) {
        printk (KERN_ERR PFX "ph3: failed vid transition\n, req 0x%x, curr 0x%x", reqvid, data -> currvid);
        return 1;
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/cpufreq/powernow-k8.c.ifdefed" startline="444" endline="449">
{
    printk (KERN_ERR PFX "ph3: bad fid change, save 0x%x, curr 0x%x\n", savefid, data -> currfid);
    return 1;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/cpufreq/powernow-k8.c.ifdefed" startline="451" endline="456">
{
    printk (KERN_ERR PFX "ph3: failed vid transition\n, req 0x%x, curr 0x%x", reqvid, data -> currvid);
    return 1;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/cpufreq/powernow-k8.c.ifdefed" startline="462" endline="465">
{
    dprintk ("ph3 failed, currvid 0x%x\n", data -> currvid);
    return 1;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/cpufreq/powernow-k8.c.ifdefed" startline="467" endline="471">
{
    dprintk ("ph3 failed, currfid changed 0x%x\n", data -> currfid);
    return 1;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/cpufreq/powernow-k8.c.ifdefed" startline="480" endline="533">
{
    cpumask_t oldmask = CPU_MASK_ALL;
    u32 eax, ebx, ecx, edx;
    unsigned int rc = 0;
    oldmask = current->cpus_allowed;
    set_cpus_allowed (current, cpumask_of_cpu (cpu));
    if (smp_processor_id () != cpu) {
        printk (KERN_ERR PFX "limiting to cpu %u failed\n", cpu);
        goto out;
    }
    if (current_cpu_data.x86_vendor != X86_VENDOR_AMD)
        goto out;
    eax = cpuid_eax (CPUID_PROCESSOR_SIGNATURE);
    if (((eax & CPUID_XFAM) != CPUID_XFAM_K8) && ((eax & CPUID_XFAM) < CPUID_XFAM_10H))
        goto out;
    if ((eax & CPUID_XFAM) == CPUID_XFAM_K8) {
        if (((eax & CPUID_USE_XFAM_XMOD) != CPUID_USE_XFAM_XMOD) || ((eax & CPUID_XMOD) > CPUID_XMOD_REV_MASK)) {
            printk (KERN_INFO PFX "Processor cpuid %x not supported\n", eax);
            goto out;
        }
        eax = cpuid_eax (CPUID_GET_MAX_CAPABILITIES);
        if (eax < CPUID_FREQ_VOLT_CAPABILITIES) {
            printk (KERN_INFO PFX "No frequency change capabilities detected\n");
            goto out;
        }
        cpuid (CPUID_FREQ_VOLT_CAPABILITIES, & eax, & ebx, & ecx, & edx);
        if ((edx & P_STATE_TRANSITION_CAPABLE) != P_STATE_TRANSITION_CAPABLE) {
            printk (KERN_INFO PFX "Power state transitions not supported\n");
            goto out;
        }
    }
    else {
        cpuid (CPUID_FREQ_VOLT_CAPABILITIES, & eax, & ebx, & ecx, & edx);
        if ((edx & USE_HW_PSTATE) == USE_HW_PSTATE)
            cpu_family = CPU_HW_PSTATE;
        else
            goto out;
    }
    rc = 1;
out :
    set_cpus_allowed (current, oldmask);
    return rc;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/cpufreq/powernow-k8.c.ifdefed" startline="488" endline="491">
{
    printk (KERN_ERR PFX "limiting to cpu %u failed\n", cpu);
    goto out;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/cpufreq/powernow-k8.c.ifdefed" startline="501" endline="520">
{
    if (((eax & CPUID_USE_XFAM_XMOD) != CPUID_USE_XFAM_XMOD) || ((eax & CPUID_XMOD) > CPUID_XMOD_REV_MASK)) {
        printk (KERN_INFO PFX "Processor cpuid %x not supported\n", eax);
        goto out;
    }
    eax = cpuid_eax (CPUID_GET_MAX_CAPABILITIES);
    if (eax < CPUID_FREQ_VOLT_CAPABILITIES) {
        printk (KERN_INFO PFX "No frequency change capabilities detected\n");
        goto out;
    }
    cpuid (CPUID_FREQ_VOLT_CAPABILITIES, & eax, & ebx, & ecx, & edx);
    if ((edx & P_STATE_TRANSITION_CAPABLE) != P_STATE_TRANSITION_CAPABLE) {
        printk (KERN_INFO PFX "Power state transitions not supported\n");
        goto out;
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/cpufreq/powernow-k8.c.ifdefed" startline="503" endline="506">
{
    printk (KERN_INFO PFX "Processor cpuid %x not supported\n", eax);
    goto out;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/cpufreq/powernow-k8.c.ifdefed" startline="509" endline="513">
{
    printk (KERN_INFO PFX "No frequency change capabilities detected\n");
    goto out;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/cpufreq/powernow-k8.c.ifdefed" startline="516" endline="519">
{
    printk (KERN_INFO PFX "Power state transitions not supported\n");
    goto out;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/cpufreq/powernow-k8.c.ifdefed" startline="520" endline="526">
{
    cpuid (CPUID_FREQ_VOLT_CAPABILITIES, & eax, & ebx, & ecx, & edx);
    if ((edx & USE_HW_PSTATE) == USE_HW_PSTATE)
        cpu_family = CPU_HW_PSTATE;
    else
        goto out;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/cpufreq/powernow-k8.c.ifdefed" startline="536" endline="573">
{
    unsigned int j;
    u8 lastfid = 0xff;
    for (j = 0; j < data->numps; j++) {
        if (pst[j].vid > LEAST_VID) {
            printk (KERN_ERR PFX "vid %d invalid : 0x%x\n", j, pst [j].vid);
            return -EINVAL;
        }
        if (pst[j].vid < data->rvo) {
            printk (KERN_ERR BFX "0 vid exceeded with pstate %d\n", j);
            return -ENODEV;
        }
        if (pst[j].vid < maxvid + data->rvo) {
            printk (KERN_ERR BFX "maxvid exceeded with pstate %d\n", j);
            return -ENODEV;
        }
        if (pst[j].fid > MAX_FID) {
            printk (KERN_ERR BFX "maxfid exceeded with pstate %d\n", j);
            return -ENODEV;
        }
        if (j && (pst[j].fid < HI_FID_TABLE_BOTTOM)) {
            printk (KERN_ERR BFX "two low fids - %d : 0x%x\n", j, pst [j].fid);
            return -EINVAL;
        }
        if (pst[j].fid < lastfid)
            lastfid = pst[j].fid;
    }
    if (lastfid & 1) {
        printk (KERN_ERR BFX "lastfid invalid\n");
        return -EINVAL;
    }
    if (lastfid > LO_FID_TABLE_TOP)
        printk (KERN_INFO BFX "first fid not from lo freq table\n");
    return 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/cpufreq/powernow-k8.c.ifdefed" startline="540" endline="564">
{
    if (pst[j].vid > LEAST_VID) {
        printk (KERN_ERR PFX "vid %d invalid : 0x%x\n", j, pst [j].vid);
        return -EINVAL;
    }
    if (pst[j].vid < data->rvo) {
        printk (KERN_ERR BFX "0 vid exceeded with pstate %d\n", j);
        return -ENODEV;
    }
    if (pst[j].vid < maxvid + data->rvo) {
        printk (KERN_ERR BFX "maxvid exceeded with pstate %d\n", j);
        return -ENODEV;
    }
    if (pst[j].fid > MAX_FID) {
        printk (KERN_ERR BFX "maxfid exceeded with pstate %d\n", j);
        return -ENODEV;
    }
    if (j && (pst[j].fid < HI_FID_TABLE_BOTTOM)) {
        printk (KERN_ERR BFX "two low fids - %d : 0x%x\n", j, pst [j].fid);
        return -EINVAL;
    }
    if (pst[j].fid < lastfid)
        lastfid = pst[j].fid;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/cpufreq/powernow-k8.c.ifdefed" startline="541" endline="544">
{
    printk (KERN_ERR PFX "vid %d invalid : 0x%x\n", j, pst [j].vid);
    return -EINVAL;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/cpufreq/powernow-k8.c.ifdefed" startline="545" endline="548">
{
    printk (KERN_ERR BFX "0 vid exceeded with pstate %d\n", j);
    return -ENODEV;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/cpufreq/powernow-k8.c.ifdefed" startline="549" endline="552">
{
    printk (KERN_ERR BFX "maxvid exceeded with pstate %d\n", j);
    return -ENODEV;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/cpufreq/powernow-k8.c.ifdefed" startline="553" endline="556">
{
    printk (KERN_ERR BFX "maxfid exceeded with pstate %d\n", j);
    return -ENODEV;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/cpufreq/powernow-k8.c.ifdefed" startline="557" endline="561">
{
    printk (KERN_ERR BFX "two low fids - %d : 0x%x\n", j, pst [j].fid);
    return -EINVAL;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/cpufreq/powernow-k8.c.ifdefed" startline="565" endline="568">
{
    printk (KERN_ERR BFX "lastfid invalid\n");
    return -EINVAL;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/cpufreq/powernow-k8.c.ifdefed" startline="576" endline="597">
{
    int j;
    for (j = 0; j < data->numps; j++) {
        if (data->powernow_table[j].frequency != CPUFREQ_ENTRY_INVALID) {
            if (cpu_family == CPU_HW_PSTATE) {
                printk (KERN_INFO PFX "   %d : fid 0x%x did 0x%x (%d MHz)\n", j, (data -> powernow_table [j].index & 0xff00) >> 8, (data -> powernow_table [j].index & 0xff0000) >> 16, data -> powernow_table [j].frequency / 1000);
            }
            else {
                printk (KERN_INFO PFX "   %d : fid 0x%x (%d MHz), vid 0x%x\n", j, data -> powernow_table [j].index & 0xff, data -> powernow_table [j].frequency / 1000, data -> powernow_table [j].index >> 8);
            }
        }
    }
    if (data->batps)
        printk (KERN_INFO PFX "Only %d pstates on battery\n", data->batps);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/cpufreq/powernow-k8.c.ifdefed" startline="578" endline="594">
{
    if (data->powernow_table[j].frequency != CPUFREQ_ENTRY_INVALID) {
        if (cpu_family == CPU_HW_PSTATE) {
            printk (KERN_INFO PFX "   %d : fid 0x%x did 0x%x (%d MHz)\n", j, (data -> powernow_table [j].index & 0xff00) >> 8, (data -> powernow_table [j].index & 0xff0000) >> 16, data -> powernow_table [j].frequency / 1000);
        }
        else {
            printk (KERN_INFO PFX "   %d : fid 0x%x (%d MHz), vid 0x%x\n", j, data -> powernow_table [j].index & 0xff, data -> powernow_table [j].frequency / 1000, data -> powernow_table [j].index >> 8);
        }
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/cpufreq/powernow-k8.c.ifdefed" startline="579" endline="593">
{
    if (cpu_family == CPU_HW_PSTATE) {
        printk (KERN_INFO PFX "   %d : fid 0x%x did 0x%x (%d MHz)\n", j, (data -> powernow_table [j].index & 0xff00) >> 8, (data -> powernow_table [j].index & 0xff0000) >> 16, data -> powernow_table [j].frequency / 1000);
    }
    else {
        printk (KERN_INFO PFX "   %d : fid 0x%x (%d MHz), vid 0x%x\n", j, data -> powernow_table [j].index & 0xff, data -> powernow_table [j].frequency / 1000, data -> powernow_table [j].index >> 8);
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/cpufreq/powernow-k8.c.ifdefed" startline="580" endline="586">
{
    printk (KERN_INFO PFX "   %d : fid 0x%x did 0x%x (%d MHz)\n", j, (data -> powernow_table [j].index & 0xff00) >> 8, (data -> powernow_table [j].index & 0xff0000) >> 16, data -> powernow_table [j].frequency / 1000);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/cpufreq/powernow-k8.c.ifdefed" startline="586" endline="592">
{
    printk (KERN_INFO PFX "   %d : fid 0x%x (%d MHz), vid 0x%x\n", j, data -> powernow_table [j].index & 0xff, data -> powernow_table [j].frequency / 1000, data -> powernow_table [j].index >> 8);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/cpufreq/powernow-k8.c.ifdefed" startline="600" endline="655">
{
    struct cpufreq_frequency_table *powernow_table;
    unsigned int j;
    if (data->batps) {
        printk (KERN_WARNING PFX "Only %d pstates usable (use ACPI driver for full range\n", data -> batps);
        data->numps = data->batps;
    }
    for (j = 1; j < data->numps; j++) {
        if (pst[j - 1].fid >= pst[j].fid) {
            printk (KERN_ERR PFX "PST out of sequence\n");
            return -EINVAL;
        }
    }
    if (data->numps < 2) {
        printk (KERN_ERR PFX "no p states to transition\n");
        return -ENODEV;
    }
    if (check_pst_table (data, pst, maxvid))
        return -EINVAL;
    powernow_table = kmalloc ((sizeof (struct cpufreq_frequency_table) * (data->numps + 1)), GFP_KERNEL);
    if (!powernow_table) {
        printk (KERN_ERR PFX "powernow_table memory alloc failure\n");
        return -ENOMEM;
    }
    for (j = 0; j < data->numps; j++) {
        powernow_table[j].index = pst[j].fid;
        powernow_table[j].index |= (pst[j].vid << 8);
        powernow_table[j].frequency = find_khz_freq_from_fid (pst[j].fid);
    }
    powernow_table[data->numps].frequency = CPUFREQ_TABLE_END;
    powernow_table[data->numps].index = 0;
    if (query_current_values_with_pending_wait (data)) {
        kfree (powernow_table);
        return -EIO;
    }
    dprintk ("cfid 0x%x, cvid 0x%x\n", data -> currfid, data -> currvid);
    data->powernow_table = powernow_table;
    if (first_cpu (per_cpu (cpu_core_map, data->cpu)) == data->cpu)
        print_basics (data);
    for (j = 0; j < data->numps; j++)
        if ((pst[j].fid == data->currfid) && (pst[j].vid == data->currvid))
            return 0;
    dprintk ("currfid/vid do not match PST, ignoring\n");
    return 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/cpufreq/powernow-k8.c.ifdefed" startline="604" endline="607">
{
    printk (KERN_WARNING PFX "Only %d pstates usable (use ACPI driver for full range\n", data -> batps);
    data->numps = data->batps;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/cpufreq/powernow-k8.c.ifdefed" startline="609" endline="614">
{
    if (pst[j - 1].fid >= pst[j].fid) {
        printk (KERN_ERR PFX "PST out of sequence\n");
        return -EINVAL;
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/cpufreq/powernow-k8.c.ifdefed" startline="610" endline="613">
{
    printk (KERN_ERR PFX "PST out of sequence\n");
    return -EINVAL;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/cpufreq/powernow-k8.c.ifdefed" startline="616" endline="619">
{
    printk (KERN_ERR PFX "no p states to transition\n");
    return -ENODEV;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/cpufreq/powernow-k8.c.ifdefed" startline="626" endline="629">
{
    printk (KERN_ERR PFX "powernow_table memory alloc failure\n");
    return -ENOMEM;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/cpufreq/powernow-k8.c.ifdefed" startline="631" endline="635">
{
    powernow_table[j].index = pst[j].fid;
    powernow_table[j].index |= (pst[j].vid << 8);
    powernow_table[j].frequency = find_khz_freq_from_fid (pst[j].fid);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/cpufreq/powernow-k8.c.ifdefed" startline="639" endline="642">
{
    kfree (powernow_table);
    return -EIO;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/cpufreq/powernow-k8.c.ifdefed" startline="659" endline="739">
{
    struct psb_s *psb;
    unsigned int i;
    u32 mvs;
    u8 maxvid;
    u32 cpst = 0;
    u32 thiscpuid;
    for (i = 0xc0000; i < 0xffff0; i += 0x10) {
        psb = phys_to_virt (i);
        if (memcmp (psb, PSB_ID_STRING, PSB_ID_STRING_LEN) != 0)
            continue;
        dprintk ("found PSB header at 0x%p\n", psb);
        dprintk ("table vers: 0x%x\n", psb -> tableversion);
        if (psb->tableversion != PSB_VERSION_1_4) {
            printk (KERN_ERR BFX "PSB table is not v1.4\n");
            return -ENODEV;
        }
        dprintk ("flags: 0x%x\n", psb -> flags1);
        if (psb->flags1) {
            printk (KERN_ERR BFX "unknown flags\n");
            return -ENODEV;
        }
        data->vstable = psb->vstable;
        dprintk ("voltage stabilization time: %d(*20us)\n", data -> vstable);
        dprintk ("flags2: 0x%x\n", psb -> flags2);
        data->rvo = psb->flags2 & 3;
        data->irt = ((psb->flags2) >> 2) & 3;
        mvs = ((psb->flags2) >> 4) & 3;
        data->vidmvs = 1 << mvs;
        data->batps = ((psb->flags2) >> 6) & 3;
        dprintk ("ramp voltage offset: %d\n", data -> rvo);
        dprintk ("isochronous relief time: %d\n", data -> irt);
        dprintk ("maximum voltage step: %d - 0x%x\n", mvs, data -> vidmvs);
        dprintk ("numpst: 0x%x\n", psb -> num_tables);
        cpst = psb->num_tables;
        if ((psb->cpuid == 0x00000fc0) || (psb->cpuid == 0x00000fe0)) {
            thiscpuid = cpuid_eax (CPUID_PROCESSOR_SIGNATURE);
            if ((thiscpuid == 0x00000fc0) || (thiscpuid == 0x00000fe0)) {
                cpst = 1;
            }
        }
        if (cpst != 1) {
            printk (KERN_ERR BFX "numpst must be 1\n");
            return -ENODEV;
        }
        data->plllock = psb->plllocktime;
        dprintk ("plllocktime: 0x%x (units 1us)\n", psb -> plllocktime);
        dprintk ("maxfid: 0x%x\n", psb -> maxfid);
        dprintk ("maxvid: 0x%x\n", psb -> maxvid);
        maxvid = psb->maxvid;
        data->numps = psb->numps;
        dprintk ("numpstates: 0x%x\n", data -> numps);
        return fill_powernow_table (data, (struct pst_s *) (psb + 1), maxvid);
    }
    printk (KERN_ERR PFX "BIOS error - no PSB or ACPI _PSS objects\n");
    return -ENODEV;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/cpufreq/powernow-k8.c.ifdefed" startline="667" endline="725">
{
    psb = phys_to_virt (i);
    if (memcmp (psb, PSB_ID_STRING, PSB_ID_STRING_LEN) != 0)
        continue;
    dprintk ("found PSB header at 0x%p\n", psb);
    dprintk ("table vers: 0x%x\n", psb -> tableversion);
    if (psb->tableversion != PSB_VERSION_1_4) {
        printk (KERN_ERR BFX "PSB table is not v1.4\n");
        return -ENODEV;
    }
    dprintk ("flags: 0x%x\n", psb -> flags1);
    if (psb->flags1) {
        printk (KERN_ERR BFX "unknown flags\n");
        return -ENODEV;
    }
    data->vstable = psb->vstable;
    dprintk ("voltage stabilization time: %d(*20us)\n", data -> vstable);
    dprintk ("flags2: 0x%x\n", psb -> flags2);
    data->rvo = psb->flags2 & 3;
    data->irt = ((psb->flags2) >> 2) & 3;
    mvs = ((psb->flags2) >> 4) & 3;
    data->vidmvs = 1 << mvs;
    data->batps = ((psb->flags2) >> 6) & 3;
    dprintk ("ramp voltage offset: %d\n", data -> rvo);
    dprintk ("isochronous relief time: %d\n", data -> irt);
    dprintk ("maximum voltage step: %d - 0x%x\n", mvs, data -> vidmvs);
    dprintk ("numpst: 0x%x\n", psb -> num_tables);
    cpst = psb->num_tables;
    if ((psb->cpuid == 0x00000fc0) || (psb->cpuid == 0x00000fe0)) {
        thiscpuid = cpuid_eax (CPUID_PROCESSOR_SIGNATURE);
        if ((thiscpuid == 0x00000fc0) || (thiscpuid == 0x00000fe0)) {
            cpst = 1;
        }
    }
    if (cpst != 1) {
        printk (KERN_ERR BFX "numpst must be 1\n");
        return -ENODEV;
    }
    data->plllock = psb->plllocktime;
    dprintk ("plllocktime: 0x%x (units 1us)\n", psb -> plllocktime);
    dprintk ("maxfid: 0x%x\n", psb -> maxfid);
    dprintk ("maxvid: 0x%x\n", psb -> maxvid);
    maxvid = psb->maxvid;
    data->numps = psb->numps;
    dprintk ("numpstates: 0x%x\n", data -> numps);
    return fill_powernow_table (data, (struct pst_s *) (psb + 1), maxvid);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/cpufreq/powernow-k8.c.ifdefed" startline="678" endline="681">
{
    printk (KERN_ERR BFX "PSB table is not v1.4\n");
    return -ENODEV;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/cpufreq/powernow-k8.c.ifdefed" startline="684" endline="687">
{
    printk (KERN_ERR BFX "unknown flags\n");
    return -ENODEV;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/cpufreq/powernow-k8.c.ifdefed" startline="705" endline="710">
{
    thiscpuid = cpuid_eax (CPUID_PROCESSOR_SIGNATURE);
    if ((thiscpuid == 0x00000fc0) || (thiscpuid == 0x00000fe0)) {
        cpst = 1;
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/cpufreq/powernow-k8.c.ifdefed" startline="707" endline="709">
{
    cpst = 1;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/cpufreq/powernow-k8.c.ifdefed" startline="711" endline="714">
{
    printk (KERN_ERR BFX "numpst must be 1\n");
    return -ENODEV;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/cpufreq/powernow-k8.c.ifdefed" startline="925" endline="925">
{
    return -ENODEV;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/cpufreq/powernow-k8.c.ifdefed" startline="926" endline="926">
{
    return;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/cpufreq/powernow-k8.c.ifdefed" startline="927" endline="927">
{
    return;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/cpufreq/powernow-k8.c.ifdefed" startline="932" endline="984">
{
    u32 fid = 0;
    u32 vid = 0;
    int res, i;
    struct cpufreq_freqs freqs;
    dprintk ("cpu %d transition to index %u\n", smp_processor_id (), index);
    fid = data->powernow_table[index].index & 0xFF;
    vid = (data->powernow_table[index].index & 0xFF00) >> 8;
    dprintk ("table matched fid 0x%x, giving vid 0x%x\n", fid, vid);
    if (query_current_values_with_pending_wait (data))
        return 1;
    if ((data->currvid == vid) && (data->currfid == fid)) {
        dprintk ("target matches current values (fid 0x%x, vid 0x%x)\n", fid, vid);
        return 0;
    }
    if ((fid < HI_FID_TABLE_BOTTOM) && (data->currfid < HI_FID_TABLE_BOTTOM)) {
        printk (KERN_ERR PFX "ignoring illegal change in lo freq table-%x to 0x%x\n", data -> currfid, fid);
        return 1;
    }
    dprintk ("cpu %d, changing to fid 0x%x, vid 0x%x\n", smp_processor_id (), fid, vid);
    freqs.old = find_khz_freq_from_fid (data->currfid);
    freqs.new = find_khz_freq_from_fid (fid);
    for_each_cpu_mask (i, * (data -> available_cores)) {freqs
        .cpu = i cpufreq_notify_transition (&freqs, CPUFREQ_PRECHANGE)
    } res
    = transition_fid_vid (data, fid, vid);
    freqs.new = find_khz_freq_from_fid (data->currfid);
    for_each_cpu_mask (i, * (data -> available_cores)) {freqs
        .cpu = i cpufreq_notify_transition (&freqs, CPUFREQ_POSTCHANGE)
    }
    return res;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/cpufreq/powernow-k8.c.ifdefed" startline="953" endline="957">
{
    dprintk ("target matches current values (fid 0x%x, vid 0x%x)\n", fid, vid);
    return 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/cpufreq/powernow-k8.c.ifdefed" startline="959" endline="964">
{
    printk (KERN_ERR PFX "ignoring illegal change in lo freq table-%x to 0x%x\n", data -> currfid, fid);
    return 1;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/cpufreq/powernow-k8.c.ifdefed" startline="988" endline="1015">
{
    u32 pstate = 0;
    int res, i;
    struct cpufreq_freqs freqs;
    dprintk ("cpu %d transition to index %u\n", smp_processor_id (), index);
    pstate = index & HW_PSTATE_MASK;
    if (pstate > data->max_hw_pstate)
        return 0;
    freqs.old = find_khz_freq_from_pstate (data->powernow_table, data->currpstate);
    freqs.new = find_khz_freq_from_pstate (data->powernow_table, pstate);
    for_each_cpu_mask (i, * (data -> available_cores)) {freqs
        .cpu = i cpufreq_notify_transition (&freqs, CPUFREQ_PRECHANGE)
    } res
    = transition_pstate (data, pstate);
    freqs.new = find_khz_freq_from_pstate (data->powernow_table, pstate);
    for_each_cpu_mask (i, * (data -> available_cores)) {freqs
        .cpu = i cpufreq_notify_transition (&freqs, CPUFREQ_POSTCHANGE)
    }
    return res;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/cpufreq/powernow-k8.c.ifdefed" startline="1019" endline="1092">
{
    cpumask_t oldmask = CPU_MASK_ALL;
    struct powernow_k8_data *data = powernow_data[pol->cpu];
    u32 checkfid;
    u32 checkvid;
    unsigned int newstate;
    int ret = -EIO;
    if (!data)
        return -EINVAL;
    checkfid = data->currfid;
    checkvid = data->currvid;
    oldmask = current->cpus_allowed;
    set_cpus_allowed (current, cpumask_of_cpu (pol -> cpu));
    if (smp_processor_id () != pol->cpu) {
        printk (KERN_ERR PFX "limiting to cpu %u failed\n", pol -> cpu);
        goto err_out;
    }
    if (pending_bit_stuck ()) {
        printk (KERN_ERR PFX "failing targ, change pending bit set\n");
        goto err_out;
    }
    dprintk ("targ: cpu %d, %d kHz, min %d, max %d, relation %d\n", pol -> cpu, targfreq, pol -> min, pol -> max, relation);
    if (query_current_values_with_pending_wait (data))
        goto err_out;
    if (cpu_family != CPU_HW_PSTATE) {
        dprintk ("targ: curr fid 0x%x, vid 0x%x\n", data -> currfid, data -> currvid);
        if ((checkvid != data->currvid) || (checkfid != data->currfid)) {
            printk (KERN_INFO PFX "error - out of sync, fix 0x%x 0x%x, vid 0x%x 0x%x\n", checkfid, data -> currfid, checkvid, data -> currvid);
        }
    }
    if (cpufreq_frequency_table_target (pol, data->powernow_table, targfreq, relation, &newstate))
        goto err_out;
    mutex_lock (& fidvid_mutex);
    powernow_k8_acpi_pst_values (data, newstate);
    if (cpu_family == CPU_HW_PSTATE)
        ret = transition_frequency_pstate (data, newstate);
    else
        ret = transition_frequency_fidvid (data, newstate);
    if (ret) {
        printk (KERN_ERR PFX "transition frequency failed\n");
        ret = 1;
        mutex_unlock (& fidvid_mutex);
        goto err_out;
    }
    mutex_unlock (& fidvid_mutex);
    if (cpu_family == CPU_HW_PSTATE)
        pol->cur = find_khz_freq_from_pstate (data->powernow_table, newstate);
    else
        pol->cur = find_khz_freq_from_fid (data->currfid);
    ret = 0;
err_out :
    set_cpus_allowed (current, oldmask);
    return ret;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/cpufreq/powernow-k8.c.ifdefed" startline="1037" endline="1040">
{
    printk (KERN_ERR PFX "limiting to cpu %u failed\n", pol -> cpu);
    goto err_out;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/cpufreq/powernow-k8.c.ifdefed" startline="1042" endline="1045">
{
    printk (KERN_ERR PFX "failing targ, change pending bit set\n");
    goto err_out;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/cpufreq/powernow-k8.c.ifdefed" startline="1053" endline="1062">
{
    dprintk ("targ: curr fid 0x%x, vid 0x%x\n", data -> currfid, data -> currvid);
    if ((checkvid != data->currvid) || (checkfid != data->currfid)) {
        printk (KERN_INFO PFX "error - out of sync, fix 0x%x 0x%x, vid 0x%x 0x%x\n", checkfid, data -> currfid, checkvid, data -> currvid);
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/cpufreq/powernow-k8.c.ifdefed" startline="1057" endline="1061">
{
    printk (KERN_INFO PFX "error - out of sync, fix 0x%x 0x%x, vid 0x%x 0x%x\n", checkfid, data -> currfid, checkvid, data -> currvid);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/cpufreq/powernow-k8.c.ifdefed" startline="1075" endline="1080">
{
    printk (KERN_ERR PFX "transition frequency failed\n");
    ret = 1;
    mutex_unlock (& fidvid_mutex);
    goto err_out;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/cpufreq/powernow-k8.c.ifdefed" startline="1096" endline="1103">
{
    struct powernow_k8_data *data = powernow_data[pol->cpu];
    if (!data)
        return -EINVAL;
    return cpufreq_frequency_table_verify (pol, data->powernow_table);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/cpufreq/powernow-k8.c.ifdefed" startline="1107" endline="1215">
{
    struct powernow_k8_data *data;
    cpumask_t oldmask = CPU_MASK_ALL;
    int rc;
    if (!cpu_online (pol->cpu))
        return -ENODEV;
    if (!check_supported_cpu (pol->cpu))
        return -ENODEV;
    data = kzalloc (sizeof (struct powernow_k8_data), GFP_KERNEL);
    if (!data) {
        printk (KERN_ERR PFX "unable to alloc powernow_k8_data");
        return -ENOMEM;
    }
    data->cpu = pol->cpu;
    if (powernow_k8_cpu_init_acpi (data)) {
        if (num_online_cpus () != 1) {
            printk (KERN_ERR PFX "MP systems not supported by PSB BIOS structure\n");
            kfree (data);
            return -ENODEV;
        }
        if (pol->cpu != 0) {
            printk (KERN_ERR PFX "No _PSS objects for CPU other than CPU0\n");
            kfree (data);
            return -ENODEV;
        }
        rc = find_psb_table (data);
        if (rc) {
            kfree (data);
            return -ENODEV;
        }
    }
    oldmask = current->cpus_allowed;
    set_cpus_allowed (current, cpumask_of_cpu (pol -> cpu));
    if (smp_processor_id () != pol->cpu) {
        printk (KERN_ERR PFX "limiting to cpu %u failed\n", pol -> cpu);
        goto err_out;
    }
    if (pending_bit_stuck ()) {
        printk (KERN_ERR PFX "failing init, change pending bit set\n");
        goto err_out;
    }
    if (query_current_values_with_pending_wait (data))
        goto err_out;
    if (cpu_family == CPU_OPTERON)
        fidvid_msr_init ();
    set_cpus_allowed (current, oldmask);
    if (cpu_family == CPU_HW_PSTATE)
        pol->cpus = cpumask_of_cpu (pol->cpu);
    else
        pol->cpus = per_cpu (cpu_core_map, pol->cpu);
    data->available_cores = &(pol->cpus);
    pol->cpuinfo.transition_latency = (((data->rvo + 8) * data->vstable * VST_UNITS_20US) + (3 * (1 << data->irt) * 10)) * 1000;
    if (cpu_family == CPU_HW_PSTATE)
        pol->cur = find_khz_freq_from_pstate (data->powernow_table, data->currpstate);
    else
        pol->cur = find_khz_freq_from_fid (data->currfid);
    dprintk ("policy current frequency %d kHz\n", pol -> cur);
    if (cpufreq_frequency_table_cpuinfo (pol, data->powernow_table)) {
        printk (KERN_ERR PFX "invalid powernow_table\n");
        powernow_k8_cpu_exit_acpi (data);
        kfree (data -> powernow_table);
        kfree (data);
        return -EINVAL;
    }
    cpufreq_frequency_table_get_attr (data -> powernow_table, pol -> cpu);
    if (cpu_family == CPU_HW_PSTATE)
        dprintk ("cpu_init done, current pstate 0x%x\n", data->currpstate);
    else
        dprintk ("cpu_init done, current fid 0x%x, vid 0x%x\n", data->currfid, data->currvid);
    powernow_data[pol->cpu] = data;
    return 0;
err_out :
    set_cpus_allowed (current, oldmask);
    powernow_k8_cpu_exit_acpi (data);
    kfree (data);
    return -ENODEV;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/cpufreq/powernow-k8.c.ifdefed" startline="1119" endline="1122">
{
    printk (KERN_ERR PFX "unable to alloc powernow_k8_data");
    return -ENOMEM;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/cpufreq/powernow-k8.c.ifdefed" startline="1126" endline="1146">
{
    if (num_online_cpus () != 1) {
        printk (KERN_ERR PFX "MP systems not supported by PSB BIOS structure\n");
        kfree (data);
        return -ENODEV;
    }
    if (pol->cpu != 0) {
        printk (KERN_ERR PFX "No _PSS objects for CPU other than CPU0\n");
        kfree (data);
        return -ENODEV;
    }
    rc = find_psb_table (data);
    if (rc) {
        kfree (data);
        return -ENODEV;
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/cpufreq/powernow-k8.c.ifdefed" startline="1131" endline="1135">
{
    printk (KERN_ERR PFX "MP systems not supported by PSB BIOS structure\n");
    kfree (data);
    return -ENODEV;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/cpufreq/powernow-k8.c.ifdefed" startline="1136" endline="1140">
{
    printk (KERN_ERR PFX "No _PSS objects for CPU other than CPU0\n");
    kfree (data);
    return -ENODEV;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/cpufreq/powernow-k8.c.ifdefed" startline="1142" endline="1145">
{
    kfree (data);
    return -ENODEV;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/cpufreq/powernow-k8.c.ifdefed" startline="1152" endline="1155">
{
    printk (KERN_ERR PFX "limiting to cpu %u failed\n", pol -> cpu);
    goto err_out;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/cpufreq/powernow-k8.c.ifdefed" startline="1157" endline="1160">
{
    printk (KERN_ERR PFX "failing init, change pending bit set\n");
    goto err_out;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/cpufreq/powernow-k8.c.ifdefed" startline="1189" endline="1195">
{
    printk (KERN_ERR PFX "invalid powernow_table\n");
    powernow_k8_cpu_exit_acpi (data);
    kfree (data -> powernow_table);
    kfree (data);
    return -EINVAL;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/cpufreq/powernow-k8.c.ifdefed" startline="1218" endline="1232">
{
    struct powernow_k8_data *data = powernow_data[pol->cpu];
    if (!data)
        return -EINVAL;
    powernow_k8_cpu_exit_acpi (data);
    cpufreq_frequency_table_put_attr (pol -> cpu);
    kfree (data -> powernow_table);
    kfree (data);
    return 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/cpufreq/powernow-k8.c.ifdefed" startline="1235" endline="1264">
{
    struct powernow_k8_data *data;
    cpumask_t oldmask = current->cpus_allowed;
    unsigned int khz = 0;
    data = powernow_data[first_cpu (per_cpu (cpu_core_map, cpu))];
    if (!data)
        return -EINVAL;
    set_cpus_allowed (current, cpumask_of_cpu (cpu));
    if (smp_processor_id () != cpu) {
        printk (KERN_ERR PFX "limiting to CPU %d failed in powernowk8_get\n", cpu);
        set_cpus_allowed (current, oldmask);
        return 0;
    }
    if (query_current_values_with_pending_wait (data))
        goto out;
    if (cpu_family == CPU_HW_PSTATE)
        khz = find_khz_freq_from_pstate (data->powernow_table, data->currpstate);
    else
        khz = find_khz_freq_from_fid (data->currfid);
out :
    set_cpus_allowed (current, oldmask);
    return khz;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/cpufreq/powernow-k8.c.ifdefed" startline="1246" endline="1250">
{
    printk (KERN_ERR PFX "limiting to CPU %d failed in powernowk8_get\n", cpu);
    set_cpus_allowed (current, oldmask);
    return 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/cpufreq/powernow-k8.c.ifdefed" startline="1284" endline="1301">
{
    unsigned int i, supported_cpus = 0;

    for_each_online_cpu (i) {
        if (check_supported_cpu (i))
            supported_cpus++;
    }

    if (supported_cpus == num_online_cpus ()) {
        printk (KERN_INFO PFX "Found %d %s " "processors (%d cpu cores) (" VERSION ")\n", num_online_nodes (), boot_cpu_data.x86_model_id, supported_cpus);
        return cpufreq_register_driver (&cpufreq_amd64_driver);
    }
    return -ENODEV;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/cpufreq/powernow-k8.c.ifdefed" startline="1287" endline="1290">
{
    if (check_supported_cpu (i))
        supported_cpus++;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/cpufreq/powernow-k8.c.ifdefed" startline="1292" endline="1298">
{
    printk (KERN_INFO PFX "Found %d %s " "processors (%d cpu cores) (" VERSION ")\n", num_online_nodes (), boot_cpu_data.x86_model_id, supported_cpus);
    return cpufreq_register_driver (&cpufreq_amd64_driver);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/cpufreq/powernow-k8.c.ifdefed" startline="1305" endline="1309">
{
    dprintk ("exit\n");
    cpufreq_unregister_driver (& cpufreq_amd64_driver);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/perfctr-watchdog.c.ifdefed" startline="57" endline="74">
{
    switch (boot_cpu_data.x86_vendor) {
    case X86_VENDOR_AMD :
        return (msr - MSR_K7_PERFCTR0);
    case X86_VENDOR_INTEL :
        if (cpu_has (&boot_cpu_data, X86_FEATURE_ARCH_PERFMON))
            return (msr - MSR_ARCH_PERFMON_PERFCTR0);
        switch (boot_cpu_data.x86) {
        case 6 :
            return (msr - MSR_P6_PERFCTR0);
        case 15 :
            return (msr - MSR_P4_BPU_PERFCTR0);
        }
    }
    return 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/perfctr-watchdog.c.ifdefed" startline="59" endline="72">
{
case X86_VENDOR_AMD :
    return (msr - MSR_K7_PERFCTR0);
case X86_VENDOR_INTEL :
    if (cpu_has (&boot_cpu_data, X86_FEATURE_ARCH_PERFMON))
        return (msr - MSR_ARCH_PERFMON_PERFCTR0);
    switch (boot_cpu_data.x86) {
    case 6 :
        return (msr - MSR_P6_PERFCTR0);
    case 15 :
        return (msr - MSR_P4_BPU_PERFCTR0);
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/perfctr-watchdog.c.ifdefed" startline="66" endline="71">
{
case 6 :
    return (msr - MSR_P6_PERFCTR0);
case 15 :
    return (msr - MSR_P4_BPU_PERFCTR0);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/perfctr-watchdog.c.ifdefed" startline="79" endline="97">
{
    switch (boot_cpu_data.x86_vendor) {
    case X86_VENDOR_AMD :
        return (msr - MSR_K7_EVNTSEL0);
    case X86_VENDOR_INTEL :
        if (cpu_has (&boot_cpu_data, X86_FEATURE_ARCH_PERFMON))
            return (msr - MSR_ARCH_PERFMON_EVENTSEL0);
        switch (boot_cpu_data.x86) {
        case 6 :
            return (msr - MSR_P6_EVNTSEL0);
        case 15 :
            return (msr - MSR_P4_BSU_ESCR0);
        }
    }
    return 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/perfctr-watchdog.c.ifdefed" startline="81" endline="94">
{
case X86_VENDOR_AMD :
    return (msr - MSR_K7_EVNTSEL0);
case X86_VENDOR_INTEL :
    if (cpu_has (&boot_cpu_data, X86_FEATURE_ARCH_PERFMON))
        return (msr - MSR_ARCH_PERFMON_EVENTSEL0);
    switch (boot_cpu_data.x86) {
    case 6 :
        return (msr - MSR_P6_EVNTSEL0);
    case 15 :
        return (msr - MSR_P4_BSU_ESCR0);
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/perfctr-watchdog.c.ifdefed" startline="88" endline="93">
{
case 6 :
    return (msr - MSR_P6_EVNTSEL0);
case 15 :
    return (msr - MSR_P4_BSU_ESCR0);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/perfctr-watchdog.c.ifdefed" startline="101" endline="105">
{
    BUG_ON (counter > NMI_MAX_COUNTER_BITS);
    return (!test_bit (counter, perfctr_nmi_owner));
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/perfctr-watchdog.c.ifdefed" startline="109" endline="116">
{
    unsigned int counter;
    counter = nmi_perfctr_msr_to_bit (msr);
    BUG_ON (counter > NMI_MAX_COUNTER_BITS);
    return (!test_bit (counter, perfctr_nmi_owner));
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/perfctr-watchdog.c.ifdefed" startline="119" endline="130">
{
    unsigned int counter;
    counter = nmi_perfctr_msr_to_bit (msr);
    if (counter > NMI_MAX_COUNTER_BITS)
        return 1;
    if (!test_and_set_bit (counter, perfctr_nmi_owner))
        return 1;
    return 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/perfctr-watchdog.c.ifdefed" startline="133" endline="142">
{
    unsigned int counter;
    counter = nmi_perfctr_msr_to_bit (msr);
    if (counter > NMI_MAX_COUNTER_BITS)
        return;
    clear_bit (counter, perfctr_nmi_owner);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/perfctr-watchdog.c.ifdefed" startline="145" endline="156">
{
    unsigned int counter;
    counter = nmi_evntsel_msr_to_bit (msr);
    if (counter > NMI_MAX_COUNTER_BITS)
        return 1;
    if (!test_and_set_bit (counter, evntsel_nmi_owner))
        return 1;
    return 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/perfctr-watchdog.c.ifdefed" startline="159" endline="168">
{
    unsigned int counter;
    counter = nmi_evntsel_msr_to_bit (msr);
    if (counter > NMI_MAX_COUNTER_BITS)
        return;
    clear_bit (counter, evntsel_nmi_owner);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/perfctr-watchdog.c.ifdefed" startline="178" endline="188">
{
    BUG_ON (nmi_watchdog != NMI_LOCAL_APIC);
    if (atomic_read (&nmi_active) <= 0)
        return;
    on_each_cpu (stop_apic_nmi_watchdog, NULL, 0, 1);
    wd_ops->unreserve ();
    BUG_ON (atomic_read (& nmi_active) != 0);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/perfctr-watchdog.c.ifdefed" startline="191" endline="208">
{
    BUG_ON (nmi_watchdog != NMI_LOCAL_APIC);
    if (atomic_read (&nmi_active) != 0)
        return;
    if (!wd_ops)
        return;
    if (!wd_ops->reserve ()) {
        printk (KERN_ERR "NMI watchdog: cannot reserve perfctrs\n");
        return;
    }
    on_each_cpu (setup_apic_nmi_watchdog, NULL, 0, 1);
    touch_nmi_watchdog ();
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/perfctr-watchdog.c.ifdefed" startline="201" endline="204">
{
    printk (KERN_ERR "NMI watchdog: cannot reserve perfctrs\n");
    return;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/perfctr-watchdog.c.ifdefed" startline="215" endline="234">
{
    u64 counter_val;
    unsigned int retval = hz;
    counter_val = (u64) cpu_khz * 1000;
    do_div (counter_val, retval);
    if (counter_val > 0x7fffffffULL) {
        u64 count = (u64) cpu_khz * 1000;
        do_div (count, 0x7fffffffUL);
        retval = count + 1;
    }
    return retval;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/perfctr-watchdog.c.ifdefed" startline="228" endline="232">
{
    u64 count = (u64) cpu_khz * 1000;
    do_div (count, 0x7fffffffUL);
    retval = count + 1;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/perfctr-watchdog.c.ifdefed" startline="238" endline="245">
{
    u64 count = (u64) cpu_khz * 1000;
    do_div (count, nmi_hz);
    if (descr)
        Dprintk ("setting %s to -0x%08Lx\n", descr, count);
    wrmsrl (perfctr_msr, 0 - count);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/perfctr-watchdog.c.ifdefed" startline="249" endline="256">
{
    u64 count = (u64) cpu_khz * 1000;
    do_div (count, nmi_hz);
    if (descr)
        Dprintk ("setting %s to -0x%08Lx\n", descr, count);
    wrmsr (perfctr_msr, (u32) (- count), 0);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/perfctr-watchdog.c.ifdefed" startline="269" endline="295">
{
    unsigned int perfctr_msr, evntsel_msr;
    unsigned int evntsel;
    struct nmi_watchdog_ctlblk *wd = &__get_cpu_var (nmi_watchdog_ctlblk);
    perfctr_msr = wd_ops->perfctr;
    evntsel_msr = wd_ops->evntsel;
    wrmsrl (perfctr_msr, 0UL);
    evntsel = K7_EVNTSEL_INT | K7_EVNTSEL_OS | K7_EVNTSEL_USR | K7_NMI_EVENT;
    wrmsr (evntsel_msr, evntsel, 0);
    write_watchdog_counter (perfctr_msr, "K7_PERFCTR0", nmi_hz);
    apic_write (APIC_LVTPC, APIC_DM_NMI);
    evntsel |= K7_EVNTSEL_ENABLE;
    wrmsr (evntsel_msr, evntsel, 0);
    wd->perfctr_msr = perfctr_msr;
    wd->evntsel_msr = evntsel_msr;
    wd->cccr_msr = 0;
    return 1;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/perfctr-watchdog.c.ifdefed" startline="298" endline="302">
{
    struct nmi_watchdog_ctlblk *wd = &__get_cpu_var (nmi_watchdog_ctlblk);
    wrmsr (wd -> evntsel_msr, 0, 0);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/perfctr-watchdog.c.ifdefed" startline="305" endline="314">
{
    if (!reserve_perfctr_nmi (wd_ops->perfctr))
        return 0;
    if (!reserve_evntsel_nmi (wd_ops->evntsel)) {
        release_perfctr_nmi (wd_ops -> perfctr);
        return 0;
    }
    return 1;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/perfctr-watchdog.c.ifdefed" startline="309" endline="312">
{
    release_perfctr_nmi (wd_ops -> perfctr);
    return 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/perfctr-watchdog.c.ifdefed" startline="317" endline="320">
{
    release_evntsel_nmi (wd_ops -> evntsel);
    release_perfctr_nmi (wd_ops -> perfctr);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/perfctr-watchdog.c.ifdefed" startline="323" endline="326">
{
    write_watchdog_counter (wd -> perfctr_msr, NULL, nmi_hz);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/perfctr-watchdog.c.ifdefed" startline="349" endline="378">
{
    unsigned int perfctr_msr, evntsel_msr;
    unsigned int evntsel;
    struct nmi_watchdog_ctlblk *wd = &__get_cpu_var (nmi_watchdog_ctlblk);
    perfctr_msr = wd_ops->perfctr;
    evntsel_msr = wd_ops->evntsel;
    if (wrmsr_safe (perfctr_msr, 0, 0) < 0)
        return 0;
    evntsel = P6_EVNTSEL_INT | P6_EVNTSEL_OS | P6_EVNTSEL_USR | P6_NMI_EVENT;
    wrmsr (evntsel_msr, evntsel, 0);
    nmi_hz = adjust_for_32bit_ctr (nmi_hz);
    write_watchdog_counter32 (perfctr_msr, "P6_PERFCTR0", nmi_hz);
    apic_write (APIC_LVTPC, APIC_DM_NMI);
    evntsel |= P6_EVNTSEL0_ENABLE;
    wrmsr (evntsel_msr, evntsel, 0);
    wd->perfctr_msr = perfctr_msr;
    wd->evntsel_msr = evntsel_msr;
    wd->cccr_msr = 0;
    return 1;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/perfctr-watchdog.c.ifdefed" startline="381" endline="389">
{
    apic_write (APIC_LVTPC, APIC_DM_NMI);
    write_watchdog_counter32 (wd -> perfctr_msr, NULL, nmi_hz);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/perfctr-watchdog.c.ifdefed" startline="423" endline="484">
{
    unsigned int perfctr_msr, evntsel_msr, cccr_msr;
    unsigned int evntsel, cccr_val;
    unsigned int misc_enable, dummy;
    unsigned int ht_num;
    struct nmi_watchdog_ctlblk *wd = &__get_cpu_var (nmi_watchdog_ctlblk);
    rdmsr (MSR_IA32_MISC_ENABLE, misc_enable, dummy);
    if (!(misc_enable & MSR_P4_MISC_ENABLE_PERF_AVAIL))
        return 0;
    ht_num = 0;
    if (!ht_num) {
        perfctr_msr = MSR_P4_IQ_PERFCTR0;
        evntsel_msr = MSR_P4_CRU_ESCR0;
        cccr_msr = MSR_P4_IQ_CCCR0;
        cccr_val = P4_CCCR_OVF_PMI0 | P4_CCCR_ESCR_SELECT (4);
    }
    else {
        perfctr_msr = MSR_P4_IQ_PERFCTR1;
        evntsel_msr = MSR_P4_CRU_ESCR0;
        cccr_msr = MSR_P4_IQ_CCCR1;
        cccr_val = P4_CCCR_OVF_PMI1 | P4_CCCR_ESCR_SELECT (4);
    }
    evntsel = P4_ESCR_EVENT_SELECT (0x3F) | P4_ESCR_OS | P4_ESCR_USR;
    cccr_val |= P4_CCCR_THRESHOLD (15) | P4_CCCR_COMPLEMENT | P4_CCCR_COMPARE | P4_CCCR_REQUIRED;
    wrmsr (evntsel_msr, evntsel, 0);
    wrmsr (cccr_msr, cccr_val, 0);
    write_watchdog_counter (perfctr_msr, "P4_IQ_COUNTER0", nmi_hz);
    apic_write (APIC_LVTPC, APIC_DM_NMI);
    cccr_val |= P4_CCCR_ENABLE;
    wrmsr (cccr_msr, cccr_val, 0);
    wd->perfctr_msr = perfctr_msr;
    wd->evntsel_msr = evntsel_msr;
    wd->cccr_msr = cccr_msr;
    return 1;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/perfctr-watchdog.c.ifdefed" startline="451" endline="457">
{
    perfctr_msr = MSR_P4_IQ_PERFCTR0;
    evntsel_msr = MSR_P4_CRU_ESCR0;
    cccr_msr = MSR_P4_IQ_CCCR0;
    cccr_val = P4_CCCR_OVF_PMI0 | P4_CCCR_ESCR_SELECT (4);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/perfctr-watchdog.c.ifdefed" startline="457" endline="463">
{
    perfctr_msr = MSR_P4_IQ_PERFCTR1;
    evntsel_msr = MSR_P4_CRU_ESCR0;
    cccr_msr = MSR_P4_IQ_CCCR1;
    cccr_val = P4_CCCR_OVF_PMI1 | P4_CCCR_ESCR_SELECT (4);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/perfctr-watchdog.c.ifdefed" startline="487" endline="491">
{
    struct nmi_watchdog_ctlblk *wd = &__get_cpu_var (nmi_watchdog_ctlblk);
    wrmsr (wd -> cccr_msr, 0, 0);
    wrmsr (wd -> evntsel_msr, 0, 0);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/perfctr-watchdog.c.ifdefed" startline="494" endline="513">
{
    if (!reserve_perfctr_nmi (MSR_P4_IQ_PERFCTR0))
        return 0;
    if (!reserve_evntsel_nmi (MSR_P4_CRU_ESCR0))
        goto fail2;
    return 1;
fail2 :
    release_perfctr_nmi (MSR_P4_IQ_PERFCTR0);
    return 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/perfctr-watchdog.c.ifdefed" startline="516" endline="523">
{
    release_evntsel_nmi (MSR_P4_CRU_ESCR0);
    release_perfctr_nmi (MSR_P4_IQ_PERFCTR0);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/perfctr-watchdog.c.ifdefed" startline="526" endline="541">
{
    unsigned dummy;
    rdmsrl (wd -> cccr_msr, dummy);
    dummy &= ~P4_CCCR_OVF;
    wrmsrl (wd -> cccr_msr, dummy);
    apic_write (APIC_LVTPC, APIC_DM_NMI);
    write_watchdog_counter (wd -> perfctr_msr, NULL, nmi_hz);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/perfctr-watchdog.c.ifdefed" startline="564" endline="606">
{
    unsigned int ebx;
    union cpuid10_eax eax;
    unsigned int unused;
    unsigned int perfctr_msr, evntsel_msr;
    unsigned int evntsel;
    struct nmi_watchdog_ctlblk *wd = &__get_cpu_var (nmi_watchdog_ctlblk);
    cpuid (10, & (eax.full), & ebx, & unused, & unused);
    if ((eax.split.mask_length < (ARCH_PERFMON_UNHALTED_CORE_CYCLES_INDEX + 1)) || (ebx & ARCH_PERFMON_UNHALTED_CORE_CYCLES_PRESENT))
        return 0;
    perfctr_msr = wd_ops->perfctr;
    evntsel_msr = wd_ops->evntsel;
    wrmsrl (perfctr_msr, 0UL);
    evntsel = ARCH_PERFMON_EVENTSEL_INT | ARCH_PERFMON_EVENTSEL_OS | ARCH_PERFMON_EVENTSEL_USR | ARCH_PERFMON_NMI_EVENT_SEL | ARCH_PERFMON_NMI_EVENT_UMASK;
    wrmsr (evntsel_msr, evntsel, 0);
    nmi_hz = adjust_for_32bit_ctr (nmi_hz);
    write_watchdog_counter32 (perfctr_msr, "INTEL_ARCH_PERFCTR0", nmi_hz);
    apic_write (APIC_LVTPC, APIC_DM_NMI);
    evntsel |= ARCH_PERFMON_EVENTSEL0_ENABLE;
    wrmsr (evntsel_msr, evntsel, 0);
    wd->perfctr_msr = perfctr_msr;
    wd->evntsel_msr = evntsel_msr;
    wd->cccr_msr = 0;
    intel_arch_wd_ops.checkbit = 1ULL << (eax.split.bit_width - 1);
    return 1;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/perfctr-watchdog.c.ifdefed" startline="629" endline="666">
{
    switch (boot_cpu_data.x86_vendor) {
    case X86_VENDOR_AMD :
        if (boot_cpu_data.x86 != 6 && boot_cpu_data.x86 != 15 && boot_cpu_data.x86 != 16)
            return;
        wd_ops = &k7_wd_ops;
        break;
    case X86_VENDOR_INTEL :
        if (boot_cpu_data.x86 == 6 && boot_cpu_data.x86_model == 14) {
            wd_ops = &coreduo_wd_ops;
            break;
        }
        if (cpu_has (&boot_cpu_data, X86_FEATURE_ARCH_PERFMON)) {
            wd_ops = &intel_arch_wd_ops;
            break;
        }
        switch (boot_cpu_data.x86) {
        case 6 :
            if (boot_cpu_data.x86_model > 0xd)
                return;
            wd_ops = &p6_wd_ops;
            break;
        case 15 :
            if (boot_cpu_data.x86_model > 0x4)
                return;
            wd_ops = &p4_wd_ops;
            break;
        default :
            return;
        }
        break;
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/perfctr-watchdog.c.ifdefed" startline="630" endline="665">
{
case X86_VENDOR_AMD :
    if (boot_cpu_data.x86 != 6 && boot_cpu_data.x86 != 15 && boot_cpu_data.x86 != 16)
        return;
    wd_ops = &k7_wd_ops;
    break;
case X86_VENDOR_INTEL :
    if (boot_cpu_data.x86 == 6 && boot_cpu_data.x86_model == 14) {
        wd_ops = &coreduo_wd_ops;
        break;
    }
    if (cpu_has (&boot_cpu_data, X86_FEATURE_ARCH_PERFMON)) {
        wd_ops = &intel_arch_wd_ops;
        break;
    }
    switch (boot_cpu_data.x86) {
    case 6 :
        if (boot_cpu_data.x86_model > 0xd)
            return;
        wd_ops = &p6_wd_ops;
        break;
    case 15 :
        if (boot_cpu_data.x86_model > 0x4)
            return;
        wd_ops = &p4_wd_ops;
        break;
    default :
        return;
    }
    break;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/perfctr-watchdog.c.ifdefed" startline="640" endline="643">
{
    wd_ops = &coreduo_wd_ops;
    break;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/perfctr-watchdog.c.ifdefed" startline="644" endline="647">
{
    wd_ops = &intel_arch_wd_ops;
    break;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/perfctr-watchdog.c.ifdefed" startline="648" endline="663">
{
case 6 :
    if (boot_cpu_data.x86_model > 0xd)
        return;
    wd_ops = &p6_wd_ops;
    break;
case 15 :
    if (boot_cpu_data.x86_model > 0x4)
        return;
    wd_ops = &p4_wd_ops;
    break;
default :
    return;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/perfctr-watchdog.c.ifdefed" startline="671" endline="691">
{
    if (!wd_ops) {
        probe_nmi_watchdog ();
        if (!wd_ops)
            return -1;
        if (!wd_ops->reserve ()) {
            printk (KERN_ERR "NMI watchdog: cannot reserve perfctrs\n");
            return -1;
        }
    }
    if (!(wd_ops->setup (nmi_hz))) {
        printk (KERN_ERR "Cannot setup NMI watchdog on CPU %d\n", raw_smp_processor_id ());
        return -1;
    }
    return 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/perfctr-watchdog.c.ifdefed" startline="672" endline="682">
{
    probe_nmi_watchdog ();
    if (!wd_ops)
        return -1;
    if (!wd_ops->reserve ()) {
        printk (KERN_ERR "NMI watchdog: cannot reserve perfctrs\n");
        return -1;
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/perfctr-watchdog.c.ifdefed" startline="677" endline="681">
{
    printk (KERN_ERR "NMI watchdog: cannot reserve perfctrs\n");
    return -1;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/perfctr-watchdog.c.ifdefed" startline="684" endline="688">
{
    printk (KERN_ERR "Cannot setup NMI watchdog on CPU %d\n", raw_smp_processor_id ());
    return -1;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/perfctr-watchdog.c.ifdefed" startline="694" endline="697">
{
    if (wd_ops)
        wd_ops->stop ();
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/perfctr-watchdog.c.ifdefed" startline="700" endline="706">
{
    struct nmi_watchdog_ctlblk *wd = &__get_cpu_var (nmi_watchdog_ctlblk);
    if (wd->perfctr_msr == MSR_P6_PERFCTR0 || wd->perfctr_msr == MSR_ARCH_PERFMON_PERFCTR1)
        hz = adjust_for_32bit_ctr (hz);
    return hz;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/perfctr-watchdog.c.ifdefed" startline="709" endline="718">
{
    struct nmi_watchdog_ctlblk *wd = &__get_cpu_var (nmi_watchdog_ctlblk);
    u64 ctr;
    rdmsrl (wd -> perfctr_msr, ctr);
    if (ctr & wd_ops->checkbit) {
        return 0;
    }
    wd_ops->rearm (wd, nmi_hz);
    return 1;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/perfctr-watchdog.c.ifdefed" startline="713" endline="715">
{
    return 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/perfctr-watchdog.c.ifdefed" startline="721" endline="723">
{
    return wd_ops != NULL;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/mtrr/state.c.ifdefed" startline="12" endline="40">
{
    unsigned int cr0;
    local_irq_save (ctxt -> flags);
    if (use_intel () || is_cpu (CYRIX)) {
        if (cpu_has_pge) {
            ctxt->cr4val = read_cr4 ();
            write_cr4 (ctxt -> cr4val & ~ X86_CR4_PGE);
        }
        cr0 = read_cr0 () | 0x40000000;
        wbinvd ();
        write_cr0 (cr0);
        wbinvd ();
        if (use_intel ())
            rdmsr (MTRRdefType_MSR, ctxt->deftype_lo, ctxt->deftype_hi);
        else
            ctxt->ccr3 = getCx86 (CX86_CCR3);
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/mtrr/state.c.ifdefed" startline="18" endline="39">
{
    if (cpu_has_pge) {
        ctxt->cr4val = read_cr4 ();
        write_cr4 (ctxt -> cr4val & ~ X86_CR4_PGE);
    }
    cr0 = read_cr0 () | 0x40000000;
    wbinvd ();
    write_cr0 (cr0);
    wbinvd ();
    if (use_intel ())
        rdmsr (MTRRdefType_MSR, ctxt->deftype_lo, ctxt->deftype_hi);
    else
        ctxt->ccr3 = getCx86 (CX86_CCR3);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/mtrr/state.c.ifdefed" startline="21" endline="24">
{
    ctxt->cr4val = read_cr4 ();
    write_cr4 (ctxt -> cr4val & ~ X86_CR4_PGE);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/mtrr/state.c.ifdefed" startline="43" endline="51">
{
    if (use_intel ())
        mtrr_wrmsr (MTRRdefType_MSR, ctxt->deftype_lo & 0xf300UL, ctxt->deftype_hi);
    else if (is_cpu (CYRIX))
        setCx86 (CX86_CCR3, (ctxt->ccr3 & 0x0f) | 0x10);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/mtrr/state.c.ifdefed" startline="55" endline="78">
{
    if (use_intel () || is_cpu (CYRIX)) {
        wbinvd ();
        if (use_intel ())
            mtrr_wrmsr (MTRRdefType_MSR, ctxt->deftype_lo, ctxt->deftype_hi);
        else
            setCx86 (CX86_CCR3, ctxt->ccr3);
        write_cr0 (read_cr0 () & 0xbfffffff);
        if (cpu_has_pge)
            write_cr4 (ctxt->cr4val);
    }
    local_irq_restore (ctxt -> flags);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/mtrr/state.c.ifdefed" startline="56" endline="75">
{
    wbinvd ();
    if (use_intel ())
        mtrr_wrmsr (MTRRdefType_MSR, ctxt->deftype_lo, ctxt->deftype_hi);
    else
        setCx86 (CX86_CCR3, ctxt->ccr3);
    write_cr0 (read_cr0 () & 0xbfffffff);
    if (cpu_has_pge)
        write_cr4 (ctxt->cr4val);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/mtrr/if.c.ifdefed" startline="32" endline="34">
{
    return (x <= 6) ? mtrr_strings[x] : "?";
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/mtrr/generic.c.ifdefed" startline="47" endline="50">
{
    rdmsr (MTRRphysBase_MSR (index), vr -> base_lo, vr -> base_hi);
    rdmsr (MTRRphysMask_MSR (index), vr -> mask_lo, vr -> mask_hi);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/mtrr/generic.c.ifdefed" startline="54" endline="64">
{
    unsigned int *p = (unsigned int *) frs;
    int i;
    rdmsr (MTRRfix64K_00000_MSR, p [0], p [1]);
    for (i = 0; i < 2; i++)
        rdmsr (MTRRfix16K_80000_MSR +i, p[2 + i * 2], p[3 + i * 2]);
    for (i = 0; i < 8; i++)
        rdmsr (MTRRfix4K_C0000_MSR +i, p[6 + i * 2], p[7 + i * 2]);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/mtrr/generic.c.ifdefed" startline="67" endline="70">
{
    if (cpu_has_mtrr)
        get_fixed_ranges (mtrr_state.fixed_ranges);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/mtrr/generic.c.ifdefed" startline="73" endline="79">
{
    unsigned i;
    for (i = 0; i < 8; ++i, ++types, base += step)
        printk (KERN_INFO "MTRR %05X-%05X %s\n", base, base +step - 1, mtrr_attrib_to_str (*types));
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/mtrr/generic.c.ifdefed" startline="83" endline="139">
{
    unsigned int i;
    struct mtrr_var_range *vrs;
    unsigned lo, dummy;
    if (!mtrr_state.var_ranges) {
        mtrr_state.var_ranges = kmalloc (num_var_ranges * sizeof (struct mtrr_var_range), GFP_KERNEL);
        if (!mtrr_state.var_ranges)
            return;
    }
    vrs = mtrr_state.var_ranges;
    rdmsr (MTRRcap_MSR, lo, dummy);
    mtrr_state.have_fixed = (lo >> 8) & 1;
    for (i = 0; i < num_var_ranges; i++)
        get_mtrr_var_range (i, &vrs[i]);
    if (mtrr_state.have_fixed)
        get_fixed_ranges (mtrr_state.fixed_ranges);
    rdmsr (MTRRdefType_MSR, lo, dummy);
    mtrr_state.def_type = (lo & 0xff);
    mtrr_state.enabled = (lo & 0xc00) >> 10;
    if (mtrr_show) {
        int high_width;
        printk (KERN_INFO "MTRR default type: %s\n", mtrr_attrib_to_str (mtrr_state.def_type));
        if (mtrr_state.have_fixed) {
            printk (KERN_INFO "MTRR fixed ranges %sabled:\n", mtrr_state.enabled & 1 ? "en" : "dis");
            print_fixed (0x00000, 0x10000, mtrr_state.fixed_ranges + 0);
            for (i = 0; i < 2; ++i)
                print_fixed (0x80000 + i * 0x20000, 0x04000, mtrr_state.fixed_ranges + (i + 1) * 8);
            for (i = 0; i < 8; ++i)
                print_fixed (0xC0000 + i * 0x08000, 0x01000, mtrr_state.fixed_ranges + (i + 3) * 8);
        }
        printk (KERN_INFO "MTRR variable ranges %sabled:\n", mtrr_state.enabled & 2 ? "en" : "dis");
        high_width = ((size_or_mask ? ffs (size_or_mask) - 1 : 32) - (32 - PAGE_SHIFT) + 3) / 4;
        for (i = 0; i < num_var_ranges; ++i) {
            if (mtrr_state.var_ranges[i].mask_lo & (1 << 11))
                printk (KERN_INFO "MTRR %u base %0*X%05X000 mask %0*X%05X000 %s\n", i, high_width, mtrr_state.var_ranges[i].base_hi, mtrr_state.var_ranges[i].base_lo >> 12, high_width, mtrr_state.var_ranges[i].mask_hi, mtrr_state.var_ranges[i].mask_lo >> 12, mtrr_attrib_to_str (mtrr_state.var_ranges[i].base_lo & 0xff));
            else
                printk (KERN_INFO "MTRR %u disabled\n", i);
        }
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/mtrr/generic.c.ifdefed" startline="88" endline="93">
{
    mtrr_state.var_ranges = kmalloc (num_var_ranges * sizeof (struct mtrr_var_range), GFP_KERNEL);
    if (!mtrr_state.var_ranges)
        return;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/mtrr/generic.c.ifdefed" startline="108" endline="138">
{
    int high_width;
    printk (KERN_INFO "MTRR default type: %s\n", mtrr_attrib_to_str (mtrr_state.def_type));
    if (mtrr_state.have_fixed) {
        printk (KERN_INFO "MTRR fixed ranges %sabled:\n", mtrr_state.enabled & 1 ? "en" : "dis");
        print_fixed (0x00000, 0x10000, mtrr_state.fixed_ranges + 0);
        for (i = 0; i < 2; ++i)
            print_fixed (0x80000 + i * 0x20000, 0x04000, mtrr_state.fixed_ranges + (i + 1) * 8);
        for (i = 0; i < 8; ++i)
            print_fixed (0xC0000 + i * 0x08000, 0x01000, mtrr_state.fixed_ranges + (i + 3) * 8);
    }
    printk (KERN_INFO "MTRR variable ranges %sabled:\n", mtrr_state.enabled & 2 ? "en" : "dis");
    high_width = ((size_or_mask ? ffs (size_or_mask) - 1 : 32) - (32 - PAGE_SHIFT) + 3) / 4;
    for (i = 0; i < num_var_ranges; ++i) {
        if (mtrr_state.var_ranges[i].mask_lo & (1 << 11))
            printk (KERN_INFO "MTRR %u base %0*X%05X000 mask %0*X%05X000 %s\n", i, high_width, mtrr_state.var_ranges[i].base_hi, mtrr_state.var_ranges[i].base_lo >> 12, high_width, mtrr_state.var_ranges[i].mask_hi, mtrr_state.var_ranges[i].mask_lo >> 12, mtrr_attrib_to_str (mtrr_state.var_ranges[i].base_lo & 0xff));
        else
            printk (KERN_INFO "MTRR %u disabled\n", i);
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/mtrr/generic.c.ifdefed" startline="112" endline="120">
{
    printk (KERN_INFO "MTRR fixed ranges %sabled:\n", mtrr_state.enabled & 1 ? "en" : "dis");
    print_fixed (0x00000, 0x10000, mtrr_state.fixed_ranges + 0);
    for (i = 0; i < 2; ++i)
        print_fixed (0x80000 + i * 0x20000, 0x04000, mtrr_state.fixed_ranges + (i + 1) * 8);
    for (i = 0; i < 8; ++i)
        print_fixed (0xC0000 + i * 0x08000, 0x01000, mtrr_state.fixed_ranges + (i + 3) * 8);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/mtrr/generic.c.ifdefed" startline="124" endline="137">
{
    if (mtrr_state.var_ranges[i].mask_lo & (1 << 11))
        printk (KERN_INFO "MTRR %u base %0*X%05X000 mask %0*X%05X000 %s\n", i, high_width, mtrr_state.var_ranges[i].base_hi, mtrr_state.var_ranges[i].base_lo >> 12, high_width, mtrr_state.var_ranges[i].mask_hi, mtrr_state.var_ranges[i].mask_lo >> 12, mtrr_attrib_to_str (mtrr_state.var_ranges[i].base_lo & 0xff));
    else
        printk (KERN_INFO "MTRR %u disabled\n", i);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/mtrr/generic.c.ifdefed" startline="143" endline="156">
{
    unsigned long mask = smp_changes_mask;
    if (!mask)
        return;
    if (mask & MTRR_CHANGE_MASK_FIXED)
        printk (KERN_WARNING "mtrr: your CPUs had inconsistent fixed MTRR settings\n");
    if (mask & MTRR_CHANGE_MASK_VARIABLE)
        printk (KERN_WARNING "mtrr: your CPUs had inconsistent variable MTRR settings\n");
    if (mask & MTRR_CHANGE_MASK_DEFTYPE)
        printk (KERN_WARNING "mtrr: your CPUs had inconsistent MTRRdefType settings\n");
    printk (KERN_INFO "mtrr: probably your BIOS does not setup all CPUs.\n");
    printk (KERN_INFO "mtrr: corrected configuration.\n");
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/mtrr/generic.c.ifdefed" startline="162" endline="167">
{
    if (wrmsr_safe (msr, a, b) < 0)
        printk (KERN_ERR "MTRR: CPU %u: Writing MSR %x to %x:%x failed\n", smp_processor_id (), msr, a, b);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/mtrr/generic.c.ifdefed" startline="174" endline="181">
{
    unsigned lo, hi;
    rdmsr (MSR_K8_SYSCFG, lo, hi);
    mtrr_wrmsr (MSR_K8_SYSCFG, lo | K8_MTRRFIXRANGE_DRAM_ENABLE | K8_MTRRFIXRANGE_DRAM_MODIFY, hi);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/mtrr/generic.c.ifdefed" startline="192" endline="205">
{
    unsigned lo, hi;
    rdmsr (msr, lo, hi);
    if (lo != msrwords[0] || hi != msrwords[1]) {
        if (boot_cpu_data.x86_vendor == X86_VENDOR_AMD && boot_cpu_data.x86 == 15 && ((msrwords[0] | msrwords[1]) & K8_MTRR_RDMEM_WRMEM_MASK))
            k8_enable_fixed_iorrs ();
        mtrr_wrmsr (msr, msrwords [0], msrwords [1]);
        *changed = TRUE;
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/mtrr/generic.c.ifdefed" startline="197" endline="204">
{
    if (boot_cpu_data.x86_vendor == X86_VENDOR_AMD && boot_cpu_data.x86 == 15 && ((msrwords[0] | msrwords[1]) & K8_MTRR_RDMEM_WRMEM_MASK))
        k8_enable_fixed_iorrs ();
    mtrr_wrmsr (msr, msrwords [0], msrwords [1]);
    *changed = TRUE;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/mtrr/generic.c.ifdefed" startline="213" endline="227">
{
    int i, max;
    mtrr_type ltype;
    unsigned long lbase, lsize;
    max = num_var_ranges;
    if (replace_reg >= 0 && replace_reg < max)
        return replace_reg;
    for (i = 0; i < max; ++i) {
        mtrr_if->get (i, &lbase, &lsize, &ltype);
        if (lsize == 0)
            return i;
    }
    return -ENOSPC;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/mtrr/generic.c.ifdefed" startline="221" endline="225">
{
    mtrr_if->get (i, &lbase, &lsize, &ltype);
    if (lsize == 0)
        return i;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/mtrr/generic.c.ifdefed" startline="231" endline="254">
{
    unsigned int mask_lo, mask_hi, base_lo, base_hi;
    rdmsr (MTRRphysMask_MSR (reg), mask_lo, mask_hi);
    if ((mask_lo & 0x800) == 0) {
        *base = 0;
        *size = 0;
        *type = 0;
        return;
    }
    rdmsr (MTRRphysBase_MSR (reg), base_lo, base_hi);
    mask_lo = size_or_mask | mask_hi << (32 - PAGE_SHIFT) | mask_lo >> PAGE_SHIFT;
    *size = -mask_lo;
    *base = base_hi << (32 - PAGE_SHIFT) | base_lo >> PAGE_SHIFT;
    *type = base_lo & 0xff;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/mtrr/generic.c.ifdefed" startline="235" endline="241">
{
    *base = 0;
    *size = 0;
    *type = 0;
    return;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/mtrr/generic.c.ifdefed" startline="261" endline="272">
{
    unsigned long long *saved = (unsigned long long *) frs;
    int changed = FALSE;
    int block = -1, range;
    while (fixed_range_blocks[++block].ranges)
        for (range = 0; range < fixed_range_blocks[block].ranges; range++)
            set_fixed_range (fixed_range_blocks[block].base_msr + range, &changed, (unsigned int *) saved++);
    return changed;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/mtrr/generic.c.ifdefed" startline="277" endline="298">
{
    unsigned int lo, hi;
    int changed = FALSE;
    rdmsr (MTRRphysBase_MSR (index), lo, hi);
    if ((vr->base_lo & 0xfffff0ffUL) != (lo & 0xfffff0ffUL) || (vr->base_hi & (size_and_mask >> (32 - PAGE_SHIFT))) != (hi & (size_and_mask >> (32 - PAGE_SHIFT)))) {
        mtrr_wrmsr (MTRRphysBase_MSR (index), vr -> base_lo, vr -> base_hi);
        changed = TRUE;
    }
    rdmsr (MTRRphysMask_MSR (index), lo, hi);
    if ((vr->mask_lo & 0xfffff800UL) != (lo & 0xfffff800UL) || (vr->mask_hi & (size_and_mask >> (32 - PAGE_SHIFT))) != (hi & (size_and_mask >> (32 - PAGE_SHIFT)))) {
        mtrr_wrmsr (MTRRphysMask_MSR (index), vr -> mask_lo, vr -> mask_hi);
        changed = TRUE;
    }
    return changed;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/mtrr/generic.c.ifdefed" startline="284" endline="287">
{
    mtrr_wrmsr (MTRRphysBase_MSR (index), vr -> base_lo, vr -> base_hi);
    changed = TRUE;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/mtrr/generic.c.ifdefed" startline="293" endline="296">
{
    mtrr_wrmsr (MTRRphysMask_MSR (index), vr -> mask_lo, vr -> mask_hi);
    changed = TRUE;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/mtrr/generic.c.ifdefed" startline="309" endline="329">
{
    unsigned int i;
    unsigned long change_mask = 0;
    for (i = 0; i < num_var_ranges; i++)
        if (set_mtrr_var_ranges (i, &mtrr_state.var_ranges[i]))
            change_mask |= MTRR_CHANGE_MASK_VARIABLE;
    if (mtrr_state.have_fixed && set_fixed_ranges (mtrr_state.fixed_ranges))
        change_mask |= MTRR_CHANGE_MASK_FIXED;
    if ((deftype_lo & 0xff) != mtrr_state.def_type || ((deftype_lo & 0xc00) >> 10) != mtrr_state.enabled) {
        deftype_lo = (deftype_lo & ~0xcff) | mtrr_state.def_type | (mtrr_state.enabled << 10);
        change_mask |= MTRR_CHANGE_MASK_DEFTYPE;
    }
    return change_mask;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/mtrr/generic.c.ifdefed" startline="323" endline="326">
{
    deftype_lo = (deftype_lo & ~0xcff) | mtrr_state.def_type | (mtrr_state.enabled << 10);
    change_mask |= MTRR_CHANGE_MASK_DEFTYPE;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/mtrr/generic.c.ifdefed" startline="343" endline="371">
{
    unsigned long cr0;
    spin_lock (& set_atomicity_lock);
    cr0 = read_cr0 () | 0x40000000;
    write_cr0 (cr0);
    wbinvd ();
    if (cpu_has_pge) {
        cr4 = read_cr4 ();
        write_cr4 (cr4 & ~ X86_CR4_PGE);
    }
    __flush_tlb ();
    rdmsr (MTRRdefType_MSR, deftype_lo, deftype_hi);
    mtrr_wrmsr (MTRRdefType_MSR, deftype_lo & ~ 0xcff, deftype_hi);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/mtrr/generic.c.ifdefed" startline="358" endline="361">
{
    cr4 = read_cr4 ();
    write_cr4 (cr4 & ~ X86_CR4_PGE);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/mtrr/generic.c.ifdefed" startline="374" endline="388">
{
    __flush_tlb ();
    mtrr_wrmsr (MTRRdefType_MSR, deftype_lo, deftype_hi);
    write_cr0 (read_cr0 () & 0xbfffffff);
    if (cpu_has_pge)
        write_cr4 (cr4);
    spin_unlock (& set_atomicity_lock);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/mtrr/generic.c.ifdefed" startline="391" endline="411">
{
    unsigned long mask, count;
    unsigned long flags;
    local_irq_save (flags);
    prepare_set ();
    mask = set_mtrr_state ();
    post_set ();
    local_irq_restore (flags);
    for (count = 0; count < sizeof mask * 8; ++count) {
        if (mask & 0x01)
            set_bit (count, &smp_changes_mask);
        mask >>= 1;
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/mtrr/generic.c.ifdefed" startline="405" endline="409">
{
    if (mask & 0x01)
        set_bit (count, &smp_changes_mask);
    mask >>= 1;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/mtrr/generic.c.ifdefed" startline="424" endline="450">
{
    unsigned long flags;
    struct mtrr_var_range *vr;
    vr = &mtrr_state.var_ranges[reg];
    local_irq_save (flags);
    prepare_set ();
    if (size == 0) {
        mtrr_wrmsr (MTRRphysMask_MSR (reg), 0, 0);
        memset (vr, 0, sizeof (struct mtrr_var_range));
    }
    else {
        vr->base_lo = base << PAGE_SHIFT | type;
        vr->base_hi = (base & size_and_mask) >> (32 - PAGE_SHIFT);
        vr->mask_lo = -size << PAGE_SHIFT | 0x800;
        vr->mask_hi = (-size & size_and_mask) >> (32 - PAGE_SHIFT);
        mtrr_wrmsr (MTRRphysBase_MSR (reg), vr -> base_lo, vr -> base_hi);
        mtrr_wrmsr (MTRRphysMask_MSR (reg), vr -> mask_lo, vr -> mask_hi);
    }
    post_set ();
    local_irq_restore (flags);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/mtrr/generic.c.ifdefed" startline="433" endline="438">
{
    mtrr_wrmsr (MTRRphysMask_MSR (reg), 0, 0);
    memset (vr, 0, sizeof (struct mtrr_var_range));
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/mtrr/generic.c.ifdefed" startline="438" endline="446">
{
    vr->base_lo = base << PAGE_SHIFT | type;
    vr->base_hi = (base & size_and_mask) >> (32 - PAGE_SHIFT);
    vr->mask_lo = -size << PAGE_SHIFT | 0x800;
    vr->mask_hi = (-size & size_and_mask) >> (32 - PAGE_SHIFT);
    mtrr_wrmsr (MTRRphysBase_MSR (reg), vr -> base_lo, vr -> base_hi);
    mtrr_wrmsr (MTRRphysMask_MSR (reg), vr -> mask_lo, vr -> mask_hi);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/mtrr/generic.c.ifdefed" startline="453" endline="484">
{
    unsigned long lbase, last;
    if (is_cpu (INTEL) && boot_cpu_data.x86 == 6 && boot_cpu_data.x86_model == 1 && boot_cpu_data.x86_mask <= 7) {
        if (base & ((1 << (22 - PAGE_SHIFT)) - 1)) {
            printk (KERN_WARNING "mtrr: base(0x%lx000) is not 4 MiB aligned\n", base);
            return -EINVAL;
        }
        if (!(base + size < 0x70000 || base > 0x7003F) && (type == MTRR_TYPE_WRCOMB || type == MTRR_TYPE_WRBACK)) {
            printk (KERN_WARNING "mtrr: writable mtrr between 0x70000000 and 0x7003FFFF may hang the CPU.\n");
            return -EINVAL;
        }
    }
    last = base + size - 1;
    for (lbase = base; !(lbase & 1) && (last & 1); lbase = lbase >> 1, last = last >> 1)
        ;
    if (lbase != last) {
        printk (KERN_WARNING "mtrr: base(0x%lx000) is not aligned on a size(0x%lx000) boundary\n", base, size);
        return -EINVAL;
    }
    return 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/mtrr/generic.c.ifdefed" startline="460" endline="471">
{
    if (base & ((1 << (22 - PAGE_SHIFT)) - 1)) {
        printk (KERN_WARNING "mtrr: base(0x%lx000) is not 4 MiB aligned\n", base);
        return -EINVAL;
    }
    if (!(base + size < 0x70000 || base > 0x7003F) && (type == MTRR_TYPE_WRCOMB || type == MTRR_TYPE_WRBACK)) {
        printk (KERN_WARNING "mtrr: writable mtrr between 0x70000000 and 0x7003FFFF may hang the CPU.\n");
        return -EINVAL;
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/mtrr/generic.c.ifdefed" startline="461" endline="464">
{
    printk (KERN_WARNING "mtrr: base(0x%lx000) is not 4 MiB aligned\n", base);
    return -EINVAL;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/mtrr/generic.c.ifdefed" startline="467" endline="470">
{
    printk (KERN_WARNING "mtrr: writable mtrr between 0x70000000 and 0x7003FFFF may hang the CPU.\n");
    return -EINVAL;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/mtrr/generic.c.ifdefed" startline="478" endline="482">
{
    printk (KERN_WARNING "mtrr: base(0x%lx000) is not aligned on a size(0x%lx000) boundary\n", base, size);
    return -EINVAL;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/mtrr/generic.c.ifdefed" startline="488" endline="492">
{
    unsigned long config, dummy;
    rdmsr (MTRRcap_MSR, config, dummy);
    return (config & (1 << 10));
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/mtrr/generic.c.ifdefed" startline="495" endline="497">
{
    return 1;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/mtrr/main.c.ifdefed" startline="69" endline="72">
{
    if (ops->vendor && ops->vendor < X86_VENDOR_NUM)
        mtrr_ops[ops->vendor] = ops;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/mtrr/main.c.ifdefed" startline="76" endline="103">
{
    struct pci_dev *dev;
    u8 rev;
    if ((dev = pci_get_class (PCI_CLASS_BRIDGE_HOST << 8, NULL)) != NULL) {
        if (dev->vendor == PCI_VENDOR_ID_SERVERWORKS && dev->device == PCI_DEVICE_ID_SERVERWORKS_LE) {
            pci_read_config_byte (dev, PCI_CLASS_REVISION, & rev);
            if (rev <= 5) {
                printk (KERN_INFO "mtrr: Serverworks LE rev < 6 detected. Write-combining disabled.\n");
                pci_dev_put (dev);
                return 0;
            }
        }
        if (dev->vendor == PCI_VENDOR_ID_INTEL && dev->device == PCI_DEVICE_ID_INTEL_82451NX) {
            printk (KERN_INFO "mtrr: Intel 450NX MMC detected. Write-combining disabled.\n");
            pci_dev_put (dev);
            return 0;
        }
        pci_dev_put (dev);
    }
    return (mtrr_if->have_wrcomb ? mtrr_if->have_wrcomb () : 0);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/mtrr/main.c.ifdefed" startline="80" endline="101">
{
    if (dev->vendor == PCI_VENDOR_ID_SERVERWORKS && dev->device == PCI_DEVICE_ID_SERVERWORKS_LE) {
        pci_read_config_byte (dev, PCI_CLASS_REVISION, & rev);
        if (rev <= 5) {
            printk (KERN_INFO "mtrr: Serverworks LE rev < 6 detected. Write-combining disabled.\n");
            pci_dev_put (dev);
            return 0;
        }
    }
    if (dev->vendor == PCI_VENDOR_ID_INTEL && dev->device == PCI_DEVICE_ID_INTEL_82451NX) {
        printk (KERN_INFO "mtrr: Intel 450NX MMC detected. Write-combining disabled.\n");
        pci_dev_put (dev);
        return 0;
    }
    pci_dev_put (dev);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/mtrr/main.c.ifdefed" startline="84" endline="91">
{
    pci_read_config_byte (dev, PCI_CLASS_REVISION, & rev);
    if (rev <= 5) {
        printk (KERN_INFO "mtrr: Serverworks LE rev < 6 detected. Write-combining disabled.\n");
        pci_dev_put (dev);
        return 0;
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/mtrr/main.c.ifdefed" startline="86" endline="90">
{
    printk (KERN_INFO "mtrr: Serverworks LE rev < 6 detected. Write-combining disabled.\n");
    pci_dev_put (dev);
    return 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/mtrr/main.c.ifdefed" startline="95" endline="99">
{
    printk (KERN_INFO "mtrr: Intel 450NX MMC detected. Write-combining disabled.\n");
    pci_dev_put (dev);
    return 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/mtrr/main.c.ifdefed" startline="107" endline="117">
{
    unsigned long config = 0, dummy;
    if (use_intel ()) {
        rdmsr (MTRRcap_MSR, config, dummy);
    }
    else if (is_cpu (AMD))
        config = 2;
    else if (is_cpu (CYRIX) || is_cpu (CENTAUR))
        config = 8;
    num_var_ranges = config & 0xff;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/mtrr/main.c.ifdefed" startline="110" endline="112">
{
    rdmsr (MTRRcap_MSR, config, dummy);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/mtrr/main.c.ifdefed" startline="120" endline="131">
{
    int i, max;
    max = num_var_ranges;
    if ((usage_table = kmalloc (max * sizeof *usage_table, GFP_KERNEL)) == NULL) {
        printk (KERN_ERR "mtrr: could not allocate\n");
        return;
    }
    for (i = 0; i < max; i++)
        usage_table[i] = 1;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/mtrr/main.c.ifdefed" startline="125" endline="128">
{
    printk (KERN_ERR "mtrr: could not allocate\n");
    return;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/mtrr/main.c.ifdefed" startline="146" endline="171">
{
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/mtrr/main.c.ifdefed" startline="173" endline="178">
{
    return type1 == MTRR_TYPE_UNCACHABLE || type2 == MTRR_TYPE_UNCACHABLE || (type1 == MTRR_TYPE_WRTHROUGH && type2 == MTRR_TYPE_WRBACK) || (type1 == MTRR_TYPE_WRBACK && type2 == MTRR_TYPE_WRTHROUGH);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/mtrr/main.c.ifdefed" startline="221" endline="275">
{
    struct set_mtrr_data data;
    unsigned long flags;
    data.smp_reg = reg;
    data.smp_base = base;
    data.smp_size = size;
    data.smp_type = type;
    atomic_set (& data.count, num_booting_cpus () - 1);
    smp_wmb ();
    atomic_set (& data.gate, 0);
    if (smp_call_function (ipi_handler, &data, 1, 0) != 0)
        panic ("mtrr: timed out waiting for other CPUs\n");
    local_irq_save (flags);
    while (atomic_read (&data.count))
        cpu_relax ();
    atomic_set (& data.count, num_booting_cpus () - 1);
    smp_wmb ();
    atomic_set (& data.gate, 1);
    if (reg != ~0U)
        mtrr_if->set (reg, base, size, type);
    while (atomic_read (&data.count))
        cpu_relax ();
    atomic_set (& data.count, num_booting_cpus () - 1);
    smp_wmb ();
    atomic_set (& data.gate, 0);
    while (atomic_read (&data.count))
        cpu_relax ();
    local_irq_restore (flags);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/mtrr/main.c.ifdefed" startline="315" endline="410">
{
    int i, replace, error;
    mtrr_type ltype;
    unsigned long lbase, lsize;
    if (!mtrr_if)
        return -ENXIO;
    if ((error = mtrr_if->validate_add_page (base, size, type)))
        return error;
    if (type >= MTRR_NUM_TYPES) {
        printk (KERN_WARNING "mtrr: type: %u invalid\n", type);
        return -EINVAL;
    }
    if ((type == MTRR_TYPE_WRCOMB) && !have_wrcomb ()) {
        printk (KERN_WARNING "mtrr: your processor doesn't support write-combining\n");
        return -ENOSYS;
    }
    if (!size) {
        printk (KERN_WARNING "mtrr: zero sized request\n");
        return -EINVAL;
    }
    if (base & size_or_mask || size & size_or_mask) {
        printk (KERN_WARNING "mtrr: base or size exceeds the MTRR width\n");
        return -EINVAL;
    }
    error = -EINVAL;
    replace = -1;
    lock_cpu_hotplug ();
    mutex_lock (& mtrr_mutex);
    for (i = 0; i < num_var_ranges; ++i) {
        mtrr_if->get (i, &lbase, &lsize, &ltype);
        if (!lsize || base > lbase + lsize - 1 || base + size - 1 < lbase)
            continue;
        if (base < lbase || base + size - 1 > lbase + lsize - 1) {
            if (base <= lbase && base + size - 1 >= lbase + lsize - 1) {
                if (type == ltype) {
                    replace = replace == -1 ? i : -2;
                    continue;
                }
                else if (types_compatible (type, ltype))
                    continue;
            }
            printk (KERN_WARNING "mtrr: 0x%lx000,0x%lx000 overlaps existing" " 0x%lx000,0x%lx000\n", base, size, lbase, lsize);
            goto out;
        }
        if (ltype != type) {
            if (types_compatible (type, ltype))
                continue;
            printk (KERN_WARNING "mtrr: type mismatch for %lx000,%lx000 old: %s new: %s\n", base, size, mtrr_attrib_to_str (ltype), mtrr_attrib_to_str (type));
            goto out;
        }
        if (increment)
            ++usage_table[i];
        error = i;
        goto out;
    }
    i = mtrr_if->get_free_region (base, size, replace);
    if (i >= 0) {
        set_mtrr (i, base, size, type);
        if (likely (replace < 0))
            usage_table[i] = 1;
        else {
            usage_table[i] = usage_table[replace] + !!increment;
            if (unlikely (replace != i)) {
                set_mtrr (replace, 0, 0, 0);
                usage_table[replace] = 0;
            }
        }
    }
    else
        printk (KERN_INFO "mtrr: no more MTRRs available\n");
    error = i;
out :
    mutex_unlock (&mtrr_mutex);
    unlock_cpu_hotplug ();
    return error;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/mtrr/main.c.ifdefed" startline="326" endline="329">
{
    printk (KERN_WARNING "mtrr: type: %u invalid\n", type);
    return -EINVAL;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/mtrr/main.c.ifdefed" startline="332" endline="336">
{
    printk (KERN_WARNING "mtrr: your processor doesn't support write-combining\n");
    return -ENOSYS;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/mtrr/main.c.ifdefed" startline="338" endline="341">
{
    printk (KERN_WARNING "mtrr: zero sized request\n");
    return -EINVAL;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/mtrr/main.c.ifdefed" startline="343" endline="346">
{
    printk (KERN_WARNING "mtrr: base or size exceeds the MTRR width\n");
    return -EINVAL;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/mtrr/main.c.ifdefed" startline="355" endline="389">
{
    mtrr_if->get (i, &lbase, &lsize, &ltype);
    if (!lsize || base > lbase + lsize - 1 || base + size - 1 < lbase)
        continue;
    if (base < lbase || base + size - 1 > lbase + lsize - 1) {
        if (base <= lbase && base + size - 1 >= lbase + lsize - 1) {
            if (type == ltype) {
                replace = replace == -1 ? i : -2;
                continue;
            }
            else if (types_compatible (type, ltype))
                continue;
        }
        printk (KERN_WARNING "mtrr: 0x%lx000,0x%lx000 overlaps existing" " 0x%lx000,0x%lx000\n", base, size, lbase, lsize);
        goto out;
    }
    if (ltype != type) {
        if (types_compatible (type, ltype))
            continue;
        printk (KERN_WARNING "mtrr: type mismatch for %lx000,%lx000 old: %s new: %s\n", base, size, mtrr_attrib_to_str (ltype), mtrr_attrib_to_str (type));
        goto out;
    }
    if (increment)
        ++usage_table[i];
    error = i;
    goto out;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/mtrr/main.c.ifdefed" startline="360" endline="375">
{
    if (base <= lbase && base + size - 1 >= lbase + lsize - 1) {
        if (type == ltype) {
            replace = replace == -1 ? i : -2;
            continue;
        }
        else if (types_compatible (type, ltype))
            continue;
    }
    printk (KERN_WARNING "mtrr: 0x%lx000,0x%lx000 overlaps existing" " 0x%lx000,0x%lx000\n", base, size, lbase, lsize);
    goto out;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/mtrr/main.c.ifdefed" startline="361" endline="369">
{
    if (type == ltype) {
        replace = replace == -1 ? i : -2;
        continue;
    }
    else if (types_compatible (type, ltype))
        continue;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/mtrr/main.c.ifdefed" startline="363" endline="366">
{
    replace = replace == -1 ? i : -2;
    continue;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/mtrr/main.c.ifdefed" startline="377" endline="384">
{
    if (types_compatible (type, ltype))
        continue;
    printk (KERN_WARNING "mtrr: type mismatch for %lx000,%lx000 old: %s new: %s\n", base, size, mtrr_attrib_to_str (ltype), mtrr_attrib_to_str (type));
    goto out;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/mtrr/main.c.ifdefed" startline="392" endline="403">
{
    set_mtrr (i, base, size, type);
    if (likely (replace < 0))
        usage_table[i] = 1;
    else {
        usage_table[i] = usage_table[replace] + !!increment;
        if (unlikely (replace != i)) {
            set_mtrr (replace, 0, 0, 0);
            usage_table[replace] = 0;
        }
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/mtrr/main.c.ifdefed" startline="396" endline="402">
{
    usage_table[i] = usage_table[replace] + !!increment;
    if (unlikely (replace != i)) {
        set_mtrr (replace, 0, 0, 0);
        usage_table[replace] = 0;
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/mtrr/main.c.ifdefed" startline="398" endline="401">
{
    set_mtrr (replace, 0, 0, 0);
    usage_table[replace] = 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/mtrr/main.c.ifdefed" startline="413" endline="423">
{
    if ((base & (PAGE_SIZE - 1)) || (size & (PAGE_SIZE - 1))) {
        printk (KERN_WARNING "mtrr: size and base must be multiples of 4 kiB\n");
        printk (KERN_DEBUG "mtrr: size: 0x%lx  base: 0x%lx\n", size, base);
        dump_stack ();
        return -1;
    }
    return 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/mtrr/main.c.ifdefed" startline="414" endline="421">
{
    printk (KERN_WARNING "mtrr: size and base must be multiples of 4 kiB\n");
    printk (KERN_DEBUG "mtrr: size: 0x%lx  base: 0x%lx\n", size, base);
    dump_stack ();
    return -1;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/mtrr/main.c.ifdefed" startline="464" endline="469">
{
    if (mtrr_check (base, size))
        return -EINVAL;
    return mtrr_add_page (base >> PAGE_SHIFT, size >> PAGE_SHIFT, type, increment);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/mtrr/main.c.ifdefed" startline="487" endline="541">
{
    int i, max;
    mtrr_type ltype;
    unsigned long lbase, lsize;
    int error = -EINVAL;
    if (!mtrr_if)
        return -ENXIO;
    max = num_var_ranges;
    lock_cpu_hotplug ();
    mutex_lock (& mtrr_mutex);
    if (reg < 0) {
        for (i = 0; i < max; ++i) {
            mtrr_if->get (i, &lbase, &lsize, &ltype);
            if (lbase == base && lsize == size) {
                reg = i;
                break;
            }
        }
        if (reg < 0) {
            printk (KERN_DEBUG "mtrr: no MTRR for %lx000,%lx000 found\n", base, size);
            goto out;
        }
    }
    if (reg >= max) {
        printk (KERN_WARNING "mtrr: register: %d too big\n", reg);
        goto out;
    }
    if (is_cpu (CYRIX) && !use_intel ()) {
        if ((reg == 3) && arr3_protected) {
            printk (KERN_WARNING "mtrr: ARR3 cannot be changed\n");
            goto out;
        }
    }
    mtrr_if->get (reg, &lbase, &lsize, &ltype);
    if (lsize < 1) {
        printk (KERN_WARNING "mtrr: MTRR %d not used\n", reg);
        goto out;
    }
    if (usage_table[reg] < 1) {
        printk (KERN_WARNING "mtrr: reg: %d has count=0\n", reg);
        goto out;
    }
    if (--usage_table[reg] < 1)
        set_mtrr (reg, 0, 0, 0);
    error = reg;
out :
    mutex_unlock (&mtrr_mutex);
    unlock_cpu_hotplug ();
    return error;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/mtrr/main.c.ifdefed" startline="500" endline="514">
{
    for (i = 0; i < max; ++i) {
        mtrr_if->get (i, &lbase, &lsize, &ltype);
        if (lbase == base && lsize == size) {
            reg = i;
            break;
        }
    }
    if (reg < 0) {
        printk (KERN_DEBUG "mtrr: no MTRR for %lx000,%lx000 found\n", base, size);
        goto out;
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/mtrr/main.c.ifdefed" startline="502" endline="508">
{
    mtrr_if->get (i, &lbase, &lsize, &ltype);
    if (lbase == base && lsize == size) {
        reg = i;
        break;
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/mtrr/main.c.ifdefed" startline="504" endline="507">
{
    reg = i;
    break;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/mtrr/main.c.ifdefed" startline="509" endline="513">
{
    printk (KERN_DEBUG "mtrr: no MTRR for %lx000,%lx000 found\n", base, size);
    goto out;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/mtrr/main.c.ifdefed" startline="515" endline="518">
{
    printk (KERN_WARNING "mtrr: register: %d too big\n", reg);
    goto out;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/mtrr/main.c.ifdefed" startline="519" endline="524">
{
    if ((reg == 3) && arr3_protected) {
        printk (KERN_WARNING "mtrr: ARR3 cannot be changed\n");
        goto out;
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/mtrr/main.c.ifdefed" startline="520" endline="523">
{
    printk (KERN_WARNING "mtrr: ARR3 cannot be changed\n");
    goto out;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/mtrr/main.c.ifdefed" startline="526" endline="529">
{
    printk (KERN_WARNING "mtrr: MTRR %d not used\n", reg);
    goto out;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/mtrr/main.c.ifdefed" startline="530" endline="533">
{
    printk (KERN_WARNING "mtrr: reg: %d has count=0\n", reg);
    goto out;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/mtrr/main.c.ifdefed" startline="559" endline="563">
{
    if (mtrr_check (base, size))
        return -EINVAL;
    return mtrr_del_page (reg, base >> PAGE_SHIFT, size >> PAGE_SHIFT);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/mtrr/main.c.ifdefed" startline="577" endline="583">
{
    amd_init_mtrr ();
    cyrix_init_mtrr ();
    centaur_init_mtrr ();
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/mtrr/main.c.ifdefed" startline="597" endline="612">
{
    int i;
    int size = num_var_ranges * sizeof (struct mtrr_value);
    mtrr_state = kzalloc (size, GFP_ATOMIC);
    if (!mtrr_state)
        return -ENOMEM;
    for (i = 0; i < num_var_ranges; i++) {
        mtrr_if->get (i, &mtrr_state[i].lbase, &mtrr_state[i].lsize, &mtrr_state[i].ltype);
    }
    return 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/mtrr/main.c.ifdefed" startline="605" endline="610">
{
    mtrr_if->get (i, &mtrr_state[i].lbase, &mtrr_state[i].lsize, &mtrr_state[i].ltype);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/mtrr/main.c.ifdefed" startline="615" endline="627">
{
    int i;
    for (i = 0; i < num_var_ranges; i++) {
        if (mtrr_state[i].lsize)
            set_mtrr (i, mtrr_state[i].lbase, mtrr_state[i].lsize, mtrr_state[i].ltype);
    }
    kfree (mtrr_state);
    return 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/mtrr/main.c.ifdefed" startline="618" endline="624">
{
    if (mtrr_state[i].lsize)
        set_mtrr (i, mtrr_state[i].lbase, mtrr_state[i].lsize, mtrr_state[i].ltype);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/mtrr/main.c.ifdefed" startline="645" endline="711">
{
    init_ifs ();
    if (cpu_has_mtrr) {
        mtrr_if = &generic_mtrr_ops;
        size_or_mask = 0xff000000;
        size_and_mask = 0x00f00000;
        if (cpuid_eax (0x80000000) >= 0x80000008) {
            u32 phys_addr;
            phys_addr = cpuid_eax (0x80000008) & 0xff;
            if (boot_cpu_data.x86_vendor == X86_VENDOR_INTEL && boot_cpu_data.x86 == 0xF && boot_cpu_data.x86_model == 0x3 && (boot_cpu_data.x86_mask == 0x3 || boot_cpu_data.x86_mask == 0x4))
                phys_addr = 36;
            size_or_mask = ~((1ULL << (phys_addr - PAGE_SHIFT)) - 1);
            size_and_mask = ~size_or_mask & 0xfffff00000ULL;
        }
        else if (boot_cpu_data.x86_vendor == X86_VENDOR_CENTAUR && boot_cpu_data.x86 == 6) {
            size_or_mask = 0xfff00000;
            size_and_mask = 0;
        }
    }
    else {
        switch (boot_cpu_data.x86_vendor) {
        case X86_VENDOR_AMD :
            if (cpu_has_k6_mtrr) {
                mtrr_if = mtrr_ops[X86_VENDOR_AMD];
                size_or_mask = 0xfff00000;
                size_and_mask = 0;
            }
            break;
        case X86_VENDOR_CENTAUR :
            if (cpu_has_centaur_mcr) {
                mtrr_if = mtrr_ops[X86_VENDOR_CENTAUR];
                size_or_mask = 0xfff00000;
                size_and_mask = 0;
            }
            break;
        case X86_VENDOR_CYRIX :
            if (cpu_has_cyrix_arr) {
                mtrr_if = mtrr_ops[X86_VENDOR_CYRIX];
                size_or_mask = 0xfff00000;
                size_and_mask = 0;
            }
            break;
        default :
            break;
        }
    }
    if (mtrr_if) {
        set_num_var_ranges ();
        init_table ();
        if (use_intel ())
            get_mtrr_state ();
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/mtrr/main.c.ifdefed" startline="648" endline="676">
{
    mtrr_if = &generic_mtrr_ops;
    size_or_mask = 0xff000000;
    size_and_mask = 0x00f00000;
    if (cpuid_eax (0x80000000) >= 0x80000008) {
        u32 phys_addr;
        phys_addr = cpuid_eax (0x80000008) & 0xff;
        if (boot_cpu_data.x86_vendor == X86_VENDOR_INTEL && boot_cpu_data.x86 == 0xF && boot_cpu_data.x86_model == 0x3 && (boot_cpu_data.x86_mask == 0x3 || boot_cpu_data.x86_mask == 0x4))
            phys_addr = 36;
        size_or_mask = ~((1ULL << (phys_addr - PAGE_SHIFT)) - 1);
        size_and_mask = ~size_or_mask & 0xfffff00000ULL;
    }
    else if (boot_cpu_data.x86_vendor == X86_VENDOR_CENTAUR && boot_cpu_data.x86 == 6) {
        size_or_mask = 0xfff00000;
        size_and_mask = 0;
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/mtrr/main.c.ifdefed" startline="656" endline="669">
{
    u32 phys_addr;
    phys_addr = cpuid_eax (0x80000008) & 0xff;
    if (boot_cpu_data.x86_vendor == X86_VENDOR_INTEL && boot_cpu_data.x86 == 0xF && boot_cpu_data.x86_model == 0x3 && (boot_cpu_data.x86_mask == 0x3 || boot_cpu_data.x86_mask == 0x4))
        phys_addr = 36;
    size_or_mask = ~((1ULL << (phys_addr - PAGE_SHIFT)) - 1);
    size_and_mask = ~size_or_mask & 0xfffff00000ULL;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/mtrr/main.c.ifdefed" startline="670" endline="675">
{
    size_or_mask = 0xfff00000;
    size_and_mask = 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/mtrr/main.c.ifdefed" startline="676" endline="703">
{
    switch (boot_cpu_data.x86_vendor) {
    case X86_VENDOR_AMD :
        if (cpu_has_k6_mtrr) {
            mtrr_if = mtrr_ops[X86_VENDOR_AMD];
            size_or_mask = 0xfff00000;
            size_and_mask = 0;
        }
        break;
    case X86_VENDOR_CENTAUR :
        if (cpu_has_centaur_mcr) {
            mtrr_if = mtrr_ops[X86_VENDOR_CENTAUR];
            size_or_mask = 0xfff00000;
            size_and_mask = 0;
        }
        break;
    case X86_VENDOR_CYRIX :
        if (cpu_has_cyrix_arr) {
            mtrr_if = mtrr_ops[X86_VENDOR_CYRIX];
            size_or_mask = 0xfff00000;
            size_and_mask = 0;
        }
        break;
    default :
        break;
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/mtrr/main.c.ifdefed" startline="677" endline="702">
{
case X86_VENDOR_AMD :
    if (cpu_has_k6_mtrr) {
        mtrr_if = mtrr_ops[X86_VENDOR_AMD];
        size_or_mask = 0xfff00000;
        size_and_mask = 0;
    }
    break;
case X86_VENDOR_CENTAUR :
    if (cpu_has_centaur_mcr) {
        mtrr_if = mtrr_ops[X86_VENDOR_CENTAUR];
        size_or_mask = 0xfff00000;
        size_and_mask = 0;
    }
    break;
case X86_VENDOR_CYRIX :
    if (cpu_has_cyrix_arr) {
        mtrr_if = mtrr_ops[X86_VENDOR_CYRIX];
        size_or_mask = 0xfff00000;
        size_and_mask = 0;
    }
    break;
default :
    break;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/mtrr/main.c.ifdefed" startline="679" endline="684">
{
    mtrr_if = mtrr_ops[X86_VENDOR_AMD];
    size_or_mask = 0xfff00000;
    size_and_mask = 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/mtrr/main.c.ifdefed" startline="687" endline="691">
{
    mtrr_if = mtrr_ops[X86_VENDOR_CENTAUR];
    size_or_mask = 0xfff00000;
    size_and_mask = 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/mtrr/main.c.ifdefed" startline="694" endline="698">
{
    mtrr_if = mtrr_ops[X86_VENDOR_CYRIX];
    size_or_mask = 0xfff00000;
    size_and_mask = 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/mtrr/main.c.ifdefed" startline="705" endline="710">
{
    set_num_var_ranges ();
    init_table ();
    if (use_intel ())
        get_mtrr_state ();
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/mtrr/main.c.ifdefed" startline="714" endline="732">
{
    unsigned long flags;
    if (!mtrr_if || !use_intel ())
        return;
    local_irq_save (flags);
    mtrr_if->set_all ();
    local_irq_restore (flags);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/mtrr/main.c.ifdefed" startline="738" endline="740">
{
    smp_call_function_single (0, mtrr_save_fixed_ranges, NULL, 1, 1);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/mtrr/main.c.ifdefed" startline="743" endline="759">
{
    if (!mtrr_if)
        return 0;
    if (use_intel ())
        mtrr_state_warn ();
    else {
        sysdev_driver_register (& cpu_sysdev_class, & mtrr_sysdev_driver);
    }
    return 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/mtrr/main.c.ifdefed" startline="748" endline="757">
{
    sysdev_driver_register (& cpu_sysdev_class, & mtrr_sysdev_driver);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/mcheck/mce_64.c.ifdefed" startline="72" endline="104">
{
    unsigned next, entry;
    atomic_inc (& mce_events);
    mce->finished = 0;
    wmb ();
    for (;;) {
        entry = rcu_dereference (mcelog.next);
        for (;;) {
            if (entry >= MCE_LOG_LEN) {
                set_bit (MCE_OVERFLOW, & mcelog.flags);
                return;
            }
            if (mcelog.entry[entry].finished) {
                entry++;
                continue;
            }
            break;
        }
        smp_rmb ();
        next = entry + 1;
        if (cmpxchg (&mcelog.next, entry, next) == entry)
            break;
    }
    memcpy (mcelog.entry + entry, mce, sizeof (struct mce));
    wmb ();
    mcelog.entry[entry].finished = 1;
    wmb ();
    set_bit (0, & notify_user);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/mcheck/mce_64.c.ifdefed" startline="77" endline="97">
{
    entry = rcu_dereference (mcelog.next);
    for (;;) {
        if (entry >= MCE_LOG_LEN) {
            set_bit (MCE_OVERFLOW, & mcelog.flags);
            return;
        }
        if (mcelog.entry[entry].finished) {
            entry++;
            continue;
        }
        break;
    }
    smp_rmb ();
    next = entry + 1;
    if (cmpxchg (&mcelog.next, entry, next) == entry)
        break;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/mcheck/mce_64.c.ifdefed" startline="79" endline="92">
{
    if (entry >= MCE_LOG_LEN) {
        set_bit (MCE_OVERFLOW, & mcelog.flags);
        return;
    }
    if (mcelog.entry[entry].finished) {
        entry++;
        continue;
    }
    break;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/mcheck/mce_64.c.ifdefed" startline="82" endline="85">
{
    set_bit (MCE_OVERFLOW, & mcelog.flags);
    return;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/mcheck/mce_64.c.ifdefed" startline="87" endline="90">
{
    entry++;
    continue;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/mcheck/mce_64.c.ifdefed" startline="107" endline="130">
{
    printk (KERN_EMERG "\n" KERN_EMERG "HARDWARE ERROR\n" KERN_EMERG "CPU %d: Machine Check Exception: %16Lx Bank %d: %016Lx\n", m -> cpu, m -> mcgstatus, m -> bank, m -> status);
    if (m->rip) {
        printk (KERN_EMERG "RIP%s %02x:<%016Lx> ", ! (m -> mcgstatus & MCG_STATUS_EIPV) ? " !INEXACT!" : "", m -> cs, m -> rip);
        if (m->cs == __KERNEL_CS)
            print_symbol ("{%s}", m->rip);
        printk ("\n");
    }
    printk (KERN_EMERG "TSC %Lx ", m -> tsc);
    if (m->addr)
        printk ("ADDR %Lx ", m->addr);
    if (m->misc)
        printk ("MISC %Lx ", m->misc);
    printk ("\n");
    printk (KERN_EMERG "This is not a software problem!\n");
    printk (KERN_EMERG "Run through mcelog --ascii to decode " "and contact your hardware vendor\n");
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/mcheck/mce_64.c.ifdefed" startline="113" endline="120">
{
    printk (KERN_EMERG "RIP%s %02x:<%016Lx> ", ! (m -> mcgstatus & MCG_STATUS_EIPV) ? " !INEXACT!" : "", m -> cs, m -> rip);
    if (m->cs == __KERNEL_CS)
        print_symbol ("{%s}", m->rip);
    printk ("\n");
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/mcheck/mce_64.c.ifdefed" startline="133" endline="149">
{
    int i;
    oops_begin ();
    for (i = 0; i < MCE_LOG_LEN; i++) {
        unsigned long tsc = mcelog.entry[i].tsc;
        if (time_before (tsc, start))
            continue;
        print_mce (& mcelog.entry [i]);
        if (backup && mcelog.entry[i].tsc == backup->tsc)
            backup = NULL;
    }
    if (backup)
        print_mce (backup);
    panic (msg);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/mcheck/mce_64.c.ifdefed" startline="137" endline="145">
{
    unsigned long tsc = mcelog.entry[i].tsc;
    if (time_before (tsc, start))
        continue;
    print_mce (& mcelog.entry [i]);
    if (backup && mcelog.entry[i].tsc == backup->tsc)
        backup = NULL;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/mcheck/mce_64.c.ifdefed" startline="152" endline="154">
{
    return cpu_has (c, X86_FEATURE_MCE) && cpu_has (c, X86_FEATURE_MCA);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/mcheck/mce_64.c.ifdefed" startline="157" endline="171">
{
    if (regs && (m->mcgstatus & MCG_STATUS_RIPV)) {
        m->rip = regs->rip;
        m->cs = regs->cs;
    }
    else {
        m->rip = 0;
        m->cs = 0;
    }
    if (rip_msr) {
        m->mcgstatus |= MCG_STATUS_EIPV;
        rdmsrl (rip_msr, m -> rip);
        m->cs = 0;
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/mcheck/mce_64.c.ifdefed" startline="158" endline="161">
{
    m->rip = regs->rip;
    m->cs = regs->cs;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/mcheck/mce_64.c.ifdefed" startline="161" endline="164">
{
    m->rip = 0;
    m->cs = 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/mcheck/mce_64.c.ifdefed" startline="165" endline="170">
{
    m->mcgstatus |= MCG_STATUS_EIPV;
    rdmsrl (rip_msr, m -> rip);
    m->cs = 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/mcheck/mce_64.c.ifdefed" startline="177" endline="318">
{
    struct mce m, panicm;
    u64 mcestart = 0;
    int i;
    int panicm_found = 0;
    int no_way_out = 0;
    int kill_it = 0;
    atomic_inc (& mce_entry);
    if (regs)
        notify_die (DIE_NMI, "machine check", regs, error_code, 18, SIGKILL);
    if (!banks)
        goto out2;
    memset (& m, 0, sizeof (struct mce));
    m.cpu = smp_processor_id ();
    rdmsrl (MSR_IA32_MCG_STATUS, m.mcgstatus);
    if (!(m.mcgstatus & MCG_STATUS_RIPV))
        no_way_out = 1;
    rdtscll (mcestart);
    barrier ();
    for (i = 0; i < banks; i++) {
        if (!bank[i])
            continue;
        m.misc = 0;
        m.addr = 0;
        m.bank = i;
        m.tsc = 0;
        rdmsrl (MSR_IA32_MC0_STATUS + i * 4, m.status);
        if ((m.status & MCI_STATUS_VAL) == 0)
            continue;
        if (m.status & MCI_STATUS_EN) {
            no_way_out |= !!(m.status & MCI_STATUS_PCC);
            if (m.status & MCI_STATUS_UC) {
                if (tolerant < 1 || m.status & MCI_STATUS_OVER)
                    no_way_out = 1;
                kill_it = 1;
            }
        }
        if (m.status & MCI_STATUS_MISCV)
            rdmsrl (MSR_IA32_MC0_MISC +i * 4, m.misc);
        if (m.status & MCI_STATUS_ADDRV)
            rdmsrl (MSR_IA32_MC0_ADDR +i * 4, m.addr);
        mce_get_rip (& m, regs);
        if (error_code >= 0)
            rdtscll (m.tsc);
        if (error_code != -2)
            mce_log (&m);
        if ((m.status & MCI_STATUS_UC) && (m.status & MCI_STATUS_EN)) {
            panicm = m;
            panicm_found = 1;
        }
        add_taint (TAINT_MACHINE_CHECK);
    }
    if (!regs)
        goto out;
    if (!panicm_found)
        panicm = m;
    if (no_way_out && tolerant < 3)
        mce_panic ("Machine check", &panicm, mcestart);
    if (kill_it && tolerant < 3) {
        int user_space = 0;
        if (m.mcgstatus & MCG_STATUS_EIPV)
            user_space = panicm.rip && (panicm.cs & 3);
        if (user_space) {
            do_exit (SIGBUS);
        }
        else if (panic_on_oops || tolerant < 2) {
            mce_panic ("Uncorrected machine check", & panicm, mcestart);
        }
    }
    set_thread_flag (TIF_MCE_NOTIFY);
out :
    for (i = 0; i < banks; i++)
        wrmsrl (MSR_IA32_MC0_STATUS +4 * i, 0);
    wrmsrl (MSR_IA32_MCG_STATUS, 0);
out2 :
    atomic_dec (&mce_entry);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/mcheck/mce_64.c.ifdefed" startline="211" endline="259">
{
    if (!bank[i])
        continue;
    m.misc = 0;
    m.addr = 0;
    m.bank = i;
    m.tsc = 0;
    rdmsrl (MSR_IA32_MC0_STATUS + i * 4, m.status);
    if ((m.status & MCI_STATUS_VAL) == 0)
        continue;
    if (m.status & MCI_STATUS_EN) {
        no_way_out |= !!(m.status & MCI_STATUS_PCC);
        if (m.status & MCI_STATUS_UC) {
            if (tolerant < 1 || m.status & MCI_STATUS_OVER)
                no_way_out = 1;
            kill_it = 1;
        }
    }
    if (m.status & MCI_STATUS_MISCV)
        rdmsrl (MSR_IA32_MC0_MISC +i * 4, m.misc);
    if (m.status & MCI_STATUS_ADDRV)
        rdmsrl (MSR_IA32_MC0_ADDR +i * 4, m.addr);
    mce_get_rip (& m, regs);
    if (error_code >= 0)
        rdtscll (m.tsc);
    if (error_code != -2)
        mce_log (&m);
    if ((m.status & MCI_STATUS_UC) && (m.status & MCI_STATUS_EN)) {
        panicm = m;
        panicm_found = 1;
    }
    add_taint (TAINT_MACHINE_CHECK);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/mcheck/mce_64.c.ifdefed" startline="224" endline="237">
{
    no_way_out |= !!(m.status & MCI_STATUS_PCC);
    if (m.status & MCI_STATUS_UC) {
        if (tolerant < 1 || m.status & MCI_STATUS_OVER)
            no_way_out = 1;
        kill_it = 1;
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/mcheck/mce_64.c.ifdefed" startline="232" endline="236">
{
    if (tolerant < 1 || m.status & MCI_STATUS_OVER)
        no_way_out = 1;
    kill_it = 1;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/mcheck/mce_64.c.ifdefed" startline="253" endline="256">
{
    panicm = m;
    panicm_found = 1;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/mcheck/mce_64.c.ifdefed" startline="283" endline="306">
{
    int user_space = 0;
    if (m.mcgstatus & MCG_STATUS_EIPV)
        user_space = panicm.rip && (panicm.cs & 3);
    if (user_space) {
        do_exit (SIGBUS);
    }
    else if (panic_on_oops || tolerant < 2) {
        mce_panic ("Uncorrected machine check", & panicm, mcestart);
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/mcheck/mce_64.c.ifdefed" startline="300" endline="302">
{
    do_exit (SIGBUS);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/mcheck/mce_64.c.ifdefed" startline="302" endline="305">
{
    mce_panic ("Uncorrected machine check", & panicm, mcestart);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/mcheck/mce_64.c.ifdefed" startline="359" endline="362">
{
    if (mce_available (&current_cpu_data))
        do_machine_check (NULL, 0);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/mcheck/mce_64.c.ifdefed" startline="365" endline="380">
{
    on_each_cpu (mcheck_check_cpu, NULL, 1, 1);
    if (mce_notify_user ()) {
        next_interval = max (next_interval / 2, HZ / 100);
    }
    else {
        next_interval = min (next_interval *2, (int) round_jiffies_relative (check_interval *HZ));
    }
    schedule_delayed_work (& mcheck_work, next_interval);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/mcheck/mce_64.c.ifdefed" startline="372" endline="374">
{
    next_interval = max (next_interval / 2, HZ / 100);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/mcheck/mce_64.c.ifdefed" startline="374" endline="377">
{
    next_interval = min (next_interval *2, (int) round_jiffies_relative (check_interval *HZ));
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/mcheck/mce_64.c.ifdefed" startline="389" endline="408">
{
    clear_thread_flag (TIF_MCE_NOTIFY);
    if (test_and_clear_bit (0, &notify_user)) {
        static unsigned long last_print;
        unsigned long now = jiffies;
        wake_up_interruptible (& mce_wait);
        if (trigger[0])
            call_usermodehelper (trigger, trigger_argv, NULL, UMH_NO_WAIT);
        if (time_after_eq (now, last_print +(check_interval * HZ))) {
            last_print = now;
            printk (KERN_INFO "Machine check events logged\n");
        }
        return 1;
    }
    return 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/mcheck/mce_64.c.ifdefed" startline="391" endline="406">
{
    static unsigned long last_print;
    unsigned long now = jiffies;
    wake_up_interruptible (& mce_wait);
    if (trigger[0])
        call_usermodehelper (trigger, trigger_argv, NULL, UMH_NO_WAIT);
    if (time_after_eq (now, last_print +(check_interval * HZ))) {
        last_print = now;
        printk (KERN_INFO "Machine check events logged\n");
    }
    return 1;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/mcheck/mce_64.c.ifdefed" startline="400" endline="403">
{
    last_print = now;
    printk (KERN_INFO "Machine check events logged\n");
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/mcheck/mce_64.c.ifdefed" startline="413" endline="419">
{
    if (action == IDLE_END && test_thread_flag (TIF_MCE_NOTIFY))
        mce_notify_user ();
    return NOTIFY_OK;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/mcheck/mce_64.c.ifdefed" startline="426" endline="433">
{
    next_interval = check_interval * HZ;
    if (next_interval)
        schedule_delayed_work (&mcheck_work, round_jiffies_relative (next_interval));
    idle_notifier_register (& mce_idle_notifier);
    return 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/mcheck/mce_64.c.ifdefed" startline="441" endline="468">
{
    u64 cap;
    int i;
    rdmsrl (MSR_IA32_MCG_CAP, cap);
    banks = cap & 0xff;
    if (banks > NR_BANKS) {
        printk (KERN_INFO "MCE: warning: using only %d banks\n", banks);
        banks = NR_BANKS;
    }
    if ((cap & (1 << 9)) && ((cap >> 16) & 0xff) >= 9)
        rip_msr = MSR_IA32_MCG_EIP;
    do_machine_check (NULL, mce_bootlog ? - 1 : - 2);
    set_in_cr4 (X86_CR4_MCE);
    if (cap & MCG_CTL_P)
        wrmsr (MSR_IA32_MCG_CTL, 0xffffffff, 0xffffffff);
    for (i = 0; i < banks; i++) {
        wrmsrl (MSR_IA32_MC0_CTL + 4 * i, bank [i]);
        wrmsrl (MSR_IA32_MC0_STATUS + 4 * i, 0);
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/mcheck/mce_64.c.ifdefed" startline="447" endline="450">
{
    printk (KERN_INFO "MCE: warning: using only %d banks\n", banks);
    banks = NR_BANKS;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/mcheck/mce_64.c.ifdefed" startline="464" endline="467">
{
    wrmsrl (MSR_IA32_MC0_CTL + 4 * i, bank [i]);
    wrmsrl (MSR_IA32_MC0_STATUS + 4 * i, 0);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/mcheck/mce_64.c.ifdefed" startline="472" endline="483">
{
    if (c->x86_vendor == X86_VENDOR_AMD && c->x86 == 15) {
        clear_bit (10, & bank [4]);
        mce_bootlog = 0;
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/mcheck/mce_64.c.ifdefed" startline="474" endline="481">
{
    clear_bit (10, & bank [4]);
    mce_bootlog = 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/mcheck/mce_64.c.ifdefed" startline="486" endline="497">
{
    switch (c->x86_vendor) {
    case X86_VENDOR_INTEL :
        mce_intel_feature_init (c);
        break;
    case X86_VENDOR_AMD :
        mce_amd_feature_init (c);
        break;
    default :
        break;
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/mcheck/mce_64.c.ifdefed" startline="487" endline="496">
{
case X86_VENDOR_INTEL :
    mce_intel_feature_init (c);
    break;
case X86_VENDOR_AMD :
    mce_amd_feature_init (c);
    break;
default :
    break;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/mcheck/mce_64.c.ifdefed" startline="504" endline="516">
{
    static cpumask_t mce_cpus = CPU_MASK_NONE;
    mce_cpu_quirks (c);
    if (mce_dont_init || cpu_test_and_set (smp_processor_id (), mce_cpus) || !mce_available (c))
        return;
    mce_init (NULL);
    mce_cpu_features (c);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/mcheck/mce_64.c.ifdefed" startline="527" endline="542">
{
    spin_lock (& mce_state_lock);
    if (open_exclu || (open_count && (file->f_flags & O_EXCL))) {
        spin_unlock (& mce_state_lock);
        return -EBUSY;
    }
    if (file->f_flags & O_EXCL)
        open_exclu = 1;
    open_count++;
    spin_unlock (& mce_state_lock);
    return nonseekable_open (inode, file);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/mcheck/mce_64.c.ifdefed" startline="530" endline="533">
{
    spin_unlock (& mce_state_lock);
    return -EBUSY;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/mcheck/mce_64.c.ifdefed" startline="545" endline="554">
{
    spin_lock (& mce_state_lock);
    open_count--;
    open_exclu = 0;
    spin_unlock (& mce_state_lock);
    return 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/mcheck/mce_64.c.ifdefed" startline="557" endline="561">
{
    unsigned long *cpu_tsc = (unsigned long *) data;
    rdtscll (cpu_tsc [smp_processor_id ()]);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/mcheck/mce_64.c.ifdefed" startline="565" endline="627">
{
    unsigned long *cpu_tsc;
    static DECLARE_MUTEX (mce_read_sem);
    unsigned next;
    char __user *buf = ubuf;
    int i, err;
    cpu_tsc = kmalloc (NR_CPUS * sizeof (long), GFP_KERNEL);
    if (!cpu_tsc)
        return -ENOMEM;
    down (& mce_read_sem);
    next = rcu_dereference (mcelog.next);
    if (*off != 0 || usize < MCE_LOG_LEN * sizeof (struct mce)) {
        up (& mce_read_sem);
        kfree (cpu_tsc);
        return -EINVAL;
    }
    err = 0;
    for (i = 0; i < next; i++) {
        unsigned long start = jiffies;
        while (!mcelog.entry[i].finished) {
            if (time_after_eq (jiffies, start +2)) {
                memset (mcelog.entry + i, 0, sizeof (struct mce));
                goto timeout;
            }
            cpu_relax ();
        }
        smp_rmb ();
        err |= copy_to_user (buf, mcelog.entry + i, sizeof (struct mce));
        buf += sizeof (struct mce);
    timeout :
        ;
    }
    memset (mcelog.entry, 0, next * sizeof (struct mce));
    mcelog.next = 0;
    synchronize_sched ();
    on_each_cpu (collect_tscs, cpu_tsc, 1, 1);
    for (i = next; i < MCE_LOG_LEN; i++) {
        if (mcelog.entry[i].finished && mcelog.entry[i].tsc < cpu_tsc[mcelog.entry[i].cpu]) {
            err |= copy_to_user (buf, mcelog.entry + i, sizeof (struct mce));
            smp_rmb ();
            buf += sizeof (struct mce);
            memset (& mcelog.entry [i], 0, sizeof (struct mce));
        }
    }
    up (& mce_read_sem);
    kfree (cpu_tsc);
    return err ? -EFAULT : buf - ubuf;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/mcheck/mce_64.c.ifdefed" startline="580" endline="584">
{
    up (& mce_read_sem);
    kfree (cpu_tsc);
    return -EINVAL;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/mcheck/mce_64.c.ifdefed" startline="587" endline="602">
{
    unsigned long start = jiffies;
    while (!mcelog.entry[i].finished) {
        if (time_after_eq (jiffies, start +2)) {
            memset (mcelog.entry + i, 0, sizeof (struct mce));
            goto timeout;
        }
        cpu_relax ();
    }
    smp_rmb ();
    err |= copy_to_user (buf, mcelog.entry + i, sizeof (struct mce));
    buf += sizeof (struct mce);
timeout :
    ;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/mcheck/mce_64.c.ifdefed" startline="590" endline="596">
{
    if (time_after_eq (jiffies, start +2)) {
        memset (mcelog.entry + i, 0, sizeof (struct mce));
        goto timeout;
    }
    cpu_relax ();
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/mcheck/mce_64.c.ifdefed" startline="591" endline="594">
{
    memset (mcelog.entry + i, 0, sizeof (struct mce));
    goto timeout;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/mcheck/mce_64.c.ifdefed" startline="614" endline="623">
{
    if (mcelog.entry[i].finished && mcelog.entry[i].tsc < cpu_tsc[mcelog.entry[i].cpu]) {
        err |= copy_to_user (buf, mcelog.entry + i, sizeof (struct mce));
        smp_rmb ();
        buf += sizeof (struct mce);
        memset (& mcelog.entry [i], 0, sizeof (struct mce));
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/mcheck/mce_64.c.ifdefed" startline="616" endline="622">
{
    err |= copy_to_user (buf, mcelog.entry + i, sizeof (struct mce));
    smp_rmb ();
    buf += sizeof (struct mce);
    memset (& mcelog.entry [i], 0, sizeof (struct mce));
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/mcheck/mce_64.c.ifdefed" startline="630" endline="635">
{
    poll_wait (file, & mce_wait, wait);
    if (rcu_dereference (mcelog.next))
        return POLLIN | POLLRDNORM;
    return 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/mcheck/mce_64.c.ifdefed" startline="639" endline="660">
{
    int __user *p = (int __user *) arg;
    if (!capable (CAP_SYS_ADMIN))
        return -EPERM;
    switch (cmd) {
    case MCE_GET_RECORD_LEN :
        return put_user (sizeof (struct mce), p);
    case MCE_GET_LOG_LEN :
        return put_user (MCE_LOG_LEN, p);
    case MCE_GETCLEAR_FLAGS :
        {
            unsigned flags;
            do {
                flags = mcelog.flags;
            }
            while (cmpxchg (&mcelog.flags, flags, 0) != flags);
            return put_user (flags, p);
        }
    default :
        return -ENOTTY;
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/mcheck/mce_64.c.ifdefed" startline="644" endline="659">
{
case MCE_GET_RECORD_LEN :
    return put_user (sizeof (struct mce), p);
case MCE_GET_LOG_LEN :
    return put_user (MCE_LOG_LEN, p);
case MCE_GETCLEAR_FLAGS :
    {
        unsigned flags;
        do {
            flags = mcelog.flags;
        }
        while (cmpxchg (&mcelog.flags, flags, 0) != flags);
        return put_user (flags, p);
    }
default :
    return -ENOTTY;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/mcheck/mce_64.c.ifdefed" startline="649" endline="656">
{
    unsigned flags;
    do {
        flags = mcelog.flags;
    }
    while (cmpxchg (&mcelog.flags, flags, 0) != flags);
    return put_user (flags, p);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/mcheck/mce_64.c.ifdefed" startline="652" endline="654">
{
    flags = mcelog.flags;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/mcheck/mce_64.c.ifdefed" startline="679" endline="682">
{
    old_cr4 = read_cr4 ();
    clear_in_cr4 (X86_CR4_MCE);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/mcheck/mce_64.c.ifdefed" startline="685" endline="688">
{
    if (old_cr4 & X86_CR4_MCE)
        set_in_cr4 (X86_CR4_MCE);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/mcheck/mce_64.c.ifdefed" startline="694" endline="697">
{
    mce_dont_init = 1;
    return 1;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/mcheck/mce_64.c.ifdefed" startline="705" endline="715">
{
    if (!strcmp (str, "off"))
        mce_dont_init = 1;
    else if (!strcmp (str, "bootlog") || !strcmp (str, "nobootlog"))
        mce_bootlog = str[0] == 'b';
    else if (isdigit (str[0]))
        get_option (&str, &tolerant);
    else
        printk ("mce= argument %s ignored. Please use /sys", str);
    return 1;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/mcheck/mce_64.c.ifdefed" startline="728" endline="731">
{
    mce_init (NULL);
    return 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/mcheck/mce_64.c.ifdefed" startline="735" endline="744">
{
    if (next_interval)
        cancel_delayed_work (&mcheck_work);
    on_each_cpu (mce_init, NULL, 1, 1);
    next_interval = check_interval * HZ;
    if (next_interval)
        schedule_delayed_work (&mcheck_work, round_jiffies_relative (next_interval));
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/mcheck/mce_64.c.ifdefed" startline="777" endline="781">
{
    strcpy (buf, trigger);
    strcat (buf, "\n");
    return strlen (trigger) + 1;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/mcheck/mce_64.c.ifdefed" startline="784" endline="793">
{
    char *p;
    int len;
    strncpy (trigger, buf, sizeof (trigger));
    trigger[sizeof (trigger) - 1] = 0;
    len = strlen (trigger);
    p = strchr (trigger, '\n');
    if (*p)
        *p = 0;
    return len;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/mcheck/mce_64.c.ifdefed" startline="809" endline="841">
{
    int err;
    int i;
    if (!mce_available (&boot_cpu_data))
        return -EIO;
    memset (& per_cpu (device_mce, cpu).kobj, 0, sizeof (struct kobject));
    per_cpu (device_mce, cpu).id = cpu;
    per_cpu (device_mce, cpu).cls = &mce_sysclass;
    err = sysdev_register (&per_cpu (device_mce, cpu));
    if (err)
        return err;
    for (i = 0; mce_attributes[i]; i++) {
        err = sysdev_create_file (&per_cpu (device_mce, cpu), mce_attributes[i]);
        if (err)
            goto error;
    }
    cpu_set (cpu, mce_device_initialized);
    return 0;
error :
    while (i--) {
        sysdev_remove_file (& per_cpu (device_mce, cpu), mce_attributes [i]);
    }
    sysdev_unregister (& per_cpu (device_mce, cpu));
    return err;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/mcheck/mce_64.c.ifdefed" startline="824" endline="829">
{
    err = sysdev_create_file (&per_cpu (device_mce, cpu), mce_attributes[i]);
    if (err)
        goto error;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/mcheck/mce_64.c.ifdefed" startline="834" endline="837">
{
    sysdev_remove_file (& per_cpu (device_mce, cpu), mce_attributes [i]);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/mcheck/mce_64.c.ifdefed" startline="844" endline="855">
{
    int i;
    if (!cpu_isset (cpu, mce_device_initialized))
        return;
    for (i = 0; mce_attributes[i]; i++)
        sysdev_remove_file (&per_cpu (device_mce, cpu), mce_attributes[i]);
    sysdev_unregister (& per_cpu (device_mce, cpu));
    cpu_clear (cpu, mce_device_initialized);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/mcheck/mce_64.c.ifdefed" startline="860" endline="874">
{
    unsigned int cpu = (unsigned long) hcpu;
    switch (action) {
    case CPU_ONLINE :
    case CPU_ONLINE_FROZEN :
        mce_create_device (cpu);
        break;
    case CPU_DEAD :
    case CPU_DEAD_FROZEN :
        mce_remove_device (cpu);
        break;
    }
    return NOTIFY_OK;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/mcheck/mce_64.c.ifdefed" startline="863" endline="872">
{
case CPU_ONLINE :
case CPU_ONLINE_FROZEN :
    mce_create_device (cpu);
    break;
case CPU_DEAD :
case CPU_DEAD_FROZEN :
    mce_remove_device (cpu);
    break;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/mcheck/mce_64.c.ifdefed" startline="881" endline="900">
{
    int err;
    int i = 0;
    if (!mce_available (&boot_cpu_data))
        return -EIO;
    err = sysdev_class_register (&mce_sysclass);
    if (err)
        return err;

    for_each_online_cpu (i) {
        err = mce_create_device (i);
        if (err)
            return err;
    }

    register_hotcpu_notifier (& mce_cpu_notifier);
    misc_register (& mce_log_device);
    return err;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/mcheck/mce_64.c.ifdefed" startline="891" endline="895">
{
    err = mce_create_device (i);
    if (err)
        return err;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/mcheck/mce_amd_64.c.ifdefed" startline="89" endline="114">
{
    u32 mci_misc_hi, mci_misc_lo;
    rdmsr (b -> address, mci_misc_lo, mci_misc_hi);
    if (b->threshold_limit < (mci_misc_hi & THRESHOLD_MAX))
        reset = 1;
    if (reset) {
        mci_misc_hi = (mci_misc_hi & ~(MASK_ERR_COUNT_HI | MASK_OVERFLOW_HI)) | (THRESHOLD_MAX - b->threshold_limit);
    }
    else if (old_limit) {
        int new_count = (mci_misc_hi & THRESHOLD_MAX) + (old_limit - b->threshold_limit);
        mci_misc_hi = (mci_misc_hi & ~MASK_ERR_COUNT_HI) | (new_count & THRESHOLD_MAX);
    }
    b->interrupt_enable ? (mci_misc_hi = (mci_misc_hi & ~MASK_INT_TYPE_HI) | INT_TYPE_APIC) : (mci_misc_hi &= ~MASK_INT_TYPE_HI);
    mci_misc_hi |= MASK_COUNT_EN_HI;
    wrmsr (b -> address, mci_misc_lo, mci_misc_hi);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/mcheck/mce_amd_64.c.ifdefed" startline="97" endline="101">
{
    mci_misc_hi = (mci_misc_hi & ~(MASK_ERR_COUNT_HI | MASK_OVERFLOW_HI)) | (THRESHOLD_MAX - b->threshold_limit);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/mcheck/mce_amd_64.c.ifdefed" startline="101" endline="106">
{
    int new_count = (mci_misc_hi & THRESHOLD_MAX) + (old_limit - b->threshold_limit);
    mci_misc_hi = (mci_misc_hi & ~MASK_ERR_COUNT_HI) | (new_count & THRESHOLD_MAX);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/mcheck/mce_amd_64.c.ifdefed" startline="118" endline="168">
{
    unsigned int bank, block;
    unsigned int cpu = smp_processor_id ();
    u32 low = 0, high = 0, address = 0;
    for (bank = 0; bank < NR_BANKS; ++bank) {
        for (block = 0; block < NR_BLOCKS; ++block) {
            if (block == 0)
                address = MSR_IA32_MC0_MISC + bank * 4;
            else if (block == 1) {
                address = (low & MASK_BLKPTR_LO) >> 21;
                if (!address)
                    break;
                address += MCG_XBLK_ADDR;
            }
            else
                ++address;
            if (rdmsr_safe (address, &low, &high))
                break;
            if (!(high & MASK_VALID_HI)) {
                if (block)
                    continue;
                else
                    break;
            }
            if (!(high & MASK_CNTP_HI) || (high & MASK_LOCKED_HI))
                continue;
            if (!block)
                per_cpu (bank_map, cpu) |= (1 << bank);
            high &= ~MASK_LVTOFF_HI;
            high |= K8_APIC_EXT_LVT_ENTRY_THRESHOLD << 20;
            wrmsr (address, low, high);
            setup_APIC_extended_lvt (K8_APIC_EXT_LVT_ENTRY_THRESHOLD, THRESHOLD_APIC_VECTOR, K8_APIC_EXT_INT_MSG_FIX, 0);
            threshold_defaults.address = address;
            threshold_restart_bank (& threshold_defaults, 0, 0);
        }
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/mcheck/mce_amd_64.c.ifdefed" startline="123" endline="167">
{
    for (block = 0; block < NR_BLOCKS; ++block) {
        if (block == 0)
            address = MSR_IA32_MC0_MISC + bank * 4;
        else if (block == 1) {
            address = (low & MASK_BLKPTR_LO) >> 21;
            if (!address)
                break;
            address += MCG_XBLK_ADDR;
        }
        else
            ++address;
        if (rdmsr_safe (address, &low, &high))
            break;
        if (!(high & MASK_VALID_HI)) {
            if (block)
                continue;
            else
                break;
        }
        if (!(high & MASK_CNTP_HI) || (high & MASK_LOCKED_HI))
            continue;
        if (!block)
            per_cpu (bank_map, cpu) |= (1 << bank);
        high &= ~MASK_LVTOFF_HI;
        high |= K8_APIC_EXT_LVT_ENTRY_THRESHOLD << 20;
        wrmsr (address, low, high);
        setup_APIC_extended_lvt (K8_APIC_EXT_LVT_ENTRY_THRESHOLD, THRESHOLD_APIC_VECTOR, K8_APIC_EXT_INT_MSG_FIX, 0);
        threshold_defaults.address = address;
        threshold_restart_bank (& threshold_defaults, 0, 0);
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/mcheck/mce_amd_64.c.ifdefed" startline="124" endline="166">
{
    if (block == 0)
        address = MSR_IA32_MC0_MISC + bank * 4;
    else if (block == 1) {
        address = (low & MASK_BLKPTR_LO) >> 21;
        if (!address)
            break;
        address += MCG_XBLK_ADDR;
    }
    else
        ++address;
    if (rdmsr_safe (address, &low, &high))
        break;
    if (!(high & MASK_VALID_HI)) {
        if (block)
            continue;
        else
            break;
    }
    if (!(high & MASK_CNTP_HI) || (high & MASK_LOCKED_HI))
        continue;
    if (!block)
        per_cpu (bank_map, cpu) |= (1 << bank);
    high &= ~MASK_LVTOFF_HI;
    high |= K8_APIC_EXT_LVT_ENTRY_THRESHOLD << 20;
    wrmsr (address, low, high);
    setup_APIC_extended_lvt (K8_APIC_EXT_LVT_ENTRY_THRESHOLD, THRESHOLD_APIC_VECTOR, K8_APIC_EXT_INT_MSG_FIX, 0);
    threshold_defaults.address = address;
    threshold_restart_bank (& threshold_defaults, 0, 0);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/mcheck/mce_amd_64.c.ifdefed" startline="127" endline="132">
{
    address = (low & MASK_BLKPTR_LO) >> 21;
    if (!address)
        break;
    address += MCG_XBLK_ADDR;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/mcheck/mce_amd_64.c.ifdefed" startline="139" endline="144">
{
    if (block)
        continue;
    else
        break;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/mcheck/mce_amd_64.c.ifdefed" startline="180" endline="242">
{
    unsigned int bank, block;
    struct mce m;
    u32 low = 0, high = 0, address = 0;
    ack_APIC_irq ();
    exit_idle ();
    irq_enter ();
    memset (& m, 0, sizeof (m));
    rdtscll (m.tsc);
    m.cpu = smp_processor_id ();
    for (bank = 0; bank < NR_BANKS; ++bank) {
        if (!(per_cpu (bank_map, m.cpu) & (1 << bank)))
            continue;
        for (block = 0; block < NR_BLOCKS; ++block) {
            if (block == 0)
                address = MSR_IA32_MC0_MISC + bank * 4;
            else if (block == 1) {
                address = (low & MASK_BLKPTR_LO) >> 21;
                if (!address)
                    break;
                address += MCG_XBLK_ADDR;
            }
            else
                ++address;
            if (rdmsr_safe (address, &low, &high))
                break;
            if (!(high & MASK_VALID_HI)) {
                if (block)
                    continue;
                else
                    break;
            }
            if (!(high & MASK_CNTP_HI) || (high & MASK_LOCKED_HI))
                continue;
            do_machine_check (NULL, 0);
            if (high & MASK_OVERFLOW_HI) {
                rdmsrl (address, m.misc);
                rdmsrl (MSR_IA32_MC0_STATUS + bank * 4, m.status);
                m.bank = K8_MCE_THRESHOLD_BASE + bank * NR_BLOCKS + block;
                mce_log (& m);
                goto out;
            }
        }
    }
out :
    add_pda (irq_threshold_count, 1);
    irq_exit ();
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/mcheck/mce_amd_64.c.ifdefed" startline="194" endline="238">
{
    if (!(per_cpu (bank_map, m.cpu) & (1 << bank)))
        continue;
    for (block = 0; block < NR_BLOCKS; ++block) {
        if (block == 0)
            address = MSR_IA32_MC0_MISC + bank * 4;
        else if (block == 1) {
            address = (low & MASK_BLKPTR_LO) >> 21;
            if (!address)
                break;
            address += MCG_XBLK_ADDR;
        }
        else
            ++address;
        if (rdmsr_safe (address, &low, &high))
            break;
        if (!(high & MASK_VALID_HI)) {
            if (block)
                continue;
            else
                break;
        }
        if (!(high & MASK_CNTP_HI) || (high & MASK_LOCKED_HI))
            continue;
        do_machine_check (NULL, 0);
        if (high & MASK_OVERFLOW_HI) {
            rdmsrl (address, m.misc);
            rdmsrl (MSR_IA32_MC0_STATUS + bank * 4, m.status);
            m.bank = K8_MCE_THRESHOLD_BASE + bank * NR_BLOCKS + block;
            mce_log (& m);
            goto out;
        }
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/mcheck/mce_amd_64.c.ifdefed" startline="197" endline="237">
{
    if (block == 0)
        address = MSR_IA32_MC0_MISC + bank * 4;
    else if (block == 1) {
        address = (low & MASK_BLKPTR_LO) >> 21;
        if (!address)
            break;
        address += MCG_XBLK_ADDR;
    }
    else
        ++address;
    if (rdmsr_safe (address, &low, &high))
        break;
    if (!(high & MASK_VALID_HI)) {
        if (block)
            continue;
        else
            break;
    }
    if (!(high & MASK_CNTP_HI) || (high & MASK_LOCKED_HI))
        continue;
    do_machine_check (NULL, 0);
    if (high & MASK_OVERFLOW_HI) {
        rdmsrl (address, m.misc);
        rdmsrl (MSR_IA32_MC0_STATUS + bank * 4, m.status);
        m.bank = K8_MCE_THRESHOLD_BASE + bank * NR_BLOCKS + block;
        mce_log (& m);
        goto out;
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/mcheck/mce_amd_64.c.ifdefed" startline="200" endline="205">
{
    address = (low & MASK_BLKPTR_LO) >> 21;
    if (!address)
        break;
    address += MCG_XBLK_ADDR;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/mcheck/mce_amd_64.c.ifdefed" startline="212" endline="217">
{
    if (block)
        continue;
    else
        break;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/mcheck/mce_amd_64.c.ifdefed" startline="227" endline="236">
{
    rdmsrl (address, m.misc);
    rdmsrl (MSR_IA32_MC0_STATUS + bank * 4, m.status);
    m.bank = K8_MCE_THRESHOLD_BASE + bank * NR_BLOCKS + block;
    mce_log (& m);
    goto out;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/mcheck/mce_amd_64.c.ifdefed" startline="255" endline="261">
{
    cpumask_t oldmask = current->cpus_allowed;
    cpumask_t newmask = CPU_MASK_NONE;
    cpu_set (cpu, newmask);
    set_cpus_allowed (current, newmask);
    return oldmask;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/mcheck/mce_amd_64.c.ifdefed" startline="264" endline="266">
{
    set_cpus_allowed (current, oldmask);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/mcheck/mce_amd_64.c.ifdefed" startline="278" endline="291">
{
    char *end;
    cpumask_t oldmask;
    unsigned long new = simple_strtoul (buf, &end, 0);
    if (end == buf)
        return -EINVAL;
    b->interrupt_enable = !!new;
    oldmask = affinity_set (b->cpu);
    threshold_restart_bank (b, 0, 0);
    affinity_restore (oldmask);
    return end - buf;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/mcheck/mce_amd_64.c.ifdefed" startline="295" endline="314">
{
    char *end;
    cpumask_t oldmask;
    u16 old;
    unsigned long new = simple_strtoul (buf, &end, 0);
    if (end == buf)
        return -EINVAL;
    if (new > THRESHOLD_MAX)
        new = THRESHOLD_MAX;
    if (new < 1)
        new = 1;
    old = b->threshold_limit;
    b->threshold_limit = new;
    oldmask = affinity_set (b->cpu);
    threshold_restart_bank (b, 0, old);
    affinity_restore (oldmask);
    return end - buf;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/mcheck/mce_amd_64.c.ifdefed" startline="317" endline="325">
{
    u32 high, low;
    cpumask_t oldmask;
    oldmask = affinity_set (b->cpu);
    rdmsr (b -> address, low, high);
    affinity_restore (oldmask);
    return sprintf (buf, "%x\n", (high & 0xFFF) - (THRESHOLD_MAX - b->threshold_limit));
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/mcheck/mce_amd_64.c.ifdefed" startline="329" endline="335">
{
    cpumask_t oldmask;
    oldmask = affinity_set (b->cpu);
    threshold_restart_bank (b, 1, 0);
    affinity_restore (oldmask);
    return 1;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/mcheck/mce_amd_64.c.ifdefed" startline="362" endline="368">
{
    struct threshold_block *b = to_block (kobj);
    struct threshold_attr *a = to_attr (attr);
    ssize_t ret;
    ret = a->show ? a->show (b, buf) : -EIO;
    return ret;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/mcheck/mce_amd_64.c.ifdefed" startline="372" endline="378">
{
    struct threshold_block *b = to_block (kobj);
    struct threshold_attr *a = to_attr (attr);
    ssize_t ret;
    ret = a->store ? a->store (b, buf, count) : -EIO;
    return ret;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/mcheck/mce_amd_64.c.ifdefed" startline="394" endline="462">
{
    int err;
    u32 low, high;
    struct threshold_block *b = NULL;
    if ((bank >= NR_BANKS) || (block >= NR_BLOCKS))
        return 0;
    if (rdmsr_safe (address, &low, &high))
        return 0;
    if (!(high & MASK_VALID_HI)) {
        if (block)
            goto recurse;
        else
            return 0;
    }
    if (!(high & MASK_CNTP_HI) || (high & MASK_LOCKED_HI))
        goto recurse;
    b = kzalloc (sizeof (struct threshold_block), GFP_KERNEL);
    if (!b)
        return -ENOMEM;
    b->block = block;
    b->bank = bank;
    b->cpu = cpu;
    b->address = address;
    b->interrupt_enable = 0;
    b->threshold_limit = THRESHOLD_MAX;
    INIT_LIST_HEAD (& b -> miscj);
    if (per_cpu (threshold_banks, cpu)[bank]->blocks)
        list_add (&b->miscj, &per_cpu (threshold_banks, cpu)[bank]->blocks->miscj);
    else
        per_cpu (threshold_banks, cpu)[bank]->blocks = b;
    kobject_set_name (& b -> kobj, "misc%i", block);
    b->kobj.parent = &per_cpu (threshold_banks, cpu)[bank]->kobj;
    b->kobj.ktype = &threshold_ktype;
    err = kobject_register (&b->kobj);
    if (err)
        goto out_free;
recurse :
    if (!block) {
        address = (low & MASK_BLKPTR_LO) >> 21;
        if (!address)
            return 0;
        address += MCG_XBLK_ADDR;
    }
    else
        ++address;
    err = allocate_threshold_blocks (cpu, bank, ++block, address);
    if (err)
        goto out_free;
    return err;
out_free :
    if (b) {
        kobject_unregister (& b -> kobj);
        kfree (b);
    }
    return err;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/mcheck/mce_amd_64.c.ifdefed" startline="405" endline="410">
{
    if (block)
        goto recurse;
    else
        return 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/mcheck/mce_amd_64.c.ifdefed" startline="442" endline="447">
{
    address = (low & MASK_BLKPTR_LO) >> 21;
    if (!address)
        return 0;
    address += MCG_XBLK_ADDR;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/mcheck/mce_amd_64.c.ifdefed" startline="457" endline="460">
{
    kobject_unregister (& b -> kobj);
    kfree (b);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/mcheck/mce_amd_64.c.ifdefed" startline="466" endline="548">
{
    int i, err = 0;
    struct threshold_bank *b = NULL;
    cpumask_t oldmask = CPU_MASK_NONE;
    char name [32];
    sprintf (name, "threshold_bank%i", bank);
    b = kzalloc (sizeof (struct threshold_bank), GFP_KERNEL);
    if (!b) {
        err = -ENOMEM;
        goto out;
    }
    kobject_set_name (& b -> kobj, "threshold_bank%i", bank);
    b->kobj.parent = &per_cpu (device_mce, cpu).kobj;
    b->cpus = CPU_MASK_ALL;
    err = kobject_register (&b->kobj);
    if (err)
        goto out_free;
    per_cpu (threshold_banks, cpu)[bank] = b;
    oldmask = affinity_set (cpu);
    err = allocate_threshold_blocks (cpu, bank, 0, MSR_IA32_MC0_MISC +bank * 4);
    affinity_restore (oldmask);
    if (err)
        goto out_free;
    for_each_cpu_mask (i, b -> cpus)
    {
        if (i == cpu)
            continue;
        err = sysfs_create_link (&per_cpu (device_mce, i).kobj, &b->kobj, name);
        if (err)
            goto out;
        per_cpu (threshold_banks, i)[bank] = b;
    }
    goto out;
out_free :
    per_cpu (threshold_banks, cpu)[bank] = NULL;
    kfree (b);
out :
    return err;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/mcheck/mce_amd_64.c.ifdefed" startline="503" endline="506">
{
    err = -ENOMEM;
    goto out;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/mcheck/mce_amd_64.c.ifdefed" startline="529" endline="539">
{
    if (i == cpu)
        continue;
    err = sysfs_create_link (&per_cpu (device_mce, i).kobj, &b->kobj, name);
    if (err)
        goto out;
    per_cpu (threshold_banks, i)[bank] = b;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/mcheck/mce_amd_64.c.ifdefed" startline="552" endline="565">
{
    unsigned int bank;
    int err = 0;
    for (bank = 0; bank < NR_BANKS; ++bank) {
        if (!(per_cpu (bank_map, cpu) & 1 << bank))
            continue;
        err = threshold_create_bank (cpu, bank);
        if (err)
            goto out;
    }
out :
    return err;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/mcheck/mce_amd_64.c.ifdefed" startline="556" endline="562">
{
    if (!(per_cpu (bank_map, cpu) & 1 << bank))
        continue;
    err = threshold_create_bank (cpu, bank);
    if (err)
        goto out;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/mcheck/mce_amd_64.c.ifdefed" startline="575" endline="591">
{
    struct threshold_block *pos = NULL;
    struct threshold_block *tmp = NULL;
    struct threshold_bank *head = per_cpu (threshold_banks, cpu)[bank];
    if (!head)
        return;
    list_for_each_entry_safe (pos, tmp, &head->blocks->miscj, miscj) {
        kobject_unregister (& pos -> kobj);
        list_del (& pos -> miscj);
        kfree (pos);
    }
    kfree (per_cpu (threshold_banks, cpu) [bank] -> blocks);
    per_cpu (threshold_banks, cpu)[bank]->blocks = NULL;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/mcheck/mce_amd_64.c.ifdefed" startline="583" endline="587">
{
    kobject_unregister (& pos -> kobj);
    list_del (& pos -> miscj);
    kfree (pos);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/mcheck/mce_amd_64.c.ifdefed" startline="594" endline="633">
{
    int i = 0;
    struct threshold_bank *b;
    char name [32];
    b = per_cpu (threshold_banks, cpu)[bank];
    if (!b)
        return;
    if (!b->blocks)
        goto free_out;
    sprintf (name, "threshold_bank%i", bank);
    for_each_cpu_mask (i, b -> cpus)
    {
        if (i == cpu)
            continue;
        sysfs_remove_link (& per_cpu (device_mce, i).kobj, name);
        per_cpu (threshold_banks, i)[bank] = NULL;
    }
    deallocate_threshold_block (cpu, bank);
free_out :
    kobject_unregister (&b->kobj);
    kfree (b);
    per_cpu (threshold_banks, cpu)[bank] = NULL;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/mcheck/mce_amd_64.c.ifdefed" startline="619" endline="625">
{
    if (i == cpu)
        continue;
    sysfs_remove_link (& per_cpu (device_mce, i).kobj, name);
    per_cpu (threshold_banks, i)[bank] = NULL;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/mcheck/mce_amd_64.c.ifdefed" startline="636" endline="644">
{
    unsigned int bank;
    for (bank = 0; bank < NR_BANKS; ++bank) {
        if (!(per_cpu (bank_map, cpu) & 1 << bank))
            continue;
        threshold_remove_bank (cpu, bank);
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/mcheck/mce_amd_64.c.ifdefed" startline="639" endline="643">
{
    if (!(per_cpu (bank_map, cpu) & 1 << bank))
        continue;
    threshold_remove_bank (cpu, bank);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/mcheck/mce_amd_64.c.ifdefed" startline="649" endline="670">
{
    unsigned int cpu = (unsigned long) hcpu;
    if (cpu >= NR_CPUS)
        goto out;
    switch (action) {
    case CPU_ONLINE :
    case CPU_ONLINE_FROZEN :
        threshold_create_device (cpu);
        break;
    case CPU_DEAD :
    case CPU_DEAD_FROZEN :
        threshold_remove_device (cpu);
        break;
    default :
        break;
    }
out :
    return NOTIFY_OK;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/mcheck/mce_amd_64.c.ifdefed" startline="656" endline="667">
{
case CPU_ONLINE :
case CPU_ONLINE_FROZEN :
    threshold_create_device (cpu);
    break;
case CPU_DEAD :
case CPU_DEAD_FROZEN :
    threshold_remove_device (cpu);
    break;
default :
    break;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/mcheck/mce_amd_64.c.ifdefed" startline="677" endline="688">
{
    unsigned lcpu = 0;

    for_each_online_cpu (lcpu) {
        int err = threshold_create_device (lcpu);
        if (err)
            return err;
    }

    register_hotcpu_notifier (& threshold_cpu_notifier);
    return 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/mcheck/mce_amd_64.c.ifdefed" startline="681" endline="685">
{
    int err = threshold_create_device (lcpu);
    if (err)
        return err;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/mcheck/mce_intel_64.c.ifdefed" startline="17" endline="31">
{
    __u64 msr_val;
    ack_APIC_irq ();
    exit_idle ();
    irq_enter ();
    rdmsrl (MSR_IA32_THERM_STATUS, msr_val);
    if (therm_throt_process (msr_val &1))
        mce_log_therm_throt_event (smp_processor_id (), msr_val);
    add_pda (irq_thermal_count, 1);
    irq_exit ();
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/mcheck/mce_intel_64.c.ifdefed" startline="34" endline="85">
{
    u32 l, h;
    int tm2 = 0;
    unsigned int cpu = smp_processor_id ();
    if (!cpu_has (c, X86_FEATURE_ACPI))
        return;
    if (!cpu_has (c, X86_FEATURE_ACC))
        return;
    rdmsr (MSR_IA32_MISC_ENABLE, l, h);
    h = apic_read (APIC_LVTTHMR);
    if ((l & (1 << 3)) && (h & APIC_DM_SMI)) {
        printk (KERN_DEBUG "CPU%d: Thermal monitoring handled by SMI\n", cpu);
        return;
    }
    if (cpu_has (c, X86_FEATURE_TM2) && (l & (1 << 13)))
        tm2 = 1;
    if (h & APIC_VECTOR_MASK) {
        printk (KERN_DEBUG "CPU%d: Thermal LVT vector (%#x) already " "installed\n", cpu, (h & APIC_VECTOR_MASK));
        return;
    }
    h = THERMAL_APIC_VECTOR;
    h |= (APIC_DM_FIXED | APIC_LVT_MASKED);
    apic_write (APIC_LVTTHMR, h);
    rdmsr (MSR_IA32_THERM_INTERRUPT, l, h);
    wrmsr (MSR_IA32_THERM_INTERRUPT, l | 0x03, h);
    rdmsr (MSR_IA32_MISC_ENABLE, l, h);
    wrmsr (MSR_IA32_MISC_ENABLE, l | (1 << 3), h);
    l = apic_read (APIC_LVTTHMR);
    apic_write (APIC_LVTTHMR, l & ~ APIC_LVT_MASKED);
    printk (KERN_INFO "CPU%d: Thermal monitoring enabled (%s)\n", cpu, tm2 ? "TM2" : "TM1");
    atomic_set (& therm_throt_en, 1);
    return;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/mcheck/mce_intel_64.c.ifdefed" startline="51" endline="55">
{
    printk (KERN_DEBUG "CPU%d: Thermal monitoring handled by SMI\n", cpu);
    return;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/mcheck/mce_intel_64.c.ifdefed" startline="60" endline="65">
{
    printk (KERN_DEBUG "CPU%d: Thermal LVT vector (%#x) already " "installed\n", cpu, (h & APIC_VECTOR_MASK));
    return;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/mcheck/mce_intel_64.c.ifdefed" startline="88" endline="90">
{
    intel_init_thermal (c);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/mcheck/therm_throt.c.ifdefed" startline="86" endline="110">
{
    unsigned int cpu = smp_processor_id ();
    __u64 tmp_jiffs = get_jiffies_64 ();
    if (curr)
        __get_cpu_var (thermal_throttle_count)++;
    if (time_before64 (tmp_jiffs, __get_cpu_var (next_check)))
        return 0;
    __get_cpu_var (next_check) = tmp_jiffs + CHECK_INTERVAL;
    if (curr) {
        printk (KERN_CRIT "CPU%d: Temperature above threshold, " "cpu clock throttled (total events = %lu)\n", cpu, __get_cpu_var (thermal_throttle_count));
        add_taint (TAINT_MACHINE_CHECK);
    }
    else {
        printk (KERN_CRIT "CPU%d: Temperature/speed normal\n", cpu);
    }
    return 1;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/mcheck/therm_throt.c.ifdefed" startline="99" endline="105">
{
    printk (KERN_CRIT "CPU%d: Temperature above threshold, " "cpu clock throttled (total events = %lu)\n", cpu, __get_cpu_var (thermal_throttle_count));
    add_taint (TAINT_MACHINE_CHECK);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/cpu/mcheck/therm_throt.c.ifdefed" startline="105" endline="107">
{
    printk (KERN_CRIT "CPU%d: Temperature/speed normal\n", cpu);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/ioport_64.c.ifdefed" startline="20" endline="28">
{
    int i;
    if (new_value)
        for (i = base; i < base + extent; i++)
            __set_bit (i, bitmap);
    else
        for (i = base; i < base + extent; i++)
            clear_bit (i, bitmap);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/ioport_64.c.ifdefed" startline="34" endline="91">
{
    unsigned int i, max_long, bytes, bytes_updated;
    struct thread_struct *t = &current->thread;
    struct tss_struct *tss;
    unsigned long *bitmap;
    if ((from + num <= from) || (from + num > IO_BITMAP_BITS))
        return -EINVAL;
    if (turn_on && !capable (CAP_SYS_RAWIO))
        return -EPERM;
    if (!t->io_bitmap_ptr) {
        bitmap = kmalloc (IO_BITMAP_BYTES, GFP_KERNEL);
        if (!bitmap)
            return -ENOMEM;
        memset (bitmap, 0xff, IO_BITMAP_BYTES);
        t->io_bitmap_ptr = bitmap;
        set_thread_flag (TIF_IO_BITMAP);
    }
    tss = &per_cpu (init_tss, get_cpu ());
    set_bitmap (t -> io_bitmap_ptr, from, num, ! turn_on);
    max_long = 0;
    for (i = 0; i < IO_BITMAP_LONGS; i++)
        if (t->io_bitmap_ptr[i] != ~0UL)
            max_long = i;
    bytes = (max_long + 1) * sizeof (long);
    bytes_updated = max (bytes, t->io_bitmap_max);
    t->io_bitmap_max = bytes;
    memcpy (tss -> io_bitmap, t -> io_bitmap_ptr, bytes_updated);
    put_cpu ();
    return 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/ioport_64.c.ifdefed" startline="50" endline="58">
{
    bitmap = kmalloc (IO_BITMAP_BYTES, GFP_KERNEL);
    if (!bitmap)
        return -ENOMEM;
    memset (bitmap, 0xff, IO_BITMAP_BYTES);
    t->io_bitmap_ptr = bitmap;
    set_thread_flag (TIF_IO_BITMAP);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/ioport_64.c.ifdefed" startline="105" endline="117">
{
    unsigned int old = (regs->eflags >> 12) & 3;
    if (level > 3)
        return -EINVAL;
    if (level > old) {
        if (!capable (CAP_SYS_RAWIO))
            return -EPERM;
    }
    regs->eflags = (regs->eflags & ~X86_EFLAGS_IOPL) | (level << 12);
    return 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/ioport_64.c.ifdefed" startline="111" endline="114">
{
    if (!capable (CAP_SYS_RAWIO))
        return -EPERM;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/topology.c.ifdefed" startline="37" endline="53">
{
    return register_cpu (&cpu_devices[num].cpu, num);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/topology.c.ifdefed" startline="65" endline="76">
{
    int i;
    for_each_present_cpu (i)
    arch_register_cpu (i);
    return 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/time_64.c.ifdefed" startline="55" endline="69">
{
    unsigned long pc = instruction_pointer (regs);
    if (!user_mode (regs) && in_lock_functions (pc)) {
        unsigned long *sp = (unsigned long *) regs->rsp;
        if (sp[0] >> 22)
            return sp[0];
        if (sp[1] >> 22)
            return sp[1];
    }
    return pc;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/time_64.c.ifdefed" startline="61" endline="67">
{
    unsigned long *sp = (unsigned long *) regs->rsp;
    if (sp[0] >> 22)
        return sp[0];
    if (sp[1] >> 22)
        return sp[1];
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/time_64.c.ifdefed" startline="81" endline="141">
{
    int retval = 0;
    int real_seconds, real_minutes, cmos_minutes;
    unsigned char control, freq_select;
    unsigned long flags;
    spin_lock_irqsave (& rtc_lock, flags);
    control = CMOS_READ (RTC_CONTROL);
    CMOS_WRITE (control | RTC_SET, RTC_CONTROL);
    freq_select = CMOS_READ (RTC_FREQ_SELECT);
    CMOS_WRITE (freq_select | RTC_DIV_RESET2, RTC_FREQ_SELECT);
    cmos_minutes = CMOS_READ (RTC_MINUTES);
    BCD_TO_BIN (cmos_minutes);
    real_seconds = nowtime % 60;
    real_minutes = nowtime / 60;
    if (((abs (real_minutes -cmos_minutes) + 15) / 30) & 1)
        real_minutes += 30;
    real_minutes %= 60;
    if (abs (real_minutes -cmos_minutes) >= 30) {
        printk (KERN_WARNING "time.c: can't update CMOS clock " "from %d to %d\n", cmos_minutes, real_minutes);
        retval = -1;
    }
    else {
        BIN_TO_BCD (real_seconds);
        BIN_TO_BCD (real_minutes);
        CMOS_WRITE (real_seconds, RTC_SECONDS);
        CMOS_WRITE (real_minutes, RTC_MINUTES);
    }
    CMOS_WRITE (control, RTC_CONTROL);
    CMOS_WRITE (freq_select, RTC_FREQ_SELECT);
    spin_unlock_irqrestore (& rtc_lock, flags);
    return retval;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/time_64.c.ifdefed" startline="116" endline="120">
{
    printk (KERN_WARNING "time.c: can't update CMOS clock " "from %d to %d\n", cmos_minutes, real_minutes);
    retval = -1;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/time_64.c.ifdefed" startline="120" endline="125">
{
    BIN_TO_BCD (real_seconds);
    BIN_TO_BCD (real_minutes);
    CMOS_WRITE (real_seconds, RTC_SECONDS);
    CMOS_WRITE (real_minutes, RTC_MINUTES);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/time_64.c.ifdefed" startline="144" endline="146">
{
    return set_rtc_mmss (now.tv_sec);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/time_64.c.ifdefed" startline="149" endline="155">
{
    add_pda (irq0_irqs, 1);
    global_clock_event->event_handler (global_clock_event);
    return IRQ_HANDLED;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/time_64.c.ifdefed" startline="158" endline="212">
{
    unsigned int year, mon, day, hour, min, sec;
    unsigned long flags;
    unsigned century = 0;
    spin_lock_irqsave (& rtc_lock, flags);
    while ((CMOS_READ (RTC_FREQ_SELECT) & RTC_UIP))
        cpu_relax ();
    sec = CMOS_READ (RTC_SECONDS);
    min = CMOS_READ (RTC_MINUTES);
    hour = CMOS_READ (RTC_HOURS);
    day = CMOS_READ (RTC_DAY_OF_MONTH);
    mon = CMOS_READ (RTC_MONTH);
    year = CMOS_READ (RTC_YEAR);
    spin_unlock_irqrestore (& rtc_lock, flags);
    BCD_TO_BIN (sec);
    BCD_TO_BIN (min);
    BCD_TO_BIN (hour);
    BCD_TO_BIN (day);
    BCD_TO_BIN (mon);
    BCD_TO_BIN (year);
    if (century) {
        BCD_TO_BIN (century);
        year += century * 100;
        printk (KERN_INFO "Extended CMOS year: %d\n", century * 100);
    }
    else {
        year += 2000;
    }
    return mktime (year, mon, day, hour, min, sec);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/time_64.c.ifdefed" startline="199" endline="203">
{
    BCD_TO_BIN (century);
    year += century * 100;
    printk (KERN_INFO "Extended CMOS year: %d\n", century * 100);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/time_64.c.ifdefed" startline="203" endline="209">
{
    year += 2000;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/time_64.c.ifdefed" startline="218" endline="258">
{
    int tsc_start, tsc_now;
    int i, no_ctr_free;
    unsigned long evntsel3 = 0, pmc3 = 0, pmc_now = 0;
    unsigned long flags;
    for (i = 0; i < 4; i++)
        if (avail_to_resrv_perfctr_nmi_bit (i))
            break;
    no_ctr_free = (i == 4);
    if (no_ctr_free) {
        i = 3;
        rdmsrl (MSR_K7_EVNTSEL3, evntsel3);
        wrmsrl (MSR_K7_EVNTSEL3, 0);
        rdmsrl (MSR_K7_PERFCTR3, pmc3);
    }
    else {
        reserve_perfctr_nmi (MSR_K7_PERFCTR0 + i);
        reserve_evntsel_nmi (MSR_K7_EVNTSEL0 + i);
    }
    local_irq_save (flags);
    wrmsrl (MSR_K7_PERFCTR0 + i, 0);
    wrmsrl (MSR_K7_EVNTSEL0 + i, 1 << 22 | 3 << 16 | 0x76);
    rdtscl (tsc_start);
    do {
        rdmsrl (MSR_K7_PERFCTR0 + i, pmc_now);
        tsc_now = get_cycles_sync ();
    }
    while ((tsc_now - tsc_start) < TICK_COUNT);
    local_irq_restore (flags);
    if (no_ctr_free) {
        wrmsrl (MSR_K7_EVNTSEL3, 0);
        wrmsrl (MSR_K7_PERFCTR3, pmc3);
        wrmsrl (MSR_K7_EVNTSEL3, evntsel3);
    }
    else {
        release_perfctr_nmi (MSR_K7_PERFCTR0 + i);
        release_evntsel_nmi (MSR_K7_EVNTSEL0 + i);
    }
    return pmc_now * tsc_khz / (tsc_now - tsc_start);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/time_64.c.ifdefed" startline="228" endline="233">
{
    i = 3;
    rdmsrl (MSR_K7_EVNTSEL3, evntsel3);
    wrmsrl (MSR_K7_EVNTSEL3, 0);
    rdmsrl (MSR_K7_PERFCTR3, pmc3);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/time_64.c.ifdefed" startline="233" endline="236">
{
    reserve_perfctr_nmi (MSR_K7_PERFCTR0 + i);
    reserve_evntsel_nmi (MSR_K7_EVNTSEL0 + i);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/time_64.c.ifdefed" startline="242" endline="245">
{
    rdmsrl (MSR_K7_PERFCTR0 + i, pmc_now);
    tsc_now = get_cycles_sync ();
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/time_64.c.ifdefed" startline="248" endline="252">
{
    wrmsrl (MSR_K7_EVNTSEL3, 0);
    wrmsrl (MSR_K7_PERFCTR3, pmc3);
    wrmsrl (MSR_K7_EVNTSEL3, evntsel3);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/time_64.c.ifdefed" startline="252" endline="255">
{
    release_perfctr_nmi (MSR_K7_PERFCTR0 + i);
    release_evntsel_nmi (MSR_K7_EVNTSEL0 + i);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/time_64.c.ifdefed" startline="268" endline="293">
{
    if (!hpet_enable ())
        setup_pit_timer ();
    setup_irq (0, & irq0);
    tsc_calibrate ();
    cpu_khz = tsc_khz;
    if (cpu_has (&boot_cpu_data, X86_FEATURE_CONSTANT_TSC) && boot_cpu_data.x86_vendor == X86_VENDOR_AMD && boot_cpu_data.x86 == 16)
        cpu_khz = tsc_calibrate_cpu_khz ();
    if (unsynchronized_tsc ())
        mark_tsc_unstable ("TSCs unsynchronized");
    if (cpu_has (&boot_cpu_data, X86_FEATURE_RDTSCP))
        vgetcpu_mode = VGETCPU_RDTSCP;
    else
        vgetcpu_mode = VGETCPU_LSL;
    printk (KERN_INFO "time.c: Detected %d.%03d MHz processor.\n", cpu_khz / 1000, cpu_khz % 1000);
    init_tsc_clocksource ();
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/k8.c.ifdefed" startline="29" endline="36">
{
    do {
        dev = pci_get_device (PCI_ANY_ID, PCI_ANY_ID, dev);
        if (!dev)
            break;
    }
    while (!pci_match_id (&k8_nb_ids[0], dev));
    return dev;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/k8.c.ifdefed" startline="30" endline="34">
{
    dev = pci_get_device (PCI_ANY_ID, PCI_ANY_ID, dev);
    if (!dev)
        break;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/k8.c.ifdefed" startline="39" endline="74">
{
    int i;
    struct pci_dev *dev;
    if (num_k8_northbridges)
        return 0;
    dev = NULL;
    while ((dev = next_k8_northbridge (dev)) != NULL)
        num_k8_northbridges++;
    k8_northbridges = kmalloc ((num_k8_northbridges + 1) * sizeof (void *), GFP_KERNEL);
    if (!k8_northbridges)
        return -ENOMEM;
    if (!num_k8_northbridges) {
        k8_northbridges[0] = NULL;
        return 0;
    }
    flush_words = kmalloc (num_k8_northbridges * sizeof (u32), GFP_KERNEL);
    if (!flush_words) {
        kfree (k8_northbridges);
        return -ENOMEM;
    }
    dev = NULL;
    i = 0;
    while ((dev = next_k8_northbridge (dev)) != NULL) {
        k8_northbridges[i] = dev;
        pci_read_config_dword (dev, 0x9c, & flush_words [i ++]);
    }
    k8_northbridges[i] = NULL;
    return 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/k8.c.ifdefed" startline="55" endline="58">
{
    k8_northbridges[0] = NULL;
    return 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/k8.c.ifdefed" startline="61" endline="64">
{
    kfree (k8_northbridges);
    return -ENOMEM;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/k8.c.ifdefed" startline="68" endline="71">
{
    k8_northbridges[i] = dev;
    pci_read_config_dword (dev, 0x9c, & flush_words [i ++]);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/k8.c.ifdefed" startline="80" endline="88">
{
    struct pci_device_id *id;
    u32 vendor = device & 0xffff;
    device >>= 16;
    for (id = k8_nb_ids; id->vendor; id++)
        if (vendor == id->vendor && device == id->device)
            return 1;
    return 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/k8.c.ifdefed" startline="91" endline="121">
{
    int flushed, i;
    unsigned long flags;
    static DEFINE_SPINLOCK (gart_lock);
    spin_lock_irqsave (& gart_lock, flags);
    flushed = 0;
    for (i = 0; i < num_k8_northbridges; i++) {
        pci_write_config_dword (k8_northbridges [i], 0x9c, flush_words [i] | 1);
        flushed++;
    }
    for (i = 0; i < num_k8_northbridges; i++) {
        u32 w;
        for (;;) {
            pci_read_config_dword (k8_northbridges [i], 0x9c, & w);
            if (!(w & 1))
                break;
            cpu_relax ();
        }
    }
    spin_unlock_irqrestore (& gart_lock, flags);
    if (!flushed)
        printk ("nothing to flush?\n");
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/k8.c.ifdefed" startline="102" endline="106">
{
    pci_write_config_dword (k8_northbridges [i], 0x9c, flush_words [i] | 1);
    flushed++;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/k8.c.ifdefed" startline="107" endline="117">
{
    u32 w;
    for (;;) {
        pci_read_config_dword (k8_northbridges [i], 0x9c, & w);
        if (!(w & 1))
            break;
        cpu_relax ();
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/k8.c.ifdefed" startline="110" endline="116">
{
    pci_read_config_dword (k8_northbridges [i], 0x9c, & w);
    if (!(w & 1))
        break;
    cpu_relax ();
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/suspend_64.c.ifdefed" startline="23" endline="57">
{
    kernel_fpu_begin ();
    store_gdt ((struct desc_ptr *) & ctxt -> gdt_limit);
    store_idt ((struct desc_ptr *) & ctxt -> idt_limit);
    store_tr (ctxt -> tr);
    asm volatile ("movw %%ds, %0"
        : "=m" (ctxt->ds)
    ) asm volatile ("movw %%es, %0"
        : "=m" (ctxt->es)
    ) asm volatile ("movw %%fs, %0"
        : "=m" (ctxt->fs)
    ) asm volatile ("movw %%gs, %0"
        : "=m" (ctxt->gs)
    ) asm volatile ("movw %%ss, %0"
        : "=m" (ctxt->ss)
    ) rdmsrl (MSR_FS_BASE, ctxt -> fs_base);
    rdmsrl (MSR_GS_BASE, ctxt -> gs_base);
    rdmsrl (MSR_KERNEL_GS_BASE, ctxt -> gs_kernel_base);
    mtrr_save_fixed_ranges (NULL);
    rdmsrl (MSR_EFER, ctxt -> efer);
    ctxt->cr0 = read_cr0 ();
    ctxt->cr2 = read_cr2 ();
    ctxt->cr3 = read_cr3 ();
    ctxt->cr4 = read_cr4 ();
    ctxt->cr8 = read_cr8 ();
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/suspend_64.c.ifdefed" startline="60" endline="62">
{
    __save_processor_state (& saved_context);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/suspend_64.c.ifdefed" startline="65" endline="70">
{
    kernel_fpu_end ();
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/suspend_64.c.ifdefed" startline="73" endline="109">
{
    wrmsrl (MSR_EFER, ctxt -> efer);
    write_cr8 (ctxt -> cr8);
    write_cr4 (ctxt -> cr4);
    write_cr3 (ctxt -> cr3);
    write_cr2 (ctxt -> cr2);
    write_cr0 (ctxt -> cr0);
    load_gdt ((const struct desc_ptr *) & ctxt -> gdt_limit);
    load_idt ((const struct desc_ptr *) & ctxt -> idt_limit);
    asm volatile ("movw %0, %%ds"
        :
        : "r" (ctxt->ds)
    ) asm volatile ("movw %0, %%es"
        :
        : "r" (ctxt->es)
    ) asm volatile ("movw %0, %%fs"
        :
        : "r" (ctxt->fs)
    ) load_gs_index (ctxt -> gs);
    asm volatile ("movw %0, %%ss"
        :
        : "r" (ctxt->ss)
    ) wrmsrl (MSR_FS_BASE, ctxt -> fs_base);
    wrmsrl (MSR_GS_BASE, ctxt -> gs_base);
    wrmsrl (MSR_KERNEL_GS_BASE, ctxt -> gs_kernel_base);
    fix_processor_context ();
    do_fpu_end ();
    mtrr_ap_init ();
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/suspend_64.c.ifdefed" startline="112" endline="114">
{
    __restore_processor_state (& saved_context);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/suspend_64.c.ifdefed" startline="117" endline="142">
{
    int cpu = smp_processor_id ();
    struct tss_struct *t = &per_cpu (init_tss, cpu);
    set_tss_desc (cpu, t);
    cpu_gdt (cpu)[GDT_ENTRY_TSS].type = 9;
    syscall_init ();
    load_TR_desc ();
    load_LDT (& current -> active_mm -> context);
    if (current->thread.debugreg7) {
        loaddebug (& current -> thread, 0);
        loaddebug (& current -> thread, 1);
        loaddebug (& current -> thread, 2);
        loaddebug (& current -> thread, 3);
        loaddebug (& current -> thread, 6);
        loaddebug (& current -> thread, 7);
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/suspend_64.c.ifdefed" startline="132" endline="140">
{
    loaddebug (& current -> thread, 0);
    loaddebug (& current -> thread, 1);
    loaddebug (& current -> thread, 2);
    loaddebug (& current -> thread, 3);
    loaddebug (& current -> thread, 6);
    loaddebug (& current -> thread, 7);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/ldt_64.c.ifdefed" startline="32" endline="79">
{
    void *oldldt;
    void *newldt;
    unsigned oldsize;
    if (mincount <= (unsigned) pc->size)
        return 0;
    oldsize = pc->size;
    mincount = (mincount + 511) & (~511);
    if (mincount * LDT_ENTRY_SIZE > PAGE_SIZE)
        newldt = vmalloc (mincount *LDT_ENTRY_SIZE);
    else
        newldt = kmalloc (mincount *LDT_ENTRY_SIZE, GFP_KERNEL);
    if (!newldt)
        return -ENOMEM;
    if (oldsize)
        memcpy (newldt, pc->ldt, oldsize *LDT_ENTRY_SIZE);
    oldldt = pc->ldt;
    memset (newldt + oldsize * LDT_ENTRY_SIZE, 0, (mincount - oldsize) * LDT_ENTRY_SIZE);
    wmb ();
    pc->ldt = newldt;
    wmb ();
    pc->size = mincount;
    wmb ();
    if (reload) {
        load_LDT (pc);
    }
    if (oldsize) {
        if (oldsize * LDT_ENTRY_SIZE > PAGE_SIZE)
            vfree (oldldt);
        else
            kfree (oldldt);
    }
    return 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/ldt_64.c.ifdefed" startline="58" endline="71">
{
    load_LDT (pc);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/ldt_64.c.ifdefed" startline="72" endline="77">
{
    if (oldsize * LDT_ENTRY_SIZE > PAGE_SIZE)
        vfree (oldldt);
    else
        kfree (oldldt);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/ldt_64.c.ifdefed" startline="82" endline="88">
{
    int err = alloc_ldt (new, old->size, 0);
    if (err < 0)
        return err;
    memcpy (new -> ldt, old -> ldt, old -> size * LDT_ENTRY_SIZE);
    return 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/ldt_64.c.ifdefed" startline="95" endline="108">
{
    struct mm_struct *old_mm;
    int retval = 0;
    mutex_init (& mm -> context.lock);
    mm->context.size = 0;
    old_mm = current->mm;
    if (old_mm && old_mm->context.size > 0) {
        mutex_lock (& old_mm -> context.lock);
        retval = copy_ldt (&mm->context, &old_mm->context);
        mutex_unlock (& old_mm -> context.lock);
    }
    return retval;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/ldt_64.c.ifdefed" startline="102" endline="106">
{
    mutex_lock (& old_mm -> context.lock);
    retval = copy_ldt (&mm->context, &old_mm->context);
    mutex_unlock (& old_mm -> context.lock);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/ldt_64.c.ifdefed" startline="115" endline="123">
{
    if (mm->context.size) {
        if ((unsigned) mm->context.size * LDT_ENTRY_SIZE > PAGE_SIZE)
            vfree (mm->context.ldt);
        else
            kfree (mm->context.ldt);
        mm->context.size = 0;
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/ldt_64.c.ifdefed" startline="116" endline="122">
{
    if ((unsigned) mm->context.size * LDT_ENTRY_SIZE > PAGE_SIZE)
        vfree (mm->context.ldt);
    else
        kfree (mm->context.ldt);
    mm->context.size = 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/ldt_64.c.ifdefed" startline="126" endline="157">
{
    int err;
    unsigned long size;
    struct mm_struct *mm = current->mm;
    if (!mm->context.size)
        return 0;
    if (bytecount > LDT_ENTRY_SIZE * LDT_ENTRIES)
        bytecount = LDT_ENTRY_SIZE * LDT_ENTRIES;
    mutex_lock (& mm -> context.lock);
    size = mm->context.size * LDT_ENTRY_SIZE;
    if (size > bytecount)
        size = bytecount;
    err = 0;
    if (copy_to_user (ptr, mm->context.ldt, size))
        err = -EFAULT;
    mutex_unlock (& mm -> context.lock);
    if (err < 0)
        goto error_return;
    if (size != bytecount) {
        if (clear_user (ptr +size, bytecount -size) != 0) {
            err = -EFAULT;
            goto error_return;
        }
    }
    return bytecount;
error_return :
    return err;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/ldt_64.c.ifdefed" startline="147" endline="153">
{
    if (clear_user (ptr +size, bytecount -size) != 0) {
        err = -EFAULT;
        goto error_return;
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/ldt_64.c.ifdefed" startline="149" endline="152">
{
    err = -EFAULT;
    goto error_return;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/ldt_64.c.ifdefed" startline="160" endline="168">
{
    if (bytecount > 128)
        bytecount = 128;
    if (clear_user (ptr, bytecount))
        return -EFAULT;
    return bytecount;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/ldt_64.c.ifdefed" startline="171" endline="229">
{
    struct task_struct *me = current;
    struct mm_struct *mm = me->mm;
    __u32 entry_1, entry_2, *lp;
    int error;
    struct user_desc ldt_info;
    error = -EINVAL;
    if (bytecount != sizeof (ldt_info))
        goto out;
    error = -EFAULT;
    if (copy_from_user (&ldt_info, ptr, bytecount))
        goto out;
    error = -EINVAL;
    if (ldt_info.entry_number >= LDT_ENTRIES)
        goto out;
    if (ldt_info.contents == 3) {
        if (oldmode)
            goto out;
        if (ldt_info.seg_not_present == 0)
            goto out;
    }
    mutex_lock (& mm -> context.lock);
    if (ldt_info.entry_number >= (unsigned) mm->context.size) {
        error = alloc_ldt (&current->mm->context, ldt_info.entry_number + 1, 1);
        if (error < 0)
            goto out_unlock;
    }
    lp = (__u32 *) ((ldt_info.entry_number << 3) + (char *) mm->context.ldt);
    if (ldt_info.base_addr == 0 && ldt_info.limit == 0) {
        if (oldmode || LDT_empty (&ldt_info)) {
            entry_1 = 0;
            entry_2 = 0;
            goto install;
        }
    }
    entry_1 = LDT_entry_a (&ldt_info);
    entry_2 = LDT_entry_b (&ldt_info);
    if (oldmode)
        entry_2 &= ~(1 << 20);
install :
    *lp = entry_1;
    *(lp + 1) = entry_2;
    error = 0;
out_unlock :
    mutex_unlock (&mm->context.lock);
out :
    return error;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/ldt_64.c.ifdefed" startline="189" endline="194">
{
    if (oldmode)
        goto out;
    if (ldt_info.seg_not_present == 0)
        goto out;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/ldt_64.c.ifdefed" startline="197" endline="201">
{
    error = alloc_ldt (&current->mm->context, ldt_info.entry_number + 1, 1);
    if (error < 0)
        goto out_unlock;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/ldt_64.c.ifdefed" startline="206" endline="212">
{
    if (oldmode || LDT_empty (&ldt_info)) {
        entry_1 = 0;
        entry_2 = 0;
        goto install;
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/ldt_64.c.ifdefed" startline="207" endline="211">
{
    entry_1 = 0;
    entry_2 = 0;
    goto install;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/ldt_64.c.ifdefed" startline="232" endline="250">
{
    int ret = -ENOSYS;
    switch (func) {
    case 0 :
        ret = read_ldt (ptr, bytecount);
        break;
    case 1 :
        ret = write_ldt (ptr, bytecount, 1);
        break;
    case 2 :
        ret = read_default_ldt (ptr, bytecount);
        break;
    case 0x11 :
        ret = write_ldt (ptr, bytecount, 0);
        break;
    }
    return ret;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/ldt_64.c.ifdefed" startline="235" endline="248">
{
case 0 :
    ret = read_ldt (ptr, bytecount);
    break;
case 1 :
    ret = write_ldt (ptr, bytecount, 1);
    break;
case 2 :
    ret = read_default_ldt (ptr, bytecount);
    break;
case 0x11 :
    ret = write_ldt (ptr, bytecount, 0);
    break;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/pcspeaker.c.ifdefed" startline="6" endline="19">
{
    struct platform_device *pd;
    int ret;
    pd = platform_device_alloc ("pcspkr", -1);
    if (!pd)
        return -ENOMEM;
    ret = platform_device_add (pd);
    if (ret)
        platform_device_put (pd);
    return ret;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/i8237.c.ifdefed" startline="25" endline="46">
{
    unsigned long flags;
    int i;
    flags = claim_dma_lock ();
    dma_outb (DMA1_RESET_REG, 0);
    dma_outb (DMA2_RESET_REG, 0);
    for (i = 0; i < 8; i++) {
        set_dma_addr (i, 0x000000);
        set_dma_count (i, 1);
    }
    enable_dma (4);
    release_dma_lock (flags);
    return 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/i8237.c.ifdefed" startline="34" endline="38">
{
    set_dma_addr (i, 0x000000);
    set_dma_count (i, 1);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/i8237.c.ifdefed" startline="49" endline="51">
{
    return 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/i8237.c.ifdefed" startline="65" endline="70">
{
    int error = sysdev_class_register (&i8237_sysdev_class);
    if (!error)
        error = sysdev_register (&device_i8237A);
    return error;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/pci-gart_64.c.ifdefed" startline="83" endline="104">
{
    unsigned long offset, flags;
    spin_lock_irqsave (& iommu_bitmap_lock, flags);
    offset = find_next_zero_string (iommu_gart_bitmap, next_bit, iommu_pages, size);
    if (offset == -1) {
        need_flush = 1;
        offset = find_next_zero_string (iommu_gart_bitmap, 0, iommu_pages, size);
    }
    if (offset != -1) {
        set_bit_string (iommu_gart_bitmap, offset, size);
        next_bit = offset + size;
        if (next_bit >= iommu_pages) {
            next_bit = 0;
            need_flush = 1;
        }
    }
    if (iommu_fullflush)
        need_flush = 1;
    spin_unlock_irqrestore (& iommu_bitmap_lock, flags);
    return offset;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/pci-gart_64.c.ifdefed" startline="88" endline="91">
{
    need_flush = 1;
    offset = find_next_zero_string (iommu_gart_bitmap, 0, iommu_pages, size);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/pci-gart_64.c.ifdefed" startline="92" endline="99">
{
    set_bit_string (iommu_gart_bitmap, offset, size);
    next_bit = offset + size;
    if (next_bit >= iommu_pages) {
        next_bit = 0;
        need_flush = 1;
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/pci-gart_64.c.ifdefed" startline="95" endline="98">
{
    next_bit = 0;
    need_flush = 1;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/pci-gart_64.c.ifdefed" startline="107" endline="112">
{
    unsigned long flags;
    spin_lock_irqsave (& iommu_bitmap_lock, flags);
    __clear_bit_string (iommu_gart_bitmap, offset, size);
    spin_unlock_irqrestore (& iommu_bitmap_lock, flags);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/pci-gart_64.c.ifdefed" startline="118" endline="126">
{
    unsigned long flags;
    spin_lock_irqsave (& iommu_bitmap_lock, flags);
    if (need_flush) {
        k8_flush_garts ();
        need_flush = 0;
    }
    spin_unlock_irqrestore (& iommu_bitmap_lock, flags);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/pci-gart_64.c.ifdefed" startline="121" endline="124">
{
    k8_flush_garts ();
    need_flush = 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/pci-gart_64.c.ifdefed" startline="161" endline="186">
{
    printk (KERN_ERR "PCI-DMA: Out of IOMMU space for %lu bytes at device %s\n", size, dev -> bus_id);
    if (size > PAGE_SIZE * EMERGENCY_PAGES) {
        if (dir == PCI_DMA_FROMDEVICE || dir == PCI_DMA_BIDIRECTIONAL)
            panic ("PCI-DMA: Memory would be corrupted\n");
        if (dir == PCI_DMA_TODEVICE || dir == PCI_DMA_BIDIRECTIONAL)
            panic (KERN_ERR "PCI-DMA: Random memory would be DMAed\n");
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/pci-gart_64.c.ifdefed" startline="176" endline="181">
{
    if (dir == PCI_DMA_FROMDEVICE || dir == PCI_DMA_BIDIRECTIONAL)
        panic ("PCI-DMA: Memory would be corrupted\n");
    if (dir == PCI_DMA_TODEVICE || dir == PCI_DMA_BIDIRECTIONAL)
        panic (KERN_ERR "PCI-DMA: Random memory would be DMAed\n");
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/pci-gart_64.c.ifdefed" startline="189" endline="196">
{
    u64 mask = *dev->dma_mask;
    int high = addr + size > mask;
    int mmu = high;
    if (force_iommu)
        mmu = 1;
    return mmu;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/pci-gart_64.c.ifdefed" startline="199" endline="204">
{
    u64 mask = *dev->dma_mask;
    int high = addr + size > mask;
    int mmu = high;
    return mmu;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/pci-gart_64.c.ifdefed" startline="211" endline="230">
{
    unsigned long npages = to_pages (phys_mem, size);
    unsigned long iommu_page = alloc_iommu (npages);
    int i;
    if (iommu_page == -1) {
        if (!nonforced_iommu (dev, phys_mem, size))
            return phys_mem;
        if (panic_on_overflow)
            panic ("dma_map_area overflow %lu bytes\n", size);
        iommu_full (dev, size, dir);
        return bad_dma_address;
    }
    for (i = 0; i < npages; i++) {
        iommu_gatt_base[iommu_page + i] = GPTE_ENCODE (phys_mem);
        SET_LEAK (iommu_page + i);
        phys_mem += PAGE_SIZE;
    }
    return iommu_bus_base + iommu_page * PAGE_SIZE + (phys_mem & ~PAGE_MASK);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/pci-gart_64.c.ifdefed" startline="215" endline="222">
{
    if (!nonforced_iommu (dev, phys_mem, size))
        return phys_mem;
    if (panic_on_overflow)
        panic ("dma_map_area overflow %lu bytes\n", size);
    iommu_full (dev, size, dir);
    return bad_dma_address;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/pci-gart_64.c.ifdefed" startline="224" endline="228">
{
    iommu_gatt_base[iommu_page + i] = GPTE_ENCODE (phys_mem);
    SET_LEAK (iommu_page + i);
    phys_mem += PAGE_SIZE;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/pci-gart_64.c.ifdefed" startline="234" endline="238">
{
    dma_addr_t map = dma_map_area (dev, virt_to_bus (buf), size, dir);
    flush_gart ();
    return map;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/pci-gart_64.c.ifdefed" startline="242" endline="254">
{
    unsigned long phys_mem, bus;
    if (!dev)
        dev = &fallback_dev;
    phys_mem = virt_to_phys (addr);
    if (!need_iommu (dev, phys_mem, size))
        return phys_mem;
    bus = gart_map_simple (dev, addr, size, dir);
    return bus;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/pci-gart_64.c.ifdefed" startline="261" endline="276">
{
    unsigned long iommu_page;
    int npages;
    int i;
    if (dma_addr < iommu_bus_base + EMERGENCY_PAGES * PAGE_SIZE || dma_addr >= iommu_bus_base + iommu_size)
        return;
    iommu_page = (dma_addr - iommu_bus_base) >> PAGE_SHIFT;
    npages = to_pages (dma_addr, size);
    for (i = 0; i < npages; i++) {
        iommu_gatt_base[iommu_page + i] = gart_unmapped_entry;
        CLEAR_LEAK (iommu_page + i);
    }
    free_iommu (iommu_page, npages);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/pci-gart_64.c.ifdefed" startline="271" endline="274">
{
    iommu_gatt_base[iommu_page + i] = gart_unmapped_entry;
    CLEAR_LEAK (iommu_page + i);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/pci-gart_64.c.ifdefed" startline="282" endline="291">
{
    struct scatterlist *s;
    int i;

    for_each_sg (sg, s, nents, i) {
        if (!s->dma_length || !s->length)
            break;
        gart_unmap_single (dev, s -> dma_address, s -> dma_length, dir);
    }

}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/pci-gart_64.c.ifdefed" startline="286" endline="290">
{
    if (!s->dma_length || !s->length)
        break;
    gart_unmap_single (dev, s -> dma_address, s -> dma_length, dir);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/pci-gart_64.c.ifdefed" startline="296" endline="321">
{
    struct scatterlist *s;
    int i;

    for_each_sg (sg, s, nents, i) {
        unsigned long addr = sg_phys (s);
        if (nonforced_iommu (dev, addr, s->length)) {
            addr = dma_map_area (dev, addr, s->length, dir);
            if (addr == bad_dma_address) {
                if (i > 0)
                    gart_unmap_sg (dev, sg, i, dir);
                nents = 0;
                sg[0].dma_length = 0;
                break;
            }
        }
        s->dma_address = addr;
        s->dma_length = s->length;
    }

    flush_gart ();
    return nents;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/pci-gart_64.c.ifdefed" startline="304" endline="318">
{
    unsigned long addr = sg_phys (s);
    if (nonforced_iommu (dev, addr, s->length)) {
        addr = dma_map_area (dev, addr, s->length, dir);
        if (addr == bad_dma_address) {
            if (i > 0)
                gart_unmap_sg (dev, sg, i, dir);
            nents = 0;
            sg[0].dma_length = 0;
            break;
        }
    }
    s->dma_address = addr;
    s->dma_length = s->length;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/pci-gart_64.c.ifdefed" startline="306" endline="315">
{
    addr = dma_map_area (dev, addr, s->length, dir);
    if (addr == bad_dma_address) {
        if (i > 0)
            gart_unmap_sg (dev, sg, i, dir);
        nents = 0;
        sg[0].dma_length = 0;
        break;
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/pci-gart_64.c.ifdefed" startline="308" endline="314">
{
    if (i > 0)
        gart_unmap_sg (dev, sg, i, dir);
    nents = 0;
    sg[0].dma_length = 0;
    break;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/pci-gart_64.c.ifdefed" startline="326" endline="359">
{
    unsigned long iommu_start = alloc_iommu (pages);
    unsigned long iommu_page = iommu_start;
    struct scatterlist *s;
    int i;
    if (iommu_start == -1)
        return -1;

    for_each_sg (start, s, nelems, i) {
        unsigned long pages, addr;
        unsigned long phys_addr = s->dma_address;
        BUG_ON (s != start && s -> offset);
        if (s == start) {
            sout->dma_address = iommu_bus_base;
            sout->dma_address += iommu_page * PAGE_SIZE + s->offset;
            sout->dma_length = s->length;
        }
        else {
            sout->dma_length += s->length;
        }
        addr = phys_addr;
        pages = to_pages (s->offset, s->length);
        while (pages--) {
            iommu_gatt_base[iommu_page] = GPTE_ENCODE (addr);
            SET_LEAK (iommu_page);
            addr += PAGE_SIZE;
            iommu_page++;
        }
    }

    BUG_ON (iommu_page - iommu_start != pages);
    return 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/pci-gart_64.c.ifdefed" startline="335" endline="356">
{
    unsigned long pages, addr;
    unsigned long phys_addr = s->dma_address;
    BUG_ON (s != start && s -> offset);
    if (s == start) {
        sout->dma_address = iommu_bus_base;
        sout->dma_address += iommu_page * PAGE_SIZE + s->offset;
        sout->dma_length = s->length;
    }
    else {
        sout->dma_length += s->length;
    }
    addr = phys_addr;
    pages = to_pages (s->offset, s->length);
    while (pages--) {
        iommu_gatt_base[iommu_page] = GPTE_ENCODE (addr);
        SET_LEAK (iommu_page);
        addr += PAGE_SIZE;
        iommu_page++;
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/pci-gart_64.c.ifdefed" startline="340" endline="344">
{
    sout->dma_address = iommu_bus_base;
    sout->dma_address += iommu_page * PAGE_SIZE + s->offset;
    sout->dma_length = s->length;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/pci-gart_64.c.ifdefed" startline="344" endline="346">
{
    sout->dma_length += s->length;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/pci-gart_64.c.ifdefed" startline="350" endline="355">
{
    iommu_gatt_base[iommu_page] = GPTE_ENCODE (addr);
    SET_LEAK (iommu_page);
    addr += PAGE_SIZE;
    iommu_page++;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/pci-gart_64.c.ifdefed" startline="364" endline="372">
{
    if (!need) {
        BUG_ON (nelems != 1);
        sout->dma_address = start->dma_address;
        sout->dma_length = start->length;
        return 0;
    }
    return __dma_map_cont (start, nelems, sout, pages);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/pci-gart_64.c.ifdefed" startline="365" endline="370">
{
    BUG_ON (nelems != 1);
    sout->dma_address = start->dma_address;
    sout->dma_length = start->length;
    return 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/pci-gart_64.c.ifdefed" startline="380" endline="451">
{
    int i;
    int out;
    int start;
    unsigned long pages = 0;
    int need = 0, nextneed;
    struct scatterlist *s, *ps, *start_sg, *sgmap;
    if (nents == 0)
        return 0;
    if (!dev)
        dev = &fallback_dev;
    out = 0;
    start = 0;
    start_sg = sgmap = sg;
    ps = NULL;

    for_each_sg (sg, s, nents, i) {
        dma_addr_t addr = sg_phys (s);
        s->dma_address = addr;
        BUG_ON (s -> length == 0);
        nextneed = need_iommu (dev, addr, s->length);
        if (i > start) {
            if (!iommu_merge || !nextneed || !need || s->offset || (ps->offset + ps->length) % PAGE_SIZE) {
                if (dma_map_cont (start_sg, i -start, sgmap, pages, need) < 0)
                    goto error;
                out++;
                sgmap = sg_next (sgmap);
                pages = 0;
                start = i;
                start_sg = s;
            }
        }
        need = nextneed;
        pages += to_pages (s->offset, s->length);
        ps = s;
    }

    if (dma_map_cont (start_sg, i -start, sgmap, pages, need) < 0)
        goto error;
    out++;
    flush_gart ();
    if (out < nents) {
        sgmap = sg_next (sgmap);
        sgmap->dma_length = 0;
    }
    return out;
error :
    flush_gart ();
    gart_unmap_sg (dev, sg, out, dir);
    if (force_iommu || iommu_merge) {
        out = dma_map_sg_nonforce (dev, sg, nents, dir);
        if (out > 0)
            return out;
    }
    if (panic_on_overflow)
        panic ("dma_map_sg: overflow on %lu pages\n", pages);
    iommu_full (dev, pages << PAGE_SHIFT, dir);
    for_each_sg (sg, s, nents, i)
    s->dma_address = bad_dma_address;
    return 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/pci-gart_64.c.ifdefed" startline="398" endline="425">
{
    dma_addr_t addr = sg_phys (s);
    s->dma_address = addr;
    BUG_ON (s -> length == 0);
    nextneed = need_iommu (dev, addr, s->length);
    if (i > start) {
        if (!iommu_merge || !nextneed || !need || s->offset || (ps->offset + ps->length) % PAGE_SIZE) {
            if (dma_map_cont (start_sg, i -start, sgmap, pages, need) < 0)
                goto error;
            out++;
            sgmap = sg_next (sgmap);
            pages = 0;
            start = i;
            start_sg = s;
        }
    }
    need = nextneed;
    pages += to_pages (s->offset, s->length);
    ps = s;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/pci-gart_64.c.ifdefed" startline="406" endline="420">
{
    if (!iommu_merge || !nextneed || !need || s->offset || (ps->offset + ps->length) % PAGE_SIZE) {
        if (dma_map_cont (start_sg, i -start, sgmap, pages, need) < 0)
            goto error;
        out++;
        sgmap = sg_next (sgmap);
        pages = 0;
        start = i;
        start_sg = s;
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/pci-gart_64.c.ifdefed" startline="410" endline="419">
{
    if (dma_map_cont (start_sg, i -start, sgmap, pages, need) < 0)
        goto error;
    out++;
    sgmap = sg_next (sgmap);
    pages = 0;
    start = i;
    start_sg = s;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/pci-gart_64.c.ifdefed" startline="430" endline="433">
{
    sgmap = sg_next (sgmap);
    sgmap->dma_length = 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/pci-gart_64.c.ifdefed" startline="440" endline="444">
{
    out = dma_map_sg_nonforce (dev, sg, nents, dir);
    if (out > 0)
        return out;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/pci-gart_64.c.ifdefed" startline="456" endline="472">
{
    unsigned long a;
    if (!iommu_size) {
        iommu_size = aper_size;
        if (!no_agp)
            iommu_size /= 2;
    }
    a = aper + iommu_size;
    iommu_size -= round_up (a, LARGE_PAGE_SIZE) - a;
    if (iommu_size < 64 * 1024 * 1024)
        printk (KERN_WARNING "PCI-DMA: Warning: Small IOMMU %luMB. Consider increasing the AGP aperture in BIOS\n", iommu_size >> 20);
    return iommu_size;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/pci-gart_64.c.ifdefed" startline="458" endline="462">
{
    iommu_size = aper_size;
    if (!no_agp)
        iommu_size /= 2;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/pci-gart_64.c.ifdefed" startline="475" endline="493">
{
    unsigned aper_size = 0, aper_base_32;
    u64 aper_base;
    unsigned aper_order;
    pci_read_config_dword (dev, 0x94, & aper_base_32);
    pci_read_config_dword (dev, 0x90, & aper_order);
    aper_order = (aper_order >> 1) & 7;
    aper_base = aper_base_32 & 0x7fff;
    aper_base <<= 25;
    aper_size = (32 * 1024 * 1024) << aper_order;
    if (aper_base + aper_size > 0x100000000UL || !aper_size)
        aper_base = 0;
    *size = aper_size;
    return aper_base;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/pci-gart_64.c.ifdefed" startline="500" endline="564">
{
    struct pci_dev *dev;
    void *gatt;
    unsigned aper_base, new_aper_base;
    unsigned aper_size, gatt_size, new_aper_size;
    int i;
    printk (KERN_INFO "PCI-DMA: Disabling AGP.\n");
    aper_size = aper_base = info->aper_size = 0;
    dev = NULL;
    for (i = 0; i < num_k8_northbridges; i++) {
        dev = k8_northbridges[i];
        new_aper_base = read_aperture (dev, &new_aper_size);
        if (!new_aper_base)
            goto nommu;
        if (!aper_base) {
            aper_size = new_aper_size;
            aper_base = new_aper_base;
        }
        if (aper_size != new_aper_size || aper_base != new_aper_base)
            goto nommu;
    }
    if (!aper_base)
        goto nommu;
    info->aper_base = aper_base;
    info->aper_size = aper_size >> 20;
    gatt_size = (aper_size >> PAGE_SHIFT) * sizeof (u32);
    gatt = (void *) __get_free_pages (GFP_KERNEL, get_order (gatt_size));
    if (!gatt)
        panic ("Cannot allocate GATT table");
    if (change_page_attr_addr ((unsigned long) gatt, gatt_size >> PAGE_SHIFT, PAGE_KERNEL_NOCACHE))
        panic ("Could not set GART PTEs to uncacheable pages");
    global_flush_tlb ();
    memset (gatt, 0, gatt_size);
    agp_gatt_table = gatt;
    for (i = 0; i < num_k8_northbridges; i++) {
        u32 ctl;
        u32 gatt_reg;
        dev = k8_northbridges[i];
        gatt_reg = __pa (gatt) >> 12;
        gatt_reg <<= 4;
        pci_write_config_dword (dev, 0x98, gatt_reg);
        pci_read_config_dword (dev, 0x90, & ctl);
        ctl |= 1;
        ctl &= ~((1 << 4) | (1 << 5));
        pci_write_config_dword (dev, 0x90, ctl);
    }
    flush_gart ();
    printk ("PCI-DMA: aperture base @ %x size %u KB\n", aper_base, aper_size >> 10);
    return 0;
nommu :
    printk (KERN_ERR "PCI-DMA: More than 4GB of RAM and no IOMMU\n" KERN_ERR "PCI-DMA: 32bit PCI IO may malfunction.\n");
    return -1;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/pci-gart_64.c.ifdefed" startline="510" endline="522">
{
    dev = k8_northbridges[i];
    new_aper_base = read_aperture (dev, &new_aper_size);
    if (!new_aper_base)
        goto nommu;
    if (!aper_base) {
        aper_size = new_aper_size;
        aper_base = new_aper_base;
    }
    if (aper_size != new_aper_size || aper_base != new_aper_base)
        goto nommu;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/pci-gart_64.c.ifdefed" startline="516" endline="519">
{
    aper_size = new_aper_size;
    aper_base = new_aper_base;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/pci-gart_64.c.ifdefed" startline="539" endline="553">
{
    u32 ctl;
    u32 gatt_reg;
    dev = k8_northbridges[i];
    gatt_reg = __pa (gatt) >> 12;
    gatt_reg <<= 4;
    pci_write_config_dword (dev, 0x98, gatt_reg);
    pci_read_config_dword (dev, 0x90, & ctl);
    ctl |= 1;
    ctl &= ~((1 << 4) | (1 << 5));
    pci_write_config_dword (dev, 0x90, ctl);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/pci-gart_64.c.ifdefed" startline="584" endline="601">
{
    struct pci_dev *dev;
    int i;
    if (no_agp && (dma_ops != &gart_dma_ops))
        return;
    for (i = 0; i < num_k8_northbridges; i++) {
        u32 ctl;
        dev = k8_northbridges[i];
        pci_read_config_dword (dev, 0x90, & ctl);
        ctl &= ~1;
        pci_write_config_dword (dev, 0x90, ctl);
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/pci-gart_64.c.ifdefed" startline="591" endline="600">
{
    u32 ctl;
    dev = k8_northbridges[i];
    pci_read_config_dword (dev, 0x90, & ctl);
    ctl &= ~1;
    pci_write_config_dword (dev, 0x90, ctl);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/pci-gart_64.c.ifdefed" startline="604" endline="709">
{
    struct agp_kern_info info;
    unsigned long aper_size;
    unsigned long iommu_start;
    unsigned long scratch;
    long i;
    if (cache_k8_northbridges () < 0 || num_k8_northbridges == 0) {
        printk (KERN_INFO "PCI-GART: No AMD northbridge found.\n");
        return;
    }
    no_agp = 1;
    if (swiotlb)
        return;
    if (iommu_detected && !gart_iommu_aperture)
        return;
    if (no_iommu || (!force_iommu && end_pfn <= MAX_DMA32_PFN) || !gart_iommu_aperture || (no_agp && init_k8_gatt (&info) < 0)) {
        if (end_pfn > MAX_DMA32_PFN) {
            printk (KERN_ERR "WARNING more than 4GB of memory " "but GART IOMMU not available.\n" KERN_ERR "WARNING 32bit PCI may malfunction.\n");
        }
        return;
    }
    printk (KERN_INFO "PCI-DMA: using GART IOMMU.\n");
    aper_size = info.aper_size * 1024 * 1024;
    iommu_size = check_iommu_size (info.aper_base, aper_size);
    iommu_pages = iommu_size >> PAGE_SHIFT;
    iommu_gart_bitmap = (void *) __get_free_pages (GFP_KERNEL, get_order (iommu_pages / 8));
    if (!iommu_gart_bitmap)
        panic ("Cannot allocate iommu bitmap\n");
    memset (iommu_gart_bitmap, 0, iommu_pages / 8);
    set_bit_string (iommu_gart_bitmap, 0, EMERGENCY_PAGES);
    agp_memory_reserved = iommu_size;
    printk (KERN_INFO "PCI-DMA: Reserving %luMB of IOMMU area in the AGP aperture\n", iommu_size >> 20);
    iommu_start = aper_size - iommu_size;
    iommu_bus_base = info.aper_base + iommu_start;
    bad_dma_address = iommu_bus_base;
    iommu_gatt_base = agp_gatt_table + (iommu_start >> PAGE_SHIFT);
    clear_kernel_mapping ((unsigned long) __va (iommu_bus_base), iommu_size);
    scratch = get_zeroed_page (GFP_KERNEL);
    if (!scratch)
        panic ("Cannot allocate iommu scratch page");
    gart_unmapped_entry = GPTE_ENCODE (__pa (scratch));
    for (i = EMERGENCY_PAGES; i < iommu_pages; i++)
        iommu_gatt_base[i] = gart_unmapped_entry;
    flush_gart ();
    dma_ops = &gart_dma_ops;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/pci-gart_64.c.ifdefed" startline="611" endline="614">
{
    printk (KERN_INFO "PCI-GART: No AMD northbridge found.\n");
    return;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/pci-gart_64.c.ifdefed" startline="636" endline="643">
{
    if (end_pfn > MAX_DMA32_PFN) {
        printk (KERN_ERR "WARNING more than 4GB of memory " "but GART IOMMU not available.\n" KERN_ERR "WARNING 32bit PCI may malfunction.\n");
    }
    return;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/pci-gart_64.c.ifdefed" startline="637" endline="641">
{
    printk (KERN_ERR "WARNING more than 4GB of memory " "but GART IOMMU not available.\n" KERN_ERR "WARNING 32bit PCI may malfunction.\n");
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/pci-gart_64.c.ifdefed" startline="712" endline="748">
{
    int arg;
    if (isdigit (*p) && get_option (&p, &arg))
        iommu_size = arg;
    if (!strncmp (p, "fullflush", 8))
        iommu_fullflush = 1;
    if (!strncmp (p, "nofullflush", 11))
        iommu_fullflush = 0;
    if (!strncmp (p, "noagp", 5))
        no_agp = 1;
    if (!strncmp (p, "noaperture", 10))
        fix_aperture = 0;
    if (!strncmp (p, "force", 5))
        gart_iommu_aperture_allowed = 1;
    if (!strncmp (p, "allowed", 7))
        gart_iommu_aperture_allowed = 1;
    if (!strncmp (p, "memaper", 7)) {
        fallback_aper_force = 1;
        p += 7;
        if (*p == '=') {
            ++p;
            if (get_option (&p, &arg))
                fallback_aper_order = arg;
        }
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/pci-gart_64.c.ifdefed" startline="739" endline="747">
{
    fallback_aper_force = 1;
    p += 7;
    if (*p == '=') {
        ++p;
        if (get_option (&p, &arg))
            fallback_aper_order = arg;
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/pci-gart_64.c.ifdefed" startline="742" endline="746">
{
    ++p;
    if (get_option (&p, &arg))
        fallback_aper_order = arg;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/i8259_64.c.ifdefed" startline="135" endline="146">
{
    unsigned int mask = 1 << irq;
    unsigned long flags;
    spin_lock_irqsave (& i8259A_lock, flags);
    cached_irq_mask |= mask;
    if (irq & 8)
        outb (cached_A1, 0xA1);
    else
        outb (cached_21, 0x21);
    spin_unlock_irqrestore (& i8259A_lock, flags);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/i8259_64.c.ifdefed" startline="149" endline="160">
{
    unsigned int mask = ~(1 << irq);
    unsigned long flags;
    spin_lock_irqsave (& i8259A_lock, flags);
    cached_irq_mask &= mask;
    if (irq & 8)
        outb (cached_A1, 0xA1);
    else
        outb (cached_21, 0x21);
    spin_unlock_irqrestore (& i8259A_lock, flags);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/i8259_64.c.ifdefed" startline="163" endline="176">
{
    unsigned int mask = 1 << irq;
    unsigned long flags;
    int ret;
    spin_lock_irqsave (& i8259A_lock, flags);
    if (irq < 8)
        ret = inb (0x20) & mask;
    else
        ret = inb (0xA0) & (mask >> 8);
    spin_unlock_irqrestore (& i8259A_lock, flags);
    return ret;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/i8259_64.c.ifdefed" startline="179" endline="185">
{
    disable_irq_nosync (irq);
    io_apic_irqs &= ~(1 << irq);
    set_irq_chip_and_handler_name (irq, & i8259A_chip, handle_level_irq, "XT");
    enable_irq (irq);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/i8259_64.c.ifdefed" startline="194" endline="208">
{
    int value;
    int irqmask = 1 << irq;
    if (irq < 8) {
        outb (0x0B, 0x20);
        value = inb (0x20) & irqmask;
        outb (0x0A, 0x20);
        return value;
    }
    outb (0x0B, 0xA0);
    value = inb (0xA0) & (irqmask >> 8);
    outb (0x0A, 0xA0);
    return value;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/i8259_64.c.ifdefed" startline="198" endline="203">
{
    outb (0x0B, 0x20);
    value = inb (0x20) & irqmask;
    outb (0x0A, 0x20);
    return value;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/i8259_64.c.ifdefed" startline="217" endline="284">
{
    unsigned int irqmask = 1 << irq;
    unsigned long flags;
    spin_lock_irqsave (& i8259A_lock, flags);
    if (cached_irq_mask & irqmask)
        goto spurious_8259A_irq;
    cached_irq_mask |= irqmask;
handle_real_irq :
    if (irq & 8) {
        inb (0xA1);
        outb (cached_A1, 0xA1);
        outb (0x60 + (irq & 7), 0xA0);
        outb (0x62, 0x20);
    }
    else {
        inb (0x21);
        outb (cached_21, 0x21);
        outb (0x60 + irq, 0x20);
    }
    spin_unlock_irqrestore (& i8259A_lock, flags);
    return;
spurious_8259A_irq :
    if (i8259A_irq_real (irq))
        goto handle_real_irq;
    {
        static int spurious_irq_mask;
        if (!(spurious_irq_mask & irqmask)) {
            printk (KERN_DEBUG "spurious 8259A interrupt: IRQ%d.\n", irq);
            spurious_irq_mask |= irqmask;
        }
        atomic_inc (& irq_err_count);
        goto handle_real_irq;
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/i8259_64.c.ifdefed" startline="242" endline="247">
{
    inb (0xA1);
    outb (cached_A1, 0xA1);
    outb (0x60 + (irq & 7), 0xA0);
    outb (0x62, 0x20);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/i8259_64.c.ifdefed" startline="247" endline="251">
{
    inb (0x21);
    outb (cached_21, 0x21);
    outb (0x60 + irq, 0x20);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/i8259_64.c.ifdefed" startline="266" endline="283">
{
    static int spurious_irq_mask;
    if (!(spurious_irq_mask & irqmask)) {
        printk (KERN_DEBUG "spurious 8259A interrupt: IRQ%d.\n", irq);
        spurious_irq_mask |= irqmask;
    }
    atomic_inc (& irq_err_count);
    goto handle_real_irq;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/i8259_64.c.ifdefed" startline="272" endline="275">
{
    printk (KERN_DEBUG "spurious 8259A interrupt: IRQ%d.\n", irq);
    spurious_irq_mask |= irqmask;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/i8259_64.c.ifdefed" startline="287" endline="329">
{
    unsigned long flags;
    i8259A_auto_eoi = auto_eoi;
    spin_lock_irqsave (& i8259A_lock, flags);
    outb (0xff, 0x21);
    outb (0xff, 0xA1);
    outb_p (0x11, 0x20);
    outb_p (IRQ0_VECTOR, 0x21);
    outb_p (0x04, 0x21);
    if (auto_eoi)
        outb_p (0x03, 0x21);
    else
        outb_p (0x01, 0x21);
    outb_p (0x11, 0xA0);
    outb_p (IRQ8_VECTOR, 0xA1);
    outb_p (0x02, 0xA1);
    outb_p (0x01, 0xA1);
    if (auto_eoi)
        i8259A_chip.mask_ack = disable_8259A_irq;
    else
        i8259A_chip.mask_ack = mask_and_ack_8259A;
    udelay (100);
    outb (cached_21, 0x21);
    outb (cached_A1, 0xA1);
    spin_unlock_irqrestore (& i8259A_lock, flags);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/i8259_64.c.ifdefed" startline="336" endline="339">
{
    outb (trigger [0], 0x4d0);
    outb (trigger [1], 0x4d1);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/i8259_64.c.ifdefed" startline="342" endline="346">
{
    trigger[0] = inb (0x4d0) & 0xF8;
    trigger[1] = inb (0x4d1) & 0xDE;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/i8259_64.c.ifdefed" startline="349" endline="353">
{
    init_8259A (i8259A_auto_eoi);
    restore_ELCR (irq_trigger);
    return 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/i8259_64.c.ifdefed" startline="356" endline="359">
{
    save_ELCR (irq_trigger);
    return 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/i8259_64.c.ifdefed" startline="362" endline="370">
{
    outb (0xff, 0x21);
    outb (0xff, 0xA1);
    return 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/i8259_64.c.ifdefed" startline="385" endline="390">
{
    int error = sysdev_class_register (&i8259_sysdev_class);
    if (!error)
        error = sysdev_register (&device_i8259A);
    return error;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/i8259_64.c.ifdefed" startline="425" endline="449">
{
    int i;
    init_bsp_APIC ();
    init_8259A (0);
    for (i = 0; i < NR_IRQS; i++) {
        irq_desc[i].status = IRQ_DISABLED;
        irq_desc[i].action = NULL;
        irq_desc[i].depth = 1;
        if (i < 16) {
            set_irq_chip_and_handler_name (i, & i8259A_chip, handle_level_irq, "XT");
        }
        else {
            irq_desc[i].chip = &no_irq_chip;
        }
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/i8259_64.c.ifdefed" startline="431" endline="448">
{
    irq_desc[i].status = IRQ_DISABLED;
    irq_desc[i].action = NULL;
    irq_desc[i].depth = 1;
    if (i < 16) {
        set_irq_chip_and_handler_name (i, & i8259A_chip, handle_level_irq, "XT");
    }
    else {
        irq_desc[i].chip = &no_irq_chip;
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/i8259_64.c.ifdefed" startline="436" endline="442">
{
    set_irq_chip_and_handler_name (i, & i8259A_chip, handle_level_irq, "XT");
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/i8259_64.c.ifdefed" startline="442" endline="447">
{
    irq_desc[i].chip = &no_irq_chip;
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/i8259_64.c.ifdefed" startline="452" endline="502">
{
    int i;
    init_ISA_irqs ();
    for (i = 0; i < (NR_VECTORS - FIRST_EXTERNAL_VECTOR); i++) {
        int vector = FIRST_EXTERNAL_VECTOR + i;
        if (vector != IA32_SYSCALL_VECTOR)
            set_intr_gate (vector, interrupt[i]);
    }
    set_intr_gate (THERMAL_APIC_VECTOR, thermal_interrupt);
    set_intr_gate (THRESHOLD_APIC_VECTOR, threshold_interrupt);
    set_intr_gate (LOCAL_TIMER_VECTOR, apic_timer_interrupt);
    set_intr_gate (SPURIOUS_APIC_VECTOR, spurious_interrupt);
    set_intr_gate (ERROR_APIC_VECTOR, error_interrupt);
    if (!acpi_ioapic)
        setup_irq (2, &irq2);
}
</source>
<source file="/cmpt816/tmp/arch/x86/kernel/i8259_64.c.ifdefed" startline="461" endline="465">
{
    int vector = FIRST_EXTERNAL_VECTOR + i;
    if (vector != IA32_SYSCALL_VECTOR)
        set_intr_gate (vector, interrupt[i]);
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/srat_64.c.ifdefed" startline="39" endline="41">
{
    return acpi_map_pxm_to_node (pxm);
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/srat_64.c.ifdefed" startline="44" endline="56">
{
    int i;

    for_each_node_mask (i, nodes_parsed) {
        struct bootnode *nd = &nodes[i];
        if (nd->start == nd->end)
            continue;
        if (nd->end > start && nd->start < end)
            return i;
        if (nd->end == end && nd->start == start)
            return i;
    }

    return -1;
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/srat_64.c.ifdefed" startline="46" endline="54">
{
    struct bootnode *nd = &nodes[i];
    if (nd->start == nd->end)
        continue;
    if (nd->end > start && nd->start < end)
        return i;
    if (nd->end == end && nd->start == start)
        return i;
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/srat_64.c.ifdefed" startline="59" endline="75">
{
    struct bootnode *nd = &nodes[i];
    if (found_add_area)
        return;
    if (nd->start < start) {
        nd->start = start;
        if (nd->end < nd->start)
            nd->start = nd->end;
    }
    if (nd->end > end) {
        nd->end = end;
        if (nd->start > nd->end)
            nd->start = nd->end;
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/srat_64.c.ifdefed" startline="65" endline="69">
{
    nd->start = start;
    if (nd->end < nd->start)
        nd->start = nd->end;
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/srat_64.c.ifdefed" startline="70" endline="74">
{
    nd->end = end;
    if (nd->start > nd->end)
        nd->start = nd->end;
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/srat_64.c.ifdefed" startline="78" endline="88">
{
    int i;
    printk (KERN_ERR "SRAT: SRAT not used.\n");
    acpi_numa = -1;
    found_add_area = 0;
    for (i = 0; i < MAX_LOCAL_APIC; i++)
        apicid_to_node[i] = NUMA_NO_NODE;
    for (i = 0; i < MAX_NUMNODES; i++)
        nodes_add[i].start = nodes[i].end = 0;
    remove_all_active_ranges ();
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/srat_64.c.ifdefed" startline="91" endline="93">
{
    return numa_off || acpi_numa < 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/srat_64.c.ifdefed" startline="102" endline="116">
{
    int i, j;
    int d = slit->locality_count;
    for (i = 0; i < d; i++) {
        for (j = 0; j < d; j++) {
            u8 val = slit->entry[d * i + j];
            if (i == j) {
                if (val != LOCAL_DISTANCE)
                    return 0;
            }
            else if (val <= LOCAL_DISTANCE)
                return 0;
        }
    }
    return 1;
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/srat_64.c.ifdefed" startline="105" endline="114">
{
    for (j = 0; j < d; j++) {
        u8 val = slit->entry[d * i + j];
        if (i == j) {
            if (val != LOCAL_DISTANCE)
                return 0;
        }
        else if (val <= LOCAL_DISTANCE)
            return 0;
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/srat_64.c.ifdefed" startline="106" endline="113">
{
    u8 val = slit->entry[d * i + j];
    if (i == j) {
        if (val != LOCAL_DISTANCE)
            return 0;
    }
    else if (val <= LOCAL_DISTANCE)
        return 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/srat_64.c.ifdefed" startline="108" endline="111">
{
    if (val != LOCAL_DISTANCE)
        return 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/srat_64.c.ifdefed" startline="120" endline="126">
{
    if (!slit_valid (slit)) {
        printk (KERN_INFO "ACPI: SLIT table looks invalid. Not used.\n");
        return;
    }
    acpi_slit = slit;
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/srat_64.c.ifdefed" startline="121" endline="124">
{
    printk (KERN_INFO "ACPI: SLIT table looks invalid. Not used.\n");
    return;
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/srat_64.c.ifdefed" startline="131" endline="152">
{
    int pxm, node;
    if (srat_disabled ())
        return;
    if (pa->header.length != sizeof (struct acpi_srat_cpu_affinity)) {
        bad_srat ();
        return;
    }
    if ((pa->flags & ACPI_SRAT_CPU_ENABLED) == 0)
        return;
    pxm = pa->proximity_domain_lo;
    node = setup_node (pxm);
    if (node < 0) {
        printk (KERN_ERR "SRAT: Too many proximity domains %x\n", pxm);
        bad_srat ();
        return;
    }
    apicid_to_node[pa->apic_id] = node;
    acpi_numa = 1;
    printk (KERN_INFO "SRAT: PXM %u -> APIC %u -> Node %u\n", pxm, pa -> apic_id, node);
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/srat_64.c.ifdefed" startline="135" endline="138">
{
    bad_srat ();
    return;
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/srat_64.c.ifdefed" startline="143" endline="147">
{
    printk (KERN_ERR "SRAT: Too many proximity domains %x\n", pxm);
    bad_srat ();
    return;
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/srat_64.c.ifdefed" startline="210" endline="210">
{
    return -1;
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/srat_64.c.ifdefed" startline="211" endline="211">
{
    return 1;
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/srat_64.c.ifdefed" startline="215" endline="215">
{
    return 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/srat_64.c.ifdefed" startline="224" endline="278">
{
    unsigned long s_pfn = start >> PAGE_SHIFT;
    unsigned long e_pfn = end >> PAGE_SHIFT;
    int ret = 0, changed = 0;
    struct bootnode *nd = &nodes_add[node];
    if ((signed long) (end - start) < NODE_MIN_SIZE) {
        printk (KERN_ERR "SRAT: Hotplug area too small\n");
        return -1;
    }
    if (absent_pages_in_range (s_pfn, e_pfn) != e_pfn - s_pfn) {
        printk (KERN_ERR "SRAT: Hotplug area %lu -> %lu has existing memory\n", s_pfn, e_pfn);
        return -1;
    }
    if (!hotadd_enough_memory (&nodes_add[node])) {
        printk (KERN_ERR "SRAT: Hotplug area too large\n");
        return -1;
    }
    if (nd->start == nd->end) {
        nd->start = start;
        nd->end = end;
        changed = 1;
    }
    else {
        if (nd->start == end) {
            nd->start = start;
            changed = 1;
        }
        if (nd->end == start) {
            nd->end = end;
            changed = 1;
        }
        if (!changed)
            printk (KERN_ERR "SRAT: Hotplug zone not continuous. Partly ignored\n");
    }
    ret = update_end_of_memory (nd->end);
    if (changed)
        printk (KERN_INFO "SRAT: hot plug zone found %Lx - %Lx\n", nd->start, nd->end);
    return ret;
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/srat_64.c.ifdefed" startline="236" endline="239">
{
    printk (KERN_ERR "SRAT: Hotplug area too small\n");
    return -1;
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/srat_64.c.ifdefed" startline="242" endline="247">
{
    printk (KERN_ERR "SRAT: Hotplug area %lu -> %lu has existing memory\n", s_pfn, e_pfn);
    return -1;
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/srat_64.c.ifdefed" startline="249" endline="252">
{
    printk (KERN_ERR "SRAT: Hotplug area too large\n");
    return -1;
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/srat_64.c.ifdefed" startline="256" endline="260">
{
    nd->start = start;
    nd->end = end;
    changed = 1;
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/srat_64.c.ifdefed" startline="260" endline="271">
{
    if (nd->start == end) {
        nd->start = start;
        changed = 1;
    }
    if (nd->end == start) {
        nd->end = end;
        changed = 1;
    }
    if (!changed)
        printk (KERN_ERR "SRAT: Hotplug zone not continuous. Partly ignored\n");
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/srat_64.c.ifdefed" startline="261" endline="264">
{
    nd->start = start;
    changed = 1;
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/srat_64.c.ifdefed" startline="265" endline="268">
{
    nd->end = end;
    changed = 1;
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/srat_64.c.ifdefed" startline="283" endline="349">
{
    struct bootnode *nd, oldnode;
    unsigned long start, end;
    int node, pxm;
    int i;
    if (srat_disabled ())
        return;
    if (ma->header.length != sizeof (struct acpi_srat_mem_affinity)) {
        bad_srat ();
        return;
    }
    if ((ma->flags & ACPI_SRAT_MEM_ENABLED) == 0)
        return;
    if ((ma->flags & ACPI_SRAT_MEM_HOT_PLUGGABLE) && !save_add_info ())
        return;
    start = ma->base_address;
    end = start + ma->length;
    pxm = ma->proximity_domain;
    node = setup_node (pxm);
    if (node < 0) {
        printk (KERN_ERR "SRAT: Too many proximity domains.\n");
        bad_srat ();
        return;
    }
    i = conflicting_nodes (start, end);
    if (i == node) {
        printk (KERN_WARNING "SRAT: Warning: PXM %d (%lx-%lx) overlaps with itself (%Lx-%Lx)\n", pxm, start, end, nodes [i].start, nodes [i].end);
    }
    else if (i >= 0) {
        printk (KERN_ERR "SRAT: PXM %d (%lx-%lx) overlaps with PXM %d (%Lx-%Lx)\n", pxm, start, end, node_to_pxm (i), nodes [i].start, nodes [i].end);
        bad_srat ();
        return;
    }
    nd = &nodes[node];
    oldnode = *nd;
    if (!node_test_and_set (node, nodes_parsed)) {
        nd->start = start;
        nd->end = end;
    }
    else {
        if (start < nd->start)
            nd->start = start;
        if (nd->end < end)
            nd->end = end;
    }
    printk (KERN_INFO "SRAT: Node %u PXM %u %Lx-%Lx\n", node, pxm, nd -> start, nd -> end);
    e820_register_active_regions (node, nd -> start >> PAGE_SHIFT, nd -> end >> PAGE_SHIFT);
    push_node_boundaries (node, nd -> start >> PAGE_SHIFT, nd -> end >> PAGE_SHIFT);
    if ((ma->flags & ACPI_SRAT_MEM_HOT_PLUGGABLE) && (reserve_hotadd (node, start, end) < 0)) {
        printk (KERN_NOTICE "SRAT: Hotplug region ignored\n");
        *nd = oldnode;
        if ((nd->start | nd->end) == 0)
            node_clear (node, nodes_parsed);
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/srat_64.c.ifdefed" startline="291" endline="294">
{
    bad_srat ();
    return;
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/srat_64.c.ifdefed" startline="304" endline="308">
{
    printk (KERN_ERR "SRAT: Too many proximity domains.\n");
    bad_srat ();
    return;
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/srat_64.c.ifdefed" startline="310" endline="314">
{
    printk (KERN_WARNING "SRAT: Warning: PXM %d (%lx-%lx) overlaps with itself (%Lx-%Lx)\n", pxm, start, end, nodes [i].start, nodes [i].end);
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/srat_64.c.ifdefed" startline="314" endline="321">
{
    printk (KERN_ERR "SRAT: PXM %d (%lx-%lx) overlaps with PXM %d (%Lx-%Lx)\n", pxm, start, end, node_to_pxm (i), nodes [i].start, nodes [i].end);
    bad_srat ();
    return;
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/srat_64.c.ifdefed" startline="324" endline="327">
{
    nd->start = start;
    nd->end = end;
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/srat_64.c.ifdefed" startline="327" endline="332">
{
    if (start < nd->start)
        nd->start = start;
    if (nd->end < end)
        nd->end = end;
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/srat_64.c.ifdefed" startline="342" endline="348">
{
    printk (KERN_NOTICE "SRAT: Hotplug region ignored\n");
    *nd = oldnode;
    if ((nd->start | nd->end) == 0)
        node_clear (node, nodes_parsed);
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/srat_64.c.ifdefed" startline="354" endline="378">
{
    int i;
    unsigned long pxmram, e820ram;
    pxmram = 0;

    for_each_node_mask (i, nodes_parsed) {
        unsigned long s = nodes[i].start >> PAGE_SHIFT;
        unsigned long e = nodes[i].end >> PAGE_SHIFT;
        pxmram += e - s;
        pxmram -= absent_pages_in_range (s, e);
        if ((long) pxmram < 0)
            pxmram = 0;
    }

    e820ram = end_pfn - absent_pages_in_range (0, end_pfn);
    if ((long) (e820ram - pxmram) >= 1 * 1024 * 1024) {
        printk (KERN_ERR "SRAT: PXMs only cover %luMB of your %luMB e820 RAM. Not used.\n", (pxmram << PAGE_SHIFT) >> 20, (e820ram << PAGE_SHIFT) >> 20);
        return 0;
    }
    return 1;
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/srat_64.c.ifdefed" startline="359" endline="366">
{
    unsigned long s = nodes[i].start >> PAGE_SHIFT;
    unsigned long e = nodes[i].end >> PAGE_SHIFT;
    pxmram += e - s;
    pxmram -= absent_pages_in_range (s, e);
    if ((long) pxmram < 0)
        pxmram = 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/srat_64.c.ifdefed" startline="370" endline="376">
{
    printk (KERN_ERR "SRAT: PXMs only cover %luMB of your %luMB e820 RAM. Not used.\n", (pxmram << PAGE_SHIFT) >> 20, (e820ram << PAGE_SHIFT) >> 20);
    return 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/srat_64.c.ifdefed" startline="381" endline="388">
{
    int i;
    node_clear (node, nodes_parsed);
    for (i = 0; i < MAX_LOCAL_APIC; i++) {
        if (apicid_to_node[i] == node)
            apicid_to_node[i] = NUMA_NO_NODE;
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/srat_64.c.ifdefed" startline="384" endline="387">
{
    if (apicid_to_node[i] == node)
        apicid_to_node[i] = NUMA_NO_NODE;
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/srat_64.c.ifdefed" startline="390" endline="390">
{
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/srat_64.c.ifdefed" startline="394" endline="441">
{
    int i;
    if (acpi_numa <= 0)
        return -1;
    for (i = 0; i < MAX_NUMNODES; i++) {
        cutoff_node (i, start, end);
        if ((nodes[i].end - nodes[i].start) < NODE_MIN_SIZE) {
            unparse_node (i);
            node_set_offline (i);
        }
    }
    if (!nodes_cover_memory (nodes)) {
        bad_srat ();
        return -1;
    }
    memnode_shift = compute_hash_shift (nodes, MAX_NUMNODES);
    if (memnode_shift < 0) {
        printk (KERN_ERR "SRAT: No NUMA node hash function found. Contact maintainer\n");
        bad_srat ();
        return -1;
    }
    node_possible_map = nodes_parsed;
    for_each_node_mask (i, node_possible_map)
    setup_node_bootmem (i, nodes [i].start, nodes [i].end);
    for_each_node_mask (i, node_possible_map)
    if (!node_online (i))
        setup_node_bootmem (i, nodes[i].start, nodes[i].end);
    for (i = 0; i < NR_CPUS; i++) {
        if (cpu_to_node (i) == NUMA_NO_NODE)
            continue;
        if (!node_isset (cpu_to_node (i), node_possible_map))
            numa_set_node (i, NUMA_NO_NODE);
    }
    numa_init_array ();
    return 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/srat_64.c.ifdefed" startline="401" endline="407">
{
    cutoff_node (i, start, end);
    if ((nodes[i].end - nodes[i].start) < NODE_MIN_SIZE) {
        unparse_node (i);
        node_set_offline (i);
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/srat_64.c.ifdefed" startline="403" endline="406">
{
    unparse_node (i);
    node_set_offline (i);
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/srat_64.c.ifdefed" startline="409" endline="412">
{
    bad_srat ();
    return -1;
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/srat_64.c.ifdefed" startline="415" endline="420">
{
    printk (KERN_ERR "SRAT: No NUMA node hash function found. Contact maintainer\n");
    bad_srat ();
    return -1;
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/srat_64.c.ifdefed" startline="433" endline="438">
{
    if (cpu_to_node (i) == NUMA_NO_NODE)
        continue;
    if (!node_isset (cpu_to_node (i), node_possible_map))
        numa_set_node (i, NUMA_NO_NODE);
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/srat_64.c.ifdefed" startline="518" endline="520">
{
    return a == b;
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/srat_64.c.ifdefed" startline="524" endline="540">
{
    if (found_add_area && nodes_add[nodeid].end) {
        u64 total_mb;
        printk (KERN_INFO "SRAT: Reserving hot-add memory space " "for node %d at %Lx-%Lx\n", nodeid, nodes_add [nodeid].start, nodes_add [nodeid].end);
        total_mb = (nodes_add[nodeid].end - nodes_add[nodeid].start) >> PAGE_SHIFT;
        total_mb *= sizeof (struct page);
        total_mb >>= 20;
        printk (KERN_INFO "SRAT: This will cost you %Lu MB of " "pre-allocated memory.\n", (unsigned long long) total_mb);
        reserve_bootmem_node (NODE_DATA (nodeid), nodes_add [nodeid].start, nodes_add [nodeid].end - nodes_add [nodeid].start);
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/srat_64.c.ifdefed" startline="525" endline="539">
{
    u64 total_mb;
    printk (KERN_INFO "SRAT: Reserving hot-add memory space " "for node %d at %Lx-%Lx\n", nodeid, nodes_add [nodeid].start, nodes_add [nodeid].end);
    total_mb = (nodes_add[nodeid].end - nodes_add[nodeid].start) >> PAGE_SHIFT;
    total_mb *= sizeof (struct page);
    total_mb >>= 20;
    printk (KERN_INFO "SRAT: This will cost you %Lu MB of " "pre-allocated memory.\n", (unsigned long long) total_mb);
    reserve_bootmem_node (NODE_DATA (nodeid), nodes_add [nodeid].start, nodes_add [nodeid].end - nodes_add [nodeid].start);
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/srat_64.c.ifdefed" startline="543" endline="551">
{
    int index;
    if (!acpi_slit)
        return null_slit_node_compare (a, b) ? LOCAL_DISTANCE : REMOTE_DISTANCE;
    index = acpi_slit->locality_count * node_to_pxm (a);
    return acpi_slit->entry[index + node_to_pxm (b)];
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/srat_64.c.ifdefed" startline="556" endline="564">
{
    int i, ret = 0;
    for_each_node (i)
    if (nodes_add[i].start <= start && nodes_add[i].end > start)
        ret = i;
    return ret;
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/ioremap_64.c.ifdefed" startline="24" endline="28">
{
    if (x >= __START_KERNEL_map)
        return x - __START_KERNEL_map + phys_base;
    return x - PAGE_OFFSET;
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/ioremap_64.c.ifdefed" startline="41" endline="56">
{
    int err = 0;
    if (phys_addr + size - 1 < (end_pfn_map << PAGE_SHIFT)) {
        unsigned long npages = (size + PAGE_SIZE - 1) >> PAGE_SHIFT;
        unsigned long vaddr = (unsigned long) __va (phys_addr);
        err = change_page_attr_addr (vaddr, npages, __pgprot (__PAGE_KERNEL | flags));
        if (!err)
            global_flush_tlb ();
    }
    return err;
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/ioremap_64.c.ifdefed" startline="43" endline="54">
{
    unsigned long npages = (size + PAGE_SIZE - 1) >> PAGE_SHIFT;
    unsigned long vaddr = (unsigned long) __va (phys_addr);
    err = change_page_attr_addr (vaddr, npages, __pgprot (__PAGE_KERNEL | flags));
    if (!err)
        global_flush_tlb ();
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/ioremap_64.c.ifdefed" startline="72" endline="134">
{
    void *addr;
    struct vm_struct *area;
    unsigned long offset, last_addr;
    pgprot_t pgprot;
    last_addr = phys_addr + size - 1;
    if (!size || last_addr < phys_addr)
        return NULL;
    if (phys_addr >= ISA_START_ADDRESS && last_addr < ISA_END_ADDRESS)
        return (__force void __iomem *) phys_to_virt (phys_addr);
    pgprot = __pgprot (_PAGE_PRESENT | _PAGE_RW | _PAGE_GLOBAL | _PAGE_DIRTY | _PAGE_ACCESSED | flags);
    offset = phys_addr & ~PAGE_MASK;
    phys_addr &= PAGE_MASK;
    size = PAGE_ALIGN (last_addr +1) - phys_addr;
    area = get_vm_area (size, VM_IOREMAP | (flags << 20));
    if (!area)
        return NULL;
    area->phys_addr = phys_addr;
    addr = area->addr;
    if (ioremap_page_range ((unsigned long) addr, (unsigned long) addr + size, phys_addr, pgprot)) {
        remove_vm_area ((void *) (PAGE_MASK & (unsigned long) addr));
        return NULL;
    }
    if (flags && ioremap_change_attr (phys_addr, size, flags) < 0) {
        area->flags &= 0xffffff;
        vunmap (addr);
        return NULL;
    }
    return (__force void __iomem *) (offset + (char *) addr);
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/ioremap_64.c.ifdefed" startline="124" endline="127">
{
    remove_vm_area ((void *) (PAGE_MASK & (unsigned long) addr));
    return NULL;
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/ioremap_64.c.ifdefed" startline="128" endline="132">
{
    area->flags &= 0xffffff;
    vunmap (addr);
    return NULL;
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/ioremap_64.c.ifdefed" startline="160" endline="162">
{
    return __ioremap (phys_addr, size, _PAGE_PCD);
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/ioremap_64.c.ifdefed" startline="172" endline="208">
{
    struct vm_struct *p, *o;
    if (addr <= high_memory)
        return;
    if (addr >= phys_to_virt (ISA_START_ADDRESS) && addr < phys_to_virt (ISA_END_ADDRESS))
        return;
    addr = (volatile void __iomem *) (PAGE_MASK & (unsigned long __force) addr);
    read_lock (& vmlist_lock);
    for (p = vmlist; p; p = p->next) {
        if (p->addr == addr)
            break;
    }
    read_unlock (& vmlist_lock);
    if (!p) {
        printk ("iounmap: bad address %p\n", addr);
        dump_stack ();
        return;
    }
    if (p->flags >> 20)
        ioremap_change_attr (p->phys_addr, p->size, 0);
    o = remove_vm_area ((void *) addr);
    BUG_ON (p != o || o == NULL);
    kfree (p);
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/ioremap_64.c.ifdefed" startline="188" endline="191">
{
    if (p->addr == addr)
        break;
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/ioremap_64.c.ifdefed" startline="194" endline="198">
{
    printk ("iounmap: bad address %p\n", addr);
    dump_stack ();
    return;
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/pageattr_64.c.ifdefed" startline="17" endline="36">
{
    pgd_t *pgd = pgd_offset_k (address);
    pud_t *pud;
    pmd_t *pmd;
    pte_t *pte;
    if (pgd_none (*pgd))
        return NULL;
    pud = pud_offset (pgd, address);
    if (!pud_present (*pud))
        return NULL;
    pmd = pmd_offset (pud, address);
    if (!pmd_present (*pmd))
        return NULL;
    if (pmd_large (*pmd))
        return (pte_t *) pmd;
    pte = pte_offset_kernel (pmd, address);
    if (pte && !pte_present (*pte))
        pte = NULL;
    return pte;
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/pageattr_64.c.ifdefed" startline="40" endline="62">
{
    int i;
    unsigned long addr;
    struct page *base = alloc_pages (GFP_KERNEL, 0);
    pte_t *pbase;
    if (!base)
        return NULL;
    SetPagePrivate (base);
    page_private (base) = 0;
    address = __pa (address);
    addr = address & LARGE_PAGE_MASK;
    pbase = (pte_t *) page_address (base);
    for (i = 0; i < PTRS_PER_PTE; i++, addr += PAGE_SIZE) {
        pbase[i] = pfn_pte (addr >> PAGE_SHIFT, addr == address ? prot : ref_prot);
    }
    return base;
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/pageattr_64.c.ifdefed" startline="57" endline="60">
{
    pbase[i] = pfn_pte (addr >> PAGE_SHIFT, addr == address ? prot : ref_prot);
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/pageattr_64.c.ifdefed" startline="65" endline="69">
{
    int i;
    for (i = 0; i < size; i += boot_cpu_data.x86_clflush_size)
        clflush (adr +i);
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/pageattr_64.c.ifdefed" startline="72" endline="86">
{
    struct list_head *l = (struct list_head *) arg;
    struct page *pg;
    if (1 || !cpu_has_clflush)
        asm volatile ("wbinvd"
            :
            :
            : "memory"
        );
    else
        list_for_each_entry (pg, l, lru) {
            void *adr = page_address (pg);
            clflush_cache_range (adr, PAGE_SIZE);
        }
    __flush_tlb_all ();
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/pageattr_64.c.ifdefed" startline="81" endline="84">
{
    void *adr = page_address (pg);
    clflush_cache_range (adr, PAGE_SIZE);
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/pageattr_64.c.ifdefed" startline="89" endline="91">
{
    on_each_cpu (flush_kernel_map, l, 1, 1);
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/pageattr_64.c.ifdefed" startline="96" endline="99">
{
    if (!test_and_set_bit (PG_arch_1, &fpage->flags))
        list_add (&fpage->lru, &deferred_pages);
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/pageattr_64.c.ifdefed" startline="106" endline="123">
{
    pgd_t *pgd;
    pud_t *pud;
    pmd_t *pmd;
    pte_t large_pte;
    unsigned long pfn;
    pgd = pgd_offset_k (address);
    BUG_ON (pgd_none (*pgd));
    pud = pud_offset (pgd, address);
    BUG_ON (pud_none (*pud));
    pmd = pmd_offset (pud, address);
    BUG_ON (pmd_val (* pmd) & _PAGE_PSE);
    pfn = (__pa (address) & LARGE_PAGE_MASK) >> PAGE_SHIFT;
    large_pte = pfn_pte (pfn, ref_prot);
    large_pte = pte_mkhuge (large_pte);
    set_pte ((pte_t *) pmd, large_pte);
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/pageattr_64.c.ifdefed" startline="128" endline="170">
{
    pte_t *kpte;
    struct page *kpte_page;
    pgprot_t ref_prot2;
    kpte = lookup_address (address);
    if (!kpte)
        return 0;
    kpte_page = virt_to_page (((unsigned long) kpte) & PAGE_MASK);
    BUG_ON (PageLRU (kpte_page));
    BUG_ON (PageCompound (kpte_page));
    if (pgprot_val (prot) != pgprot_val (ref_prot)) {
        if (!pte_huge (*kpte)) {
            set_pte (kpte, pfn_pte (pfn, prot));
        }
        else {
            struct page *split;
            ref_prot2 = pte_pgprot (pte_clrhuge (*kpte));
            split = split_large_page (address, prot, ref_prot2);
            if (!split)
                return -ENOMEM;
            pgprot_val (ref_prot2) &= ~_PAGE_NX;
            set_pte (kpte, mk_pte (split, ref_prot2));
            kpte_page = split;
        }
        page_private (kpte_page)++;
    }
    else if (!pte_huge (*kpte)) {
        set_pte (kpte, pfn_pte (pfn, ref_prot));
        BUG_ON (page_private (kpte_page) == 0);
        page_private (kpte_page)--;
    }
    else
        BUG ();
    BUG_ON (PageReserved (kpte_page));
    save_page (kpte_page);
    if (page_private (kpte_page) == 0)
        revert_page (address, ref_prot);
    return 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/pageattr_64.c.ifdefed" startline="138" endline="156">
{
    if (!pte_huge (*kpte)) {
        set_pte (kpte, pfn_pte (pfn, prot));
    }
    else {
        struct page *split;
        ref_prot2 = pte_pgprot (pte_clrhuge (*kpte));
        split = split_large_page (address, prot, ref_prot2);
        if (!split)
            return -ENOMEM;
        pgprot_val (ref_prot2) &= ~_PAGE_NX;
        set_pte (kpte, mk_pte (split, ref_prot2));
        kpte_page = split;
    }
    page_private (kpte_page)++;
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/pageattr_64.c.ifdefed" startline="139" endline="141">
{
    set_pte (kpte, pfn_pte (pfn, prot));
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/pageattr_64.c.ifdefed" startline="141" endline="154">
{
    struct page *split;
    ref_prot2 = pte_pgprot (pte_clrhuge (*kpte));
    split = split_large_page (address, prot, ref_prot2);
    if (!split)
        return -ENOMEM;
    pgprot_val (ref_prot2) &= ~_PAGE_NX;
    set_pte (kpte, mk_pte (split, ref_prot2));
    kpte_page = split;
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/pageattr_64.c.ifdefed" startline="156" endline="160">
{
    set_pte (kpte, pfn_pte (pfn, ref_prot));
    BUG_ON (page_private (kpte_page) == 0);
    page_private (kpte_page)--;
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/pageattr_64.c.ifdefed" startline="186" endline="219">
{
    int err = 0, kernel_map = 0;
    int i;
    if (address >= __START_KERNEL_map && address < __START_KERNEL_map + KERNEL_TEXT_SIZE) {
        address = (unsigned long) __va (__pa (address));
        kernel_map = 1;
    }
    down_write (& init_mm.mmap_sem);
    for (i = 0; i < numpages; i++, address += PAGE_SIZE) {
        unsigned long pfn = __pa (address) >> PAGE_SHIFT;
        if (!kernel_map || pte_present (pfn_pte (0, prot))) {
            err = __change_page_attr (address, pfn, prot, PAGE_KERNEL);
            if (err)
                break;
        }
        if (__pa (address) < KERNEL_TEXT_SIZE) {
            unsigned long addr2;
            pgprot_t prot2;
            addr2 = __START_KERNEL_map + __pa (address);
            prot2 = pte_pgprot (pte_mkexec (pfn_pte (0, prot)));
            err = __change_page_attr (addr2, pfn, prot2, PAGE_KERNEL_EXEC);
        }
    }
    up_write (& init_mm.mmap_sem);
    return err;
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/pageattr_64.c.ifdefed" startline="191" endline="194">
{
    address = (unsigned long) __va (__pa (address));
    kernel_map = 1;
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/pageattr_64.c.ifdefed" startline="197" endline="216">
{
    unsigned long pfn = __pa (address) >> PAGE_SHIFT;
    if (!kernel_map || pte_present (pfn_pte (0, prot))) {
        err = __change_page_attr (address, pfn, prot, PAGE_KERNEL);
        if (err)
            break;
    }
    if (__pa (address) < KERNEL_TEXT_SIZE) {
        unsigned long addr2;
        pgprot_t prot2;
        addr2 = __START_KERNEL_map + __pa (address);
        prot2 = pte_pgprot (pte_mkexec (pfn_pte (0, prot)));
        err = __change_page_attr (addr2, pfn, prot2, PAGE_KERNEL_EXEC);
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/pageattr_64.c.ifdefed" startline="200" endline="204">
{
    err = __change_page_attr (address, pfn, prot, PAGE_KERNEL);
    if (err)
        break;
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/pageattr_64.c.ifdefed" startline="207" endline="215">
{
    unsigned long addr2;
    pgprot_t prot2;
    addr2 = __START_KERNEL_map + __pa (address);
    prot2 = pte_pgprot (pte_mkexec (pfn_pte (0, prot)));
    err = __change_page_attr (addr2, pfn, prot2, PAGE_KERNEL_EXEC);
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/pageattr_64.c.ifdefed" startline="223" endline="226">
{
    unsigned long addr = (unsigned long) page_address (page);
    return change_page_attr_addr (addr, numpages, prot);
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/pageattr_64.c.ifdefed" startline="229" endline="252">
{
    struct page *pg, *next;
    struct list_head l;
    down_write (& init_mm.mmap_sem);
    list_replace_init (& deferred_pages, & l);
    up_write (& init_mm.mmap_sem);
    flush_map (& l);
    list_for_each_entry_safe (pg, next, &l, lru) {
        list_del (& pg -> lru);
        clear_bit (PG_arch_1, & pg -> flags);
        if (page_private (pg) != 0)
            continue;
        ClearPagePrivate (pg);
        __free_page (pg);
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/pageattr_64.c.ifdefed" startline="244" endline="251">
{
    list_del (& pg -> lru);
    clear_bit (PG_arch_1, & pg -> flags);
    if (page_private (pg) != 0)
        continue;
    ClearPagePrivate (pg);
    __free_page (pg);
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/numa_64.c.ifdefed" startline="52" endline="74">
{
    int i;
    int res = -1;
    unsigned long addr, end;
    memset (memnodemap, 0xff, memnodemapsize);
    for (i = 0; i < numnodes; i++) {
        addr = nodes[i].start;
        end = nodes[i].end;
        if (addr >= end)
            continue;
        if ((end >> shift) >= memnodemapsize)
            return 0;
        do {
            if (memnodemap[addr >> shift] != 0xff)
                return -1;
            memnodemap[addr >> shift] = i;
            addr += (1UL << shift);
        }
        while (addr < end);
        res = 1;
    }
    return res;
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/numa_64.c.ifdefed" startline="58" endline="72">
{
    addr = nodes[i].start;
    end = nodes[i].end;
    if (addr >= end)
        continue;
    if ((end >> shift) >= memnodemapsize)
        return 0;
    do {
        if (memnodemap[addr >> shift] != 0xff)
            return -1;
        memnodemap[addr >> shift] = i;
        addr += (1UL << shift);
    }
    while (addr < end);
    res = 1;
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/numa_64.c.ifdefed" startline="65" endline="70">
{
    if (memnodemap[addr >> shift] != 0xff)
        return -1;
    memnodemap[addr >> shift] = i;
    addr += (1UL << shift);
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/numa_64.c.ifdefed" startline="77" endline="101">
{
    unsigned long pad, pad_addr;
    memnodemap = memnode.embedded_map;
    if (memnodemapsize <= 48)
        return 0;
    pad = L1_CACHE_BYTES - 1;
    pad_addr = 0x8000;
    nodemap_size = pad + memnodemapsize;
    nodemap_addr = find_e820_area (pad_addr, end_pfn << PAGE_SHIFT, nodemap_size);
    if (nodemap_addr == -1UL) {
        printk (KERN_ERR "NUMA: Unable to allocate Memory to Node hash map\n");
        nodemap_addr = nodemap_size = 0;
        return -1;
    }
    pad_addr = (nodemap_addr + pad) & ~pad;
    memnodemap = phys_to_virt (pad_addr);
    printk (KERN_DEBUG "NUMA: Allocated memnodemap from %lx - %lx\n", nodemap_addr, nodemap_addr + nodemap_size);
    return 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/numa_64.c.ifdefed" startline="89" endline="94">
{
    printk (KERN_ERR "NUMA: Unable to allocate Memory to Node hash map\n");
    nodemap_addr = nodemap_size = 0;
    return -1;
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/numa_64.c.ifdefed" startline="109" endline="130">
{
    int i, nodes_used = 0;
    unsigned long start, end;
    unsigned long bitfield = 0, memtop = 0;
    for (i = 0; i < numnodes; i++) {
        start = nodes[i].start;
        end = nodes[i].end;
        if (start >= end)
            continue;
        bitfield |= start;
        nodes_used++;
        if (end > memtop)
            memtop = end;
    }
    if (nodes_used <= 1)
        i = 63;
    else
        i = find_first_bit (&bitfield, sizeof (unsigned long) * 8);
    memnodemapsize = (memtop >> i) + 1;
    return i;
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/numa_64.c.ifdefed" startline="114" endline="123">
{
    start = nodes[i].start;
    end = nodes[i].end;
    if (start >= end)
        continue;
    bitfield |= start;
    nodes_used++;
    if (end > memtop)
        memtop = end;
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/numa_64.c.ifdefed" startline="133" endline="150">
{
    int shift;
    shift = extract_lsb_from_nodes (nodes, numnodes);
    if (allocate_cachealigned_memnodemap ())
        return -1;
    printk (KERN_DEBUG "NUMA: Using %d for the hash shift.\n", shift);
    if (populate_memnodemap (nodes, numnodes, shift) != 1) {
        printk (KERN_INFO "Your memory is not aligned you need to rebuild your kernel " "with a bigger NODEMAPSIZE shift=%d\n", shift);
        return -1;
    }
    return shift;
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/numa_64.c.ifdefed" startline="142" endline="148">
{
    printk (KERN_INFO "Your memory is not aligned you need to rebuild your kernel " "with a bigger NODEMAPSIZE shift=%d\n", shift);
    return -1;
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/numa_64.c.ifdefed" startline="162" endline="175">
{
    unsigned long mem = find_e820_area (start, end, size);
    void *ptr;
    if (mem != -1L)
        return __va (mem);
    ptr = __alloc_bootmem_nopanic (size, SMP_CACHE_BYTES, __pa (MAX_DMA_ADDRESS));
    if (ptr == NULL) {
        printk (KERN_ERR "Cannot find %lu bytes in node %d\n", size, nodeid);
        return NULL;
    }
    return ptr;
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/numa_64.c.ifdefed" startline="169" endline="173">
{
    printk (KERN_ERR "Cannot find %lu bytes in node %d\n", size, nodeid);
    return NULL;
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/numa_64.c.ifdefed" startline="179" endline="228">
{
    unsigned long start_pfn, end_pfn, bootmap_pages, bootmap_size, bootmap_start;
    unsigned long nodedata_phys;
    void *bootmap;
    const int pgdat_size = round_up (sizeof (pg_data_t), PAGE_SIZE);
    start = round_up (start, ZONE_ALIGN);
    printk (KERN_INFO "Bootmem setup node %d %016lx-%016lx\n", nodeid, start, end);
    start_pfn = start >> PAGE_SHIFT;
    end_pfn = end >> PAGE_SHIFT;
    node_data[nodeid] = early_node_mem (nodeid, start, end, pgdat_size);
    if (node_data[nodeid] == NULL)
        return;
    nodedata_phys = __pa (node_data[nodeid]);
    memset (NODE_DATA (nodeid), 0, sizeof (pg_data_t));
    NODE_DATA (nodeid)->bdata = &plat_node_bdata[nodeid];
    NODE_DATA (nodeid)->node_start_pfn = start_pfn;
    NODE_DATA (nodeid)->node_spanned_pages = end_pfn - start_pfn;
    bootmap_pages = bootmem_bootmap_pages (end_pfn -start_pfn);
    bootmap_start = round_up (nodedata_phys +pgdat_size, PAGE_SIZE);
    bootmap = early_node_mem (nodeid, bootmap_start, end, bootmap_pages << PAGE_SHIFT);
    if (bootmap == NULL) {
        if (nodedata_phys < start || nodedata_phys >= end)
            free_bootmem ((unsigned long) node_data[nodeid], pgdat_size);
        node_data[nodeid] = NULL;
        return;
    }
    bootmap_start = __pa (bootmap);
    Dprintk ("bootmap start %lu pages %lu\n", bootmap_start, bootmap_pages);
    bootmap_size = init_bootmem_node (NODE_DATA (nodeid), bootmap_start >> PAGE_SHIFT, start_pfn, end_pfn);
    free_bootmem_with_active_regions (nodeid, end);
    reserve_bootmem_node (NODE_DATA (nodeid), nodedata_phys, pgdat_size);
    reserve_bootmem_node (NODE_DATA (nodeid), bootmap_start, bootmap_pages << PAGE_SHIFT);
    node_set_online (nodeid);
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/numa_64.c.ifdefed" startline="207" endline="212">
{
    if (nodedata_phys < start || nodedata_phys >= end)
        free_bootmem ((unsigned long) node_data[nodeid], pgdat_size);
    node_data[nodeid] = NULL;
    return;
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/numa_64.c.ifdefed" startline="232" endline="252">
{
    unsigned long start_pfn, end_pfn, memmapsize, limit;
    start_pfn = node_start_pfn (nodeid);
    end_pfn = node_end_pfn (nodeid);
    Dprintk (KERN_INFO "Setting up memmap for node %d %lx-%lx\n", nodeid, start_pfn, end_pfn);
    memmapsize = sizeof (struct page) * (end_pfn - start_pfn);
    limit = end_pfn << PAGE_SHIFT;
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/numa_64.c.ifdefed" startline="255" endline="272">
{
    int rr, i;
    rr = first_node (node_online_map);
    for (i = 0; i < NR_CPUS; i++) {
        if (cpu_to_node (i) != NUMA_NO_NODE)
            continue;
        numa_set_node (i, rr);
        rr = next_node (rr, node_online_map);
        if (rr == MAX_NUMNODES)
            rr = first_node (node_online_map);
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/numa_64.c.ifdefed" startline="263" endline="270">
{
    if (cpu_to_node (i) != NUMA_NO_NODE)
        continue;
    numa_set_node (i, rr);
    rr = next_node (rr, node_online_map);
    if (rr == MAX_NUMNODES)
        rr = first_node (node_online_map);
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/numa_64.c.ifdefed" startline="495" endline="536">
{
    int i;
    nodes_clear (node_possible_map);
    printk (KERN_INFO "%s\n", numa_off ? "NUMA turned off" : "No NUMA configuration found");
    printk (KERN_INFO "Faking a node at %016lx-%016lx\n", start_pfn << PAGE_SHIFT, end_pfn << PAGE_SHIFT);
    memnode_shift = 63;
    memnodemap = memnode.embedded_map;
    memnodemap[0] = 0;
    nodes_clear (node_online_map);
    node_set_online (0);
    node_set (0, node_possible_map);
    for (i = 0; i < NR_CPUS; i++)
        numa_set_node (i, 0);
    node_to_cpumask[0] = cpumask_of_cpu (0);
    e820_register_active_regions (0, start_pfn, end_pfn);
    setup_node_bootmem (0, start_pfn << PAGE_SHIFT, end_pfn << PAGE_SHIFT);
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/numa_64.c.ifdefed" startline="539" endline="541">
{
    set_bit (cpu, & node_to_cpumask [cpu_to_node (cpu)]);
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/numa_64.c.ifdefed" startline="544" endline="547">
{
    cpu_pda (cpu)->nodenumber = node;
    cpu_to_node (cpu) = node;
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/numa_64.c.ifdefed" startline="550" endline="557">
{
    int i;
    unsigned long pages = 0;

    for_each_online_node (i) {
        pages += free_all_bootmem_node (NODE_DATA (i));
    }

    return pages;
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/numa_64.c.ifdefed" startline="553" endline="555">
{
    pages += free_all_bootmem_node (NODE_DATA (i));
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/numa_64.c.ifdefed" startline="560" endline="576">
{
    int i;
    unsigned long max_zone_pfns [MAX_NR_ZONES];
    memset (max_zone_pfns, 0, sizeof (max_zone_pfns));
    max_zone_pfns[ZONE_DMA] = MAX_DMA_PFN;
    max_zone_pfns[ZONE_DMA32] = MAX_DMA32_PFN;
    max_zone_pfns[ZONE_NORMAL] = end_pfn;
    sparse_memory_present_with_active_regions (MAX_NUMNODES);
    sparse_init ();

    for_each_online_node (i) {
        setup_node_zones (i);
    }

    free_area_init_nodes (max_zone_pfns);
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/numa_64.c.ifdefed" startline="571" endline="573">
{
    setup_node_zones (i);
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/numa_64.c.ifdefed" startline="579" endline="595">
{
    if (!opt)
        return -EINVAL;
    if (!strncmp (opt, "off", 3))
        numa_off = 1;
    return 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/numa_64.c.ifdefed" startline="612" endline="622">
{
    int i;
    for (i = 0; i < NR_CPUS; i++) {
        u8 apicid = x86_cpu_to_apicid_init[i];
        if (apicid == BAD_APICID)
            continue;
        if (apicid_to_node[apicid] == NUMA_NO_NODE)
            continue;
        numa_set_node (i, apicid_to_node [apicid]);
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/numa_64.c.ifdefed" startline="614" endline="621">
{
    u8 apicid = x86_cpu_to_apicid_init[i];
    if (apicid == BAD_APICID)
        continue;
    if (apicid_to_node[apicid] == NUMA_NO_NODE)
        continue;
    numa_set_node (i, apicid_to_node [apicid]);
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/k8topology_64.c.ifdefed" startline="24" endline="41">
{
    int num;
    for (num = 0; num < 32; num++) {
        u32 header;
        header = read_pci_config (0, num, 0, 0x00);
        if (header != (PCI_VENDOR_ID_AMD | (0x1100 << 16)))
            continue;
        header = read_pci_config (0, num, 1, 0x00);
        if (header != (PCI_VENDOR_ID_AMD | (0x1101 << 16)))
            continue;
        return num;
    }
    return -1;
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/k8topology_64.c.ifdefed" startline="27" endline="38">
{
    u32 header;
    header = read_pci_config (0, num, 0, 0x00);
    if (header != (PCI_VENDOR_ID_AMD | (0x1100 << 16)))
        continue;
    header = read_pci_config (0, num, 1, 0x00);
    if (header != (PCI_VENDOR_ID_AMD | (0x1101 << 16)))
        continue;
    return num;
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/k8topology_64.c.ifdefed" startline="44" endline="182">
{
    unsigned long prevbase;
    struct bootnode nodes [8];
    int nodeid, i, j, nb;
    unsigned char nodeids [8];
    int found = 0;
    u32 reg;
    unsigned numnodes;
    unsigned num_cores;
    if (!early_pci_allowed ())
        return -1;
    nb = find_northbridge ();
    if (nb < 0)
        return nb;
    printk (KERN_INFO "Scanning NUMA topology in Northbridge %d\n", nb);
    num_cores = (cpuid_ecx (0x80000008) & 0xff) + 1;
    printk (KERN_INFO "CPU has %d num_cores\n", num_cores);
    reg = read_pci_config (0, nb, 0, 0x60);
    numnodes = ((reg >> 4) & 0xF) + 1;
    if (numnodes <= 1)
        return -1;
    printk (KERN_INFO "Number of nodes %d\n", numnodes);
    memset (& nodes, 0, sizeof (nodes));
    prevbase = 0;
    for (i = 0; i < 8; i++) {
        unsigned long base, limit;
        u32 nodeid;
        base = read_pci_config (0, nb, 1, 0x40 + i * 8);
        limit = read_pci_config (0, nb, 1, 0x44 + i * 8);
        nodeid = limit & 7;
        nodeids[i] = nodeid;
        if ((base & 3) == 0) {
            if (i < numnodes)
                printk ("Skipping disabled node %d\n", i);
            continue;
        }
        if (nodeid >= numnodes) {
            printk ("Ignoring excess node %d (%lx:%lx)\n", nodeid, base, limit);
            continue;
        }
        if (!limit) {
            printk (KERN_INFO "Skipping node entry %d (base %lx)\n", i, base);
            continue;
        }
        if ((base >> 8) & 3 || (limit >> 8) & 3) {
            printk (KERN_ERR "Node %d using interleaving mode %lx/%lx\n", nodeid, (base >> 8) & 3, (limit >> 8) & 3);
            return -1;
        }
        if (node_isset (nodeid, node_possible_map)) {
            printk (KERN_INFO "Node %d already present. Skipping\n", nodeid);
            continue;
        }
        limit >>= 16;
        limit <<= 24;
        limit |= (1 << 24) - 1;
        limit++;
        if (limit > end_pfn << PAGE_SHIFT)
            limit = end_pfn << PAGE_SHIFT;
        if (limit <= base)
            continue;
        base >>= 16;
        base <<= 24;
        if (base < start)
            base = start;
        if (limit > end)
            limit = end;
        if (limit == base) {
            printk (KERN_ERR "Empty node %d\n", nodeid);
            continue;
        }
        if (limit < base) {
            printk (KERN_ERR "Node %d bogus settings %lx-%lx.\n", nodeid, base, limit);
            continue;
        }
        if (prevbase > base) {
            printk (KERN_ERR "Node map not sorted %lx,%lx\n", prevbase, base);
            return -1;
        }
        printk (KERN_INFO "Node %d MemBase %016lx Limit %016lx\n", nodeid, base, limit);
        found++;
        nodes[nodeid].start = base;
        nodes[nodeid].end = limit;
        e820_register_active_regions (nodeid, nodes [nodeid].start >> PAGE_SHIFT, nodes [nodeid].end >> PAGE_SHIFT);
        prevbase = base;
        node_set (nodeid, node_possible_map);
    }
    if (!found)
        return -1;
    memnode_shift = compute_hash_shift (nodes, 8);
    if (memnode_shift < 0) {
        printk (KERN_ERR "No NUMA node hash function found. Contact maintainer\n");
        return -1;
    }
    printk (KERN_INFO "Using node hash shift of %d\n", memnode_shift);
    for (i = 0; i < 8; i++) {
        if (nodes[i].start != nodes[i].end) {
            nodeid = nodeids[i];
            for (j = 0; j < num_cores; j++)
                apicid_to_node[(nodeid * num_cores) + j] = i;
            setup_node_bootmem (i, nodes [i].start, nodes [i].end);
        }
    }
    numa_init_array ();
    return 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/k8topology_64.c.ifdefed" startline="75" endline="159">
{
    unsigned long base, limit;
    u32 nodeid;
    base = read_pci_config (0, nb, 1, 0x40 + i * 8);
    limit = read_pci_config (0, nb, 1, 0x44 + i * 8);
    nodeid = limit & 7;
    nodeids[i] = nodeid;
    if ((base & 3) == 0) {
        if (i < numnodes)
            printk ("Skipping disabled node %d\n", i);
        continue;
    }
    if (nodeid >= numnodes) {
        printk ("Ignoring excess node %d (%lx:%lx)\n", nodeid, base, limit);
        continue;
    }
    if (!limit) {
        printk (KERN_INFO "Skipping node entry %d (base %lx)\n", i, base);
        continue;
    }
    if ((base >> 8) & 3 || (limit >> 8) & 3) {
        printk (KERN_ERR "Node %d using interleaving mode %lx/%lx\n", nodeid, (base >> 8) & 3, (limit >> 8) & 3);
        return -1;
    }
    if (node_isset (nodeid, node_possible_map)) {
        printk (KERN_INFO "Node %d already present. Skipping\n", nodeid);
        continue;
    }
    limit >>= 16;
    limit <<= 24;
    limit |= (1 << 24) - 1;
    limit++;
    if (limit > end_pfn << PAGE_SHIFT)
        limit = end_pfn << PAGE_SHIFT;
    if (limit <= base)
        continue;
    base >>= 16;
    base <<= 24;
    if (base < start)
        base = start;
    if (limit > end)
        limit = end;
    if (limit == base) {
        printk (KERN_ERR "Empty node %d\n", nodeid);
        continue;
    }
    if (limit < base) {
        printk (KERN_ERR "Node %d bogus settings %lx-%lx.\n", nodeid, base, limit);
        continue;
    }
    if (prevbase > base) {
        printk (KERN_ERR "Node map not sorted %lx,%lx\n", prevbase, base);
        return -1;
    }
    printk (KERN_INFO "Node %d MemBase %016lx Limit %016lx\n", nodeid, base, limit);
    found++;
    nodes[nodeid].start = base;
    nodes[nodeid].end = limit;
    e820_register_active_regions (nodeid, nodes [nodeid].start >> PAGE_SHIFT, nodes [nodeid].end >> PAGE_SHIFT);
    prevbase = base;
    node_set (nodeid, node_possible_map);
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/k8topology_64.c.ifdefed" startline="84" endline="88">
{
    if (i < numnodes)
        printk ("Skipping disabled node %d\n", i);
    continue;
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/k8topology_64.c.ifdefed" startline="89" endline="93">
{
    printk ("Ignoring excess node %d (%lx:%lx)\n", nodeid, base, limit);
    continue;
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/k8topology_64.c.ifdefed" startline="95" endline="99">
{
    printk (KERN_INFO "Skipping node entry %d (base %lx)\n", i, base);
    continue;
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/k8topology_64.c.ifdefed" startline="100" endline="104">
{
    printk (KERN_ERR "Node %d using interleaving mode %lx/%lx\n", nodeid, (base >> 8) & 3, (limit >> 8) & 3);
    return -1;
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/k8topology_64.c.ifdefed" startline="105" endline="109">
{
    printk (KERN_INFO "Node %d already present. Skipping\n", nodeid);
    continue;
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/k8topology_64.c.ifdefed" startline="128" endline="131">
{
    printk (KERN_ERR "Empty node %d\n", nodeid);
    continue;
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/k8topology_64.c.ifdefed" startline="132" endline="136">
{
    printk (KERN_ERR "Node %d bogus settings %lx-%lx.\n", nodeid, base, limit);
    continue;
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/k8topology_64.c.ifdefed" startline="139" endline="143">
{
    printk (KERN_ERR "Node map not sorted %lx,%lx\n", prevbase, base);
    return -1;
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/k8topology_64.c.ifdefed" startline="165" endline="168">
{
    printk (KERN_ERR "No NUMA node hash function found. Contact maintainer\n");
    return -1;
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/k8topology_64.c.ifdefed" startline="171" endline="178">
{
    if (nodes[i].start != nodes[i].end) {
        nodeid = nodeids[i];
        for (j = 0; j < num_cores; j++)
            apicid_to_node[(nodeid * num_cores) + j] = i;
        setup_node_bootmem (i, nodes [i].start, nodes [i].end);
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/k8topology_64.c.ifdefed" startline="172" endline="177">
{
    nodeid = nodeids[i];
    for (j = 0; j < num_cores; j++)
        apicid_to_node[(nodeid * num_cores) + j] = i;
    setup_node_bootmem (i, nodes [i].start, nodes [i].end);
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/init_64.c.ifdefed" startline="65" endline="98">
{
    long i, total = 0, reserved = 0;
    long shared = 0, cached = 0;
    pg_data_t *pgdat;
    struct page *page;
    printk (KERN_INFO "Mem-info:\n");
    show_free_areas ();
    printk (KERN_INFO "Free swap:       %6ldkB\n", nr_swap_pages << (PAGE_SHIFT - 10));

    for_each_online_pgdat (pgdat) {
        for (i = 0; i < pgdat->node_spanned_pages; ++i) {
            if (unlikely (i % MAX_ORDER_NR_PAGES == 0)) {
                touch_nmi_watchdog ();
            }
            if (!pfn_valid (pgdat->node_start_pfn + i))
                continue;
            page = pfn_to_page (pgdat->node_start_pfn + i);
            total++;
            if (PageReserved (page))
                reserved++;
            else if (PageSwapCache (page))
                cached++;
            else if (page_count (page))
                shared += page_count (page) - 1;
        }
    }

    printk (KERN_INFO "%lu pages of RAM\n", total);
    printk (KERN_INFO "%lu reserved pages\n", reserved);
    printk (KERN_INFO "%lu pages shared\n", shared);
    printk (KERN_INFO "%lu pages swap cached\n", cached);
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/init_64.c.ifdefed" startline="75" endline="93">
{
    for (i = 0; i < pgdat->node_spanned_pages; ++i) {
        if (unlikely (i % MAX_ORDER_NR_PAGES == 0)) {
            touch_nmi_watchdog ();
        }
        if (!pfn_valid (pgdat->node_start_pfn + i))
            continue;
        page = pfn_to_page (pgdat->node_start_pfn + i);
        total++;
        if (PageReserved (page))
            reserved++;
        else if (PageSwapCache (page))
            cached++;
        else if (page_count (page))
            shared += page_count (page) - 1;
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/init_64.c.ifdefed" startline="76" endline="92">
{
    if (unlikely (i % MAX_ORDER_NR_PAGES == 0)) {
        touch_nmi_watchdog ();
    }
    if (!pfn_valid (pgdat->node_start_pfn + i))
        continue;
    page = pfn_to_page (pgdat->node_start_pfn + i);
    total++;
    if (PageReserved (page))
        reserved++;
    else if (PageSwapCache (page))
        cached++;
    else if (page_count (page))
        shared += page_count (page) - 1;
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/init_64.c.ifdefed" startline="79" endline="81">
{
    touch_nmi_watchdog ();
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/init_64.c.ifdefed" startline="103" endline="114">
{
    void *ptr;
    if (after_bootmem)
        ptr = (void *) get_zeroed_page (GFP_ATOMIC);
    else
        ptr = alloc_bootmem_pages (PAGE_SIZE);
    if (!ptr || ((unsigned long) ptr & ~PAGE_MASK))
        panic ("set_pte_phys: cannot allocate page data %s\n", after_bootmem ? "after bootmem" : "");
    Dprintk ("spp_getpage %p\n", ptr);
    return ptr;
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/init_64.c.ifdefed" startline="118" endline="162">
{
    pgd_t *pgd;
    pud_t *pud;
    pmd_t *pmd;
    pte_t *pte, new_pte;
    Dprintk ("set_pte_phys %lx to %lx\n", vaddr, phys);
    pgd = pgd_offset_k (vaddr);
    if (pgd_none (*pgd)) {
        printk ("PGD FIXMAP MISSING, it should be setup in head.S!\n");
        return;
    }
    pud = pud_offset (pgd, vaddr);
    if (pud_none (*pud)) {
        pmd = (pmd_t *) spp_getpage ();
        set_pud (pud, __pud (__pa (pmd) | _KERNPG_TABLE | _PAGE_USER));
        if (pmd != pmd_offset (pud, 0)) {
            printk ("PAGETABLE BUG #01! %p <-> %p\n", pmd, pmd_offset (pud, 0));
            return;
        }
    }
    pmd = pmd_offset (pud, vaddr);
    if (pmd_none (*pmd)) {
        pte = (pte_t *) spp_getpage ();
        set_pmd (pmd, __pmd (__pa (pte) | _KERNPG_TABLE | _PAGE_USER));
        if (pte != pte_offset_kernel (pmd, 0)) {
            printk ("PAGETABLE BUG #02!\n");
            return;
        }
    }
    new_pte = pfn_pte (phys >> PAGE_SHIFT, prot);
    pte = pte_offset_kernel (pmd, vaddr);
    if (!pte_none (*pte) && pte_val (*pte) != (pte_val (new_pte) & __supported_pte_mask))
        pte_ERROR (*pte);
    set_pte (pte, new_pte);
    __flush_tlb_one (vaddr);
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/init_64.c.ifdefed" startline="127" endline="130">
{
    printk ("PGD FIXMAP MISSING, it should be setup in head.S!\n");
    return;
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/init_64.c.ifdefed" startline="132" endline="139">
{
    pmd = (pmd_t *) spp_getpage ();
    set_pud (pud, __pud (__pa (pmd) | _KERNPG_TABLE | _PAGE_USER));
    if (pmd != pmd_offset (pud, 0)) {
        printk ("PAGETABLE BUG #01! %p <-> %p\n", pmd, pmd_offset (pud, 0));
        return;
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/init_64.c.ifdefed" startline="135" endline="138">
{
    printk ("PAGETABLE BUG #01! %p <-> %p\n", pmd, pmd_offset (pud, 0));
    return;
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/init_64.c.ifdefed" startline="141" endline="148">
{
    pte = (pte_t *) spp_getpage ();
    set_pmd (pmd, __pmd (__pa (pte) | _KERNPG_TABLE | _PAGE_USER));
    if (pte != pte_offset_kernel (pmd, 0)) {
        printk ("PAGETABLE BUG #02!\n");
        return;
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/init_64.c.ifdefed" startline="144" endline="147">
{
    printk ("PAGETABLE BUG #02!\n");
    return;
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/init_64.c.ifdefed" startline="167" endline="175">
{
    unsigned long address = __fix_to_virt (idx);
    if (idx >= __end_of_fixed_addresses) {
        printk ("Invalid __set_fixmap\n");
        return;
    }
    set_pte_phys (address, phys, prot);
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/init_64.c.ifdefed" startline="170" endline="173">
{
    printk ("Invalid __set_fixmap\n");
    return;
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/init_64.c.ifdefed" startline="180" endline="197">
{
    unsigned long pfn = table_end++;
    void *adr;
    if (after_bootmem) {
        adr = (void *) get_zeroed_page (GFP_ATOMIC);
        *phys = __pa (adr);
        return adr;
    }
    if (pfn >= end_pfn)
        panic ("alloc_low_page: ran out of memory");
    adr = early_ioremap (pfn *PAGE_SIZE, PAGE_SIZE);
    memset (adr, 0, PAGE_SIZE);
    *phys = pfn * PAGE_SIZE;
    return adr;
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/init_64.c.ifdefed" startline="184" endline="188">
{
    adr = (void *) get_zeroed_page (GFP_ATOMIC);
    *phys = __pa (adr);
    return adr;
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/init_64.c.ifdefed" startline="200" endline="206">
{
    if (after_bootmem)
        return;
    early_iounmap (adr, PAGE_SIZE);
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/init_64.c.ifdefed" startline="210" endline="235">
{
    unsigned long vaddr;
    pmd_t *pmd, *last_pmd;
    int i, pmds;
    pmds = ((addr & ~PMD_MASK) + size + ~PMD_MASK) / PMD_SIZE;
    vaddr = __START_KERNEL_map;
    pmd = level2_kernel_pgt;
    last_pmd = level2_kernel_pgt + PTRS_PER_PMD - 1;
    for (; pmd <= last_pmd; pmd++, vaddr += PMD_SIZE) {
        for (i = 0; i < pmds; i++) {
            if (pmd_present (pmd[i]))
                goto next;
        }
        vaddr += addr & ~PMD_MASK;
        addr &= PMD_MASK;
        for (i = 0; i < pmds; i++, addr += PMD_SIZE)
            set_pmd (pmd +i, __pmd (addr | _KERNPG_TABLE | _PAGE_PSE));
        __flush_tlb ();
        return (void *) vaddr;
    next :
        ;
    }
    printk ("early_ioremap(0x%lx, %lu) failed\n", addr, size);
    return NULL;
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/init_64.c.ifdefed" startline="219" endline="232">
{
    for (i = 0; i < pmds; i++) {
        if (pmd_present (pmd[i]))
            goto next;
    }
    vaddr += addr & ~PMD_MASK;
    addr &= PMD_MASK;
    for (i = 0; i < pmds; i++, addr += PMD_SIZE)
        set_pmd (pmd +i, __pmd (addr | _KERNPG_TABLE | _PAGE_PSE));
    __flush_tlb ();
    return (void *) vaddr;
next :
    ;
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/init_64.c.ifdefed" startline="220" endline="223">
{
    if (pmd_present (pmd[i]))
        goto next;
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/init_64.c.ifdefed" startline="239" endline="250">
{
    unsigned long vaddr;
    pmd_t *pmd;
    int i, pmds;
    vaddr = (unsigned long) addr;
    pmds = ((vaddr & ~PMD_MASK) + size + ~PMD_MASK) / PMD_SIZE;
    pmd = level2_kernel_pgt + pmd_index (vaddr);
    for (i = 0; i < pmds; i++)
        pmd_clear (pmd +i);
    __flush_tlb ();
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/init_64.c.ifdefed" startline="254" endline="275">
{
    int i = pmd_index (address);
    for (; i < PTRS_PER_PMD; i++, address += PMD_SIZE) {
        unsigned long entry;
        pmd_t *pmd = pmd_page + pmd_index (address);
        if (address >= end) {
            if (!after_bootmem)
                for (; i < PTRS_PER_PMD; i++, pmd++)
                    set_pmd (pmd, __pmd (0));
            break;
        }
        if (pmd_val (*pmd))
            continue;
        entry = _PAGE_NX | _PAGE_PSE | _KERNPG_TABLE | _PAGE_GLOBAL | address;
        entry &= __supported_pte_mask;
        set_pmd (pmd, __pmd (entry));
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/init_64.c.ifdefed" startline="257" endline="274">
{
    unsigned long entry;
    pmd_t *pmd = pmd_page + pmd_index (address);
    if (address >= end) {
        if (!after_bootmem)
            for (; i < PTRS_PER_PMD; i++, pmd++)
                set_pmd (pmd, __pmd (0));
        break;
    }
    if (pmd_val (*pmd))
        continue;
    entry = _PAGE_NX | _PAGE_PSE | _KERNPG_TABLE | _PAGE_GLOBAL | address;
    entry &= __supported_pte_mask;
    set_pmd (pmd, __pmd (entry));
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/init_64.c.ifdefed" startline="261" endline="266">
{
    if (!after_bootmem)
        for (; i < PTRS_PER_PMD; i++, pmd++)
            set_pmd (pmd, __pmd (0));
    break;
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/init_64.c.ifdefed" startline="279" endline="285">
{
    pmd_t *pmd = pmd_offset (pud, 0);
    spin_lock (& init_mm.page_table_lock);
    phys_pmd_init (pmd, address, end);
    spin_unlock (& init_mm.page_table_lock);
    __flush_tlb_all ();
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/init_64.c.ifdefed" startline="288" endline="318">
{
    int i = pud_index (addr);
    for (; i < PTRS_PER_PUD; i++, addr = (addr & PUD_MASK) + PUD_SIZE) {
        unsigned long pmd_phys;
        pud_t *pud = pud_page + pud_index (addr);
        pmd_t *pmd;
        if (addr >= end)
            break;
        if (!after_bootmem && !e820_any_mapped (addr, addr +PUD_SIZE, 0)) {
            set_pud (pud, __pud (0));
            continue;
        }
        if (pud_val (*pud)) {
            phys_pmd_update (pud, addr, end);
            continue;
        }
        pmd = alloc_low_page (&pmd_phys);
        spin_lock (& init_mm.page_table_lock);
        set_pud (pud, __pud (pmd_phys | _KERNPG_TABLE));
        phys_pmd_init (pmd, addr, end);
        spin_unlock (& init_mm.page_table_lock);
        unmap_low_page (pmd);
    }
    __flush_tlb ();
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/init_64.c.ifdefed" startline="292" endline="316">
{
    unsigned long pmd_phys;
    pud_t *pud = pud_page + pud_index (addr);
    pmd_t *pmd;
    if (addr >= end)
        break;
    if (!after_bootmem && !e820_any_mapped (addr, addr +PUD_SIZE, 0)) {
        set_pud (pud, __pud (0));
        continue;
    }
    if (pud_val (*pud)) {
        phys_pmd_update (pud, addr, end);
        continue;
    }
    pmd = alloc_low_page (&pmd_phys);
    spin_lock (& init_mm.page_table_lock);
    set_pud (pud, __pud (pmd_phys | _KERNPG_TABLE));
    phys_pmd_init (pmd, addr, end);
    spin_unlock (& init_mm.page_table_lock);
    unmap_low_page (pmd);
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/init_64.c.ifdefed" startline="300" endline="303">
{
    set_pud (pud, __pud (0));
    continue;
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/init_64.c.ifdefed" startline="305" endline="308">
{
    phys_pmd_update (pud, addr, end);
    continue;
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/init_64.c.ifdefed" startline="321" endline="343">
{
    unsigned long puds, pmds, tables, start;
    puds = (end + PUD_SIZE - 1) >> PUD_SHIFT;
    pmds = (end + PMD_SIZE - 1) >> PMD_SHIFT;
    tables = round_up (puds * sizeof (pud_t), PAGE_SIZE) + round_up (pmds * sizeof (pmd_t), PAGE_SIZE);
    start = 0x8000;
    table_start = find_e820_area (start, end, tables);
    if (table_start == -1UL)
        panic ("Cannot find space for the kernel page tables");
    table_start >>= PAGE_SHIFT;
    table_end = table_start;
    early_printk ("kernel direct mapping tables up to %lx @ %lx-%lx\n", end, table_start << PAGE_SHIFT, (table_start << PAGE_SHIFT) + tables);
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/init_64.c.ifdefed" startline="349" endline="388">
{
    unsigned long next;
    Dprintk ("init_memory_mapping\n");
    if (!after_bootmem)
        find_early_table_space (end);
    start = (unsigned long) __va (start);
    end = (unsigned long) __va (end);
    for (; start < end; start = next) {
        unsigned long pud_phys;
        pgd_t *pgd = pgd_offset_k (start);
        pud_t *pud;
        if (after_bootmem)
            pud = pud_offset (pgd, start &PGDIR_MASK);
        else
            pud = alloc_low_page (&pud_phys);
        next = start + PGDIR_SIZE;
        if (next > end)
            next = end;
        phys_pud_init (pud, __pa (start), __pa (next));
        if (!after_bootmem)
            set_pgd (pgd_offset_k (start), mk_kernel_pgd (pud_phys));
        unmap_low_page (pud);
    }
    if (!after_bootmem)
        mmu_cr4_features = read_cr4 ();
    __flush_tlb_all ();
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/init_64.c.ifdefed" startline="366" endline="383">
{
    unsigned long pud_phys;
    pgd_t *pgd = pgd_offset_k (start);
    pud_t *pud;
    if (after_bootmem)
        pud = pud_offset (pgd, start &PGDIR_MASK);
    else
        pud = alloc_low_page (&pud_phys);
    next = start + PGDIR_SIZE;
    if (next > end)
        next = end;
    phys_pud_init (pud, __pa (start), __pa (next));
    if (!after_bootmem)
        set_pgd (pgd_offset_k (start), mk_kernel_pgd (pud_phys));
    unmap_low_page (pud);
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/init_64.c.ifdefed" startline="392" endline="402">
{
    unsigned long max_zone_pfns [MAX_NR_ZONES];
    memset (max_zone_pfns, 0, sizeof (max_zone_pfns));
    max_zone_pfns[ZONE_DMA] = MAX_DMA_PFN;
    max_zone_pfns[ZONE_DMA32] = MAX_DMA32_PFN;
    max_zone_pfns[ZONE_NORMAL] = end_pfn;
    memory_present (0, 0, end_pfn);
    sparse_init ();
    free_area_init_nodes (max_zone_pfns);
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/init_64.c.ifdefed" startline="410" endline="437">
{
    unsigned long end = address + size;
    BUG_ON (address & ~ LARGE_PAGE_MASK);
    BUG_ON (size & ~ LARGE_PAGE_MASK);
    for (; address < end; address += LARGE_PAGE_SIZE) {
        pgd_t *pgd = pgd_offset_k (address);
        pud_t *pud;
        pmd_t *pmd;
        if (pgd_none (*pgd))
            continue;
        pud = pud_offset (pgd, address);
        if (pud_none (*pud))
            continue;
        pmd = pmd_offset (pud, address);
        if (!pmd || pmd_none (*pmd))
            continue;
        if (0 == (pmd_val (*pmd) & _PAGE_PSE)) {
            printk (KERN_ERR "clear_kernel_mapping: mapping has been split. will leak memory\n");
            pmd_ERROR (*pmd);
        }
        set_pmd (pmd, __pmd (0));
    }
    __flush_tlb_all ();
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/init_64.c.ifdefed" startline="416" endline="435">
{
    pgd_t *pgd = pgd_offset_k (address);
    pud_t *pud;
    pmd_t *pmd;
    if (pgd_none (*pgd))
        continue;
    pud = pud_offset (pgd, address);
    if (pud_none (*pud))
        continue;
    pmd = pmd_offset (pud, address);
    if (!pmd || pmd_none (*pmd))
        continue;
    if (0 == (pmd_val (*pmd) & _PAGE_PSE)) {
        printk (KERN_ERR "clear_kernel_mapping: mapping has been split. will leak memory\n");
        pmd_ERROR (*pmd);
    }
    set_pmd (pmd, __pmd (0));
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/init_64.c.ifdefed" startline="428" endline="433">
{
    printk (KERN_ERR "clear_kernel_mapping: mapping has been split. will leak memory\n");
    pmd_ERROR (*pmd);
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/init_64.c.ifdefed" startline="443" endline="449">
{
    ClearPageReserved (page);
    init_page_count (page);
    __free_page (page);
    totalram_pages++;
    num_physpages++;
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/init_64.c.ifdefed" startline="519" endline="560">
{
    long codesize, reservedpages, datasize, initsize;
    pci_iommu_alloc ();
    memset (empty_zero_page, 0, PAGE_SIZE);
    reservedpages = 0;
    totalram_pages = free_all_bootmem ();
    reservedpages = end_pfn - totalram_pages - absent_pages_in_range (0, end_pfn);
    after_bootmem = 1;
    codesize = (unsigned long) &_etext - (unsigned long) &_text;
    datasize = (unsigned long) &_edata - (unsigned long) &_etext;
    initsize = (unsigned long) &__init_end - (unsigned long) &__init_begin;
    kclist_add (& kcore_mem, __va (0), max_low_pfn << PAGE_SHIFT);
    kclist_add (& kcore_vmalloc, (void *) VMALLOC_START, VMALLOC_END - VMALLOC_START);
    kclist_add (& kcore_kernel, & _stext, _end - _stext);
    kclist_add (& kcore_modules, (void *) MODULES_VADDR, MODULES_LEN);
    kclist_add (& kcore_vsyscall, (void *) VSYSCALL_START, VSYSCALL_END - VSYSCALL_START);
    printk ("Memory: %luk/%luk available (%ldk kernel code, %ldk reserved, %ldk data, %ldk init)\n", (unsigned long) nr_free_pages () << (PAGE_SHIFT - 10), end_pfn << (PAGE_SHIFT - 10), codesize >> 10, reservedpages << (PAGE_SHIFT - 10), datasize >> 10, initsize >> 10);
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/init_64.c.ifdefed" startline="563" endline="582">
{
    unsigned long addr;
    if (begin >= end)
        return;
    printk (KERN_INFO "Freeing %s: %luk freed\n", what, (end - begin) >> 10);
    for (addr = begin; addr < end; addr += PAGE_SIZE) {
        ClearPageReserved (virt_to_page (addr));
        init_page_count (virt_to_page (addr));
        memset ((void *) (addr & ~ (PAGE_SIZE - 1)), POISON_FREE_INITMEM, PAGE_SIZE);
        if (addr >= __START_KERNEL_map)
            change_page_attr_addr (addr, 1, __pgprot (0));
        free_page (addr);
        totalram_pages++;
    }
    if (addr > __START_KERNEL_map)
        global_flush_tlb ();
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/init_64.c.ifdefed" startline="570" endline="579">
{
    ClearPageReserved (virt_to_page (addr));
    init_page_count (virt_to_page (addr));
    memset ((void *) (addr & ~ (PAGE_SIZE - 1)), POISON_FREE_INITMEM, PAGE_SIZE);
    if (addr >= __START_KERNEL_map)
        change_page_attr_addr (addr, 1, __pgprot (0));
    free_page (addr);
    totalram_pages++;
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/init_64.c.ifdefed" startline="585" endline="589">
{
    free_init_pages ("unused kernel memory", (unsigned long) (& __init_begin), (unsigned long) (& __init_end));
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/init_64.c.ifdefed" startline="636" endline="661">
{
    unsigned long pfn = phys >> PAGE_SHIFT;
    if (pfn >= end_pfn) {
        if (pfn < end_pfn_map)
            return;
        printk (KERN_ERR "reserve_bootmem: illegal reserve %lx %u\n", phys, len);
        return;
    }
    reserve_bootmem (phys, len);
    if (phys + len <= MAX_DMA_PFN * PAGE_SIZE) {
        dma_reserve += len / PAGE_SIZE;
        set_dma_reserve (dma_reserve);
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/init_64.c.ifdefed" startline="641" endline="649">
{
    if (pfn < end_pfn_map)
        return;
    printk (KERN_ERR "reserve_bootmem: illegal reserve %lx %u\n", phys, len);
    return;
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/init_64.c.ifdefed" startline="657" endline="660">
{
    dma_reserve += len / PAGE_SIZE;
    set_dma_reserve (dma_reserve);
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/init_64.c.ifdefed" startline="664" endline="692">
{
    unsigned long above = ((long) addr) >> __VIRTUAL_MASK_SHIFT;
    pgd_t *pgd;
    pud_t *pud;
    pmd_t *pmd;
    pte_t *pte;
    if (above != 0 && above != -1UL)
        return 0;
    pgd = pgd_offset_k (addr);
    if (pgd_none (*pgd))
        return 0;
    pud = pud_offset (pgd, addr);
    if (pud_none (*pud))
        return 0;
    pmd = pmd_offset (pud, addr);
    if (pmd_none (*pmd))
        return 0;
    if (pmd_large (*pmd))
        return pfn_valid (pmd_pfn (*pmd));
    pte = pte_offset_kernel (pmd, addr);
    if (pte_none (*pte))
        return 0;
    return pfn_valid (pte_pfn (*pte));
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/init_64.c.ifdefed" startline="706" endline="712">
{
    return &gate_vma;
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/init_64.c.ifdefed" startline="715" endline="720">
{
    struct vm_area_struct *vma = get_gate_vma (task);
    if (!vma)
        return 0;
    return (addr >= vma->vm_start) && (addr < vma->vm_end);
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/init_64.c.ifdefed" startline="727" endline="729">
{
    return (addr >= VSYSCALL_START) && (addr < VSYSCALL_END);
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/init_64.c.ifdefed" startline="732" endline="738">
{
    if (vma->vm_mm && vma->vm_start == (long) vma->vm_mm->context.vdso)
        return "[vdso]";
    if (vma == &gate_vma)
        return "[vsyscall]";
    return NULL;
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/mmap_64.c.ifdefed" startline="12" endline="28">
{
    mm->mmap_base = TASK_UNMAPPED_BASE;
    if (current->flags & PF_RANDOMIZE) {
        unsigned rnd = get_random_int () & 0xfffffff;
        mm->mmap_base += ((unsigned long) rnd) << PAGE_SHIFT;
    }
    mm->get_unmapped_area = arch_get_unmapped_area;
    mm->unmap_area = arch_unmap_area;
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/mmap_64.c.ifdefed" startline="18" endline="25">
{
    unsigned rnd = get_random_int () & 0xfffffff;
    mm->mmap_base += ((unsigned long) rnd) << PAGE_SHIFT;
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/fault_64.c.ifdefed" startline="61" endline="63">
{
    return 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/fault_64.c.ifdefed" startline="71" endline="141">
{
    unsigned char *instr;
    int scan_more = 1;
    int prefetch = 0;
    unsigned char *max_instr;
    if (error_code & PF_INSTR)
        return 0;
    instr = (unsigned char __user *) convert_rip_to_linear (current, regs);
    max_instr = instr + 15;
    if (user_mode (regs) && instr >= (unsigned char *) TASK_SIZE)
        return 0;
    while (scan_more && instr < max_instr) {
        unsigned char opcode;
        unsigned char instr_hi;
        unsigned char instr_lo;
        if (probe_kernel_address (instr, opcode))
            break;
        instr_hi = opcode & 0xf0;
        instr_lo = opcode & 0x0f;
        instr++;
        switch (instr_hi) {
        case 0x20 :
        case 0x30 :
            scan_more = ((instr_lo & 7) == 0x6);
            break;
        case 0x40 :
            scan_more = (!user_mode (regs)) || (regs->cs == __USER_CS);
            break;
        case 0x60 :
            scan_more = (instr_lo & 0xC) == 0x4;
            break;
        case 0xF0 :
            scan_more = !instr_lo || (instr_lo >> 1) == 1;
            break;
        case 0x00 :
            scan_more = 0;
            if (probe_kernel_address (instr, opcode))
                break;
            prefetch = (instr_lo == 0xF) && (opcode == 0x0D || opcode == 0x18);
            break;
        default :
            scan_more = 0;
            break;
        }
    }
    return prefetch;
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/fault_64.c.ifdefed" startline="87" endline="139">
{
    unsigned char opcode;
    unsigned char instr_hi;
    unsigned char instr_lo;
    if (probe_kernel_address (instr, opcode))
        break;
    instr_hi = opcode & 0xf0;
    instr_lo = opcode & 0x0f;
    instr++;
    switch (instr_hi) {
    case 0x20 :
    case 0x30 :
        scan_more = ((instr_lo & 7) == 0x6);
        break;
    case 0x40 :
        scan_more = (!user_mode (regs)) || (regs->cs == __USER_CS);
        break;
    case 0x60 :
        scan_more = (instr_lo & 0xC) == 0x4;
        break;
    case 0xF0 :
        scan_more = !instr_lo || (instr_lo >> 1) == 1;
        break;
    case 0x00 :
        scan_more = 0;
        if (probe_kernel_address (instr, opcode))
            break;
        prefetch = (instr_lo == 0xF) && (opcode == 0x0D || opcode == 0x18);
        break;
    default :
        scan_more = 0;
        break;
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/fault_64.c.ifdefed" startline="99" endline="138">
{
case 0x20 :
case 0x30 :
    scan_more = ((instr_lo & 7) == 0x6);
    break;
case 0x40 :
    scan_more = (!user_mode (regs)) || (regs->cs == __USER_CS);
    break;
case 0x60 :
    scan_more = (instr_lo & 0xC) == 0x4;
    break;
case 0xF0 :
    scan_more = !instr_lo || (instr_lo >> 1) == 1;
    break;
case 0x00 :
    scan_more = 0;
    if (probe_kernel_address (instr, opcode))
        break;
    prefetch = (instr_lo == 0xF) && (opcode == 0x0D || opcode == 0x18);
    break;
default :
    scan_more = 0;
    break;
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/fault_64.c.ifdefed" startline="144" endline="147">
{
    unsigned long dummy;
    return probe_kernel_address ((unsigned long *) p, dummy);
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/fault_64.c.ifdefed" startline="150" endline="182">
{
    pgd_t *pgd;
    pud_t *pud;
    pmd_t *pmd;
    pte_t *pte;
    pgd = (pgd_t *) read_cr3 ();
    pgd = __va ((unsigned long) pgd & PHYSICAL_PAGE_MASK);
    pgd += pgd_index (address);
    if (bad_address (pgd))
        goto bad;
    printk ("PGD %lx ", pgd_val (* pgd));
    if (!pgd_present (*pgd))
        goto ret;
    pud = pud_offset (pgd, address);
    if (bad_address (pud))
        goto bad;
    printk ("PUD %lx ", pud_val (* pud));
    if (!pud_present (*pud))
        goto ret;
    pmd = pmd_offset (pud, address);
    if (bad_address (pmd))
        goto bad;
    printk ("PMD %lx ", pmd_val (* pmd));
    if (!pmd_present (*pmd) || pmd_large (*pmd))
        goto ret;
    pte = pte_offset_kernel (pmd, address);
    if (bad_address (pte))
        goto bad;
    printk ("PTE %lx", pte_val (* pte));
ret :
    printk ("\n");
    return;
bad :
    printk ("BAD\n");
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/fault_64.c.ifdefed" startline="199" endline="216">
{
    static int warned;
    if (address != regs->rip)
        return 0;
    if ((address >> 32) != 0)
        return 0;
    address |= 0xffffffffUL << 32;
    if ((address >= (u64) _stext && address <= (u64) _etext) || (address >= MODULES_VADDR && address <= MODULES_END)) {
        if (!warned) {
            printk (errata93_warning);
            warned = 1;
        }
        regs->rip = address;
        return 1;
    }
    return 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/fault_64.c.ifdefed" startline="207" endline="214">
{
    if (!warned) {
        printk (errata93_warning);
        warned = 1;
    }
    regs->rip = address;
    return 1;
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/fault_64.c.ifdefed" startline="208" endline="211">
{
    printk (errata93_warning);
    warned = 1;
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/fault_64.c.ifdefed" startline="220" endline="234">
{
    unsigned long flags = oops_begin ();
    struct task_struct *tsk;
    printk (KERN_ALERT "%s: Corrupted page table at address %lx\n", current -> comm, address);
    dump_pagetable (address);
    tsk = current;
    tsk->thread.cr2 = address;
    tsk->thread.trap_no = 14;
    tsk->thread.error_code = error_code;
    __die ("Bad pagetable", regs, error_code);
    oops_end (flags);
    do_exit (SIGKILL);
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/fault_64.c.ifdefed" startline="242" endline="286">
{
    pgd_t *pgd, *pgd_ref;
    pud_t *pud, *pud_ref;
    pmd_t *pmd, *pmd_ref;
    pte_t *pte, *pte_ref;
    pgd = pgd_offset (current->mm ? : &init_mm, address);
    pgd_ref = pgd_offset_k (address);
    if (pgd_none (*pgd_ref))
        return -1;
    if (pgd_none (*pgd))
        set_pgd (pgd, *pgd_ref);
    else
        BUG_ON (pgd_page_vaddr (*pgd) != pgd_page_vaddr (*pgd_ref));
    pud = pud_offset (pgd, address);
    pud_ref = pud_offset (pgd_ref, address);
    if (pud_none (*pud_ref))
        return -1;
    if (pud_none (*pud) || pud_page_vaddr (*pud) != pud_page_vaddr (*pud_ref))
        BUG ();
    pmd = pmd_offset (pud, address);
    pmd_ref = pmd_offset (pud_ref, address);
    if (pmd_none (*pmd_ref))
        return -1;
    if (pmd_none (*pmd) || pmd_page (*pmd) != pmd_page (*pmd_ref))
        BUG ();
    pte_ref = pte_offset_kernel (pmd_ref, address);
    if (!pte_present (*pte_ref))
        return -1;
    pte = pte_offset_kernel (pmd, address);
    if (!pte_present (*pte) || pte_pfn (*pte) != pte_pfn (*pte_ref))
        BUG ();
    return 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/fault_64.c.ifdefed" startline="297" endline="582">
{
    struct task_struct *tsk;
    struct mm_struct *mm;
    struct vm_area_struct *vma;
    unsigned long address;
    const struct exception_table_entry *fixup;
    int write, fault;
    unsigned long flags;
    siginfo_t info;
    trace_hardirqs_fixup ();
    tsk = current;
    mm = tsk->mm;
    prefetchw (& mm -> mmap_sem);
    address = read_cr2 ();
    info.si_code = SEGV_MAPERR;
    if (unlikely (address >= TASK_SIZE64)) {
        if (!(error_code & (PF_RSVD | PF_USER | PF_PROT)) && ((address >= VMALLOC_START && address < VMALLOC_END))) {
            if (vmalloc_fault (address) >= 0)
                return;
        }
        if (notify_page_fault (regs))
            return;
        goto bad_area_nosemaphore;
    }
    if (notify_page_fault (regs))
        return;
    if (likely (regs->eflags & X86_EFLAGS_IF))
        local_irq_enable ();
    if (unlikely (error_code &PF_RSVD))
        pgtable_bad (address, regs, error_code);
    if (unlikely (in_atomic () || !mm))
        goto bad_area_nosemaphore;
    if (user_mode_vm (regs))
        error_code |= PF_USER;
again :
    if (!down_read_trylock (&mm->mmap_sem)) {
        if ((error_code & PF_USER) == 0 && !search_exception_tables (regs->rip))
            goto bad_area_nosemaphore;
        down_read (& mm -> mmap_sem);
    }
    vma = find_vma (mm, address);
    if (!vma)
        goto bad_area;
    if (likely (vma->vm_start <= address))
        goto good_area;
    if (!(vma->vm_flags & VM_GROWSDOWN))
        goto bad_area;
    if (error_code & 4) {
        if (address + 65536 + 32 * sizeof (unsigned long) < regs->rsp)
            goto bad_area;
    }
    if (expand_stack (vma, address))
        goto bad_area;
good_area :
    info.si_code = SEGV_ACCERR;
    write = 0;
    switch (error_code & (PF_PROT | PF_WRITE)) {
    default :
    case PF_WRITE :
        if (!(vma->vm_flags & VM_WRITE))
            goto bad_area;
        write++;
        break;
    case PF_PROT :
        goto bad_area;
    case 0 :
        if (!(vma->vm_flags & (VM_READ | VM_EXEC | VM_WRITE)))
            goto bad_area;
    }
    fault = handle_mm_fault (mm, vma, address, write);
    if (unlikely (fault &VM_FAULT_ERROR)) {
        if (fault & VM_FAULT_OOM)
            goto out_of_memory;
        else if (fault & VM_FAULT_SIGBUS)
            goto do_sigbus;
        BUG ();
    }
    if (fault & VM_FAULT_MAJOR)
        tsk->maj_flt++;
    else
        tsk->min_flt++;
    up_read (& mm -> mmap_sem);
    return;
bad_area :
    up_read (&mm->mmap_sem);
bad_area_nosemaphore :
    if (error_code & PF_USER) {
        local_irq_enable ();
        if (is_prefetch (regs, address, error_code))
            return;
        if ((regs->cs == __USER32_CS || (regs->cs & (1 << 2))) && (address >> 32))
            return;
        if (show_unhandled_signals && unhandled_signal (tsk, SIGSEGV) && printk_ratelimit ()) {
            printk ("%s%s[%d]: segfault at %lx rip %lx rsp %lx error %lx\n", tsk -> pid > 1 ? KERN_INFO : KERN_EMERG, tsk -> comm, tsk -> pid, address, regs -> rip, regs -> rsp, error_code);
        }
        tsk->thread.cr2 = address;
        tsk->thread.error_code = error_code | (address >= TASK_SIZE);
        tsk->thread.trap_no = 14;
        info.si_signo = SIGSEGV;
        info.si_errno = 0;
        info.si_addr = (void __user *) address;
        force_sig_info (SIGSEGV, & info, tsk);
        return;
    }
no_context :
    fixup = search_exception_tables (regs->rip);
    if (fixup) {
        regs->rip = fixup->fixup;
        return;
    }
    if (is_prefetch (regs, address, error_code))
        return;
    if (is_errata93 (regs, address))
        return;
    flags = oops_begin ();
    if (address < PAGE_SIZE)
        printk (KERN_ALERT "Unable to handle kernel NULL pointer dereference");
    else
        printk (KERN_ALERT "Unable to handle kernel paging request");
    printk (" at %016lx RIP: \n" KERN_ALERT, address);
    printk_address (regs -> rip);
    dump_pagetable (address);
    tsk->thread.cr2 = address;
    tsk->thread.trap_no = 14;
    tsk->thread.error_code = error_code;
    __die ("Oops", regs, error_code);
    printk (KERN_EMERG "CR2: %016lx\n", address);
    oops_end (flags);
    do_exit (SIGKILL);
out_of_memory :
    up_read (&mm->mmap_sem);
    if (is_global_init (current)) {
        yield ();
        goto again;
    }
    printk ("VM: killing process %s\n", tsk -> comm);
    if (error_code & 4)
        do_group_exit (SIGKILL);
    goto no_context;
do_sigbus :
    up_read (&mm->mmap_sem);
    if (!(error_code & PF_USER))
        goto no_context;
    tsk->thread.cr2 = address;
    tsk->thread.error_code = error_code;
    tsk->thread.trap_no = 14;
    info.si_signo = SIGBUS;
    info.si_errno = 0;
    info.si_code = BUS_ADRERR;
    info.si_addr = (void __user *) address;
    force_sig_info (SIGBUS, & info, tsk);
    return;
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/fault_64.c.ifdefed" startline="335" endline="353">
{
    if (!(error_code & (PF_RSVD | PF_USER | PF_PROT)) && ((address >= VMALLOC_START && address < VMALLOC_END))) {
        if (vmalloc_fault (address) >= 0)
            return;
    }
    if (notify_page_fault (regs))
        return;
    goto bad_area_nosemaphore;
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/fault_64.c.ifdefed" startline="342" endline="345">
{
    if (vmalloc_fault (address) >= 0)
        return;
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/fault_64.c.ifdefed" startline="394" endline="399">
{
    if ((error_code & PF_USER) == 0 && !search_exception_tables (regs->rip))
        goto bad_area_nosemaphore;
    down_read (& mm -> mmap_sem);
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/fault_64.c.ifdefed" startline="408" endline="414">
{
    if (address + 65536 + 32 * sizeof (unsigned long) < regs->rsp)
        goto bad_area;
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/fault_64.c.ifdefed" startline="424" endline="437">
{
default :
case PF_WRITE :
    if (!(vma->vm_flags & VM_WRITE))
        goto bad_area;
    write++;
    break;
case PF_PROT :
    goto bad_area;
case 0 :
    if (!(vma->vm_flags & (VM_READ | VM_EXEC | VM_WRITE)))
        goto bad_area;
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/fault_64.c.ifdefed" startline="445" endline="451">
{
    if (fault & VM_FAULT_OOM)
        goto out_of_memory;
    else if (fault & VM_FAULT_SIGBUS)
        goto do_sigbus;
    BUG ();
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/fault_64.c.ifdefed" startline="468" endline="507">
{
    local_irq_enable ();
    if (is_prefetch (regs, address, error_code))
        return;
    if ((regs->cs == __USER32_CS || (regs->cs & (1 << 2))) && (address >> 32))
        return;
    if (show_unhandled_signals && unhandled_signal (tsk, SIGSEGV) && printk_ratelimit ()) {
        printk ("%s%s[%d]: segfault at %lx rip %lx rsp %lx error %lx\n", tsk -> pid > 1 ? KERN_INFO : KERN_EMERG, tsk -> comm, tsk -> pid, address, regs -> rip, regs -> rsp, error_code);
    }
    tsk->thread.cr2 = address;
    tsk->thread.error_code = error_code | (address >= TASK_SIZE);
    tsk->thread.trap_no = 14;
    info.si_signo = SIGSEGV;
    info.si_errno = 0;
    info.si_addr = (void __user *) address;
    force_sig_info (SIGSEGV, & info, tsk);
    return;
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/fault_64.c.ifdefed" startline="489" endline="495">
{
    printk ("%s%s[%d]: segfault at %lx rip %lx rsp %lx error %lx\n", tsk -> pid > 1 ? KERN_INFO : KERN_EMERG, tsk -> comm, tsk -> pid, address, regs -> rip, regs -> rsp, error_code);
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/fault_64.c.ifdefed" startline="513" endline="516">
{
    regs->rip = fixup->fixup;
    return;
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/fault_64.c.ifdefed" startline="557" endline="560">
{
    yield ();
    goto again;
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/fault_64.c.ifdefed" startline="588" endline="623">
{
    static DECLARE_BITMAP (insync, PTRS_PER_PGD);
    static unsigned long start = VMALLOC_START & PGDIR_MASK;
    unsigned long address;
    for (address = start; address <= VMALLOC_END; address += PGDIR_SIZE) {
        if (!test_bit (pgd_index (address), insync)) {
            const pgd_t *pgd_ref = pgd_offset_k (address);
            struct page *page;
            if (pgd_none (*pgd_ref))
                continue;
            spin_lock (& pgd_lock);
            list_for_each_entry (page, &pgd_list, lru) {
                pgd_t *pgd;
                pgd = (pgd_t *) page_address (page) + pgd_index (address);
                if (pgd_none (*pgd))
                    set_pgd (pgd, *pgd_ref);
                else
                    BUG_ON (pgd_page_vaddr (*pgd) != pgd_page_vaddr (*pgd_ref));
            }
            spin_unlock (& pgd_lock);
            set_bit (pgd_index (address), insync);
        }
        if (address == start)
            start = address + PGDIR_SIZE;
    }
    BUILD_BUG_ON (! (MODULES_VADDR > __START_KERNEL));
    BUILD_BUG_ON (! (((MODULES_END - 1) & PGDIR_MASK) == (__START_KERNEL & PGDIR_MASK)));
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/fault_64.c.ifdefed" startline="597" endline="618">
{
    if (!test_bit (pgd_index (address), insync)) {
        const pgd_t *pgd_ref = pgd_offset_k (address);
        struct page *page;
        if (pgd_none (*pgd_ref))
            continue;
        spin_lock (& pgd_lock);
        list_for_each_entry (page, &pgd_list, lru) {
            pgd_t *pgd;
            pgd = (pgd_t *) page_address (page) + pgd_index (address);
            if (pgd_none (*pgd))
                set_pgd (pgd, *pgd_ref);
            else
                BUG_ON (pgd_page_vaddr (*pgd) != pgd_page_vaddr (*pgd_ref));
        }
        spin_unlock (& pgd_lock);
        set_bit (pgd_index (address), insync);
    }
    if (address == start)
        start = address + PGDIR_SIZE;
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/fault_64.c.ifdefed" startline="598" endline="615">
{
    const pgd_t *pgd_ref = pgd_offset_k (address);
    struct page *page;
    if (pgd_none (*pgd_ref))
        continue;
    spin_lock (& pgd_lock);
    list_for_each_entry (page, &pgd_list, lru) {
        pgd_t *pgd;
        pgd = (pgd_t *) page_address (page) + pgd_index (address);
        if (pgd_none (*pgd))
            set_pgd (pgd, *pgd_ref);
        else
            BUG_ON (pgd_page_vaddr (*pgd) != pgd_page_vaddr (*pgd_ref));
    }
    spin_unlock (& pgd_lock);
    set_bit (pgd_index (address), insync);
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/fault_64.c.ifdefed" startline="605" endline="612">
{
    pgd_t *pgd;
    pgd = (pgd_t *) page_address (page) + pgd_index (address);
    if (pgd_none (*pgd))
        set_pgd (pgd, *pgd_ref);
    else
        BUG_ON (pgd_page_vaddr (*pgd) != pgd_page_vaddr (*pgd_ref));
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/extable_64.c.ifdefed" startline="15" endline="34">
{
    if ((value >> 32) == 0)
        value |= 0xffffffffUL << 32;
    while (first <= last) {
        const struct exception_table_entry *mid;
        long diff;
        mid = (last - first) / 2 + first;
        diff = mid->insn - value;
        if (diff == 0)
            return mid;
        else if (diff < 0)
            first = mid + 1;
        else
            last = mid - 1;
    }
    return NULL;
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/extable_64.c.ifdefed" startline="20" endline="32">
{
    const struct exception_table_entry *mid;
    long diff;
    mid = (last - first) / 2 + first;
    diff = mid->insn - value;
    if (diff == 0)
        return mid;
    else if (diff < 0)
        first = mid + 1;
    else
        last = mid - 1;
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/hugetlbpage.c.ifdefed" startline="22" endline="38">
{
    unsigned long saddr = ((idx - svma->vm_pgoff) << PAGE_SHIFT) + svma->vm_start;
    unsigned long sbase = saddr & PUD_MASK;
    unsigned long s_end = sbase + PUD_SIZE;
    if (pmd_index (addr) != pmd_index (saddr) || vma->vm_flags != svma->vm_flags || sbase < svma->vm_start || svma->vm_end < s_end)
        return 0;
    return saddr;
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/hugetlbpage.c.ifdefed" startline="41" endline="52">
{
    unsigned long base = addr & PUD_MASK;
    unsigned long end = base + PUD_SIZE;
    if (vma->vm_flags & VM_MAYSHARE && vma->vm_start <= base && end <= vma->vm_end)
        return 1;
    return 0;
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/hugetlbpage.c.ifdefed" startline="58" endline="97">
{
    struct vm_area_struct *vma = find_vma (mm, addr);
    struct address_space *mapping = vma->vm_file->f_mapping;
    pgoff_t idx = ((addr - vma->vm_start) >> PAGE_SHIFT) + vma->vm_pgoff;
    struct prio_tree_iter iter;
    struct vm_area_struct *svma;
    unsigned long saddr;
    pte_t *spte = NULL;
    if (!vma_shareable (vma, addr))
        return;
    spin_lock (& mapping -> i_mmap_lock);
    vma_prio_tree_foreach (svma, & iter, & mapping -> i_mmap, idx, idx)
    {
        if (svma == vma)
            continue;
        saddr = page_table_shareable (svma, vma, addr, idx);
        if (saddr) {
            spte = huge_pte_offset (svma->vm_mm, saddr);
            if (spte) {
                get_page (virt_to_page (spte));
                break;
            }
        }
    }
    if (!spte)
        goto out;
    spin_lock (& mm -> page_table_lock);
    if (pud_none (*pud))
        pud_populate (mm, pud, (unsigned long) spte & PAGE_MASK);
    else
        put_page (virt_to_page (spte));
    spin_unlock (& mm -> page_table_lock);
out :
    spin_unlock (&mapping->i_mmap_lock);
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/hugetlbpage.c.ifdefed" startline="72" endline="84">
{
    if (svma == vma)
        continue;
    saddr = page_table_shareable (svma, vma, addr, idx);
    if (saddr) {
        spte = huge_pte_offset (svma->vm_mm, saddr);
        if (spte) {
            get_page (virt_to_page (spte));
            break;
        }
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/hugetlbpage.c.ifdefed" startline="77" endline="83">
{
    spte = huge_pte_offset (svma->vm_mm, saddr);
    if (spte) {
        get_page (virt_to_page (spte));
        break;
    }
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/hugetlbpage.c.ifdefed" startline="79" endline="82">
{
    get_page (virt_to_page (spte));
    break;
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/hugetlbpage.c.ifdefed" startline="112" endline="124">
{
    pgd_t *pgd = pgd_offset (mm, *addr);
    pud_t *pud = pud_offset (pgd, *addr);
    BUG_ON (page_count (virt_to_page (ptep)) == 0);
    if (page_count (virt_to_page (ptep)) == 1)
        return 0;
    pud_clear (pud);
    put_page (virt_to_page (ptep));
    *addr = ALIGN (*addr, HPAGE_SIZE *PTRS_PER_PTE) - HPAGE_SIZE;
    return 1;
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/hugetlbpage.c.ifdefed" startline="127" endline="142">
{
    pgd_t *pgd;
    pud_t *pud;
    pte_t *pte = NULL;
    pgd = pgd_offset (mm, addr);
    pud = pud_alloc (mm, pgd, addr);
    if (pud) {
        if (pud_none (*pud))
            huge_pmd_share (mm, addr, pud);
        pte = (pte_t *) pmd_alloc (mm, pud, addr);
    }
    BUG_ON (pte && ! pte_none (* pte) && ! pte_huge (* pte));
    return pte;
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/hugetlbpage.c.ifdefed" startline="134" endline="138">
{
    if (pud_none (*pud))
        huge_pmd_share (mm, addr, pud);
    pte = (pte_t *) pmd_alloc (mm, pud, addr);
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/hugetlbpage.c.ifdefed" startline="145" endline="157">
{
    pgd_t *pgd;
    pud_t *pud;
    pmd_t *pmd = NULL;
    pgd = pgd_offset (mm, addr);
    if (pgd_present (*pgd)) {
        pud = pud_offset (pgd, addr);
        if (pud_present (*pud))
            pmd = pmd_offset (pud, addr);
    }
    return (pte_t *) pmd;
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/hugetlbpage.c.ifdefed" startline="151" endline="155">
{
    pud = pud_offset (pgd, addr);
    if (pud_present (*pud))
        pmd = pmd_offset (pud, addr);
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/hugetlbpage.c.ifdefed" startline="201" endline="203">
{
    return ERR_PTR (-EINVAL);
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/hugetlbpage.c.ifdefed" startline="206" endline="208">
{
    return !!(pmd_val (pmd) & _PAGE_PSE);
}
</source>
<source file="/cmpt816/tmp/arch/x86/mm/hugetlbpage.c.ifdefed" startline="213" endline="220">
{
    struct page *page;
    page = pte_page (*(pte_t*) pmd);
    if (page)
        page += ((address & ~HPAGE_MASK) >> PAGE_SHIFT);
    return page;
}
</source>
